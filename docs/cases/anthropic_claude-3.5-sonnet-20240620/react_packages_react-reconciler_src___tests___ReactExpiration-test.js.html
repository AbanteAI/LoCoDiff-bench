<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: packages/react-reconciler/src/__tests__/ReactExpiration-test.js - Sonnet 3.5</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: packages/react-reconciler/src/__tests__/ReactExpiration-test.js</h1>
        <h2>Model: Sonnet 3.5</h2>
        <p><a href="../../models/anthropic_claude-3.5-sonnet-20240620.html">All Sonnet 3.5 Cases</a> | <a href="../../cases.html">All Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> Sonnet 3.5</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 61130</p>
                <p><strong>Native Prompt Tokens:</strong> 75926</p>
                <p><strong>Native Completion Tokens:</strong> 353</p>
                <p><strong>Native Tokens Reasoning:</strong> 0</p>
                <p><strong>Native Finish Reason:</strong> stop</p>
                <p><strong>Cost:</strong> $0.233073</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/anthropic_claude-3.5-sonnet-20240620/react_packages_react-reconciler_src___tests___ReactExpiration-test.js/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/anthropic_claude-3.5-sonnet-20240620/react_packages_react-reconciler_src___tests___ReactExpiration-test.js/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/anthropic_claude-3.5-sonnet-20240620/react_packages_react-reconciler_src___tests___ReactExpiration-test.js/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div></div><div>index 21d2ee830..188cfb6c6 100644</div><div class="diff-header">--- a/react_packages_react-reconciler_src___tests___ReactExpiration-test.js_expectedoutput.txt (expected):tmp/tmpw99jqcnz_expected.txt	</div><div class="diff-header">+++ b/react_packages_react-reconciler_src___tests___ReactExpiration-test.js_extracted.txt (actual):tmp/tmpqm0z_8ji_actual.txt	</div><div class="diff-info">@@ -1,770 +1,19 @@</div><div class="diff-removed">-/**</div><div class="diff-removed">- * Copyright (c) Meta Platforms, Inc. and affiliates.</div><div class="diff-removed">- *</div><div class="diff-removed">- * This source code is licensed under the MIT license found in the</div><div class="diff-removed">- * LICENSE file in the root directory of this source tree.</div><div class="diff-removed">- *</div><div class="diff-removed">- * @jest-environment node</div><div class="diff-removed">- */</div><div class="diff-added">+This commit makes changes to how passive effects are scheduled and executed in React's Fiber reconciler. Here are the key points:</div><div> </div><div class="diff-removed">-'use strict';</div><div class="diff-added">+1. Passive effects are now treated similarly to other work on the root, using the regular `ensureRootIsScheduled` flow.</div><div> </div><div class="diff-removed">-let React;</div><div class="diff-removed">-let ReactNoop;</div><div class="diff-removed">-let Scheduler;</div><div class="diff-removed">-let act;</div><div class="diff-removed">-let readText;</div><div class="diff-removed">-let resolveText;</div><div class="diff-removed">-let startTransition;</div><div class="diff-removed">-let useState;</div><div class="diff-removed">-let useEffect;</div><div class="diff-removed">-let assertLog;</div><div class="diff-removed">-let waitFor;</div><div class="diff-removed">-let waitForAll;</div><div class="diff-removed">-let unstable_waitForExpired;</div><div class="diff-added">+2. The commit introduces a new flag `enableYieldingBeforePassive` that changes the behavior of when passive effects are executed.</div><div> </div><div class="diff-removed">-describe('ReactExpiration', () => {</div><div class="diff-removed">-  beforeEach(() => {</div><div class="diff-removed">-    jest.resetModules();</div><div class="diff-added">+3. With the new behavior (when `enableYieldingBeforePassive` is true):</div><div class="diff-added">+   - Passive effects are now part of the continuation of work rather than a separate callback.</div><div class="diff-added">+   - They may be executed earlier or later than before, depending on the priority of other work.</div><div class="diff-added">+   - For Idle priority work, passive effects may be executed later if there's other non-React work.</div><div class="diff-added">+   - For Default priority work, passive effects may be executed earlier if there's other Default priority work.</div><div> </div><div class="diff-removed">-    React = require('react');</div><div class="diff-removed">-    ReactNoop = require('react-noop-renderer');</div><div class="diff-removed">-    Scheduler = require('scheduler');</div><div class="diff-removed">-    act = require('internal-test-utils').act;</div><div class="diff-removed">-    startTransition = React.startTransition;</div><div class="diff-removed">-    useState = React.useState;</div><div class="diff-removed">-    useEffect = React.useEffect;</div><div class="diff-added">+4. The changes aim to make the scheduling of passive effects more consistent with other types of work in React.</div><div> </div><div class="diff-removed">-    const InternalTestUtils = require('internal-test-utils');</div><div class="diff-removed">-    assertLog = InternalTestUtils.assertLog;</div><div class="diff-removed">-    waitFor = InternalTestUtils.waitFor;</div><div class="diff-removed">-    waitForAll = InternalTestUtils.waitForAll;</div><div class="diff-removed">-    unstable_waitForExpired = InternalTestUtils.unstable_waitForExpired;</div><div class="diff-added">+5. The test case is updated to account for this new behavior:</div><div class="diff-added">+   - If `enableYieldingBeforePassive` is true, the effect is now expected to be executed immediately after rendering, before yielding.</div><div class="diff-added">+   - If `enableYieldingBeforePassive` is false, the effect is still expected to be executed after paint, as in the previous behavior.</div><div> </div><div class="diff-removed">-    const textCache = new Map();</div><div class="diff-removed">-</div><div class="diff-removed">-    readText = text => {</div><div class="diff-removed">-      const record = textCache.get(text);</div><div class="diff-removed">-      if (record !== undefined) {</div><div class="diff-removed">-        switch (record.status) {</div><div class="diff-removed">-          case 'pending':</div><div class="diff-removed">-            throw record.promise;</div><div class="diff-removed">-          case 'rejected':</div><div class="diff-removed">-            throw Error('Failed to load: ' + text);</div><div class="diff-removed">-          case 'resolved':</div><div class="diff-removed">-            return text;</div><div class="diff-removed">-        }</div><div class="diff-removed">-      } else {</div><div class="diff-removed">-        let ping;</div><div class="diff-removed">-        const promise = new Promise(resolve => (ping = resolve));</div><div class="diff-removed">-        const newRecord = {</div><div class="diff-removed">-          status: 'pending',</div><div class="diff-removed">-          ping: ping,</div><div class="diff-removed">-          promise,</div><div class="diff-removed">-        };</div><div class="diff-removed">-        textCache.set(text, newRecord);</div><div class="diff-removed">-        throw promise;</div><div class="diff-removed">-      }</div><div class="diff-removed">-    };</div><div class="diff-removed">-</div><div class="diff-removed">-    resolveText = text => {</div><div class="diff-removed">-      const record = textCache.get(text);</div><div class="diff-removed">-      if (record !== undefined) {</div><div class="diff-removed">-        if (record.status === 'pending') {</div><div class="diff-removed">-          Scheduler.log(`Promise resolved [${text}]`);</div><div class="diff-removed">-          record.ping();</div><div class="diff-removed">-          record.ping = null;</div><div class="diff-removed">-          record.status = 'resolved';</div><div class="diff-removed">-          clearTimeout(record.promise._timer);</div><div class="diff-removed">-          record.promise = null;</div><div class="diff-removed">-        }</div><div class="diff-removed">-      } else {</div><div class="diff-removed">-        const newRecord = {</div><div class="diff-removed">-          ping: null,</div><div class="diff-removed">-          status: 'resolved',</div><div class="diff-removed">-          promise: null,</div><div class="diff-removed">-        };</div><div class="diff-removed">-        textCache.set(text, newRecord);</div><div class="diff-removed">-      }</div><div class="diff-removed">-    };</div><div class="diff-removed">-  });</div><div class="diff-removed">-</div><div class="diff-removed">-  function Text(props) {</div><div class="diff-removed">-    Scheduler.log(props.text);</div><div class="diff-removed">-    return props.text;</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  function AsyncText(props) {</div><div class="diff-removed">-    const text = props.text;</div><div class="diff-removed">-    try {</div><div class="diff-removed">-      readText(text);</div><div class="diff-removed">-      Scheduler.log(text);</div><div class="diff-removed">-      return text;</div><div class="diff-removed">-    } catch (promise) {</div><div class="diff-removed">-      if (typeof promise.then === 'function') {</div><div class="diff-removed">-        Scheduler.log(`Suspend! [${text}]`);</div><div class="diff-removed">-        if (typeof props.ms === 'number' && promise._timer === undefined) {</div><div class="diff-removed">-          promise._timer = setTimeout(() => {</div><div class="diff-removed">-            resolveText(text);</div><div class="diff-removed">-          }, props.ms);</div><div class="diff-removed">-        }</div><div class="diff-removed">-      } else {</div><div class="diff-removed">-        Scheduler.log(`Error! [${text}]`);</div><div class="diff-removed">-      }</div><div class="diff-removed">-      throw promise;</div><div class="diff-removed">-    }</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  it('increases priority of updates as time progresses', async () => {</div><div class="diff-removed">-    ReactNoop.render(<Text text="Step 1" />);</div><div class="diff-removed">-    React.startTransition(() => {</div><div class="diff-removed">-      ReactNoop.render(<Text text="Step 2" />);</div><div class="diff-removed">-    });</div><div class="diff-removed">-    await waitFor(['Step 1']);</div><div class="diff-removed">-</div><div class="diff-removed">-    expect(ReactNoop).toMatchRenderedOutput('Step 1');</div><div class="diff-removed">-</div><div class="diff-removed">-    // Nothing has expired yet because time hasn't advanced.</div><div class="diff-removed">-    await unstable_waitForExpired([]);</div><div class="diff-removed">-    expect(ReactNoop).toMatchRenderedOutput('Step 1');</div><div class="diff-removed">-</div><div class="diff-removed">-    // Advance time a bit, but not enough to expire the low pri update.</div><div class="diff-removed">-    ReactNoop.expire(4500);</div><div class="diff-removed">-    await unstable_waitForExpired([]);</div><div class="diff-removed">-    expect(ReactNoop).toMatchRenderedOutput('Step 1');</div><div class="diff-removed">-</div><div class="diff-removed">-    // Advance by a little bit more. Now the update should expire and flush.</div><div class="diff-removed">-    ReactNoop.expire(500);</div><div class="diff-removed">-    await unstable_waitForExpired(['Step 2']);</div><div class="diff-removed">-    expect(ReactNoop).toMatchRenderedOutput('Step 2');</div><div class="diff-removed">-  });</div><div class="diff-removed">-</div><div class="diff-removed">-  it('two updates of like priority in the same event always flush within the same batch', async () => {</div><div class="diff-removed">-    class TextClass extends React.Component {</div><div class="diff-removed">-      componentDidMount() {</div><div class="diff-removed">-        Scheduler.log(`${this.props.text} [commit]`);</div><div class="diff-removed">-      }</div><div class="diff-removed">-      componentDidUpdate() {</div><div class="diff-removed">-        Scheduler.log(`${this.props.text} [commit]`);</div><div class="diff-removed">-      }</div><div class="diff-removed">-      render() {</div><div class="diff-removed">-        Scheduler.log(`${this.props.text} [render]`);</div><div class="diff-removed">-        return <span prop={this.props.text} />;</div><div class="diff-removed">-      }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    function interrupt() {</div><div class="diff-removed">-      ReactNoop.flushSync(() => {</div><div class="diff-removed">-        ReactNoop.renderToRootWithID(null, 'other-root');</div><div class="diff-removed">-      });</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    // First, show what happens for updates in two separate events.</div><div class="diff-removed">-    // Schedule an update.</div><div class="diff-removed">-    React.startTransition(() => {</div><div class="diff-removed">-      ReactNoop.render(<TextClass text="A" />);</div><div class="diff-removed">-    });</div><div class="diff-removed">-    // Advance the timer.</div><div class="diff-removed">-    Scheduler.unstable_advanceTime(2000);</div><div class="diff-removed">-    // Partially flush the first update, then interrupt it.</div><div class="diff-removed">-    await waitFor(['A [render]']);</div><div class="diff-removed">-    interrupt();</div><div class="diff-removed">-</div><div class="diff-removed">-    // Don't advance time by enough to expire the first update.</div><div class="diff-removed">-    assertLog([]);</div><div class="diff-removed">-    expect(ReactNoop).toMatchRenderedOutput(null);</div><div class="diff-removed">-</div><div class="diff-removed">-    // Schedule another update.</div><div class="diff-removed">-    ReactNoop.render(<TextClass text="B" />);</div><div class="diff-removed">-    // Both updates are batched</div><div class="diff-removed">-    await waitForAll(['B [render]', 'B [commit]']);</div><div class="diff-removed">-    expect(ReactNoop).toMatchRenderedOutput(<span prop="B" />);</div><div class="diff-removed">-</div><div class="diff-removed">-    // Now do the same thing again, except this time don't flush any work in</div><div class="diff-removed">-    // between the two updates.</div><div class="diff-removed">-    ReactNoop.render(<TextClass text="A" />);</div><div class="diff-removed">-    Scheduler.unstable_advanceTime(2000);</div><div class="diff-removed">-    assertLog([]);</div><div class="diff-removed">-    expect(ReactNoop).toMatchRenderedOutput(<span prop="B" />);</div><div class="diff-removed">-    // Schedule another update.</div><div class="diff-removed">-    ReactNoop.render(<TextClass text="B" />);</div><div class="diff-removed">-    // The updates should flush in the same batch, since as far as the scheduler</div><div class="diff-removed">-    // knows, they may have occurred inside the same event.</div><div class="diff-removed">-    await waitForAll(['B [render]', 'B [commit]']);</div><div class="diff-removed">-  });</div><div class="diff-removed">-</div><div class="diff-removed">-  it(</div><div class="diff-removed">-    'two updates of like priority in the same event always flush within the ' +</div><div class="diff-removed">-      "same batch, even if there's a sync update in between",</div><div class="diff-removed">-    async () => {</div><div class="diff-removed">-      class TextClass extends React.Component {</div><div class="diff-removed">-        componentDidMount() {</div><div class="diff-removed">-          Scheduler.log(`${this.props.text} [commit]`);</div><div class="diff-removed">-        }</div><div class="diff-removed">-        componentDidUpdate() {</div><div class="diff-removed">-          Scheduler.log(`${this.props.text} [commit]`);</div><div class="diff-removed">-        }</div><div class="diff-removed">-        render() {</div><div class="diff-removed">-          Scheduler.log(`${this.props.text} [render]`);</div><div class="diff-removed">-          return <span prop={this.props.text} />;</div><div class="diff-removed">-        }</div><div class="diff-removed">-      }</div><div class="diff-removed">-</div><div class="diff-removed">-      function interrupt() {</div><div class="diff-removed">-        ReactNoop.flushSync(() => {</div><div class="diff-removed">-          ReactNoop.renderToRootWithID(null, 'other-root');</div><div class="diff-removed">-        });</div><div class="diff-removed">-      }</div><div class="diff-removed">-</div><div class="diff-removed">-      // First, show what happens for updates in two separate events.</div><div class="diff-removed">-      // Schedule an update.</div><div class="diff-removed">-      React.startTransition(() => {</div><div class="diff-removed">-        ReactNoop.render(<TextClass text="A" />);</div><div class="diff-removed">-      });</div><div class="diff-removed">-</div><div class="diff-removed">-      // Advance the timer.</div><div class="diff-removed">-      Scheduler.unstable_advanceTime(2000);</div><div class="diff-removed">-      // Partially flush the first update, then interrupt it.</div><div class="diff-removed">-      await waitFor(['A [render]']);</div><div class="diff-removed">-      interrupt();</div><div class="diff-removed">-</div><div class="diff-removed">-      // Don't advance time by enough to expire the first update.</div><div class="diff-removed">-      assertLog([]);</div><div class="diff-removed">-      expect(ReactNoop).toMatchRenderedOutput(null);</div><div class="diff-removed">-</div><div class="diff-removed">-      // Schedule another update.</div><div class="diff-removed">-      ReactNoop.render(<TextClass text="B" />);</div><div class="diff-removed">-      // Both updates are batched</div><div class="diff-removed">-      await waitForAll(['B [render]', 'B [commit]']);</div><div class="diff-removed">-      expect(ReactNoop).toMatchRenderedOutput(<span prop="B" />);</div><div class="diff-removed">-</div><div class="diff-removed">-      // Now do the same thing again, except this time don't flush any work in</div><div class="diff-removed">-      // between the two updates.</div><div class="diff-removed">-      ReactNoop.render(<TextClass text="A" />);</div><div class="diff-removed">-      Scheduler.unstable_advanceTime(2000);</div><div class="diff-removed">-      assertLog([]);</div><div class="diff-removed">-      expect(ReactNoop).toMatchRenderedOutput(<span prop="B" />);</div><div class="diff-removed">-</div><div class="diff-removed">-      // Perform some synchronous work. The scheduler must assume we're inside</div><div class="diff-removed">-      // the same event.</div><div class="diff-removed">-      interrupt();</div><div class="diff-removed">-</div><div class="diff-removed">-      // Schedule another update.</div><div class="diff-removed">-      ReactNoop.render(<TextClass text="B" />);</div><div class="diff-removed">-      // The updates should flush in the same batch, since as far as the scheduler</div><div class="diff-removed">-      // knows, they may have occurred inside the same event.</div><div class="diff-removed">-      await waitForAll(['B [render]', 'B [commit]']);</div><div class="diff-removed">-    },</div><div class="diff-removed">-  );</div><div class="diff-removed">-</div><div class="diff-removed">-  it('cannot update at the same expiration time that is already rendering', async () => {</div><div class="diff-removed">-    const store = {text: 'initial'};</div><div class="diff-removed">-    const subscribers = [];</div><div class="diff-removed">-    class Connected extends React.Component {</div><div class="diff-removed">-      state = {text: store.text};</div><div class="diff-removed">-      componentDidMount() {</div><div class="diff-removed">-        subscribers.push(this);</div><div class="diff-removed">-        Scheduler.log(`${this.state.text} [${this.props.label}] [commit]`);</div><div class="diff-removed">-      }</div><div class="diff-removed">-      componentDidUpdate() {</div><div class="diff-removed">-        Scheduler.log(`${this.state.text} [${this.props.label}] [commit]`);</div><div class="diff-removed">-      }</div><div class="diff-removed">-      render() {</div><div class="diff-removed">-        Scheduler.log(`${this.state.text} [${this.props.label}] [render]`);</div><div class="diff-removed">-        return <span prop={this.state.text} />;</div><div class="diff-removed">-      }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    function App() {</div><div class="diff-removed">-      return (</div><div class="diff-removed">-        <></div><div class="diff-removed">-          <Connected label="A" /></div><div class="diff-removed">-          <Connected label="B" /></div><div class="diff-removed">-          <Connected label="C" /></div><div class="diff-removed">-          <Connected label="D" /></div><div class="diff-removed">-        </></div><div class="diff-removed">-      );</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    // Initial mount</div><div class="diff-removed">-    React.startTransition(() => {</div><div class="diff-removed">-      ReactNoop.render(<App />);</div><div class="diff-removed">-    });</div><div class="diff-removed">-</div><div class="diff-removed">-    await waitForAll([</div><div class="diff-removed">-      'initial [A] [render]',</div><div class="diff-removed">-      'initial [B] [render]',</div><div class="diff-removed">-      'initial [C] [render]',</div><div class="diff-removed">-      'initial [D] [render]',</div><div class="diff-removed">-      'initial [A] [commit]',</div><div class="diff-removed">-      'initial [B] [commit]',</div><div class="diff-removed">-      'initial [C] [commit]',</div><div class="diff-removed">-      'initial [D] [commit]',</div><div class="diff-removed">-    ]);</div><div class="diff-removed">-</div><div class="diff-removed">-    // Partial update</div><div class="diff-removed">-    React.startTransition(() => {</div><div class="diff-removed">-      subscribers.forEach(s => s.setState({text: '1'}));</div><div class="diff-removed">-    });</div><div class="diff-removed">-</div><div class="diff-removed">-    await waitFor(['1 [A] [render]', '1 [B] [render]']);</div><div class="diff-removed">-</div><div class="diff-removed">-    // Before the update can finish, update again. Even though no time has</div><div class="diff-removed">-    // advanced, this update should be given a different expiration time than</div><div class="diff-removed">-    // the currently rendering one. So, C and D should render with 1, not 2.</div><div class="diff-removed">-    React.startTransition(() => {</div><div class="diff-removed">-      subscribers.forEach(s => s.setState({text: '2'}));</div><div class="diff-removed">-    });</div><div class="diff-removed">-    await waitFor(['1 [C] [render]', '1 [D] [render]']);</div><div class="diff-removed">-  });</div><div class="diff-removed">-</div><div class="diff-removed">-  it('stops yielding if CPU-bound update takes too long to finish', async () => {</div><div class="diff-removed">-    const root = ReactNoop.createRoot();</div><div class="diff-removed">-    function App() {</div><div class="diff-removed">-      return (</div><div class="diff-removed">-        <></div><div class="diff-removed">-          <Text text="A" /></div><div class="diff-removed">-          <Text text="B" /></div><div class="diff-removed">-          <Text text="C" /></div><div class="diff-removed">-          <Text text="D" /></div><div class="diff-removed">-          <Text text="E" /></div><div class="diff-removed">-        </></div><div class="diff-removed">-      );</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    React.startTransition(() => {</div><div class="diff-removed">-      root.render(<App />);</div><div class="diff-removed">-    });</div><div class="diff-removed">-</div><div class="diff-removed">-    await waitFor(['A']);</div><div class="diff-removed">-    await waitFor(['B']);</div><div class="diff-removed">-    await waitFor(['C']);</div><div class="diff-removed">-</div><div class="diff-removed">-    Scheduler.unstable_advanceTime(10000);</div><div class="diff-removed">-</div><div class="diff-removed">-    await unstable_waitForExpired(['D', 'E']);</div><div class="diff-removed">-    expect(root).toMatchRenderedOutput('ABCDE');</div><div class="diff-removed">-  });</div><div class="diff-removed">-</div><div class="diff-removed">-  it('root expiration is measured from the time of the first update', async () => {</div><div class="diff-removed">-    Scheduler.unstable_advanceTime(10000);</div><div class="diff-removed">-</div><div class="diff-removed">-    const root = ReactNoop.createRoot();</div><div class="diff-removed">-    function App() {</div><div class="diff-removed">-      return (</div><div class="diff-removed">-        <></div><div class="diff-removed">-          <Text text="A" /></div><div class="diff-removed">-          <Text text="B" /></div><div class="diff-removed">-          <Text text="C" /></div><div class="diff-removed">-          <Text text="D" /></div><div class="diff-removed">-          <Text text="E" /></div><div class="diff-removed">-        </></div><div class="diff-removed">-      );</div><div class="diff-removed">-    }</div><div class="diff-removed">-    React.startTransition(() => {</div><div class="diff-removed">-      root.render(<App />);</div><div class="diff-removed">-    });</div><div class="diff-removed">-</div><div class="diff-removed">-    await waitFor(['A']);</div><div class="diff-removed">-    await waitFor(['B']);</div><div class="diff-removed">-    await waitFor(['C']);</div><div class="diff-removed">-</div><div class="diff-removed">-    Scheduler.unstable_advanceTime(10000);</div><div class="diff-removed">-</div><div class="diff-removed">-    await unstable_waitForExpired(['D', 'E']);</div><div class="diff-removed">-    expect(root).toMatchRenderedOutput('ABCDE');</div><div class="diff-removed">-  });</div><div class="diff-removed">-</div><div class="diff-removed">-  it('should measure expiration times relative to module initialization', async () => {</div><div class="diff-removed">-    // Tests an implementation detail where expiration times are computed using</div><div class="diff-removed">-    // bitwise operations.</div><div class="diff-removed">-</div><div class="diff-removed">-    jest.resetModules();</div><div class="diff-removed">-    Scheduler = require('scheduler');</div><div class="diff-removed">-</div><div class="diff-removed">-    const InternalTestUtils = require('internal-test-utils');</div><div class="diff-removed">-    waitFor = InternalTestUtils.waitFor;</div><div class="diff-removed">-    assertLog = InternalTestUtils.assertLog;</div><div class="diff-removed">-    unstable_waitForExpired = InternalTestUtils.unstable_waitForExpired;</div><div class="diff-removed">-</div><div class="diff-removed">-    // Before importing the renderer, advance the current time by a number</div><div class="diff-removed">-    // larger than the maximum allowed for bitwise operations.</div><div class="diff-removed">-    const maxSigned31BitInt = 1073741823;</div><div class="diff-removed">-    Scheduler.unstable_advanceTime(maxSigned31BitInt * 100);</div><div class="diff-removed">-</div><div class="diff-removed">-    // Now import the renderer. On module initialization, it will read the</div><div class="diff-removed">-    // current time.</div><div class="diff-removed">-    ReactNoop = require('react-noop-renderer');</div><div class="diff-removed">-    React = require('react');</div><div class="diff-removed">-</div><div class="diff-removed">-    ReactNoop.render(<Text text="Step 1" />);</div><div class="diff-removed">-    React.startTransition(() => {</div><div class="diff-removed">-      ReactNoop.render(<Text text="Step 2" />);</div><div class="diff-removed">-    });</div><div class="diff-removed">-    await waitFor(['Step 1']);</div><div class="diff-removed">-</div><div class="diff-removed">-    // The update should not have expired yet.</div><div class="diff-removed">-    await unstable_waitForExpired([]);</div><div class="diff-removed">-</div><div class="diff-removed">-    expect(ReactNoop).toMatchRenderedOutput('Step 1');</div><div class="diff-removed">-</div><div class="diff-removed">-    // Advance the time some more to expire the update.</div><div class="diff-removed">-    Scheduler.unstable_advanceTime(10000);</div><div class="diff-removed">-    await unstable_waitForExpired(['Step 2']);</div><div class="diff-removed">-    expect(ReactNoop).toMatchRenderedOutput('Step 2');</div><div class="diff-removed">-  });</div><div class="diff-removed">-</div><div class="diff-removed">-  it('should measure callback timeout relative to current time, not start-up time', async () => {</div><div class="diff-removed">-    // Corresponds to a bugfix: https://github.com/facebook/react/pull/15479</div><div class="diff-removed">-    // The bug wasn't caught by other tests because we use virtual times that</div><div class="diff-removed">-    // default to 0, and most tests don't advance time.</div><div class="diff-removed">-</div><div class="diff-removed">-    // Before scheduling an update, advance the current time.</div><div class="diff-removed">-    Scheduler.unstable_advanceTime(10000);</div><div class="diff-removed">-</div><div class="diff-removed">-    React.startTransition(() => {</div><div class="diff-removed">-      ReactNoop.render('Hi');</div><div class="diff-removed">-    });</div><div class="diff-removed">-</div><div class="diff-removed">-    await unstable_waitForExpired([]);</div><div class="diff-removed">-    expect(ReactNoop).toMatchRenderedOutput(null);</div><div class="diff-removed">-</div><div class="diff-removed">-    // Advancing by ~5 seconds should be sufficient to expire the update. (I</div><div class="diff-removed">-    // used a slightly larger number to allow for possible rounding.)</div><div class="diff-removed">-    Scheduler.unstable_advanceTime(6000);</div><div class="diff-removed">-    await unstable_waitForExpired([]);</div><div class="diff-removed">-    expect(ReactNoop).toMatchRenderedOutput('Hi');</div><div class="diff-removed">-  });</div><div class="diff-removed">-</div><div class="diff-removed">-  it('prevents starvation by sync updates by disabling time slicing if too much time has elapsed', async () => {</div><div class="diff-removed">-    let updateSyncPri;</div><div class="diff-removed">-    let updateNormalPri;</div><div class="diff-removed">-    function App() {</div><div class="diff-removed">-      const [highPri, setHighPri] = useState(0);</div><div class="diff-removed">-      const [normalPri, setNormalPri] = useState(0);</div><div class="diff-removed">-      updateSyncPri = () => {</div><div class="diff-removed">-        ReactNoop.flushSync(() => {</div><div class="diff-removed">-          setHighPri(n => n + 1);</div><div class="diff-removed">-        });</div><div class="diff-removed">-      };</div><div class="diff-removed">-      updateNormalPri = () => setNormalPri(n => n + 1);</div><div class="diff-removed">-      return (</div><div class="diff-removed">-        <></div><div class="diff-removed">-          <Text text={'Sync pri: ' + highPri} /></div><div class="diff-removed">-          {', '}</div><div class="diff-removed">-          <Text text={'Normal pri: ' + normalPri} /></div><div class="diff-removed">-        </></div><div class="diff-removed">-      );</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    const root = ReactNoop.createRoot();</div><div class="diff-removed">-    await act(() => {</div><div class="diff-removed">-      root.render(<App />);</div><div class="diff-removed">-    });</div><div class="diff-removed">-    assertLog(['Sync pri: 0', 'Normal pri: 0']);</div><div class="diff-removed">-    expect(root).toMatchRenderedOutput('Sync pri: 0, Normal pri: 0');</div><div class="diff-removed">-</div><div class="diff-removed">-    // First demonstrate what happens when there's no starvation</div><div class="diff-removed">-    await act(async () => {</div><div class="diff-removed">-      React.startTransition(() => {</div><div class="diff-removed">-        updateNormalPri();</div><div class="diff-removed">-      });</div><div class="diff-removed">-      await waitFor(['Sync pri: 0']);</div><div class="diff-removed">-      updateSyncPri();</div><div class="diff-removed">-      assertLog(['Sync pri: 1', 'Normal pri: 0']);</div><div class="diff-removed">-</div><div class="diff-removed">-      // The remaining work hasn't expired, so the render phase is time sliced.</div><div class="diff-removed">-      // In other words, we can flush just the first child without flushing</div><div class="diff-removed">-      // the rest.</div><div class="diff-removed">-      //</div><div class="diff-removed">-      // Yield right after first child.</div><div class="diff-removed">-      await waitFor(['Sync pri: 1']);</div><div class="diff-removed">-      // Now do the rest.</div><div class="diff-removed">-      await waitForAll(['Normal pri: 1']);</div><div class="diff-removed">-    });</div><div class="diff-removed">-    expect(root).toMatchRenderedOutput('Sync pri: 1, Normal pri: 1');</div><div class="diff-removed">-</div><div class="diff-removed">-    // Do the same thing, but starve the first update</div><div class="diff-removed">-    await act(async () => {</div><div class="diff-removed">-      React.startTransition(() => {</div><div class="diff-removed">-        updateNormalPri();</div><div class="diff-removed">-      });</div><div class="diff-removed">-      await waitFor(['Sync pri: 1']);</div><div class="diff-removed">-</div><div class="diff-removed">-      // This time, a lot of time has elapsed since the normal pri update</div><div class="diff-removed">-      // started rendering. (This should advance time by some number that's</div><div class="diff-removed">-      // definitely bigger than the constant heuristic we use to detect</div><div class="diff-removed">-      // starvation of normal priority updates.)</div><div class="diff-removed">-      Scheduler.unstable_advanceTime(10000);</div><div class="diff-removed">-</div><div class="diff-removed">-      updateSyncPri();</div><div class="diff-removed">-      assertLog(['Sync pri: 2', 'Normal pri: 1']);</div><div class="diff-removed">-</div><div class="diff-removed">-      // The remaining work _has_ expired, so the render phase is _not_ time</div><div class="diff-removed">-      // sliced. Attempting to flush just the first child also flushes the rest.</div><div class="diff-removed">-      await waitFor(['Sync pri: 2'], {</div><div class="diff-removed">-        additionalLogsAfterAttemptingToYield: ['Normal pri: 2'],</div><div class="diff-removed">-      });</div><div class="diff-removed">-    });</div><div class="diff-removed">-    expect(root).toMatchRenderedOutput('Sync pri: 2, Normal pri: 2');</div><div class="diff-removed">-  });</div><div class="diff-removed">-</div><div class="diff-removed">-  it('idle work never expires', async () => {</div><div class="diff-removed">-    let updateSyncPri;</div><div class="diff-removed">-    let updateIdlePri;</div><div class="diff-removed">-    function App() {</div><div class="diff-removed">-      const [syncPri, setSyncPri] = useState(0);</div><div class="diff-removed">-      const [highPri, setIdlePri] = useState(0);</div><div class="diff-removed">-      updateSyncPri = () => ReactNoop.flushSync(() => setSyncPri(n => n + 1));</div><div class="diff-removed">-      updateIdlePri = () =></div><div class="diff-removed">-        ReactNoop.idleUpdates(() => {</div><div class="diff-removed">-          setIdlePri(n => n + 1);</div><div class="diff-removed">-        });</div><div class="diff-removed">-      return (</div><div class="diff-removed">-        <></div><div class="diff-removed">-          <Text text={'Sync pri: ' + syncPri} /></div><div class="diff-removed">-          {', '}</div><div class="diff-removed">-          <Text text={'Idle pri: ' + highPri} /></div><div class="diff-removed">-        </></div><div class="diff-removed">-      );</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    const root = ReactNoop.createRoot();</div><div class="diff-removed">-    await act(() => {</div><div class="diff-removed">-      root.render(<App />);</div><div class="diff-removed">-    });</div><div class="diff-removed">-    assertLog(['Sync pri: 0', 'Idle pri: 0']);</div><div class="diff-removed">-    expect(root).toMatchRenderedOutput('Sync pri: 0, Idle pri: 0');</div><div class="diff-removed">-</div><div class="diff-removed">-    // First demonstrate what happens when there's no starvation</div><div class="diff-removed">-    await act(async () => {</div><div class="diff-removed">-      updateIdlePri();</div><div class="diff-removed">-      await waitFor(['Sync pri: 0']);</div><div class="diff-removed">-      updateSyncPri();</div><div class="diff-removed">-    });</div><div class="diff-removed">-    // Same thing should happen as last time</div><div class="diff-removed">-    assertLog([</div><div class="diff-removed">-      // Interrupt idle update to render sync update</div><div class="diff-removed">-      'Sync pri: 1',</div><div class="diff-removed">-      'Idle pri: 0',</div><div class="diff-removed">-      // Now render idle</div><div class="diff-removed">-      'Sync pri: 1',</div><div class="diff-removed">-      'Idle pri: 1',</div><div class="diff-removed">-    ]);</div><div class="diff-removed">-    expect(root).toMatchRenderedOutput('Sync pri: 1, Idle pri: 1');</div><div class="diff-removed">-</div><div class="diff-removed">-    // Do the same thing, but starve the first update</div><div class="diff-removed">-    await act(async () => {</div><div class="diff-removed">-      updateIdlePri();</div><div class="diff-removed">-      await waitFor(['Sync pri: 1']);</div><div class="diff-removed">-</div><div class="diff-removed">-      // Advance a ridiculously large amount of time to demonstrate that the</div><div class="diff-removed">-      // idle work never expires</div><div class="diff-removed">-      Scheduler.unstable_advanceTime(100000);</div><div class="diff-removed">-</div><div class="diff-removed">-      updateSyncPri();</div><div class="diff-removed">-    });</div><div class="diff-removed">-    assertLog([</div><div class="diff-removed">-      // Interrupt idle update to render sync update</div><div class="diff-removed">-      'Sync pri: 2',</div><div class="diff-removed">-      'Idle pri: 1',</div><div class="diff-removed">-      // Now render idle</div><div class="diff-removed">-      'Sync pri: 2',</div><div class="diff-removed">-      'Idle pri: 2',</div><div class="diff-removed">-    ]);</div><div class="diff-removed">-    expect(root).toMatchRenderedOutput('Sync pri: 2, Idle pri: 2');</div><div class="diff-removed">-  });</div><div class="diff-removed">-</div><div class="diff-removed">-  it('when multiple lanes expire, we can finish the in-progress one without including the others', async () => {</div><div class="diff-removed">-    let setA;</div><div class="diff-removed">-    let setB;</div><div class="diff-removed">-    function App() {</div><div class="diff-removed">-      const [a, _setA] = useState(0);</div><div class="diff-removed">-      const [b, _setB] = useState(0);</div><div class="diff-removed">-      setA = _setA;</div><div class="diff-removed">-      setB = _setB;</div><div class="diff-removed">-      return (</div><div class="diff-removed">-        <></div><div class="diff-removed">-          <Text text={'A' + a} /></div><div class="diff-removed">-          <Text text={'B' + b} /></div><div class="diff-removed">-          <Text text="C" /></div><div class="diff-removed">-        </></div><div class="diff-removed">-      );</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    const root = ReactNoop.createRoot();</div><div class="diff-removed">-    await act(() => {</div><div class="diff-removed">-      root.render(<App />);</div><div class="diff-removed">-    });</div><div class="diff-removed">-    assertLog(['A0', 'B0', 'C']);</div><div class="diff-removed">-    expect(root).toMatchRenderedOutput('A0B0C');</div><div class="diff-removed">-</div><div class="diff-removed">-    await act(async () => {</div><div class="diff-removed">-      startTransition(() => {</div><div class="diff-removed">-        setA(1);</div><div class="diff-removed">-      });</div><div class="diff-removed">-      await waitFor(['A1']);</div><div class="diff-removed">-      startTransition(() => {</div><div class="diff-removed">-        setB(1);</div><div class="diff-removed">-      });</div><div class="diff-removed">-      await waitFor(['B0']);</div><div class="diff-removed">-</div><div class="diff-removed">-      // Expire both the transitions</div><div class="diff-removed">-      Scheduler.unstable_advanceTime(10000);</div><div class="diff-removed">-      // Both transitions have expired, but since they aren't related</div><div class="diff-removed">-      // (entangled), we should be able to finish the in-progress transition</div><div class="diff-removed">-      // without also including the next one.</div><div class="diff-removed">-      await waitFor([], {</div><div class="diff-removed">-        additionalLogsAfterAttemptingToYield: ['C'],</div><div class="diff-removed">-      });</div><div class="diff-removed">-      expect(root).toMatchRenderedOutput('A1B0C');</div><div class="diff-removed">-</div><div class="diff-removed">-      // The next transition also finishes without yielding.</div><div class="diff-removed">-      await waitFor(['A1'], {</div><div class="diff-removed">-        additionalLogsAfterAttemptingToYield: ['B1', 'C'],</div><div class="diff-removed">-      });</div><div class="diff-removed">-      expect(root).toMatchRenderedOutput('A1B1C');</div><div class="diff-removed">-    });</div><div class="diff-removed">-  });</div><div class="diff-removed">-</div><div class="diff-removed">-  it('updates do not expire while they are IO-bound', async () => {</div><div class="diff-removed">-    const {Suspense} = React;</div><div class="diff-removed">-</div><div class="diff-removed">-    function App({step}) {</div><div class="diff-removed">-      return (</div><div class="diff-removed">-        <Suspense fallback={<Text text="Loading..." />}></div><div class="diff-removed">-          <AsyncText text={'A' + step} /></div><div class="diff-removed">-          <Text text="B" /></div><div class="diff-removed">-          <Text text="C" /></div><div class="diff-removed">-        </Suspense></div><div class="diff-removed">-      );</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    const root = ReactNoop.createRoot();</div><div class="diff-removed">-    await act(async () => {</div><div class="diff-removed">-      await resolveText('A0');</div><div class="diff-removed">-      root.render(<App step={0} />);</div><div class="diff-removed">-    });</div><div class="diff-removed">-    assertLog(['A0', 'B', 'C']);</div><div class="diff-removed">-    expect(root).toMatchRenderedOutput('A0BC');</div><div class="diff-removed">-</div><div class="diff-removed">-    await act(async () => {</div><div class="diff-removed">-      React.startTransition(() => {</div><div class="diff-removed">-        root.render(<App step={1} />);</div><div class="diff-removed">-      });</div><div class="diff-removed">-      await waitForAll([</div><div class="diff-removed">-        'Suspend! [A1]',</div><div class="diff-removed">-</div><div class="diff-removed">-        ...(gate('enableSiblingPrerendering') ? ['B', 'C'] : []),</div><div class="diff-removed">-</div><div class="diff-removed">-        'Loading...',</div><div class="diff-removed">-      ]);</div><div class="diff-removed">-</div><div class="diff-removed">-      // Lots of time elapses before the promise resolves</div><div class="diff-removed">-      Scheduler.unstable_advanceTime(10000);</div><div class="diff-removed">-      await resolveText('A1');</div><div class="diff-removed">-      assertLog(['Promise resolved [A1]']);</div><div class="diff-removed">-</div><div class="diff-removed">-      await waitFor(['A1']);</div><div class="diff-removed">-      expect(root).toMatchRenderedOutput('A0BC');</div><div class="diff-removed">-</div><div class="diff-removed">-      // Lots more time elapses. We're CPU-bound now, so we should treat this</div><div class="diff-removed">-      // as starvation.</div><div class="diff-removed">-      Scheduler.unstable_advanceTime(10000);</div><div class="diff-removed">-</div><div class="diff-removed">-      // The rest of the update finishes without yielding.</div><div class="diff-removed">-      await waitFor([], {</div><div class="diff-removed">-        additionalLogsAfterAttemptingToYield: ['B', 'C'],</div><div class="diff-removed">-      });</div><div class="diff-removed">-    });</div><div class="diff-removed">-  });</div><div class="diff-removed">-</div><div class="diff-removed">-  it('flushSync should not affect expired work', async () => {</div><div class="diff-removed">-    let setA;</div><div class="diff-removed">-    let setB;</div><div class="diff-removed">-    function App() {</div><div class="diff-removed">-      const [a, _setA] = useState(0);</div><div class="diff-removed">-      const [b, _setB] = useState(0);</div><div class="diff-removed">-      setA = _setA;</div><div class="diff-removed">-      setB = _setB;</div><div class="diff-removed">-      return (</div><div class="diff-removed">-        <></div><div class="diff-removed">-          <Text text={'A' + a} /></div><div class="diff-removed">-          <Text text={'B' + b} /></div><div class="diff-removed">-        </></div><div class="diff-removed">-      );</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    const root = ReactNoop.createRoot();</div><div class="diff-removed">-    await act(() => {</div><div class="diff-removed">-      root.render(<App />);</div><div class="diff-removed">-    });</div><div class="diff-removed">-    assertLog(['A0', 'B0']);</div><div class="diff-removed">-</div><div class="diff-removed">-    await act(async () => {</div><div class="diff-removed">-      startTransition(() => {</div><div class="diff-removed">-        setA(1);</div><div class="diff-removed">-      });</div><div class="diff-removed">-      await waitFor(['A1']);</div><div class="diff-removed">-</div><div class="diff-removed">-      // Expire the in-progress update</div><div class="diff-removed">-      Scheduler.unstable_advanceTime(10000);</div><div class="diff-removed">-</div><div class="diff-removed">-      ReactNoop.flushSync(() => {</div><div class="diff-removed">-        setB(1);</div><div class="diff-removed">-      });</div><div class="diff-removed">-      assertLog(['A0', 'B1']);</div><div class="diff-removed">-</div><div class="diff-removed">-      // Now flush the original update. Because it expired, it should finish</div><div class="diff-removed">-      // without yielding.</div><div class="diff-removed">-      await waitFor(['A1'], {</div><div class="diff-removed">-        additionalLogsAfterAttemptingToYield: ['B1'],</div><div class="diff-removed">-      });</div><div class="diff-removed">-    });</div><div class="diff-removed">-  });</div><div class="diff-removed">-</div><div class="diff-removed">-  it('passive effects of expired update flush after paint', async () => {</div><div class="diff-removed">-    function App({step}) {</div><div class="diff-removed">-      useEffect(() => {</div><div class="diff-removed">-        Scheduler.log('Effect: ' + step);</div><div class="diff-removed">-      }, [step]);</div><div class="diff-removed">-      return (</div><div class="diff-removed">-        <></div><div class="diff-removed">-          <Text text={'A' + step} /></div><div class="diff-removed">-          <Text text={'B' + step} /></div><div class="diff-removed">-          <Text text={'C' + step} /></div><div class="diff-removed">-        </></div><div class="diff-removed">-      );</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    const root = ReactNoop.createRoot();</div><div class="diff-removed">-    await act(() => {</div><div class="diff-removed">-      root.render(<App step={0} />);</div><div class="diff-removed">-    });</div><div class="diff-removed">-    assertLog(['A0', 'B0', 'C0', 'Effect: 0']);</div><div class="diff-removed">-    expect(root).toMatchRenderedOutput('A0B0C0');</div><div class="diff-removed">-</div><div class="diff-removed">-    await act(async () => {</div><div class="diff-removed">-      startTransition(() => {</div><div class="diff-removed">-        root.render(<App step={1} />);</div><div class="diff-removed">-      });</div><div class="diff-removed">-      await waitFor(['A1']);</div><div class="diff-removed">-</div><div class="diff-removed">-      // Expire the update</div><div class="diff-removed">-      Scheduler.unstable_advanceTime(10000);</div><div class="diff-removed">-</div><div class="diff-removed">-      // The update finishes without yielding. But it does not flush the effect.</div><div class="diff-removed">-      await waitFor(['B1'], {</div><div class="diff-removed">-        additionalLogsAfterAttemptingToYield: gate(</div><div class="diff-removed">-          flags => flags.enableYieldingBeforePassive,</div><div class="diff-removed">-        )</div><div class="diff-removed">-          ? ['C1', 'Effect: 1']</div><div class="diff-removed">-          : ['C1'],</div><div class="diff-removed">-      });</div><div class="diff-removed">-    });</div><div class="diff-removed">-    if (!gate(flags => flags.enableYieldingBeforePassive)) {</div><div class="diff-removed">-      // The effect flushes after paint.</div><div class="diff-removed">-      assertLog(['Effect: 1']);</div><div class="diff-removed">-    }</div><div class="diff-removed">-  });</div><div class="diff-removed">-});</div><div>\ No newline at end of file</div><div class="diff-added">+This change potentially improves the consistency and efficiency of React's work scheduling, particularly for passive effects. It may have implications for the timing of effect execution in certain scenarios, which developers might need to be aware of when this feature is enabled.</div><div>\ No newline at end of file</div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    