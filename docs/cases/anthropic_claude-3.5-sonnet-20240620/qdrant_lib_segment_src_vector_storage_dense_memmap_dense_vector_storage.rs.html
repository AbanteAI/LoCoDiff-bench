<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs - Sonnet 3.5</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs</h1>
        <h2>Model: Sonnet 3.5</h2>
        <p><a href="../../models/anthropic_claude-3.5-sonnet-20240620.html">All Sonnet 3.5 Cases</a> | <a href="../../cases.html">All Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> Sonnet 3.5</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 31464</p>
                <p><strong>Native Prompt Tokens:</strong> 41953</p>
                <p><strong>Native Completion Tokens:</strong> 264</p>
                <p><strong>Native Tokens Reasoning:</strong> 0</p>
                <p><strong>Native Finish Reason:</strong> stop</p>
                <p><strong>Cost:</strong> $0.129819</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/anthropic_claude-3.5-sonnet-20240620/qdrant_lib_segment_src_vector_storage_dense_memmap_dense_vector_storage.rs/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/anthropic_claude-3.5-sonnet-20240620/qdrant_lib_segment_src_vector_storage_dense_memmap_dense_vector_storage.rs/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/anthropic_claude-3.5-sonnet-20240620/qdrant_lib_segment_src_vector_storage_dense_memmap_dense_vector_storage.rs/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div></div><div>index e66df55cf..561081553 100644</div><div class="diff-header">--- a/qdrant_lib_segment_src_vector_storage_dense_memmap_dense_vector_storage.rs_expectedoutput.txt (expected):tmp/tmp17qgxyd8_expected.txt	</div><div class="diff-header">+++ b/qdrant_lib_segment_src_vector_storage_dense_memmap_dense_vector_storage.rs_extracted.txt (actual):tmp/tmpee51ak3q_actual.txt	</div><div class="diff-info">@@ -1,849 +1,23 @@</div><div class="diff-removed">-use std::borrow::Cow;</div><div class="diff-removed">-use std::fs::{File, OpenOptions, create_dir_all};</div><div class="diff-removed">-use std::io::{self, Write};</div><div class="diff-removed">-use std::mem::MaybeUninit;</div><div class="diff-removed">-use std::ops::Range;</div><div class="diff-removed">-use std::path::{Path, PathBuf};</div><div class="diff-removed">-use std::sync::atomic::AtomicBool;</div><div class="diff-added">+Here are the key changes made to the `memmap_dense_vector_storage.rs` file over time:</div><div> </div><div class="diff-removed">-use bitvec::prelude::BitSlice;</div><div class="diff-removed">-use common::counter::hardware_counter::HardwareCounterCell;</div><div class="diff-removed">-use common::types::PointOffsetType;</div><div class="diff-removed">-use memory::fadvise::clear_disk_cache;</div><div class="diff-removed">-use memory::mmap_ops;</div><div class="diff-added">+1. The initial implementation added basic functionality for a memory-mapped dense vector storage.</div><div> </div><div class="diff-removed">-use crate::common::Flusher;</div><div class="diff-removed">-use crate::common::operation_error::{OperationError, OperationResult, check_process_stopped};</div><div class="diff-removed">-use crate::data_types::named_vectors::CowVector;</div><div class="diff-removed">-use crate::data_types::primitive::PrimitiveVectorElement;</div><div class="diff-removed">-use crate::data_types::vectors::{VectorElementType, VectorRef};</div><div class="diff-removed">-use crate::types::{Distance, VectorStorageDatatype};</div><div class="diff-removed">-use crate::vector_storage::common::get_async_scorer;</div><div class="diff-removed">-use crate::vector_storage::dense::mmap_dense_vectors::MmapDenseVectors;</div><div class="diff-removed">-use crate::vector_storage::{DenseVectorStorage, VectorStorage, VectorStorageEnum};</div><div class="diff-added">+2. Support for byte and half-precision float vector types was added.</div><div> </div><div class="diff-removed">-const VECTORS_PATH: &str = "matrix.dat";</div><div class="diff-removed">-const DELETED_PATH: &str = "deleted.dat";</div><div class="diff-added">+3. The `update_from` method was modified to take an iterator of vectors instead of IDs.</div><div> </div><div class="diff-removed">-/// Stores all dense vectors in mem-mapped file</div><div class="diff-removed">-///</div><div class="diff-removed">-/// It is not possible to insert new vectors into mem-mapped storage,</div><div class="diff-removed">-/// but possible to mark some vectors as removed</div><div class="diff-removed">-///</div><div class="diff-removed">-/// Mem-mapped storage can only be constructed from another storage</div><div class="diff-removed">-#[derive(Debug)]</div><div class="diff-removed">-pub struct MemmapDenseVectorStorage<T: PrimitiveVectorElement> {</div><div class="diff-removed">-    vectors_path: PathBuf,</div><div class="diff-removed">-    deleted_path: PathBuf,</div><div class="diff-removed">-    mmap_store: Option<MmapDenseVectors<T>>,</div><div class="diff-removed">-    distance: Distance,</div><div class="diff-removed">-}</div><div class="diff-added">+4. Debug trait implementation was added.</div><div> </div><div class="diff-removed">-impl<T: PrimitiveVectorElement> MemmapDenseVectorStorage<T> {</div><div class="diff-removed">-    /// Populate all pages in the mmap.</div><div class="diff-removed">-    /// Block until all pages are populated.</div><div class="diff-removed">-    pub fn populate(&self) -> OperationResult<()> {</div><div class="diff-removed">-        if let Some(mmap_store) = &self.mmap_store {</div><div class="diff-removed">-            mmap_store.populate()?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-added">+5. The `get_dense_batch` method was updated to use `MaybeUninit` for better performance.</div><div> </div><div class="diff-removed">-    /// Drop disk cache.</div><div class="diff-removed">-    pub fn clear_cache(&self) -> OperationResult<()> {</div><div class="diff-removed">-        clear_disk_cache(&self.vectors_path)?;</div><div class="diff-removed">-        clear_disk_cache(&self.deleted_path)?;</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-}</div><div class="diff-added">+6. Methods for populating and clearing the disk cache were added.</div><div> </div><div class="diff-removed">-pub fn open_memmap_vector_storage(</div><div class="diff-removed">-    path: &Path,</div><div class="diff-removed">-    dim: usize,</div><div class="diff-removed">-    distance: Distance,</div><div class="diff-removed">-) -> OperationResult<VectorStorageEnum> {</div><div class="diff-removed">-    let storage = open_memmap_vector_storage_with_async_io_impl::<VectorElementType>(</div><div class="diff-removed">-        path,</div><div class="diff-removed">-        dim,</div><div class="diff-removed">-        distance,</div><div class="diff-removed">-        get_async_scorer(),</div><div class="diff-removed">-    )?;</div><div class="diff-removed">-    Ok(VectorStorageEnum::DenseMemmap(storage))</div><div class="diff-removed">-}</div><div class="diff-added">+7. The `is_stopped` parameter was removed from the `RawScorer` interface.</div><div> </div><div class="diff-removed">-pub fn open_memmap_vector_storage_byte(</div><div class="diff-removed">-    path: &Path,</div><div class="diff-removed">-    dim: usize,</div><div class="diff-removed">-    distance: Distance,</div><div class="diff-removed">-) -> OperationResult<VectorStorageEnum> {</div><div class="diff-removed">-    let storage =</div><div class="diff-removed">-        open_memmap_vector_storage_with_async_io_impl(path, dim, distance, get_async_scorer())?;</div><div class="diff-removed">-    Ok(VectorStorageEnum::DenseMemmapByte(storage))</div><div class="diff-removed">-}</div><div class="diff-added">+8. The `clear_disk_cache` function was moved to a new `memory::fadvise` module.</div><div> </div><div class="diff-removed">-pub fn open_memmap_vector_storage_half(</div><div class="diff-removed">-    path: &Path,</div><div class="diff-removed">-    dim: usize,</div><div class="diff-removed">-    distance: Distance,</div><div class="diff-removed">-) -> OperationResult<VectorStorageEnum> {</div><div class="diff-removed">-    let storage =</div><div class="diff-removed">-        open_memmap_vector_storage_with_async_io_impl(path, dim, distance, get_async_scorer())?;</div><div class="diff-removed">-    Ok(VectorStorageEnum::DenseMemmapHalf(storage))</div><div class="diff-removed">-}</div><div class="diff-added">+9. Hardware counter support was added to track I/O operations.</div><div> </div><div class="diff-removed">-pub fn open_memmap_vector_storage_with_async_io(</div><div class="diff-removed">-    path: &Path,</div><div class="diff-removed">-    dim: usize,</div><div class="diff-removed">-    distance: Distance,</div><div class="diff-removed">-    with_async_io: bool,</div><div class="diff-removed">-) -> OperationResult<VectorStorageEnum> {</div><div class="diff-removed">-    let storage = open_memmap_vector_storage_with_async_io_impl::<VectorElementType>(</div><div class="diff-removed">-        path,</div><div class="diff-removed">-        dim,</div><div class="diff-removed">-        distance,</div><div class="diff-removed">-        with_async_io,</div><div class="diff-removed">-    )?;</div><div class="diff-removed">-    Ok(VectorStorageEnum::DenseMemmap(storage))</div><div class="diff-removed">-}</div><div class="diff-added">+10. The storage now uses `OneshotFile` for more efficient disk cache management.</div><div> </div><div class="diff-removed">-fn open_memmap_vector_storage_with_async_io_impl<T: PrimitiveVectorElement>(</div><div class="diff-removed">-    path: &Path,</div><div class="diff-removed">-    dim: usize,</div><div class="diff-removed">-    distance: Distance,</div><div class="diff-removed">-    with_async_io: bool,</div><div class="diff-removed">-) -> OperationResult<Box<MemmapDenseVectorStorage<T>>> {</div><div class="diff-removed">-    create_dir_all(path)?;</div><div class="diff-removed">-</div><div class="diff-removed">-    let vectors_path = path.join(VECTORS_PATH);</div><div class="diff-removed">-    let deleted_path = path.join(DELETED_PATH);</div><div class="diff-removed">-    let mmap_store = MmapDenseVectors::open(&vectors_path, &deleted_path, dim, with_async_io)?;</div><div class="diff-removed">-</div><div class="diff-removed">-    Ok(Box::new(MemmapDenseVectorStorage {</div><div class="diff-removed">-        vectors_path,</div><div class="diff-removed">-        deleted_path,</div><div class="diff-removed">-        mmap_store: Some(mmap_store),</div><div class="diff-removed">-        distance,</div><div class="diff-removed">-    }))</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-impl<T: PrimitiveVectorElement> MemmapDenseVectorStorage<T> {</div><div class="diff-removed">-    pub fn get_mmap_vectors(&self) -> &MmapDenseVectors<T> {</div><div class="diff-removed">-        self.mmap_store.as_ref().unwrap()</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn has_async_reader(&self) -> bool {</div><div class="diff-removed">-        self.mmap_store</div><div class="diff-removed">-            .as_ref()</div><div class="diff-removed">-            .map(|x| x.has_async_reader())</div><div class="diff-removed">-            .unwrap_or(false)</div><div class="diff-removed">-    }</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-impl<T: PrimitiveVectorElement> DenseVectorStorage<T> for MemmapDenseVectorStorage<T> {</div><div class="diff-removed">-    fn vector_dim(&self) -> usize {</div><div class="diff-removed">-        self.mmap_store.as_ref().unwrap().dim</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn get_dense(&self, key: PointOffsetType) -> &[T] {</div><div class="diff-removed">-        self.mmap_store</div><div class="diff-removed">-            .as_ref()</div><div class="diff-removed">-            .unwrap()</div><div class="diff-removed">-            .get_vector_opt(key)</div><div class="diff-removed">-            .unwrap_or_else(|| panic!("vector not found: {key}"))</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn get_dense_batch<'a>(</div><div class="diff-removed">-        &'a self,</div><div class="diff-removed">-        keys: &[PointOffsetType],</div><div class="diff-removed">-        vectors: &'a mut [MaybeUninit<&'a [T]>],</div><div class="diff-removed">-    ) -> &'a [&'a [T]] {</div><div class="diff-removed">-        let mmap_store = self.mmap_store.as_ref().unwrap();</div><div class="diff-removed">-        mmap_store.get_vectors(keys, vectors)</div><div class="diff-removed">-    }</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-impl<T: PrimitiveVectorElement> VectorStorage for MemmapDenseVectorStorage<T> {</div><div class="diff-removed">-    fn distance(&self) -> Distance {</div><div class="diff-removed">-        self.distance</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn datatype(&self) -> VectorStorageDatatype {</div><div class="diff-removed">-        T::datatype()</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn is_on_disk(&self) -> bool {</div><div class="diff-removed">-        true</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn total_vector_count(&self) -> usize {</div><div class="diff-removed">-        self.mmap_store.as_ref().unwrap().num_vectors</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn get_vector(&self, key: PointOffsetType) -> CowVector {</div><div class="diff-removed">-        self.get_vector_opt(key).expect("vector not found")</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn get_vector_opt(&self, key: PointOffsetType) -> Option<CowVector> {</div><div class="diff-removed">-        self.mmap_store</div><div class="diff-removed">-            .as_ref()</div><div class="diff-removed">-            .unwrap()</div><div class="diff-removed">-            .get_vector_opt(key)</div><div class="diff-removed">-            .map(|vector| T::slice_to_float_cow(vector.into()).into())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn insert_vector(</div><div class="diff-removed">-        &mut self,</div><div class="diff-removed">-        _key: PointOffsetType,</div><div class="diff-removed">-        _vector: VectorRef,</div><div class="diff-removed">-        _hw_counter: &HardwareCounterCell,</div><div class="diff-removed">-    ) -> OperationResult<()> {</div><div class="diff-removed">-        panic!("Can't directly update vector in mmap storage")</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn update_from<'a>(</div><div class="diff-removed">-        &mut self,</div><div class="diff-removed">-        other_vectors: &'a mut impl Iterator<Item = (CowVector<'a>, bool)>,</div><div class="diff-removed">-        stopped: &AtomicBool,</div><div class="diff-removed">-    ) -> OperationResult<Range<PointOffsetType>> {</div><div class="diff-removed">-        let dim = self.vector_dim();</div><div class="diff-removed">-        let start_index = self.mmap_store.as_ref().unwrap().num_vectors as PointOffsetType;</div><div class="diff-removed">-        let mut end_index = start_index;</div><div class="diff-removed">-</div><div class="diff-removed">-        let with_async_io = self</div><div class="diff-removed">-            .mmap_store</div><div class="diff-removed">-            .take()</div><div class="diff-removed">-            .map(|x| x.has_async_reader())</div><div class="diff-removed">-            .unwrap_or(get_async_scorer());</div><div class="diff-removed">-</div><div class="diff-removed">-        // Extend vectors file, write other vectors into it</div><div class="diff-removed">-        let mut vectors_file = open_append(&self.vectors_path)?;</div><div class="diff-removed">-        let mut deleted_ids = vec![];</div><div class="diff-removed">-        for (offset, (other_vector, other_deleted)) in other_vectors.enumerate() {</div><div class="diff-removed">-            check_process_stopped(stopped)?;</div><div class="diff-removed">-            let vector = T::slice_from_float_cow(Cow::try_from(other_vector)?);</div><div class="diff-removed">-            let raw_bites = mmap_ops::transmute_to_u8_slice(vector.as_ref());</div><div class="diff-removed">-            vectors_file.write_all(raw_bites)?;</div><div class="diff-removed">-            end_index += 1;</div><div class="diff-removed">-</div><div class="diff-removed">-            // Remember deleted IDs so we can propagate deletions later</div><div class="diff-removed">-            if other_deleted {</div><div class="diff-removed">-                deleted_ids.push(start_index as PointOffsetType + offset as PointOffsetType);</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div class="diff-removed">-        vectors_file.sync_all()?;</div><div class="diff-removed">-        drop(vectors_file);</div><div class="diff-removed">-</div><div class="diff-removed">-        // Load store with updated files</div><div class="diff-removed">-        self.mmap_store.replace(MmapDenseVectors::open(</div><div class="diff-removed">-            &self.vectors_path,</div><div class="diff-removed">-            &self.deleted_path,</div><div class="diff-removed">-            dim,</div><div class="diff-removed">-            with_async_io,</div><div class="diff-removed">-        )?);</div><div class="diff-removed">-</div><div class="diff-removed">-        // Flush deleted flags into store</div><div class="diff-removed">-        // We must do that in the updated store, and cannot do it in the previous loop. That is</div><div class="diff-removed">-        // because the file backing delete storage must be resized, and for that we'd need to know</div><div class="diff-removed">-        // the exact number of vectors beforehand. When opening the store it is done automatically.</div><div class="diff-removed">-        let store = self.mmap_store.as_mut().unwrap();</div><div class="diff-removed">-        for id in deleted_ids {</div><div class="diff-removed">-            check_process_stopped(stopped)?;</div><div class="diff-removed">-            store.delete(id);</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        Ok(start_index..end_index)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn flusher(&self) -> Flusher {</div><div class="diff-removed">-        match &self.mmap_store {</div><div class="diff-removed">-            Some(mmap_store) => {</div><div class="diff-removed">-                let mmap_flusher = mmap_store.flusher();</div><div class="diff-removed">-                Box::new(move || mmap_flusher().map_err(OperationError::from))</div><div class="diff-removed">-            }</div><div class="diff-removed">-            None => Box::new(|| Ok(())),</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn files(&self) -> Vec<PathBuf> {</div><div class="diff-removed">-        vec![self.vectors_path.clone(), self.deleted_path.clone()]</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn delete_vector(&mut self, key: PointOffsetType) -> OperationResult<bool> {</div><div class="diff-removed">-        Ok(self.mmap_store.as_mut().unwrap().delete(key))</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn is_deleted_vector(&self, key: PointOffsetType) -> bool {</div><div class="diff-removed">-        self.mmap_store.as_ref().unwrap().is_deleted_vector(key)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn deleted_vector_count(&self) -> usize {</div><div class="diff-removed">-        self.mmap_store.as_ref().unwrap().deleted_count</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn deleted_vector_bitslice(&self) -> &BitSlice {</div><div class="diff-removed">-        self.mmap_store.as_ref().unwrap().deleted_vector_bitslice()</div><div class="diff-removed">-    }</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-/// Open a file shortly for appending</div><div class="diff-removed">-fn open_append<P: AsRef<Path>>(path: P) -> io::Result<File> {</div><div class="diff-removed">-    OpenOptions::new().append(true).open(path)</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-#[cfg(test)]</div><div class="diff-removed">-mod tests {</div><div class="diff-removed">-    use std::mem::transmute;</div><div class="diff-removed">-    use std::sync::Arc;</div><div class="diff-removed">-</div><div class="diff-removed">-    use atomic_refcell::AtomicRefCell;</div><div class="diff-removed">-    use common::counter::hardware_counter::HardwareCounterCell;</div><div class="diff-removed">-    use common::types::ScoredPointOffset;</div><div class="diff-removed">-    use memory::mmap_ops::transmute_to_u8_slice;</div><div class="diff-removed">-    use tempfile::Builder;</div><div class="diff-removed">-</div><div class="diff-removed">-    use super::*;</div><div class="diff-removed">-    use crate::common::rocksdb_wrapper::{DB_VECTOR_CF, open_db};</div><div class="diff-removed">-    use crate::data_types::vectors::{DenseVector, QueryVector};</div><div class="diff-removed">-    use crate::fixtures::payload_context_fixture::FixtureIdTracker;</div><div class="diff-removed">-    use crate::id_tracker::id_tracker_base::IdTracker;</div><div class="diff-removed">-    use crate::types::{PointIdType, QuantizationConfig, ScalarQuantizationConfig};</div><div class="diff-removed">-    use crate::vector_storage::dense::simple_dense_vector_storage::open_simple_dense_vector_storage;</div><div class="diff-removed">-    use crate::vector_storage::quantized::quantized_vectors::QuantizedVectors;</div><div class="diff-removed">-    use crate::vector_storage::{DEFAULT_STOPPED, new_raw_scorer_for_test};</div><div class="diff-removed">-</div><div class="diff-removed">-    #[test]</div><div class="diff-removed">-    fn test_basic_persistence() {</div><div class="diff-removed">-        let dir = Builder::new().prefix("storage_dir").tempdir().unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-        let points = [</div><div class="diff-removed">-            vec![1.0, 0.0, 1.0, 1.0],</div><div class="diff-removed">-            vec![1.0, 0.0, 1.0, 0.0],</div><div class="diff-removed">-            vec![1.0, 1.0, 1.0, 1.0],</div><div class="diff-removed">-            vec![1.0, 1.0, 0.0, 1.0],</div><div class="diff-removed">-            vec![1.0, 0.0, 0.0, 0.0],</div><div class="diff-removed">-        ];</div><div class="diff-removed">-        let id_tracker = Arc::new(AtomicRefCell::new(FixtureIdTracker::new(points.len())));</div><div class="diff-removed">-        let mut storage = open_memmap_vector_storage(dir.path(), 4, Distance::Dot).unwrap();</div><div class="diff-removed">-        let mut borrowed_id_tracker = id_tracker.borrow_mut();</div><div class="diff-removed">-</div><div class="diff-removed">-        // Assert this storage lists both the vector and deleted file</div><div class="diff-removed">-        let files = storage.files();</div><div class="diff-removed">-        for file_name in [VECTORS_PATH, DELETED_PATH] {</div><div class="diff-removed">-            files</div><div class="diff-removed">-                .iter()</div><div class="diff-removed">-                .find(|p| p.file_name().unwrap() == file_name)</div><div class="diff-removed">-                .expect("storage is missing required file");</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        let hw_counter = HardwareCounterCell::new();</div><div class="diff-removed">-</div><div class="diff-removed">-        {</div><div class="diff-removed">-            let dir2 = Builder::new().prefix("db_dir").tempdir().unwrap();</div><div class="diff-removed">-            let db = open_db(dir2.path(), &[DB_VECTOR_CF]).unwrap();</div><div class="diff-removed">-            let mut storage2 = open_simple_dense_vector_storage(</div><div class="diff-removed">-                db,</div><div class="diff-removed">-                DB_VECTOR_CF,</div><div class="diff-removed">-                4,</div><div class="diff-removed">-                Distance::Dot,</div><div class="diff-removed">-                &AtomicBool::new(false),</div><div class="diff-removed">-            )</div><div class="diff-removed">-            .unwrap();</div><div class="diff-removed">-            {</div><div class="diff-removed">-                storage2</div><div class="diff-removed">-                    .insert_vector(0, points[0].as_slice().into(), &hw_counter)</div><div class="diff-removed">-                    .unwrap();</div><div class="diff-removed">-                storage2</div><div class="diff-removed">-                    .insert_vector(1, points[1].as_slice().into(), &hw_counter)</div><div class="diff-removed">-                    .unwrap();</div><div class="diff-removed">-                storage2</div><div class="diff-removed">-                    .insert_vector(2, points[2].as_slice().into(), &hw_counter)</div><div class="diff-removed">-                    .unwrap();</div><div class="diff-removed">-            }</div><div class="diff-removed">-            let mut iter = (0..3).map(|i| {</div><div class="diff-removed">-                let i = i as PointOffsetType;</div><div class="diff-removed">-                let vector = storage2.get_vector(i);</div><div class="diff-removed">-                let deleted = storage2.is_deleted_vector(i);</div><div class="diff-removed">-                (vector, deleted)</div><div class="diff-removed">-            });</div><div class="diff-removed">-            storage.update_from(&mut iter, &Default::default()).unwrap();</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        assert_eq!(storage.total_vector_count(), 3);</div><div class="diff-removed">-</div><div class="diff-removed">-        let vector = storage.get_vector(1).to_owned();</div><div class="diff-removed">-        let vector: DenseVector = vector.try_into().unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-        assert_eq!(points[1], vector);</div><div class="diff-removed">-</div><div class="diff-removed">-        borrowed_id_tracker.drop(PointIdType::NumId(2)).unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-        {</div><div class="diff-removed">-            let dir2 = Builder::new().prefix("db_dir").tempdir().unwrap();</div><div class="diff-removed">-            let db = open_db(dir2.path(), &[DB_VECTOR_CF]).unwrap();</div><div class="diff-removed">-            let mut storage2 = open_simple_dense_vector_storage(</div><div class="diff-removed">-                db,</div><div class="diff-removed">-                DB_VECTOR_CF,</div><div class="diff-removed">-                4,</div><div class="diff-removed">-                Distance::Dot,</div><div class="diff-removed">-                &AtomicBool::new(false),</div><div class="diff-removed">-            )</div><div class="diff-removed">-            .unwrap();</div><div class="diff-removed">-            {</div><div class="diff-removed">-                storage2</div><div class="diff-removed">-                    .insert_vector(3, points[3].as_slice().into(), &hw_counter)</div><div class="diff-removed">-                    .unwrap();</div><div class="diff-removed">-                storage2</div><div class="diff-removed">-                    .insert_vector(4, points[4].as_slice().into(), &hw_counter)</div><div class="diff-removed">-                    .unwrap();</div><div class="diff-removed">-            }</div><div class="diff-removed">-            let mut iter = (0..2).map(|i| {</div><div class="diff-removed">-                let i = i as PointOffsetType;</div><div class="diff-removed">-                let vector = storage2.get_vector(i);</div><div class="diff-removed">-                let deleted = storage2.is_deleted_vector(i);</div><div class="diff-removed">-                (vector, deleted)</div><div class="diff-removed">-            });</div><div class="diff-removed">-            storage.update_from(&mut iter, &Default::default()).unwrap();</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        assert_eq!(storage.total_vector_count(), 5);</div><div class="diff-removed">-</div><div class="diff-removed">-        let stored_ids: Vec<PointOffsetType> = borrowed_id_tracker.iter_ids().collect();</div><div class="diff-removed">-</div><div class="diff-removed">-        assert_eq!(stored_ids, [0, 1, 3, 4]);</div><div class="diff-removed">-</div><div class="diff-removed">-        let raw_scorer = new_raw_scorer_for_test(</div><div class="diff-removed">-            points[2].as_slice().into(),</div><div class="diff-removed">-            &storage,</div><div class="diff-removed">-            borrowed_id_tracker.deleted_point_bitslice(),</div><div class="diff-removed">-        )</div><div class="diff-removed">-        .unwrap();</div><div class="diff-removed">-        let res = raw_scorer.peek_top_all(2, &DEFAULT_STOPPED).unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-        assert_eq!(res.len(), 2);</div><div class="diff-removed">-</div><div class="diff-removed">-        assert_ne!(res[0].idx, 2);</div><div class="diff-removed">-</div><div class="diff-removed">-        let res = raw_scorer</div><div class="diff-removed">-            .peek_top_iter(&mut [0, 1, 2, 3, 4].iter().cloned(), 2, &DEFAULT_STOPPED)</div><div class="diff-removed">-            .unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-        assert_eq!(res.len(), 2);</div><div class="diff-removed">-        assert_ne!(res[0].idx, 2);</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    #[test]</div><div class="diff-removed">-    fn test_delete_points() {</div><div class="diff-removed">-        let dir = Builder::new().prefix("storage_dir").tempdir().unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-        let points = [</div><div class="diff-removed">-            vec![1.0, 0.0, 1.0, 1.0],</div><div class="diff-removed">-            vec![1.0, 0.0, 1.0, 0.0],</div><div class="diff-removed">-            vec![1.0, 1.0, 1.0, 1.0],</div><div class="diff-removed">-            vec![1.0, 1.0, 0.0, 1.0],</div><div class="diff-removed">-            vec![1.0, 0.0, 0.0, 0.0],</div><div class="diff-removed">-        ];</div><div class="diff-removed">-        let delete_mask = [false, false, true, true, false];</div><div class="diff-removed">-        let id_tracker = Arc::new(AtomicRefCell::new(FixtureIdTracker::new(points.len())));</div><div class="diff-removed">-        let mut storage = open_memmap_vector_storage(dir.path(), 4, Distance::Dot).unwrap();</div><div class="diff-removed">-        let borrowed_id_tracker = id_tracker.borrow_mut();</div><div class="diff-removed">-</div><div class="diff-removed">-        let hw_counter = HardwareCounterCell::new();</div><div class="diff-removed">-</div><div class="diff-removed">-        {</div><div class="diff-removed">-            let dir2 = Builder::new().prefix("db_dir").tempdir().unwrap();</div><div class="diff-removed">-            let db = open_db(dir2.path(), &[DB_VECTOR_CF]).unwrap();</div><div class="diff-removed">-            let mut storage2 = open_simple_dense_vector_storage(</div><div class="diff-removed">-                db,</div><div class="diff-removed">-                DB_VECTOR_CF,</div><div class="diff-removed">-                4,</div><div class="diff-removed">-                Distance::Dot,</div><div class="diff-removed">-                &AtomicBool::new(false),</div><div class="diff-removed">-            )</div><div class="diff-removed">-            .unwrap();</div><div class="diff-removed">-            {</div><div class="diff-removed">-                points.iter().enumerate().for_each(|(i, vec)| {</div><div class="diff-removed">-                    storage2</div><div class="diff-removed">-                        .insert_vector(i as PointOffsetType, vec.as_slice().into(), &hw_counter)</div><div class="diff-removed">-                        .unwrap();</div><div class="diff-removed">-                });</div><div class="diff-removed">-            }</div><div class="diff-removed">-            let mut iter = (0..points.len()).map(|i| {</div><div class="diff-removed">-                let i = i as PointOffsetType;</div><div class="diff-removed">-                let vector = storage2.get_vector(i);</div><div class="diff-removed">-                let deleted = storage2.is_deleted_vector(i);</div><div class="diff-removed">-                (vector, deleted)</div><div class="diff-removed">-            });</div><div class="diff-removed">-            storage.update_from(&mut iter, &Default::default()).unwrap();</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        assert_eq!(storage.total_vector_count(), 5);</div><div class="diff-removed">-        assert_eq!(storage.deleted_vector_count(), 0);</div><div class="diff-removed">-</div><div class="diff-removed">-        // Delete select number of points</div><div class="diff-removed">-        delete_mask</div><div class="diff-removed">-            .into_iter()</div><div class="diff-removed">-            .enumerate()</div><div class="diff-removed">-            .filter(|(_, d)| *d)</div><div class="diff-removed">-            .for_each(|(i, _)| {</div><div class="diff-removed">-                storage.delete_vector(i as PointOffsetType).unwrap();</div><div class="diff-removed">-            });</div><div class="diff-removed">-        assert_eq!(</div><div class="diff-removed">-            storage.deleted_vector_count(),</div><div class="diff-removed">-            2,</div><div class="diff-removed">-            "2 vectors must be deleted"</div><div class="diff-removed">-        );</div><div class="diff-removed">-</div><div class="diff-removed">-        let vector = vec![0.0, 1.0, 1.1, 1.0];</div><div class="diff-removed">-        let query = vector.as_slice().into();</div><div class="diff-removed">-        let scorer = new_raw_scorer_for_test(</div><div class="diff-removed">-            query,</div><div class="diff-removed">-            &storage,</div><div class="diff-removed">-            borrowed_id_tracker.deleted_point_bitslice(),</div><div class="diff-removed">-        )</div><div class="diff-removed">-        .unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-        let closest = scorer</div><div class="diff-removed">-            .peek_top_iter(&mut [0, 1, 2, 3, 4].iter().cloned(), 5, &DEFAULT_STOPPED)</div><div class="diff-removed">-            .unwrap();</div><div class="diff-removed">-        assert_eq!(closest.len(), 3, "must have 3 vectors, 2 are deleted");</div><div class="diff-removed">-        assert_eq!(closest[0].idx, 0);</div><div class="diff-removed">-        assert_eq!(closest[1].idx, 1);</div><div class="diff-removed">-        assert_eq!(closest[2].idx, 4);</div><div class="diff-removed">-        drop(scorer);</div><div class="diff-removed">-</div><div class="diff-removed">-        // Delete 1, redelete 2</div><div class="diff-removed">-        storage.delete_vector(1 as PointOffsetType).unwrap();</div><div class="diff-removed">-        storage.delete_vector(2 as PointOffsetType).unwrap();</div><div class="diff-removed">-        assert_eq!(</div><div class="diff-removed">-            storage.deleted_vector_count(),</div><div class="diff-removed">-            3,</div><div class="diff-removed">-            "3 vectors must be deleted"</div><div class="diff-removed">-        );</div><div class="diff-removed">-</div><div class="diff-removed">-        let vector = vec![1.0, 0.0, 0.0, 0.0];</div><div class="diff-removed">-        let query = vector.as_slice().into();</div><div class="diff-removed">-</div><div class="diff-removed">-        let scorer = new_raw_scorer_for_test(</div><div class="diff-removed">-            query,</div><div class="diff-removed">-            &storage,</div><div class="diff-removed">-            borrowed_id_tracker.deleted_point_bitslice(),</div><div class="diff-removed">-        )</div><div class="diff-removed">-        .unwrap();</div><div class="diff-removed">-        let closest = scorer</div><div class="diff-removed">-            .peek_top_iter(&mut [0, 1, 2, 3, 4].iter().cloned(), 5, &DEFAULT_STOPPED)</div><div class="diff-removed">-            .unwrap();</div><div class="diff-removed">-        assert_eq!(closest.len(), 2, "must have 2 vectors, 3 are deleted");</div><div class="diff-removed">-        assert_eq!(closest[0].idx, 4);</div><div class="diff-removed">-        assert_eq!(closest[1].idx, 0);</div><div class="diff-removed">-        drop(scorer);</div><div class="diff-removed">-</div><div class="diff-removed">-        // Delete all</div><div class="diff-removed">-        storage.delete_vector(0 as PointOffsetType).unwrap();</div><div class="diff-removed">-        storage.delete_vector(4 as PointOffsetType).unwrap();</div><div class="diff-removed">-        assert_eq!(</div><div class="diff-removed">-            storage.deleted_vector_count(),</div><div class="diff-removed">-            5,</div><div class="diff-removed">-            "all vectors must be deleted"</div><div class="diff-removed">-        );</div><div class="diff-removed">-</div><div class="diff-removed">-        let vector = vec![1.0, 0.0, 0.0, 0.0];</div><div class="diff-removed">-        let query = vector.as_slice().into();</div><div class="diff-removed">-        let scorer = new_raw_scorer_for_test(</div><div class="diff-removed">-            query,</div><div class="diff-removed">-            &storage,</div><div class="diff-removed">-            borrowed_id_tracker.deleted_point_bitslice(),</div><div class="diff-removed">-        )</div><div class="diff-removed">-        .unwrap();</div><div class="diff-removed">-        let closest = scorer.peek_top_all(5, &DEFAULT_STOPPED).unwrap();</div><div class="diff-removed">-        assert!(closest.is_empty(), "must have no results, all deleted");</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Test that deleted points are properly transferred when updating from other storage.</div><div class="diff-removed">-    #[test]</div><div class="diff-removed">-    fn test_update_from_delete_points() {</div><div class="diff-removed">-        let dir = Builder::new().prefix("storage_dir").tempdir().unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-        let points = [</div><div class="diff-removed">-            vec![1.0, 0.0, 1.0, 1.0],</div><div class="diff-removed">-            vec![1.0, 0.0, 1.0, 0.0],</div><div class="diff-removed">-            vec![1.0, 1.0, 1.0, 1.0],</div><div class="diff-removed">-            vec![1.0, 1.0, 0.0, 1.0],</div><div class="diff-removed">-            vec![1.0, 0.0, 0.0, 0.0],</div><div class="diff-removed">-        ];</div><div class="diff-removed">-        let delete_mask = [false, false, true, true, false];</div><div class="diff-removed">-        let id_tracker = Arc::new(AtomicRefCell::new(FixtureIdTracker::new(points.len())));</div><div class="diff-removed">-        let mut storage = open_memmap_vector_storage(dir.path(), 4, Distance::Dot).unwrap();</div><div class="diff-removed">-        let borrowed_id_tracker = id_tracker.borrow_mut();</div><div class="diff-removed">-</div><div class="diff-removed">-        let hw_counter = HardwareCounterCell::new();</div><div class="diff-removed">-</div><div class="diff-removed">-        {</div><div class="diff-removed">-            let dir2 = Builder::new().prefix("db_dir").tempdir().unwrap();</div><div class="diff-removed">-            let db = open_db(dir2.path(), &[DB_VECTOR_CF]).unwrap();</div><div class="diff-removed">-            let mut storage2 = open_simple_dense_vector_storage(</div><div class="diff-removed">-                db,</div><div class="diff-removed">-                DB_VECTOR_CF,</div><div class="diff-removed">-                4,</div><div class="diff-removed">-                Distance::Dot,</div><div class="diff-removed">-                &AtomicBool::new(false),</div><div class="diff-removed">-            )</div><div class="diff-removed">-            .unwrap();</div><div class="diff-removed">-            {</div><div class="diff-removed">-                points.iter().enumerate().for_each(|(i, vec)| {</div><div class="diff-removed">-                    storage2</div><div class="diff-removed">-                        .insert_vector(i as PointOffsetType, vec.as_slice().into(), &hw_counter)</div><div class="diff-removed">-                        .unwrap();</div><div class="diff-removed">-                    if delete_mask[i] {</div><div class="diff-removed">-                        storage2.delete_vector(i as PointOffsetType).unwrap();</div><div class="diff-removed">-                    }</div><div class="diff-removed">-                });</div><div class="diff-removed">-            }</div><div class="diff-removed">-            let mut iter = (0..points.len()).map(|i| {</div><div class="diff-removed">-                let i = i as PointOffsetType;</div><div class="diff-removed">-                let vector = storage2.get_vector(i);</div><div class="diff-removed">-                let deleted = storage2.is_deleted_vector(i);</div><div class="diff-removed">-                (vector, deleted)</div><div class="diff-removed">-            });</div><div class="diff-removed">-            storage.update_from(&mut iter, &Default::default()).unwrap();</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        assert_eq!(</div><div class="diff-removed">-            storage.deleted_vector_count(),</div><div class="diff-removed">-            2,</div><div class="diff-removed">-            "2 vectors must be deleted from other storage"</div><div class="diff-removed">-        );</div><div class="diff-removed">-</div><div class="diff-removed">-        let vector = vec![0.0, 1.0, 1.1, 1.0];</div><div class="diff-removed">-        let query = vector.as_slice().into();</div><div class="diff-removed">-        let scorer = new_raw_scorer_for_test(</div><div class="diff-removed">-            query,</div><div class="diff-removed">-            &storage,</div><div class="diff-removed">-            borrowed_id_tracker.deleted_point_bitslice(),</div><div class="diff-removed">-        )</div><div class="diff-removed">-        .unwrap();</div><div class="diff-removed">-        let closest = scorer</div><div class="diff-removed">-            .peek_top_iter(&mut [0, 1, 2, 3, 4].iter().cloned(), 5, &DEFAULT_STOPPED)</div><div class="diff-removed">-            .unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-        drop(scorer);</div><div class="diff-removed">-</div><div class="diff-removed">-        assert_eq!(closest.len(), 3, "must have 3 vectors, 2 are deleted");</div><div class="diff-removed">-        assert_eq!(closest[0].idx, 0);</div><div class="diff-removed">-        assert_eq!(closest[1].idx, 1);</div><div class="diff-removed">-        assert_eq!(closest[2].idx, 4);</div><div class="diff-removed">-</div><div class="diff-removed">-        // Delete all</div><div class="diff-removed">-        storage.delete_vector(0 as PointOffsetType).unwrap();</div><div class="diff-removed">-        storage.delete_vector(1 as PointOffsetType).unwrap();</div><div class="diff-removed">-        storage.delete_vector(4 as PointOffsetType).unwrap();</div><div class="diff-removed">-        assert_eq!(</div><div class="diff-removed">-            storage.deleted_vector_count(),</div><div class="diff-removed">-            5,</div><div class="diff-removed">-            "all vectors must be deleted"</div><div class="diff-removed">-        );</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    #[test]</div><div class="diff-removed">-    fn test_mmap_raw_scorer() {</div><div class="diff-removed">-        let dir = Builder::new().prefix("storage_dir").tempdir().unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-        let points = [</div><div class="diff-removed">-            vec![1.0, 0.0, 1.0, 1.0],</div><div class="diff-removed">-            vec![1.0, 0.0, 1.0, 0.0],</div><div class="diff-removed">-            vec![1.0, 1.0, 1.0, 1.0],</div><div class="diff-removed">-            vec![1.0, 1.0, 0.0, 1.0],</div><div class="diff-removed">-            vec![1.0, 0.0, 0.0, 0.0],</div><div class="diff-removed">-        ];</div><div class="diff-removed">-        let id_tracker = Arc::new(AtomicRefCell::new(FixtureIdTracker::new(points.len())));</div><div class="diff-removed">-        let mut storage = open_memmap_vector_storage(dir.path(), 4, Distance::Dot).unwrap();</div><div class="diff-removed">-        let borrowed_id_tracker = id_tracker.borrow_mut();</div><div class="diff-removed">-</div><div class="diff-removed">-        let hw_counter = HardwareCounterCell::new();</div><div class="diff-removed">-</div><div class="diff-removed">-        {</div><div class="diff-removed">-            let dir2 = Builder::new().prefix("db_dir").tempdir().unwrap();</div><div class="diff-removed">-            let db = open_db(dir2.path(), &[DB_VECTOR_CF]).unwrap();</div><div class="diff-removed">-            let mut storage2 = open_simple_dense_vector_storage(</div><div class="diff-removed">-                db,</div><div class="diff-removed">-                DB_VECTOR_CF,</div><div class="diff-removed">-                4,</div><div class="diff-removed">-                Distance::Dot,</div><div class="diff-removed">-                &AtomicBool::new(false),</div><div class="diff-removed">-            )</div><div class="diff-removed">-            .unwrap();</div><div class="diff-removed">-            {</div><div class="diff-removed">-                for (i, vec) in points.iter().enumerate() {</div><div class="diff-removed">-                    storage2</div><div class="diff-removed">-                        .insert_vector(i as PointOffsetType, vec.as_slice().into(), &hw_counter)</div><div class="diff-removed">-                        .unwrap();</div><div class="diff-removed">-                }</div><div class="diff-removed">-            }</div><div class="diff-removed">-            let mut iter = (0..points.len()).map(|i| {</div><div class="diff-removed">-                let i = i as PointOffsetType;</div><div class="diff-removed">-                let vector = storage2.get_vector(i);</div><div class="diff-removed">-                let deleted = storage2.is_deleted_vector(i);</div><div class="diff-removed">-                (vector, deleted)</div><div class="diff-removed">-            });</div><div class="diff-removed">-            storage.update_from(&mut iter, &Default::default()).unwrap();</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        let vector = vec![-1.0, -1.0, -1.0, -1.0];</div><div class="diff-removed">-        let query = vector.as_slice().into();</div><div class="diff-removed">-        let query_points: Vec<PointOffsetType> = vec![0, 2, 4];</div><div class="diff-removed">-</div><div class="diff-removed">-        let scorer = new_raw_scorer_for_test(</div><div class="diff-removed">-            query,</div><div class="diff-removed">-            &storage,</div><div class="diff-removed">-            borrowed_id_tracker.deleted_point_bitslice(),</div><div class="diff-removed">-        )</div><div class="diff-removed">-        .unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-        let mut res = vec![ScoredPointOffset { idx: 0, score: 0. }; query_points.len()];</div><div class="diff-removed">-        let res_count = scorer.score_points(&query_points, &mut res);</div><div class="diff-removed">-        res.resize(res_count, ScoredPointOffset { idx: 0, score: 0. });</div><div class="diff-removed">-</div><div class="diff-removed">-        assert_eq!(res.len(), 3);</div><div class="diff-removed">-        assert_eq!(res[0].idx, 0);</div><div class="diff-removed">-        assert_eq!(res[1].idx, 2);</div><div class="diff-removed">-        assert_eq!(res[2].idx, 4);</div><div class="diff-removed">-</div><div class="diff-removed">-        assert_eq!(res[2].score, -1.0);</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    #[test]</div><div class="diff-removed">-    fn test_casts() {</div><div class="diff-removed">-        let data: DenseVector = vec![0.42, 0.069, 333.1, 100500.];</div><div class="diff-removed">-</div><div class="diff-removed">-        let raw_data = transmute_to_u8_slice(&data);</div><div class="diff-removed">-</div><div class="diff-removed">-        eprintln!("raw_data.len() = {:#?}", raw_data.len());</div><div class="diff-removed">-</div><div class="diff-removed">-        let arr: &[VectorElementType] = unsafe { transmute(raw_data) };</div><div class="diff-removed">-</div><div class="diff-removed">-        let slice = &arr[0..data.len()];</div><div class="diff-removed">-</div><div class="diff-removed">-        eprintln!("slice.len() = {:#?}", slice.len());</div><div class="diff-removed">-</div><div class="diff-removed">-        for (idx, element) in slice.iter().enumerate() {</div><div class="diff-removed">-            println!("slice[{idx}]  = {element:?}");</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    #[test]</div><div class="diff-removed">-    fn test_mmap_quantization() {</div><div class="diff-removed">-        let dir = Builder::new().prefix("storage_dir").tempdir().unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-        let points = [</div><div class="diff-removed">-            vec![1.0, 0.0, 1.0, 1.0],</div><div class="diff-removed">-            vec![1.0, 0.0, 1.0, 0.0],</div><div class="diff-removed">-            vec![1.0, 1.0, 1.0, 1.0],</div><div class="diff-removed">-            vec![1.0, 1.0, 0.0, 1.0],</div><div class="diff-removed">-            vec![1.0, 0.0, 0.0, 0.0],</div><div class="diff-removed">-        ];</div><div class="diff-removed">-        let id_tracker = Arc::new(AtomicRefCell::new(FixtureIdTracker::new(points.len())));</div><div class="diff-removed">-        let mut storage = open_memmap_vector_storage(dir.path(), 4, Distance::Dot).unwrap();</div><div class="diff-removed">-        let borrowed_id_tracker = id_tracker.borrow_mut();</div><div class="diff-removed">-</div><div class="diff-removed">-        let hw_counter = HardwareCounterCell::new();</div><div class="diff-removed">-</div><div class="diff-removed">-        {</div><div class="diff-removed">-            let dir2 = Builder::new().prefix("db_dir").tempdir().unwrap();</div><div class="diff-removed">-            let db = open_db(dir2.path(), &[DB_VECTOR_CF]).unwrap();</div><div class="diff-removed">-            let mut storage2 = open_simple_dense_vector_storage(</div><div class="diff-removed">-                db,</div><div class="diff-removed">-                DB_VECTOR_CF,</div><div class="diff-removed">-                4,</div><div class="diff-removed">-                Distance::Dot,</div><div class="diff-removed">-                &AtomicBool::new(false),</div><div class="diff-removed">-            )</div><div class="diff-removed">-            .unwrap();</div><div class="diff-removed">-            {</div><div class="diff-removed">-                for (i, vec) in points.iter().enumerate() {</div><div class="diff-removed">-                    storage2</div><div class="diff-removed">-                        .insert_vector(i as PointOffsetType, vec.as_slice().into(), &hw_counter)</div><div class="diff-removed">-                        .unwrap();</div><div class="diff-removed">-                }</div><div class="diff-removed">-            }</div><div class="diff-removed">-            let mut iter = (0..points.len()).map(|i| {</div><div class="diff-removed">-                let i = i as PointOffsetType;</div><div class="diff-removed">-                let vector = storage2.get_vector(i);</div><div class="diff-removed">-                let deleted = storage2.is_deleted_vector(i);</div><div class="diff-removed">-                (vector, deleted)</div><div class="diff-removed">-            });</div><div class="diff-removed">-            storage.update_from(&mut iter, &Default::default()).unwrap();</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        let config: QuantizationConfig = ScalarQuantizationConfig {</div><div class="diff-removed">-            r#type: Default::default(),</div><div class="diff-removed">-            quantile: None,</div><div class="diff-removed">-            always_ram: None,</div><div class="diff-removed">-        }</div><div class="diff-removed">-        .into();</div><div class="diff-removed">-</div><div class="diff-removed">-        let stopped = Arc::new(AtomicBool::new(false));</div><div class="diff-removed">-        let hardware_counter = HardwareCounterCell::new();</div><div class="diff-removed">-        let quantized_vectors =</div><div class="diff-removed">-            QuantizedVectors::create(&storage, &config, dir.path(), 1, &stopped).unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-        let query: QueryVector = [0.5, 0.5, 0.5, 0.5].into();</div><div class="diff-removed">-</div><div class="diff-removed">-        let scorer_quant = quantized_vectors</div><div class="diff-removed">-            .raw_scorer(</div><div class="diff-removed">-                query.clone(),</div><div class="diff-removed">-                borrowed_id_tracker.deleted_point_bitslice(),</div><div class="diff-removed">-                storage.deleted_vector_bitslice(),</div><div class="diff-removed">-                hardware_counter,</div><div class="diff-removed">-            )</div><div class="diff-removed">-            .unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-        let scorer_orig = new_raw_scorer_for_test(</div><div class="diff-removed">-            query.clone(),</div><div class="diff-removed">-            &storage,</div><div class="diff-removed">-            borrowed_id_tracker.deleted_point_bitslice(),</div><div class="diff-removed">-        )</div><div class="diff-removed">-        .unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-        for i in 0..5 {</div><div class="diff-removed">-            let quant = scorer_quant.score_point(i);</div><div class="diff-removed">-            let orig = scorer_orig.score_point(i);</div><div class="diff-removed">-            assert!((orig - quant).abs() < 0.15);</div><div class="diff-removed">-</div><div class="diff-removed">-            let quant = scorer_quant.score_internal(0, i);</div><div class="diff-removed">-            let orig = scorer_orig.score_internal(0, i);</div><div class="diff-removed">-            assert!((orig - quant).abs() < 0.15);</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        let files = storage.files();</div><div class="diff-removed">-        let quantization_files = quantized_vectors.files();</div><div class="diff-removed">-</div><div class="diff-removed">-        // test save-load</div><div class="diff-removed">-        let quantized_vectors = QuantizedVectors::load(&storage, dir.path()).unwrap();</div><div class="diff-removed">-        assert_eq!(files, storage.files());</div><div class="diff-removed">-        assert_eq!(quantization_files, quantized_vectors.files());</div><div class="diff-removed">-        let hardware_counter = HardwareCounterCell::new();</div><div class="diff-removed">-        let scorer_quant = quantized_vectors</div><div class="diff-removed">-            .raw_scorer(</div><div class="diff-removed">-                query.clone(),</div><div class="diff-removed">-                borrowed_id_tracker.deleted_point_bitslice(),</div><div class="diff-removed">-                storage.deleted_vector_bitslice(),</div><div class="diff-removed">-                hardware_counter,</div><div class="diff-removed">-            )</div><div class="diff-removed">-            .unwrap();</div><div class="diff-removed">-        let scorer_orig = new_raw_scorer_for_test(</div><div class="diff-removed">-            query,</div><div class="diff-removed">-            &storage,</div><div class="diff-removed">-            borrowed_id_tracker.deleted_point_bitslice(),</div><div class="diff-removed">-        )</div><div class="diff-removed">-        .unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-        for i in 0..5 {</div><div class="diff-removed">-            let quant = scorer_quant.score_point(i);</div><div class="diff-removed">-            let orig = scorer_orig.score_point(i);</div><div class="diff-removed">-            assert!((orig - quant).abs() < 0.15);</div><div class="diff-removed">-</div><div class="diff-removed">-            let quant = scorer_quant.score_internal(0, i);</div><div class="diff-removed">-            let orig = scorer_orig.score_internal(0, i);</div><div class="diff-removed">-            assert!((orig - quant).abs() < 0.15);</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-}</div><div>\ No newline at end of file</div><div class="diff-added">+The overall trend was towards improving performance, adding support for different vector types, enhancing caching behavior, and refining the API. The storage became more flexible and gained better control over memory and disk usage over time.</div><div>\ No newline at end of file</div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    