<!DOCTYPE html>
<!--

THIS FILE IS AUTOMATICALLY GENERATED BY benchmark_pipeline/3_generate_pages.py
DO NOT EDIT DIRECTLY - ANY CHANGES WILL BE OVERWRITTEN
Last generated: 2025-05-03 01:42:18

-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LoCoDiff Benchmark Results</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <h1>LoCoDiff Benchmark Results</h1>
        <p>Generated on 2025-05-03 01:42:18</p>
    </header>
    <main>

    <section id="token-chart">
        <h2>Success Rate by Prompt Size</h2>
        <div class="chart-controls">
            <div class="model-selection">
                <h3>Models</h3>
                <div id="model-checkboxes"></div>
            </div>
            <div class="language-selection">
                <h3>Languages</h3>
                <div id="language-checkboxes"></div>
            </div>
            <div class="bucketing-options">
                <h3>Bucketing Options</h3>
                <div class="bucket-count-control">
                    <label for="bucket-count">Number of Buckets: <span id="bucket-count-display">5</span></label>
                    <input type="range" id="bucket-count" min="1" max="20" value="5" step="1">
                </div>
            </div>
            <div class="display-options">
                <h3>Display Options</h3>
                <div class="checkbox-item">
                    <label>
                        <input type="checkbox" id="show-confidence-intervals" checked>
                        Show 95% Confidence Intervals
                    </label>
                </div>
            </div>
        </div>
        <div class="chart-container">
            <canvas id="token-success-chart"></canvas>
        </div>
    </section>
    
    <section id="overall-stats">
        <h2>Overall Model Performance</h2>
        <table>
            <thead>
                <tr>
                    <th>Model</th>
                    <th>Success Rate</th>
                    <th>Cases Run</th>
                    <th>Total Cost</th>
                    <th>Avg Cost per Run</th>
                </tr>
            </thead>
            <tbody>
    
                <tr>
                    <td>Sonnet 3.6</td>
                    <td>24.50% (49/200)</td>
                    <td>200/200 (100.00%)</td>
                    <td>$44.01</td>
                    <td>$0.220</td>
                </tr>
        
                <tr>
                    <td>Sonnet 3.7</td>
                    <td>33.00% (66/200)</td>
                    <td>200/200 (100.00%)</td>
                    <td>$47.88</td>
                    <td>$0.239</td>
                </tr>
        
                <tr>
                    <td>Sonnet 3.7 Thinking</td>
                    <td>47.00% (94/200)</td>
                    <td>200/200 (100.00%)</td>
                    <td>$70.57</td>
                    <td>$0.353</td>
                </tr>
        
                <tr>
                    <td>DeepSeek Chat v3-0324</td>
                    <td>26.00% (52/200)</td>
                    <td>200/200 (100.00%)</td>
                    <td>$4.53</td>
                    <td>$0.023</td>
                </tr>
        
                <tr>
                    <td>DeepSeek R1</td>
                    <td>18.00% (36/200)</td>
                    <td>200/200 (100.00%)</td>
                    <td>$8.07</td>
                    <td>$0.040</td>
                </tr>
        
                <tr>
                    <td>Gemini 2.5 Flash</td>
                    <td>19.50% (39/200)</td>
                    <td>200/200 (100.00%)</td>
                    <td>$2.12</td>
                    <td>$0.011</td>
                </tr>
        
                <tr>
                    <td>Gemini 2.5 Flash Thinking</td>
                    <td>11.00% (22/200)</td>
                    <td>200/200 (100.00%)</td>
                    <td>$12.39</td>
                    <td>$0.062</td>
                </tr>
        
                <tr>
                    <td>Gemini 2.5 Pro</td>
                    <td>37.19% (74/199)</td>
                    <td>199/200 (99.50%)</td>
                    <td>$34.82</td>
                    <td>$0.175</td>
                </tr>
        
                <tr>
                    <td>GPT-4.1</td>
                    <td>19.50% (39/200)</td>
                    <td>200/200 (100.00%)</td>
                    <td>$1.22</td>
                    <td>$0.006</td>
                </tr>
        
                <tr>
                    <td>o3</td>
                    <td>11.00% (22/200)</td>
                    <td>200/200 (100.00%)</td>
                    <td>$128.93</td>
                    <td>$0.645</td>
                </tr>
        
                <tr>
                    <td>o4-mini-medium</td>
                    <td>8.00% (16/200)</td>
                    <td>200/200 (100.00%)</td>
                    <td>$10.74</td>
                    <td>$0.054</td>
                </tr>
        
                <tr>
                    <td>o4-mini-high</td>
                    <td>6.50% (13/200)</td>
                    <td>200/200 (100.00%)</td>
                    <td>$26.07</td>
                    <td>$0.130</td>
                </tr>
        
                <tr>
                    <td>Grok 3</td>
                    <td>30.50% (61/200)</td>
                    <td>200/200 (100.00%)</td>
                    <td>$37.14</td>
                    <td>$0.186</td>
                </tr>
        
                <tr>
                    <td>Grok 3 Mini</td>
                    <td>6.00% (12/200)</td>
                    <td>200/200 (100.00%)</td>
                    <td>$2.98</td>
                    <td>$0.015</td>
                </tr>
        
            </tbody>
        </table>
    </section>
    
    <section id="quartile-stats">
        <h2>Success Rates by Prompt Size Quartiles</h2>
        <table>
            <thead>
                <tr>
                    <th>Model</th>
    <th>Q1 (1994-21186 tokens)</th><th>Q2 (21186-35974 tokens)</th><th>Q3 (35974-59831 tokens)</th><th>Q4 (59831-97521 tokens)</th>
                </tr>
            </thead>
            <tbody>
    <tr><td>Sonnet 3.6</td><td>62.75% (32/51)</td><td>24.00% (12/50)</td><td>4.00% (2/50)</td><td>6.12% (3/49)</td></tr><tr><td>Sonnet 3.7</td><td>52.94% (27/51)</td><td>36.00% (18/50)</td><td>24.00% (12/50)</td><td>18.37% (9/49)</td></tr><tr><td>Sonnet 3.7 Thinking</td><td>72.55% (37/51)</td><td>48.00% (24/50)</td><td>44.00% (22/50)</td><td>22.45% (11/49)</td></tr><tr><td>DeepSeek Chat v3-0324</td><td>52.94% (27/51)</td><td>32.00% (16/50)</td><td>14.00% (7/50)</td><td>4.08% (2/49)</td></tr><tr><td>DeepSeek R1</td><td>49.02% (25/51)</td><td>14.00% (7/50)</td><td>8.00% (4/50)</td><td>0.00% (0/49)</td></tr><tr><td>Gemini 2.5 Flash</td><td>47.06% (24/51)</td><td>8.00% (4/50)</td><td>18.00% (9/50)</td><td>4.08% (2/49)</td></tr><tr><td>Gemini 2.5 Flash Thinking</td><td>33.33% (17/51)</td><td>4.00% (2/50)</td><td>6.00% (3/50)</td><td>0.00% (0/49)</td></tr><tr><td>Gemini 2.5 Pro</td><td>60.78% (31/51)</td><td>44.00% (22/50)</td><td>22.45% (11/49)</td><td>20.41% (10/49)</td></tr><tr><td>GPT-4.1</td><td>47.06% (24/51)</td><td>12.00% (6/50)</td><td>14.00% (7/50)</td><td>4.08% (2/49)</td></tr><tr><td>o3</td><td>37.25% (19/51)</td><td>0.00% (0/50)</td><td>4.00% (2/50)</td><td>2.04% (1/49)</td></tr><tr><td>o4-mini-medium</td><td>27.45% (14/51)</td><td>0.00% (0/50)</td><td>4.00% (2/50)</td><td>0.00% (0/49)</td></tr><tr><td>o4-mini-high</td><td>21.57% (11/51)</td><td>0.00% (0/50)</td><td>4.00% (2/50)</td><td>0.00% (0/49)</td></tr><tr><td>Grok 3</td><td>64.71% (33/51)</td><td>38.00% (19/50)</td><td>12.00% (6/50)</td><td>6.12% (3/49)</td></tr><tr><td>Grok 3 Mini</td><td>21.57% (11/51)</td><td>0.00% (0/50)</td><td>2.00% (1/50)</td><td>0.00% (0/49)</td></tr>
            </tbody>
        </table>
    </section>
    
    <section id="language-stats">
        <h2>Success Rates by Programming Language</h2>
        <table>
            <thead>
                <tr>
                    <th>Model</th>
    <th>javascript (42)</th><th>python (39)</th><th>rust (39)</th><th>typescript (40)</th><th>zig (40)</th>
                </tr>
            </thead>
            <tbody>
    <tr><td>Sonnet 3.6</td><td>21.43% (9/42)</td><td>38.46% (15/39)</td><td>17.95% (7/39)</td><td>22.50% (9/40)</td><td>22.50% (9/40)</td></tr><tr><td>Sonnet 3.7</td><td>40.48% (17/42)</td><td>35.90% (14/39)</td><td>25.64% (10/39)</td><td>40.00% (16/40)</td><td>22.50% (9/40)</td></tr><tr><td>Sonnet 3.7 Thinking</td><td>47.62% (20/42)</td><td>48.72% (19/39)</td><td>33.33% (13/39)</td><td>55.00% (22/40)</td><td>50.00% (20/40)</td></tr><tr><td>DeepSeek Chat v3-0324</td><td>19.05% (8/42)</td><td>28.21% (11/39)</td><td>15.38% (6/39)</td><td>32.50% (13/40)</td><td>35.00% (14/40)</td></tr><tr><td>DeepSeek R1</td><td>16.67% (7/42)</td><td>17.95% (7/39)</td><td>2.56% (1/39)</td><td>22.50% (9/40)</td><td>30.00% (12/40)</td></tr><tr><td>Gemini 2.5 Flash</td><td>23.81% (10/42)</td><td>15.38% (6/39)</td><td>10.26% (4/39)</td><td>20.00% (8/40)</td><td>27.50% (11/40)</td></tr><tr><td>Gemini 2.5 Flash Thinking</td><td>11.90% (5/42)</td><td>5.13% (2/39)</td><td>5.13% (2/39)</td><td>12.50% (5/40)</td><td>20.00% (8/40)</td></tr><tr><td>Gemini 2.5 Pro</td><td>35.71% (15/42)</td><td>28.95% (11/38)</td><td>20.51% (8/39)</td><td>47.50% (19/40)</td><td>52.50% (21/40)</td></tr><tr><td>GPT-4.1</td><td>23.81% (10/42)</td><td>12.82% (5/39)</td><td>2.56% (1/39)</td><td>32.50% (13/40)</td><td>25.00% (10/40)</td></tr><tr><td>o3</td><td>11.90% (5/42)</td><td>7.69% (3/39)</td><td>2.56% (1/39)</td><td>10.00% (4/40)</td><td>22.50% (9/40)</td></tr><tr><td>o4-mini-medium</td><td>14.29% (6/42)</td><td>2.56% (1/39)</td><td>2.56% (1/39)</td><td>7.50% (3/40)</td><td>12.50% (5/40)</td></tr><tr><td>o4-mini-high</td><td>7.14% (3/42)</td><td>2.56% (1/39)</td><td>2.56% (1/39)</td><td>10.00% (4/40)</td><td>10.00% (4/40)</td></tr><tr><td>Grok 3</td><td>30.95% (13/42)</td><td>35.90% (14/39)</td><td>23.08% (9/39)</td><td>40.00% (16/40)</td><td>22.50% (9/40)</td></tr><tr><td>Grok 3 Mini</td><td>9.52% (4/42)</td><td>0.00% (0/39)</td><td>2.56% (1/39)</td><td>10.00% (4/40)</td><td>7.50% (3/40)</td></tr>
            </tbody>
        </table>
    </section>
    
    <section id="explore-benchmarks">
        <h2>Explore Benchmark Prompts and Model Outputs</h2>
        <p>Select a model below to view its benchmark cases:</p>
        <ul class="model-list">
    
            <li>
                <a href="models/anthropic_claude-3.5-sonnet.html" class="model-link">
                    Sonnet 3.6
                </a>
            </li>
        
            <li>
                <a href="models/anthropic_claude-3.7-sonnet.html" class="model-link">
                    Sonnet 3.7
                </a>
            </li>
        
            <li>
                <a href="models/anthropic_claude-3.7-sonnetthinking.html" class="model-link">
                    Sonnet 3.7 Thinking
                </a>
            </li>
        
            <li>
                <a href="models/deepseek_deepseek-chat-v3-0324.html" class="model-link">
                    DeepSeek Chat v3-0324
                </a>
            </li>
        
            <li>
                <a href="models/deepseek_deepseek-r1.html" class="model-link">
                    DeepSeek R1
                </a>
            </li>
        
            <li>
                <a href="models/google_gemini-2.5-flash-preview.html" class="model-link">
                    Gemini 2.5 Flash
                </a>
            </li>
        
            <li>
                <a href="models/google_gemini-2.5-flash-previewthinking.html" class="model-link">
                    Gemini 2.5 Flash Thinking
                </a>
            </li>
        
            <li>
                <a href="models/google_gemini-2.5-pro-preview-03-25.html" class="model-link">
                    Gemini 2.5 Pro
                </a>
            </li>
        
            <li>
                <a href="models/openai_gpt-4.1.html" class="model-link">
                    GPT-4.1
                </a>
            </li>
        
            <li>
                <a href="models/openai_o3.html" class="model-link">
                    o3
                </a>
            </li>
        
            <li>
                <a href="models/openai_o4-mini.html" class="model-link">
                    o4-mini-medium
                </a>
            </li>
        
            <li>
                <a href="models/openai_o4-mini-high.html" class="model-link">
                    o4-mini-high
                </a>
            </li>
        
            <li>
                <a href="models/x-ai_grok-3-beta.html" class="model-link">
                    Grok 3
                </a>
            </li>
        
            <li>
                <a href="models/x-ai_grok-3-mini-beta.html" class="model-link">
                    Grok 3 Mini
                </a>
            </li>
        
        </ul>
    </section>
    
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
    
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
// Load chart data
fetch('chart_data.json')
    .then(response => response.json())
    .then(wrapper => {
        // Use the data property which contains the actual chart data
        // The _warning property contains the auto-generation warning
        initializeChart(wrapper.data);
    });

// JavaScript implementation of Wilson score interval for confidence intervals
function wilson_score_interval(successful, attempts, z = 1.96) {
    if (attempts === 0) return [0.0, 0.0];
    
    // Observed proportion
    const p_hat = successful / attempts;
    
    // Wilson score calculation
    const denominator = 1 + (z * z / attempts);
    const center = (p_hat + (z * z / (2 * attempts))) / denominator;
    const interval = z * Math.sqrt((p_hat * (1 - p_hat) + (z * z / (4 * attempts))) / attempts) / denominator;
    
    const lower_bound = Math.max(0.0, center - interval);
    const upper_bound = Math.min(1.0, center + interval);
    
    return [lower_bound, upper_bound];
}

function initializeChart(chartData) {
    // Define chart colors
    const colors = [
        '#4e79a7', '#f28e2c', '#e15759', '#76b7b2', '#59a14f',
        '#edc949', '#af7aa1', '#ff9da7', '#9c755f', '#bab0ab'
    ];
    
    // Create global variables for chart state that need to be accessed by callbacks
    let currentSelectedLanguages = [];
    let currentSelectedModels = [];
    let currentBucketCount = chartData.default_bucket_count || 5;
    let buckets = []; // Will be calculated dynamically
    
    // Get canvas context
    const ctx = document.getElementById('token-success-chart').getContext('2d');
    
    // Create model checkboxes
    const modelCheckboxes = document.getElementById('model-checkboxes');
    chartData.models.forEach((model) => {
        // Use display name if available, otherwise use original model name
        const displayName = chartData.model_display_names && chartData.model_display_names[model] 
            ? chartData.model_display_names[model] 
            : model;
        
        const checkbox = document.createElement('div');
        checkbox.className = 'checkbox-item';
        checkbox.innerHTML = `
            <label>
                <input type="checkbox" data-model="${model}" checked>
                ${displayName}
            </label>
        `;
        modelCheckboxes.appendChild(checkbox);
    });
    
    // Create language checkboxes
    const languageCheckboxes = document.getElementById('language-checkboxes');
    chartData.languages.forEach(language => {
        const checkbox = document.createElement('div');
        checkbox.className = 'checkbox-item';
        checkbox.innerHTML = `
            <label>
                <input type="checkbox" data-language="${language}" checked>
                ${language}
            </label>
        `;
        languageCheckboxes.appendChild(checkbox);
    });
    
    // Setup bucket count slider
    const bucketCountSlider = document.getElementById('bucket-count');
    const bucketCountDisplay = document.getElementById('bucket-count-display');
    
    // Make sure the elements exist before trying to access them
    if (bucketCountSlider && bucketCountDisplay) {
        bucketCountSlider.value = currentBucketCount;
        bucketCountDisplay.textContent = currentBucketCount;
        
        bucketCountSlider.addEventListener('input', function() {
            currentBucketCount = parseInt(this.value);
            bucketCountDisplay.textContent = currentBucketCount;
            calculateBuckets();
            updateChart();
        });
    } else {
        console.warn('Bucket count slider elements not found. Check that the HTML includes the proper elements.');
    }
    
    // Create chart
    const chart = new Chart(ctx, {
        type: 'line',
        data: {
            datasets: []
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    type: 'linear',
                    min: 0,
                    max: chartData.max_tokens_k,
                    // We'll override ticks in updateChart
                    ticks: {
                        // Empty default ticks configuration - will be set dynamically
                    },
                    title: {
                        display: true,
                        text: 'Prompt Token Length (k)'
                    },
                    grid: {
                        // Make grid lines match our ticks
                        z: -1 // Draw grid lines behind the data
                    }
                },
                y: {
                    title: {
                        display: true,
                        text: 'Success Rate (%)'
                    },
                    min: 0,
                    max: 100
                }
            },
            plugins: {
                title: {
                    display: true,
                    text: 'LoCoDiff: Natural Long Context Code Bench',
                    font: {
                        size: 18
                    },
                    padding: {
                        top: 10,
                        bottom: 30
                    }
                },
                legend: {
                    labels: {
                        filter: (legendItem, data) => {
                            const dataset = data.datasets[legendItem.datasetIndex];
                            return dataset && dataset.display !== false;
                        }
                    }
                },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            if (!context || !context.dataset || !context.dataset.label) {
                                return null;
                            }
                            
                            if (context.dataset.label.includes('CI')) {
                                return null;
                            }
                            
                            try {
                                const displayName = context.dataset.label;
                                const originalModel = context.dataset.originalModel || displayName;
                                const xValue = context.raw.x; // Token count in thousands
                                
                                // Find the bucket with matching token count
                                const bucketData = buckets.find(bucket => 
                                    Math.abs((bucket.avgTokens / 1000) - xValue) < 0.01
                                );
                                
                                if (!bucketData) {
                                    return [`${displayName}`];
                                }
                                
                                const modelStats = bucketData.modelStats[originalModel];
                                if (!modelStats) {
                                    return [`${displayName}: No data available`];
                                }
                                
                                const successRate = context.raw.y;
                                const successful = modelStats.successful;
                                const attempts = modelStats.attempts;
                                const caseCount = bucketData.caseCount;
                                
                                // Get confidence interval
                                let ciInfo = '';
                                const ciElement = document.getElementById('show-confidence-intervals');
                                if (ciElement && ciElement.checked && attempts > 0) {
                                    const [lower, upper] = wilson_score_interval(successful, caseCount);
                                    ciInfo = `
95% CI: ${(lower * 100).toFixed(2)}% - ${(upper * 100).toFixed(2)}%`;
                                }
                                
                                // Calculate untested cases
                                const untestedCases = caseCount - attempts;
                                let untestedInfo = '';
                                if (untestedCases > 0) {
                                    untestedInfo = `
Model did not return result for ${untestedCases} case${untestedCases > 1 ? 's' : ''} in this bucket`;
                                }
                                
                                return [
                                    `${displayName}: ${successRate.toFixed(2)}% (${successful}/${caseCount})`,
                                    `Token Range: ${bucketData.minTokens/1000}k-${bucketData.maxTokens/1000}k (avg: ${(bucketData.avgTokens/1000).toFixed(1)}k)
Cases: ${bucketData.caseCount}${untestedInfo}${ciInfo}`
                                ];
                            } catch (error) {
                                console.error('Error in tooltip callback:', error);
                                return ['Error displaying tooltip'];
                            }
                        }
                    }
                }
            }
        }
    });
    
    // Function to filter cases based on selected languages
    function getFilteredCases() {
        if (currentSelectedLanguages.length === 0) {
            return [];
        }
        
        return chartData.cases.filter(caseData => 
            currentSelectedLanguages.includes(caseData.language)
        );
    }
    
    // Function to calculate buckets based on filtered cases
    function calculateBuckets() {
        const filteredCases = getFilteredCases();
        if (filteredCases.length === 0) {
            buckets = [];
            return;
        }
        
        // Sort cases by token count (should already be sorted, but just to be safe)
        filteredCases.sort((a, b) => a.token_count - b.token_count);
        
        // Calculate cases per bucket
        const casesPerBucket = Math.floor(filteredCases.length / currentBucketCount);
        const extraCases = filteredCases.length % currentBucketCount;
        
        // Create new buckets array
        buckets = [];
        
        let caseIndex = 0;
        for (let i = 0; i < currentBucketCount; i++) {
            // Calculate how many cases go in this bucket
            // Last bucket gets the extra cases if count isn't evenly divisible
            const bucketSize = (i === currentBucketCount - 1) 
                ? casesPerBucket + extraCases 
                : casesPerBucket;
            
            if (bucketSize === 0) continue;
            
            // Get cases for this bucket
            const bucketCases = filteredCases.slice(caseIndex, caseIndex + bucketSize);
            caseIndex += bucketSize;
            
            // Calculate token stats
            const minTokens = bucketCases[0].token_count;
            const maxTokens = bucketCases[bucketCases.length - 1].token_count;
            const avgTokens = bucketCases.reduce((sum, c) => sum + c.token_count, 0) / bucketCases.length;
            
            // Initialize bucket data
            const bucket = {
                minTokens,
                maxTokens,
                avgTokens,
                caseCount: bucketCases.length,
                cases: bucketCases,
                modelStats: {}
            };
            
            // Calculate model statistics for this bucket
            chartData.models.forEach(model => {
                const modelStats = {
                    successful: 0,
                    attempts: 0
                };
                
                bucketCases.forEach(caseData => {
                    const result = caseData.results[model];
                    if (result.attempted) {
                        modelStats.attempts++;
                        if (result.success) {
                            modelStats.successful++;
                        }
                    }
                });
                
                bucket.modelStats[model] = modelStats;
            });
            
            buckets.push(bucket);
        }
    }
    
    // Function to update chart based on selected models, languages, and bucket count
    function updateChart() {
        // Get selected models and languages
        currentSelectedModels = Array.from(document.querySelectorAll('input[data-model]:checked'))
            .map(checkbox => checkbox.getAttribute('data-model'));
        
        currentSelectedLanguages = Array.from(document.querySelectorAll('input[data-language]:checked'))
            .map(checkbox => checkbox.getAttribute('data-language'));
        
        // Recalculate buckets based on selected languages and bucket count
        calculateBuckets();
        
        // Clear current datasets
        chart.data.datasets = [];
        
        // If no buckets (e.g., no languages selected), don't update further
        if (buckets.length === 0) {
            chart.update();
            return;
        }
        
        // Update x-axis scale and ticks based on actual data
        const minToken = buckets[0].minTokens / 1000;
        const maxToken = buckets[buckets.length - 1].maxTokens / 1000;
        
        // Create custom ticks for each bucket
        const customTicks = buckets.map(bucket => {
            // Position tick at the bucket's average token count
            const tickValue = bucket.avgTokens / 1000;
            
            // Label shows the token range for this bucket (rounded to whole numbers)
            const minK = Math.round(bucket.minTokens / 1000);
            const maxK = Math.round(bucket.maxTokens / 1000);
            const tickLabel = `${minK}-${maxK}k`;
            
            return {
                value: tickValue,
                label: tickLabel
            };
        });
        
        // Calculate min/max from bucket averages (not the absolute min/max prompt values)
        const firstBucketAvg = buckets[0].avgTokens / 1000;
        const lastBucketAvg = buckets[buckets.length - 1].avgTokens / 1000;
        
        // Set precise min/max values with small padding for visual appeal
        chart.options.scales.x.min = Math.max(0, firstBucketAvg - 1.5);
        chart.options.scales.x.max = lastBucketAvg + 1.5;
        
        // Use our custom ticks
        chart.options.scales.x.ticks = {
            callback: function(val, index) {
                // Find the tick with this value
                const tick = customTicks.find(t => Math.abs(t.value - val) < 0.01);
                return tick ? tick.label : '';
            }
        };
        
        // Set up explicit ticks array to ensure our ticks are used
        chart.options.scales.x.afterBuildTicks = function(scale) {
            scale.ticks = customTicks;
            return;
        };
        
        // Create datasets for each selected model
        currentSelectedModels.forEach((model, index) => {
            const color = colors[index % colors.length];
            
            // Calculate data points for this model
            const dataPoints = buckets.map(bucket => {
                const modelStats = bucket.modelStats[model];
                const successful = modelStats.successful;
                const caseCount = bucket.caseCount;
                
                // Calculate success rate
                const successRate = (caseCount > 0) ? (successful / caseCount) * 100 : 0;
                
                return {
                    x: bucket.avgTokens / 1000, // Convert to k
                    y: successRate
                };
            });
            
            // Calculate confidence interval data points
            let lowerBoundPoints = null;
            let upperBoundPoints = null;
            
            if (document.getElementById('show-confidence-intervals').checked) {
                lowerBoundPoints = buckets.map(bucket => {
                    const modelStats = bucket.modelStats[model];
                    const successful = modelStats.successful;
                    const caseCount = bucket.caseCount;
                    
                    const [lower, upper] = wilson_score_interval(successful, caseCount);
                    
                    return {
                        x: bucket.avgTokens / 1000,
                        y: lower * 100
                    };
                });
                
                upperBoundPoints = buckets.map(bucket => {
                    const modelStats = bucket.modelStats[model];
                    const successful = modelStats.successful;
                    const caseCount = bucket.caseCount;
                    
                    const [lower, upper] = wilson_score_interval(successful, caseCount);
                    
                    return {
                        x: bucket.avgTokens / 1000,
                        y: upper * 100
                    };
                });
            }
            
            // Get display name if available
            const displayName = chartData.model_display_names && chartData.model_display_names[model] 
                ? chartData.model_display_names[model] 
                : model;
                
            // Add main dataset
            chart.data.datasets.push({
                label: displayName,
                originalModel: model,
                data: dataPoints,
                borderColor: color,
                backgroundColor: color + '33',
                fill: false,
                tension: 0.1,
                pointRadius: 4,
                pointHoverRadius: 6,
                parsing: false
            });
            
            // Add confidence interval datasets if enabled
            if (document.getElementById('show-confidence-intervals').checked) {
                // Add lower bound line (needed for reference by the area dataset)
                const lowerBoundIndex = chart.data.datasets.length;
                chart.data.datasets.push({
                    label: `${displayName} (95% CI lower)`,
                    data: lowerBoundPoints,
                    borderColor: 'transparent',
                    backgroundColor: 'transparent',
                    pointRadius: 0,
                    tension: 0.1,
                    fill: false,
                    parsing: false,
                    showLine: false,
                    display: false
                });
                
                // Add confidence interval area
                chart.data.datasets.push({
                    label: `${displayName} (95% CI)`,
                    data: upperBoundPoints,
                    borderColor: 'transparent',
                    backgroundColor: color + '22',
                    pointRadius: 0,
                    tension: 0.1,
                    parsing: false,
                    fill: lowerBoundIndex,
                    display: false
                });
            }
        });
        
        // Update chart
        chart.update();
    }
    
    // Add event listeners
    document.querySelectorAll('input[data-model], input[data-language]').forEach(checkbox => {
        checkbox.addEventListener('change', updateChart);
    });
    
    document.getElementById('show-confidence-intervals').addEventListener('change', updateChart);
    
    // Calculate initial buckets and update chart
    calculateBuckets();
    updateChart();
}

</script>

</body>
</html>
