
index 3a00b3f0..8965694e 100644
--- a/ghostty_src_renderer_metal_shaders.zig_expectedoutput.txt (expected):tmp/tmpuyk0961w_expected.txt	
+++ b/ghostty_src_renderer_metal_shaders.zig_extracted.txt (actual):tmp/tmprvvgwukn_actual.txt	
@@ -209,519 +209,4 @@ fn initLibrary(device: objc.Object) !objc.Object {
     try checkError(err);
 
     const end = try std.time.Instant.now();
-    log.debug("shader library loaded time={}us", .{end.since(start) / std.time.ns_per_us});
-
-    return library;
-}
-
-/// Initialize our custom shader pipelines. The shaders argument is a
-/// set of shader source code, not file paths.
-fn initPostPipelines(
-    alloc: Allocator,
-    device: objc.Object,
-    library: objc.Object,
-    shaders: []const [:0]const u8,
-    pixel_format: mtl.MTLPixelFormat,
-) ![]const objc.Object {
-    // If we have no shaders, do nothing.
-    if (shaders.len == 0) return &.{};
-
-    // Keeps track of how many shaders we successfully wrote.
-    var i: usize = 0;
-
-    // Initialize our result set. If any error happens, we undo everything.
-    var pipelines = try alloc.alloc(objc.Object, shaders.len);
-    errdefer {
-        for (pipelines[0..i]) |pipeline| {
-            pipeline.msgSend(void, objc.sel("release"), .{});
-        }
-        alloc.free(pipelines);
-    }
-
-    // Build each shader. Note we don't use "0.." to build our index
-    // because we need to keep track of our length to clean up above.
-    for (shaders) |source| {
-        pipelines[i] = try initPostPipeline(
-            device,
-            library,
-            source,
-            pixel_format,
-        );
-        i += 1;
-    }
-
-    return pipelines;
-}
-
-/// Initialize a single custom shader pipeline from shader source.
-fn initPostPipeline(
-    device: objc.Object,
-    library: objc.Object,
-    data: [:0]const u8,
-    pixel_format: mtl.MTLPixelFormat,
-) !objc.Object {
-    // Create our library which has the shader source
-    const post_library = library: {
-        const source = try macos.foundation.String.createWithBytes(
-            data,
-            .utf8,
-            false,
-        );
-        defer source.release();
-
-        var err: ?*anyopaque = null;
-        const post_library = device.msgSend(
-            objc.Object,
-            objc.sel("newLibraryWithSource:options:error:"),
-            .{ source, @as(?*anyopaque, null), &err },
-        );
-        try checkError(err);
-        errdefer post_library.msgSend(void, objc.sel("release"), .{});
-
-        break :library post_library;
-    };
-    defer post_library.msgSend(void, objc.sel("release"), .{});
-
-    // Get our vertex and fragment functions
-    const func_vert = func_vert: {
-        const str = try macos.foundation.String.createWithBytes(
-            "full_screen_vertex",
-            .utf8,
-            false,
-        );
-        defer str.release();
-
-        const ptr = library.msgSend(?*anyopaque, objc.sel("newFunctionWithName:"), .{str});
-        break :func_vert objc.Object.fromId(ptr.?);
-    };
-    const func_frag = func_frag: {
-        const str = try macos.foundation.String.createWithBytes(
-            "main0",
-            .utf8,
-            false,
-        );
-        defer str.release();
-
-        const ptr = post_library.msgSend(?*anyopaque, objc.sel("newFunctionWithName:"), .{str});
-        break :func_frag objc.Object.fromId(ptr.?);
-    };
-    defer func_vert.msgSend(void, objc.sel("release"), .{});
-    defer func_frag.msgSend(void, objc.sel("release"), .{});
-
-    // Create our descriptor
-    const desc = init: {
-        const Class = objc.getClass("MTLRenderPipelineDescriptor").?;
-        const id_alloc = Class.msgSend(objc.Object, objc.sel("alloc"), .{});
-        const id_init = id_alloc.msgSend(objc.Object, objc.sel("init"), .{});
-        break :init id_init;
-    };
-    defer desc.msgSend(void, objc.sel("release"), .{});
-    desc.setProperty("vertexFunction", func_vert);
-    desc.setProperty("fragmentFunction", func_frag);
-
-    // Set our color attachment
-    const attachments = objc.Object.fromId(desc.getProperty(?*anyopaque, "colorAttachments"));
-    {
-        const attachment = attachments.msgSend(
-            objc.Object,
-            objc.sel("objectAtIndexedSubscript:"),
-            .{@as(c_ulong, 0)},
-        );
-
-        attachment.setProperty("pixelFormat", @intFromEnum(pixel_format));
-    }
-
-    // Make our state
-    var err: ?*anyopaque = null;
-    const pipeline_state = device.msgSend(
-        objc.Object,
-        objc.sel("newRenderPipelineStateWithDescriptor:error:"),
-        .{ desc, &err },
-    );
-    try checkError(err);
-
-    return pipeline_state;
-}
-
-/// This is a single parameter for the terminal cell shader.
-pub const CellText = extern struct {
-    glyph_pos: [2]u32 align(8) = .{ 0, 0 },
-    glyph_size: [2]u32 align(8) = .{ 0, 0 },
-    bearings: [2]i16 align(4) = .{ 0, 0 },
-    grid_pos: [2]u16 align(4),
-    color: [4]u8 align(4),
-    mode: Mode align(1),
-    constraint_width: u8 align(1) = 0,
-
-    pub const Mode = enum(u8) {
-        fg = 1,
-        fg_constrained = 2,
-        fg_color = 3,
-        cursor = 4,
-        fg_powerline = 5,
-    };
-
-    test {
-        // Minimizing the size of this struct is important,
-        // so we test it in order to be aware of any changes.
-        try std.testing.expectEqual(32, @sizeOf(CellText));
-    }
-};
-
-/// Initialize the cell render pipeline for our shader library.
-fn initCellTextPipeline(
-    device: objc.Object,
-    library: objc.Object,
-    pixel_format: mtl.MTLPixelFormat,
-) !objc.Object {
-    // Get our vertex and fragment functions
-    const func_vert = func_vert: {
-        const str = try macos.foundation.String.createWithBytes(
-            "cell_text_vertex",
-            .utf8,
-            false,
-        );
-        defer str.release();
-
-        const ptr = library.msgSend(?*anyopaque, objc.sel("newFunctionWithName:"), .{str});
-        break :func_vert objc.Object.fromId(ptr.?);
-    };
-    const func_frag = func_frag: {
-        const str = try macos.foundation.String.createWithBytes(
-            "cell_text_fragment",
-            .utf8,
-            false,
-        );
-        defer str.release();
-
-        const ptr = library.msgSend(?*anyopaque, objc.sel("newFunctionWithName:"), .{str});
-        break :func_frag objc.Object.fromId(ptr.?);
-    };
-    defer func_vert.msgSend(void, objc.sel("release"), .{});
-    defer func_frag.msgSend(void, objc.sel("release"), .{});
-
-    // Create the vertex descriptor. The vertex descriptor describes the
-    // data layout of the vertex inputs. We use indexed (or "instanced")
-    // rendering, so this makes it so that each instance gets a single
-    // Cell as input.
-    const vertex_desc = vertex_desc: {
-        const desc = init: {
-            const Class = objc.getClass("MTLVertexDescriptor").?;
-            const id_alloc = Class.msgSend(objc.Object, objc.sel("alloc"), .{});
-            const id_init = id_alloc.msgSend(objc.Object, objc.sel("init"), .{});
-            break :init id_init;
-        };
-
-        // Our attributes are the fields of the input
-        const attrs = objc.Object.fromId(desc.getProperty(?*anyopaque, "attributes"));
-        autoAttribute(CellText, attrs);
-
-        // The layout describes how and when we fetch the next vertex input.
-        const layouts = objc.Object.fromId(desc.getProperty(?*anyopaque, "layouts"));
-        {
-            const layout = layouts.msgSend(
-                objc.Object,
-                objc.sel("objectAtIndexedSubscript:"),
-                .{@as(c_ulong, 0)},
-            );
-
-            // Access each Cell per instance, not per vertex.
-            layout.setProperty("stepFunction", @intFromEnum(mtl.MTLVertexStepFunction.per_instance));
-            layout.setProperty("stride", @as(c_ulong, @sizeOf(CellText)));
-        }
-
-        break :vertex_desc desc;
-    };
-    defer vertex_desc.msgSend(void, objc.sel("release"), .{});
-
-    // Create our descriptor
-    const desc = init: {
-        const Class = objc.getClass("MTLRenderPipelineDescriptor").?;
-        const id_alloc = Class.msgSend(objc.Object, objc.sel("alloc"), .{});
-        const id_init = id_alloc.msgSend(objc.Object, objc.sel("init"), .{});
-        break :init id_init;
-    };
-    defer desc.msgSend(void, objc.sel("release"), .{});
-
-    // Set our properties
-    desc.setProperty("vertexFunction", func_vert);
-    desc.setProperty("fragmentFunction", func_frag);
-    desc.setProperty("vertexDescriptor", vertex_desc);
-
-    // Set our color attachment
-    const attachments = objc.Object.fromId(desc.getProperty(?*anyopaque, "colorAttachments"));
-    {
-        const attachment = attachments.msgSend(
-            objc.Object,
-            objc.sel("objectAtIndexedSubscript:"),
-            .{@as(c_ulong, 0)},
-        );
-
-        attachment.setProperty("pixelFormat", @intFromEnum(pixel_format));
-
-        // Blending. This is required so that our text we render on top
-        // of our drawable properly blends into the bg.
-        attachment.setProperty("blendingEnabled", true);
-        attachment.setProperty("rgbBlendOperation", @intFromEnum(mtl.MTLBlendOperation.add));
-        attachment.setProperty("alphaBlendOperation", @intFromEnum(mtl.MTLBlendOperation.add));
-        attachment.setProperty("sourceRGBBlendFactor", @intFromEnum(mtl.MTLBlendFactor.one));
-        attachment.setProperty("sourceAlphaBlendFactor", @intFromEnum(mtl.MTLBlendFactor.one));
-        attachment.setProperty("destinationRGBBlendFactor", @intFromEnum(mtl.MTLBlendFactor.one_minus_source_alpha));
-        attachment.setProperty("destinationAlphaBlendFactor", @intFromEnum(mtl.MTLBlendFactor.one_minus_source_alpha));
-    }
-
-    // Make our state
-    var err: ?*anyopaque = null;
-    const pipeline_state = device.msgSend(
-        objc.Object,
-        objc.sel("newRenderPipelineStateWithDescriptor:error:"),
-        .{ desc, &err },
-    );
-    try checkError(err);
-    errdefer pipeline_state.msgSend(void, objc.sel("release"), .{});
-
-    return pipeline_state;
-}
-
-/// This is a single parameter for the cell bg shader.
-pub const CellBg = [4]u8;
-
-/// Initialize the cell background render pipeline for our shader library.
-fn initCellBgPipeline(
-    device: objc.Object,
-    library: objc.Object,
-    pixel_format: mtl.MTLPixelFormat,
-) !objc.Object {
-    // Get our vertex and fragment functions
-    const func_vert = func_vert: {
-        const str = try macos.foundation.String.createWithBytes(
-            "cell_bg_vertex",
-            .utf8,
-            false,
-        );
-        defer str.release();
-
-        const ptr = library.msgSend(?*anyopaque, objc.sel("newFunctionWithName:"), .{str});
-        break :func_vert objc.Object.fromId(ptr.?);
-    };
-    defer func_vert.msgSend(void, objc.sel("release"), .{});
-    const func_frag = func_frag: {
-        const str = try macos.foundation.String.createWithBytes(
-            "cell_bg_fragment",
-            .utf8,
-            false,
-        );
-        defer str.release();
-
-        const ptr = library.msgSend(?*anyopaque, objc.sel("newFunctionWithName:"), .{str});
-        break :func_frag objc.Object.fromId(ptr.?);
-    };
-    defer func_frag.msgSend(void, objc.sel("release"), .{});
-
-    // Create our descriptor
-    const desc = init: {
-        const Class = objc.getClass("MTLRenderPipelineDescriptor").?;
-        const id_alloc = Class.msgSend(objc.Object, objc.sel("alloc"), .{});
-        const id_init = id_alloc.msgSend(objc.Object, objc.sel("init"), .{});
-        break :init id_init;
-    };
-    defer desc.msgSend(void, objc.sel("release"), .{});
-
-    // Set our properties
-    desc.setProperty("vertexFunction", func_vert);
-    desc.setProperty("fragmentFunction", func_frag);
-
-    // Set our color attachment
-    const attachments = objc.Object.fromId(desc.getProperty(?*anyopaque, "colorAttachments"));
-    {
-        const attachment = attachments.msgSend(
-            objc.Object,
-            objc.sel("objectAtIndexedSubscript:"),
-            .{@as(c_ulong, 0)},
-        );
-
-        attachment.setProperty("pixelFormat", @intFromEnum(pixel_format));
-
-        // Blending. This is required so that our text we render on top
-        // of our drawable properly blends into the bg.
-        attachment.setProperty("blendingEnabled", true);
-        attachment.setProperty("rgbBlendOperation", @intFromEnum(mtl.MTLBlendOperation.add));
-        attachment.setProperty("alphaBlendOperation", @intFromEnum(mtl.MTLBlendOperation.add));
-        attachment.setProperty("sourceRGBBlendFactor", @intFromEnum(mtl.MTLBlendFactor.one));
-        attachment.setProperty("sourceAlphaBlendFactor", @intFromEnum(mtl.MTLBlendFactor.one));
-        attachment.setProperty("destinationRGBBlendFactor", @intFromEnum(mtl.MTLBlendFactor.one_minus_source_alpha));
-        attachment.setProperty("destinationAlphaBlendFactor", @intFromEnum(mtl.MTLBlendFactor.one_minus_source_alpha));
-    }
-
-    // Make our state
-    var err: ?*anyopaque = null;
-    const pipeline_state = device.msgSend(
-        objc.Object,
-        objc.sel("newRenderPipelineStateWithDescriptor:error:"),
-        .{ desc, &err },
-    );
-    try checkError(err);
-    errdefer pipeline_state.msgSend(void, objc.sel("release"), .{});
-
-    return pipeline_state;
-}
-
-/// Initialize the image render pipeline for our shader library.
-fn initImagePipeline(
-    device: objc.Object,
-    library: objc.Object,
-    pixel_format: mtl.MTLPixelFormat,
-) !objc.Object {
-    // Get our vertex and fragment functions
-    const func_vert = func_vert: {
-        const str = try macos.foundation.String.createWithBytes(
-            "image_vertex",
-            .utf8,
-            false,
-        );
-        defer str.release();
-
-        const ptr = library.msgSend(?*anyopaque, objc.sel("newFunctionWithName:"), .{str});
-        break :func_vert objc.Object.fromId(ptr.?);
-    };
-    const func_frag = func_frag: {
-        const str = try macos.foundation.String.createWithBytes(
-            "image_fragment",
-            .utf8,
-            false,
-        );
-        defer str.release();
-
-        const ptr = library.msgSend(?*anyopaque, objc.sel("newFunctionWithName:"), .{str});
-        break :func_frag objc.Object.fromId(ptr.?);
-    };
-    defer func_vert.msgSend(void, objc.sel("release"), .{});
-    defer func_frag.msgSend(void, objc.sel("release"), .{});
-
-    // Create the vertex descriptor. The vertex descriptor describes the
-    // data layout of the vertex inputs. We use indexed (or "instanced")
-    // rendering, so this makes it so that each instance gets a single
-    // Image as input.
-    const vertex_desc = vertex_desc: {
-        const desc = init: {
-            const Class = objc.getClass("MTLVertexDescriptor").?;
-            const id_alloc = Class.msgSend(objc.Object, objc.sel("alloc"), .{});
-            const id_init = id_alloc.msgSend(objc.Object, objc.sel("init"), .{});
-            break :init id_init;
-        };
-
-        // Our attributes are the fields of the input
-        const attrs = objc.Object.fromId(desc.getProperty(?*anyopaque, "attributes"));
-        autoAttribute(Image, attrs);
-
-        // The layout describes how and when we fetch the next vertex input.
-        const layouts = objc.Object.fromId(desc.getProperty(?*anyopaque, "layouts"));
-        {
-            const layout = layouts.msgSend(
-                objc.Object,
-                objc.sel("objectAtIndexedSubscript:"),
-                .{@as(c_ulong, 0)},
-            );
-
-            // Access each Image per instance, not per vertex.
-            layout.setProperty("stepFunction", @intFromEnum(mtl.MTLVertexStepFunction.per_instance));
-            layout.setProperty("stride", @as(c_ulong, @sizeOf(Image)));
-        }
-
-        break :vertex_desc desc;
-    };
-    defer vertex_desc.msgSend(void, objc.sel("release"), .{});
-
-    // Create our descriptor
-    const desc = init: {
-        const Class = objc.getClass("MTLRenderPipelineDescriptor").?;
-        const id_alloc = Class.msgSend(objc.Object, objc.sel("alloc"), .{});
-        const id_init = id_alloc.msgSend(objc.Object, objc.sel("init"), .{});
-        break :init id_init;
-    };
-    defer desc.msgSend(void, objc.sel("release"), .{});
-
-    // Set our properties
-    desc.setProperty("vertexFunction", func_vert);
-    desc.setProperty("fragmentFunction", func_frag);
-    desc.setProperty("vertexDescriptor", vertex_desc);
-
-    // Set our color attachment
-    const attachments = objc.Object.fromId(desc.getProperty(?*anyopaque, "colorAttachments"));
-    {
-        const attachment = attachments.msgSend(
-            objc.Object,
-            objc.sel("objectAtIndexedSubscript:"),
-            .{@as(c_ulong, 0)},
-        );
-
-        attachment.setProperty("pixelFormat", @intFromEnum(pixel_format));
-
-        // Blending. This is required so that our text we render on top
-        // of our drawable properly blends into the bg.
-        attachment.setProperty("blendingEnabled", true);
-        attachment.setProperty("rgbBlendOperation", @intFromEnum(mtl.MTLBlendOperation.add));
-        attachment.setProperty("alphaBlendOperation", @intFromEnum(mtl.MTLBlendOperation.add));
-        attachment.setProperty("sourceRGBBlendFactor", @intFromEnum(mtl.MTLBlendFactor.one));
-        attachment.setProperty("sourceAlphaBlendFactor", @intFromEnum(mtl.MTLBlendFactor.one));
-        attachment.setProperty("destinationRGBBlendFactor", @intFromEnum(mtl.MTLBlendFactor.one_minus_source_alpha));
-        attachment.setProperty("destinationAlphaBlendFactor", @intFromEnum(mtl.MTLBlendFactor.one_minus_source_alpha));
-    }
-
-    // Make our state
-    var err: ?*anyopaque = null;
-    const pipeline_state = device.msgSend(
-        objc.Object,
-        objc.sel("newRenderPipelineStateWithDescriptor:error:"),
-        .{ desc, &err },
-    );
-    try checkError(err);
-
-    return pipeline_state;
-}
-
-fn autoAttribute(T: type, attrs: objc.Object) void {
-    inline for (@typeInfo(T).@"struct".fields, 0..) |field, i| {
-        const offset = @offsetOf(T, field.name);
-
-        const FT = switch (@typeInfo(field.type)) {
-            .@"enum" => |e| e.tag_type,
-            else => field.type,
-        };
-
-        const format = switch (FT) {
-            [4]u8 => mtl.MTLVertexFormat.uchar4,
-            [2]u16 => mtl.MTLVertexFormat.ushort2,
-            [2]i16 => mtl.MTLVertexFormat.short2,
-            [2]f32 => mtl.MTLVertexFormat.float2,
-            [4]f32 => mtl.MTLVertexFormat.float4,
-            [2]i32 => mtl.MTLVertexFormat.int2,
-            u32 => mtl.MTLVertexFormat.uint,
-            [2]u32 => mtl.MTLVertexFormat.uint2,
-            [4]u32 => mtl.MTLVertexFormat.uint4,
-            u8 => mtl.MTLVertexFormat.uchar,
-            else => comptime unreachable,
-        };
-
-        const attr = attrs.msgSend(
-            objc.Object,
-            objc.sel("objectAtIndexedSubscript:"),
-            .{@as(c_ulong, i)},
-        );
-
-        attr.setProperty("format", @intFromEnum(format));
-        attr.setProperty("offset", @as(c_ulong, offset));
-        attr.setProperty("bufferIndex", @as(c_ulong, 0));
-    }
-}
-
-fn checkError(err_: ?*anyopaque) !void {
-    const nserr = objc.Object.fromId(err_ orelse return);
-    const str = @as(
-        *macos.foundation.String,
-        @ptrCast(nserr.getProperty(?*anyopaque, "localizedDescription").?),
-    );
-
-    log.err("metal error={s}", .{str.cstringPtr(.ascii).?});
-    return error.MetalFailed;
-}
\ No newline at end of file
+    log.debug("shader library loaded
\ No newline at end of file
