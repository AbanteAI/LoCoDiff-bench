
index 3a00b3f01..dceb6363c 100644
--- a/ghostty_src_renderer_metal_shaders.zig_expectedoutput.txt (expected):tmp/tmpbdqqd8kw_expected.txt	
+++ b/ghostty_src_renderer_metal_shaders.zig_extracted.txt (actual):tmp/tmpngdbh_5r_actual.txt	
@@ -24,9 +24,7 @@ pub const Shaders = struct {
     /// like the Kitty image protocol.
     image_pipeline: objc.Object,
 
-    /// Custom shaders to run against the final drawable texture. This
-    /// can be used to apply a lot of effects. Each shader is run in sequence
-    /// against the output of the previous shader.
+    /// Custom shaders to run against the final drawable texture.
     post_pipelines: []const objc.Object,
 
     /// Initialize our shader set.
@@ -96,6 +94,33 @@ pub const Shaders = struct {
     }
 };
 
+/// Single parameter for the terminal cell shader.
+pub const CellText = extern struct {
+    glyph_pos: [2]u32 align(8) = .{ 0, 0 },
+    glyph_size: [2]u32 align(8) = .{ 0, 0 },
+    bearings: [2]i16 align(4) = .{ 0, 0 },
+    grid_pos: [2]u16 align(4),
+    color: [4]u8 align(4),
+    mode: Mode align(1),
+    constraint_width: u8 align(1) = 0,
+
+    pub const Mode = enum(u8) {
+        fg = 1,
+        fg_constrained = 2,
+        cursor = 4,
+        fg_powerline = 5,
+    };
+
+    test {
+        // Minimizing the size of this struct is important,
+        // so we test it in order to be aware of any changes.
+        try std.testing.expectEqual(32, @sizeOf(CellText));
+    }
+};
+
+/// This is a single parameter for the cell bg shader.
+pub const CellBg = [4]u8;
+
 /// Single parameter for the image shader. See shader for field details.
 pub const Image = extern struct {
     grid_pos: [2]f32,
@@ -106,10 +131,6 @@ pub const Image = extern struct {
 
 /// The uniforms that are passed to the terminal cell shader.
 pub const Uniforms = extern struct {
-    // Note: all of the explicit aligmnments are copied from the
-    // MSL developer reference just so that we can be sure that we got
-    // it all exactly right.
-
     /// The projection matrix for turning world coordinates to normalized.
     /// This is calculated based on the size of the screen.
     projection_matrix: math.Mat align(16),
@@ -133,13 +154,13 @@ pub const Uniforms = extern struct {
     /// according to the WCAG 2.0 spec.
     min_contrast: f32 align(4),
 
+    /// The background color for the whole surface.
+    bg_color: [4]u8 align(4),
+
     /// The cursor position and color.
     cursor_pos: [2]u16 align(4),
     cursor_color: [4]u8 align(4),
 
-    /// The background color for the whole surface.
-    bg_color: [4]u8 align(4),
-
     /// Whether the cursor is 2 cells wide.
     cursor_wide: bool align(1),
 
@@ -171,9 +192,6 @@ pub const Uniforms = extern struct {
 
 /// The uniforms used for custom postprocess shaders.
 pub const PostUniforms = extern struct {
-    // Note: all of the explicit aligmnments are copied from the
-    // MSL developer reference just so that we can be sure that we got
-    // it all exactly right.
     resolution: [3]f32 align(16),
     time: f32 align(4),
     time_delta: f32 align(4),
@@ -214,8 +232,6 @@ fn initLibrary(device: objc.Object) !objc.Object {
     return library;
 }
 
-/// Initialize our custom shader pipelines. The shaders argument is a
-/// set of shader source code, not file paths.
 fn initPostPipelines(
     alloc: Allocator,
     device: objc.Object,
@@ -238,8 +254,7 @@ fn initPostPipelines(
         alloc.free(pipelines);
     }
 
-    // Build each shader. Note we don't use "0.." to build our index
-    // because we need to keep track of our length to clean up above.
+    // Build each shader.
     for (shaders) |source| {
         pipelines[i] = try initPostPipeline(
             device,
@@ -253,7 +268,6 @@ fn initPostPipelines(
     return pipelines;
 }
 
-/// Initialize a single custom shader pipeline from shader source.
 fn initPostPipeline(
     device: objc.Object,
     library: objc.Object,
@@ -270,15 +284,19 @@ fn initPostPipeline(
         defer source.release();
 
         var err: ?*anyopaque = null;
-        const post_library = device.msgSend(
+        const lib = device.msgSend(
             objc.Object,
             objc.sel("newLibraryWithSource:options:error:"),
-            .{ source, @as(?*anyopaque, null), &err },
+            .{
+                source,
+                @as(?*anyopaque, null),
+                &err,
+            },
         );
         try checkError(err);
-        errdefer post_library.msgSend(void, objc.sel("release"), .{});
+        errdefer lib.msgSend(void, objc.sel("release"), .{});
 
-        break :library post_library;
+        break :library lib;
     };
     defer post_library.msgSend(void, objc.sel("release"), .{});
 
@@ -291,7 +309,7 @@ fn initPostPipeline(
         );
         defer str.release();
 
-        const ptr = library.msgSend(?*anyopaque, objc.sel("newFunctionWithName:"), .{str});
+        const ptr = post_library.msgSend(?*anyopaque, objc.sel("newFunctionWithName:"), .{str});
         break :func_vert objc.Object.fromId(ptr.?);
     };
     const func_frag = func_frag: {
@@ -305,8 +323,6 @@ fn initPostPipeline(
         const ptr = post_library.msgSend(?*anyopaque, objc.sel("newFunctionWithName:"), .{str});
         break :func_frag objc.Object.fromId(ptr.?);
     };
-    defer func_vert.msgSend(void, objc.sel("release"), .{});
-    defer func_frag.msgSend(void, objc.sel("release"), .{});
 
     // Create our descriptor
     const desc = init: {
@@ -316,6 +332,8 @@ fn initPostPipeline(
         break :init id_init;
     };
     defer desc.msgSend(void, objc.sel("release"), .{});
+
+    // Set our properties
     desc.setProperty("vertexFunction", func_vert);
     desc.setProperty("fragmentFunction", func_frag);
 
@@ -339,35 +357,11 @@ fn initPostPipeline(
         .{ desc, &err },
     );
     try checkError(err);
+    errdefer pipeline_state.msgSend(void, objc.sel("release"), .{});
 
     return pipeline_state;
 }
 
-/// This is a single parameter for the terminal cell shader.
-pub const CellText = extern struct {
-    glyph_pos: [2]u32 align(8) = .{ 0, 0 },
-    glyph_size: [2]u32 align(8) = .{ 0, 0 },
-    bearings: [2]i16 align(4) = .{ 0, 0 },
-    grid_pos: [2]u16 align(4),
-    color: [4]u8 align(4),
-    mode: Mode align(1),
-    constraint_width: u8 align(1) = 0,
-
-    pub const Mode = enum(u8) {
-        fg = 1,
-        fg_constrained = 2,
-        fg_color = 3,
-        cursor = 4,
-        fg_powerline = 5,
-    };
-
-    test {
-        // Minimizing the size of this struct is important,
-        // so we test it in order to be aware of any changes.
-        try std.testing.expectEqual(32, @sizeOf(CellText));
-    }
-};
-
 /// Initialize the cell render pipeline for our shader library.
 fn initCellTextPipeline(
     device: objc.Object,
@@ -397,8 +391,6 @@ fn initCellTextPipeline(
         const ptr = library.msgSend(?*anyopaque, objc.sel("newFunctionWithName:"), .{str});
         break :func_frag objc.Object.fromId(ptr.?);
     };
-    defer func_vert.msgSend(void, objc.sel("release"), .{});
-    defer func_frag.msgSend(void, objc.sel("release"), .{});
 
     // Create the vertex descriptor. The vertex descriptor describes the
     // data layout of the vertex inputs. We use indexed (or "instanced")
@@ -483,9 +475,6 @@ fn initCellTextPipeline(
     return pipeline_state;
 }
 
-/// This is a single parameter for the cell bg shader.
-pub const CellBg = [4]u8;
-
 /// Initialize the cell background render pipeline for our shader library.
 fn initCellBgPipeline(
     device: objc.Object,
@@ -504,7 +493,6 @@ fn initCellBgPipeline(
         const ptr = library.msgSend(?*anyopaque, objc.sel("newFunctionWithName:"), .{str});
         break :func_vert objc.Object.fromId(ptr.?);
     };
-    defer func_vert.msgSend(void, objc.sel("release"), .{});
     const func_frag = func_frag: {
         const str = try macos.foundation.String.createWithBytes(
             "cell_bg_fragment",
@@ -516,7 +504,6 @@ fn initCellBgPipeline(
         const ptr = library.msgSend(?*anyopaque, objc.sel("newFunctionWithName:"), .{str});
         break :func_frag objc.Object.fromId(ptr.?);
     };
-    defer func_frag.msgSend(void, objc.sel("release"), .{});
 
     // Create our descriptor
     const desc = init: {
@@ -595,8 +582,6 @@ fn initImagePipeline(
         const ptr = library.msgSend(?*anyopaque, objc.sel("newFunctionWithName:"), .{str});
         break :func_frag objc.Object.fromId(ptr.?);
     };
-    defer func_vert.msgSend(void, objc.sel("release"), .{});
-    defer func_frag.msgSend(void, objc.sel("release"), .{});
 
     // Create the vertex descriptor. The vertex descriptor describes the
     // data layout of the vertex inputs. We use indexed (or "instanced")
@@ -676,6 +661,7 @@ fn initImagePipeline(
         .{ desc, &err },
     );
     try checkError(err);
+    errdefer pipeline_state.msgSend(void, objc.sel("release"), .{});
 
     return pipeline_state;
 }
