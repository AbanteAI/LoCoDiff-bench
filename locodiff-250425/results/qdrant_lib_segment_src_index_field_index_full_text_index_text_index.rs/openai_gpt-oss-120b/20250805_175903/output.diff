
index 9edafacaa..3936c2250 100644
--- a/qdrant_lib_segment_src_index_field_index_full_text_index_text_index.rs_expectedoutput.txt (expected):tmp/tmpb5rijjsr_expected.txt	
+++ b/qdrant_lib_segment_src_index_field_index_full_text_index_text_index.rs_extracted.txt (actual):tmp/tmpf3188yfc_actual.txt	
@@ -14,10 +14,10 @@ use super::inverted_index::{Document, InvertedIndex, ParsedQuery, TokenId};
 use super::mmap_text_index::{FullTextMmapIndexBuilder, MmapFullTextIndex};
 use super::mutable_text_index::MutableFullTextIndex;
 use super::tokenizers::Tokenizer;
-use crate::common::Flusher;
 use crate::common::operation_error::{OperationError, OperationResult};
 use crate::common::rocksdb_buffered_delete_wrapper::DatabaseColumnScheduledDeleteWrapper;
 use crate::common::rocksdb_wrapper::DatabaseColumnWrapper;
+use crate::common::Flusher;
 use crate::data_types::index::TextIndexParams;
 use crate::index::field_index::{
     CardinalityEstimation, FieldIndexBuilderTrait, PayloadBlockCondition, PayloadFieldIndex,
@@ -26,6 +26,7 @@ use crate::index::field_index::{
 use crate::telemetry::PayloadIndexTelemetry;
 use crate::types::{FieldCondition, Match, PayloadKeyType};
 
+#[allow(clippy::large_enum_variant)]
 pub enum FullTextIndex {
     Mutable(MutableFullTextIndex),
     Immutable(ImmutableFullTextIndex),
@@ -65,7 +66,7 @@ impl FullTextIndex {
         match self {
             Self::Mutable(index) => index.init(),
             Self::Immutable(index) => index.init(),
-            Self::Mmap(_) => unreachable!("not applicable for mmap immutable index"),
+            Self::Mmap(_index) => unreachable!("not applicable for mmap immutable index"),
         }
     }
 
@@ -89,12 +90,35 @@ impl FullTextIndex {
         format!("{field}_fts")
     }
 
-    fn config(&self) -> &TextIndexParams {
-        match self {
-            Self::Mutable(index) => &index.config,
-            Self::Immutable(index) => &index.config,
-            Self::Mmap(index) => &index.config,
+    pub(super) fn store_key(id: PointOffsetType) -> Vec<u8> {
+        bincode::serialize(&id).unwrap()
+    }
+
+    pub(super) fn restore_key(data: &[u8]) -> PointOffsetType {
+        bincode::deserialize(data).unwrap()
+    }
+
+    pub(super) fn serialize_document_tokens(tokens: BTreeSet<String>) -> OperationResult<Vec<u8>> {
+        #[derive(Serialize)]
+        struct StoredDocument {
+            tokens: BTreeSet<String>,
+        }
+        let doc = StoredDocument { tokens };
+        serde_cbor::to_vec(&doc).map_err(|e| {
+            OperationError::service_error(format!("Failed to serialize document: {e}"))
+        })
+    }
+
+    pub(super) fn deserialize_document(data: &[u8]) -> OperationResult<BTreeSet<String>> {
+        #[derive(Deserialize)]
+        struct StoredDocument {
+            tokens: BTreeSet<String>,
         }
+        serde_cbor::from_slice::<StoredDocument>(data)
+            .map_err(|e| {
+                OperationError::service_error(format!("Failed to deserialize document: {e}"))
+            })
+            .map(|doc| doc.tokens)
     }
 
     fn points_count(&self) -> usize {
@@ -125,18 +149,6 @@ impl FullTextIndex {
         }
     }
 
-    fn payload_blocks(
-        &self,
-        threshold: usize,
-        key: PayloadKeyType,
-    ) -> Box<dyn Iterator<Item = PayloadBlockCondition> + '_> {
-        match self {
-            Self::Mutable(index) => Box::new(index.inverted_index.payload_blocks(threshold, key)),
-            Self::Immutable(index) => Box::new(index.inverted_index.payload_blocks(threshold, key)),
-            Self::Mmap(index) => Box::new(index.inverted_index.payload_blocks(threshold, key)),
-        }
-    }
-
     fn estimate_cardinality(
         &self,
         query: &ParsedQuery,
@@ -156,72 +168,6 @@ impl FullTextIndex {
         }
     }
 
-    pub fn check_match(
-        &self,
-        query: &ParsedQuery,
-        point_id: PointOffsetType,
-        hw_counter: &HardwareCounterCell,
-    ) -> bool {
-        match self {
-            Self::Mutable(index) => index
-                .inverted_index
-                .check_match(query, point_id, hw_counter),
-            Self::Immutable(index) => index
-                .inverted_index
-                .check_match(query, point_id, hw_counter),
-            Self::Mmap(index) => index
-                .inverted_index
-                .check_match(query, point_id, hw_counter),
-        }
-    }
-
-    pub fn values_count(&self, point_id: PointOffsetType) -> usize {
-        match self {
-            Self::Mutable(index) => index.inverted_index.values_count(point_id),
-            Self::Immutable(index) => index.inverted_index.values_count(point_id),
-            Self::Mmap(index) => index.inverted_index.values_count(point_id),
-        }
-    }
-
-    pub fn values_is_empty(&self, point_id: PointOffsetType) -> bool {
-        match self {
-            Self::Mutable(index) => index.inverted_index.values_is_empty(point_id),
-            Self::Immutable(index) => index.inverted_index.values_is_empty(point_id),
-            Self::Mmap(index) => index.inverted_index.values_is_empty(point_id),
-        }
-    }
-
-    pub(super) fn store_key(id: PointOffsetType) -> Vec<u8> {
-        bincode::serialize(&id).unwrap()
-    }
-
-    pub(super) fn restore_key(data: &[u8]) -> PointOffsetType {
-        bincode::deserialize(data).unwrap()
-    }
-
-    pub(super) fn serialize_document_tokens(tokens: BTreeSet<String>) -> OperationResult<Vec<u8>> {
-        #[derive(Serialize)]
-        struct StoredDocument {
-            tokens: BTreeSet<String>,
-        }
-        let doc = StoredDocument { tokens };
-        serde_cbor::to_vec(&doc).map_err(|e| {
-            OperationError::service_error(format!("Failed to serialize document: {e}"))
-        })
-    }
-
-    pub(super) fn deserialize_document(data: &[u8]) -> OperationResult<BTreeSet<String>> {
-        #[derive(Deserialize)]
-        struct StoredDocument {
-            tokens: BTreeSet<String>,
-        }
-        serde_cbor::from_slice::<StoredDocument>(data)
-            .map_err(|e| {
-                OperationError::service_error(format!("Failed to deserialize document: {e}"))
-            })
-            .map(|doc| doc.tokens)
-    }
-
     pub fn get_telemetry_data(&self) -> PayloadIndexTelemetry {
         PayloadIndexTelemetry {
             field_name: None,
@@ -266,6 +212,41 @@ impl FullTextIndex {
         self.filter(parsed_query, hw_counter)
     }
 
+    pub fn values_count(&self, point_id: PointOffsetType) -> usize {
+        match self {
+            Self::Mutable(index) => index.inverted_index.values_count(point_id),
+            Self::Immutable(index) => index.inverted_index.values_count(point_id),
+            Self::Mmap(index) => index.inverted_index.values_count(point_id),
+        }
+    }
+
+    pub fn values_is_empty(&self, point_id: PointOffsetType) -> bool {
+        match self {
+            Self::Mutable(index) => index.inverted_index.values_is_empty(point_id),
+            Self::Immutable(index) => index.inverted_index.values_is_empty(point_id),
+            Self::Mmap(index) => index.inverted_index.values_is_empty(point_id),
+        }
+    }
+
+    pub fn check_match(
+        &self,
+        query: &ParsedQuery,
+        point_id: PointOffsetType,
+        hw_counter: &HardwareCounterCell,
+    ) -> bool {
+        match self {
+            Self::Mutable(index) => index
+                .inverted_index
+                .check_match(query, point_id, hw_counter),
+            Self::Immutable(index) => index
+                .inverted_index
+                .check_match(query, point_id, hw_counter),
+            Self::Mmap(index) => index
+                .inverted_index
+                .check_match(query, point_id, hw_counter),
+        }
+    }
+
     pub fn is_on_disk(&self) -> bool {
         match self {
             FullTextIndex::Mutable(_) => false,
@@ -278,8 +259,8 @@ impl FullTextIndex {
     /// Block until all pages are populated.
     pub fn populate(&self) -> OperationResult<()> {
         match self {
-            FullTextIndex::Mutable(_) => {}   // Not a mmap
-            FullTextIndex::Immutable(_) => {} // Not a mmap
+            FullTextIndex::Mutable(_) => {}
+            FullTextIndex::Immutable(_) => {}
             FullTextIndex::Mmap(index) => index.populate()?,
         }
         Ok(())
@@ -288,12 +269,28 @@ impl FullTextIndex {
     /// Drop disk cache.
     pub fn clear_cache(&self) -> OperationResult<()> {
         match self {
-            FullTextIndex::Mutable(_) => {}   // Not a mmap
-            FullTextIndex::Immutable(_) => {} // Not a mmap
+            FullTextIndex::Mutable(_) => {}
+            FullTextIndex::Immutable(_) => {}
             FullTextIndex::Mmap(index) => index.clear_cache()?,
         }
         Ok(())
     }
+
+    fn config(&self) -> &TextIndexParams {
+        match self {
+            Self::Mutable(index) => &index.config,
+            Self::Immutable(index) => &index.config,
+            Self::Mmap(index) => &index.config,
+        }
+    }
+
+    fn db_wrapper(&self) -> &DatabaseColumnScheduledDeleteWrapper {
+        match self {
+            Self::Mutable(index) => &index.db_wrapper,
+            Self::Immutable(index) => &index.db_wrapper,
+            Self::Mmap(_index) => unreachable!(),
+        }
+    }
 }
 
 pub struct FullTextIndexBuilder(FullTextIndex);
@@ -368,11 +365,11 @@ impl PayloadFieldIndex for FullTextIndex {
         }
     }
 
-    fn cleanup(self) -> OperationResult<()> {
+    fn clear(self) -> OperationResult<()> {
         match self {
             Self::Mutable(index) => index.clear(),
             Self::Immutable(index) => index.clear(),
-            Self::Mmap(index) => index.clear(),
+            Self::Mmap(_index) => Ok(true), // mmap index is always loaded
         }
     }
 
@@ -421,6 +418,133 @@ impl PayloadFieldIndex for FullTextIndex {
         threshold: usize,
         key: PayloadKeyType,
     ) -> Box<dyn Iterator<Item = PayloadBlockCondition> + '_> {
-        self.payload_blocks(threshold, key)
+        match self {
+            Self::Mutable(index) => Box::new(index.inverted_index.payload_blocks(threshold, key)),
+            Self::Immutable(index) => Box::new(index.inverted_index.payload_blocks(threshold, key)),
+            Self::Mmap(index) => Box::new(index.inverted_index.payload_blocks(threshold, key)),
+        }
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use rstest::rstest;
+    use tempfile::Builder;
+
+    use super::*;
+    use crate::common::rocksdb_wrapper::open_db_with_existing_cf;
+    use crate::data_types::index::{TextIndexType, TokenizerType};
+    use crate::json_path::JsonPath;
+
+    fn filter_request(text: &str) -> FieldCondition {
+        FieldCondition::new_match(JsonPath::new("text"), Match::new_text(text))
+    }
+
+    #[rstest]
+    #[case(true)]
+    #[case(false)]
+    fn test_full_text_indexing(#[case] immutable: bool) {
+        let payloads: Vec<_> = vec![
+            serde_json::json!("The celebration had a long way to go and even in the silent depths of Multivac's underground chambers, it hung in the air."),
+            serde_json::json!("If nothing else, there was the mere fact of isolation and silence."),
+            serde_json::json!([
+                "For the first time in a decade, technicians were not scurrying about the vitals of the giant computer, ",
+                "the soft lights did not wink out their erratic patterns, the flow of information in and out had halted."
+            ]),
+            serde_json::json!("It would not be halted long, of course, for the needs of peace would be pressing."),
+            serde_json::json!("Yet now, for a day, perhaps for a week, even Multivac might celebrate the great time, and rest."),
+        ];
+
+        let temp_dir = Builder::new().prefix("test_dir").tempdir().unwrap();
+        let config = TextIndexParams {
+            r#type: TextIndexType::Text,
+            tokenizer: TokenizerType::Word,
+            min_token_len: None,
+            max_token_len: None,
+            lowercase: None,
+        };
+
+        {
+            let db = open_db_with_existing_cf(&temp_dir.path().join("test_db")).unwrap();
+
+            let mut index = FullTextIndex::builder(db, config.clone(), "text")
+                .make_empty()
+                .unwrap();
+
+            for (idx, payload) in payloads.iter().enumerate() {
+                index.add_point(idx as PointOffsetType, &[payload]).unwrap();
+            }
+
+            assert_eq!(index.count_indexed_points(), payloads.len());
+
+            let filter_condition = filter_request("multivac");
+            let search_res: Vec<_> = index.filter(&filter_condition).unwrap().collect();
+            assert_eq!(search_res, vec![0, 4]);
+
+            let filter_condition = filter_request("giant computer");
+            let search_res: Vec<_> = index.filter(&filter_condition).unwrap().collect();
+            assert_eq!(search_res, vec![2]);
+
+            let filter_condition = filter_request("the great time");
+            let search_res: Vec<_> = index.filter(&filter_condition).unwrap().collect();
+            assert_eq!(search_res, vec![4]);
+
+            index.remove_point(2).unwrap();
+            index.remove_point(3).unwrap();
+
+            let filter_condition = filter_request("giant computer");
+            assert!(index.filter(&filter_condition).unwrap().next().is_none());
+
+            assert_eq!(index.count_indexed_points(), payloads.len() - 2);
+
+            let payload = serde_json::json!([
+                "The last question was asked for the first time, half in jest, on May 21, 2061,",
+                "at a time when humanity first stepped into the light."
+            ]);
+            index.add_point(3, &[&payload]).unwrap();
+
+            let payload = serde_json::json!([
+                "The question came about as a result of a five dollar bet over highballs, and it happened this way: "
+            ]);
+            index.add_point(4, &[&payload]).unwrap();
+
+            assert_eq!(index.count_indexed_points(), payloads.len() - 1);
+
+            index.flusher()().unwrap();
+        }
+
+        {
+            let db = open_db_with_existing_cf(&temp_dir.path().join("test_db")).unwrap();
+            let mut index = FullTextIndex::new_memory(db, config, "text", immutable);
+            let loaded = index.load().unwrap();
+            assert!(loaded);
+
+            assert_eq!(index.count_indexed_points(), 4);
+
+            let filter_condition = filter_request("multivac");
+            let search_res: Vec<_> = index.filter(&filter_condition).unwrap().collect();
+            assert_eq!(search_res, vec![0]);
+
+            let filter_condition = filter_request("the");
+            let search_res: Vec<_> = index.filter(&filter_condition).unwrap().collect();
+            assert_eq!(search_res, vec![0, 1, 3, 4]);
+
+            // check deletion
+            index.remove_point(0).unwrap();
+            let filter_condition = filter_request("multivac");
+            let search_res: Vec<_> = index.filter(&filter_condition).unwrap().collect();
+            assert!(search_res.is_empty());
+            assert_eq!(index.count_indexed_points(), 3);
+
+            index.remove_point(3).unwrap();
+            let filter_condition = filter_request("the");
+            let search_res: Vec<_> = index.filter(&filter_condition).unwrap().collect();
+            assert_eq!(search_res, vec![1, 4]);
+            assert_eq!(index.count_indexed_points(), 2);
+
+            // check deletion of non-existing point
+            index.remove_point(3).unwrap();
+            assert_eq!(index.count_indexed_points(), 2);
+        }
     }
 }
\ No newline at end of file
