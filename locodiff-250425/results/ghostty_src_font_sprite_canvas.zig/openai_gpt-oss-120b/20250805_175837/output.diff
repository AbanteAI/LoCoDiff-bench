
index 0683ced4d..3d7c7c0ce 100644
--- a/ghostty_src_font_sprite_canvas.zig_expectedoutput.txt (expected):tmp/tmpmxll8qel_expected.txt	
+++ b/ghostty_src_font_sprite_canvas.zig_extracted.txt (actual):tmp/tmpv4q5ob1h_actual.txt	
@@ -30,7 +30,6 @@ pub fn Box(comptime T: type) type {
             const tl_y = @min(self.p0.y, self.p1.y);
             const br_x = @max(self.p0.x, self.p1.x);
             const br_y = @max(self.p0.y, self.p1.y);
-
             return .{
                 .x = tl_x,
                 .y = tl_y,
@@ -74,17 +73,16 @@ pub const Color = enum(u8) {
     _,
 };
 
-/// This is a managed struct, it keeps a reference to the allocator that is
-/// used to initialize it, and the same allocator is used for any further
-/// necessary allocations when drawing.
+/// This is a managed struct; it keeps a reference to the allocator that
+/// is used to initialize it, and the same allocator is used for any
+/// further necessary allocations when drawing.
 pub const Canvas = struct {
     /// The underlying z2d surface.
     sfc: z2d.Surface,
-
+    /// The allocator used for this canvas.
     alloc: Allocator,
 
     pub fn init(alloc: Allocator, width: u32, height: u32) !Canvas {
-        // Create the surface we'll be using.
         const sfc = try z2d.Surface.initPixel(
             .{ .alpha8 = .{ .a = 0 } },
             alloc,
@@ -92,7 +90,6 @@ pub const Canvas = struct {
             @intCast(height),
         );
         errdefer sfc.deinit(alloc);
-
         return .{ .sfc = sfc, .alloc = alloc };
     }
 
@@ -112,23 +109,16 @@ pub const Canvas = struct {
         const width = @as(u32, @intCast(self.sfc.getWidth()));
         const height = @as(u32, @intCast(self.sfc.getHeight()));
 
-        // Allocate our texture atlas region
+        // Allocate our texture atlas region with padding.
         const region = region: {
-            // We need to add a 1px padding to the font so that we don't
-            // get fuzzy issues when blending textures.
             const padding = 1;
 
-            // Get the full padded region
             var region = try atlas.reserve(
                 alloc,
-                width + (padding * 2), // * 2 because left+right
-                height + (padding * 2), // * 2 because top+bottom
+                width + (padding * 2),
+                height + (padding * 2),
             );
 
-            // Modify the region so that we remove the padding so that
-            // we write to the non-zero location. The data in an Altlas
-            // is always initialized to zero (Atlas.clear) so we don't
-            // need to worry about zero-ing that.
             region.x += padding;
             region.y += padding;
             region.width -= padding * 2;
@@ -138,8 +128,6 @@ pub const Canvas = struct {
 
         if (region.width > 0 and region.height > 0) {
             const buffer: []u8 = @ptrCast(self.sfc.image_surface_alpha8.buf);
-
-            // Write the glyph information into the atlas
             assert(region.width == width);
             assert(region.height == height);
             atlas.set(region, buffer);
@@ -148,12 +136,12 @@ pub const Canvas = struct {
         return region;
     }
 
-    /// Acquires a z2d drawing context, caller MUST deinit context.
+    /// Acquire a z2d draw context (caller must deinit elsewhere).
     pub fn getContext(self: *Canvas) z2d.Context {
         return z2d.Context.init(self.alloc, &self.sfc);
     }
 
-    /// Draw and fill a single pixel
+    /// Draw a single pixel.
     pub fn pixel(self: *Canvas, x: u32, y: u32, color: Color) void {
         self.sfc.putPixel(
             @intCast(x),
@@ -162,8 +150,7 @@ pub const Canvas = struct {
         );
     }
 
-    /// Draw and fill a rectangle. This is the main primitive for drawing
-    /// lines as well (which are just generally skinny rectangles...)
+    /// Draw and fill a rectangle (width, height are u32).
     pub fn rect(self: *Canvas, v: Rect(u32), color: Color) void {
         const x0 = v.x;
         const x1 = v.x + v.width;
@@ -172,11 +159,7 @@ pub const Canvas = struct {
 
         for (y0..y1) |y| {
             for (x0..x1) |x| {
-                self.pixel(
-                    @intCast(x),
-                    @intCast(y),
-                    color,
-                );
+                self.pixel(@intCast(x), @intCast(y), color);
             }
         }
     }
@@ -186,11 +169,11 @@ pub const Canvas = struct {
         var path: z2d.StaticPath(6) = .{};
         path.init(); // nodes.len = 0
 
-        path.moveTo(q.p0.x, q.p0.y); // +1, nodes.len = 1
-        path.lineTo(q.p1.x, q.p1.y); // +1, nodes.len = 2
-        path.lineTo(q.p2.x, q.p2.y); // +1, nodes.len = 3
-        path.lineTo(q.p3.x, q.p3.y); // +1, nodes.len = 4
-        path.close(); // +2, nodes.len = 6
+        path.moveTo(q.p0.x, p0.y);
+        path.lineTo(q.p1.x, q.p1.y);
+        path.lineTo(q.p2.x, q.p2.y);
+        path.lineTo(q.p3.x, q.p3.y);
+        path.close(); // nodes len = 6
 
         try z2d.painter.fill(
             self.alloc,
@@ -208,10 +191,10 @@ pub const Canvas = struct {
         var path: z2d.StaticPath(5) = .{};
         path.init(); // nodes.len = 0
 
-        path.moveTo(t.p0.x, t.p0.y); // +1, nodes.len = 1
-        path.lineTo(t.p1.x, t.p1.y); // +1, nodes.len = 2
-        path.lineTo(t.p2.x, t.p2.y); // +1, nodes.len = 3
-        path.close(); // +2, nodes.len = 5
+        path.moveTo(t.p0.x, t.p0.y);
+        path.lineTo(t.p1.x, t.p1.y);
+        path.lineTo(t.p2.x, t.p2.y);
+        path.close(); // nodes len = 5
 
         try z2d.painter.fill(
             self.alloc,
@@ -219,18 +202,19 @@ pub const Canvas = struct {
             &.{ .opaque_pattern = .{
                 .pixel = .{ .alpha8 = .{ .a = @intFromEnum(color) } },
             } },
-            path.wrapped_path.nodes.items,
+            path.wrapped_path.items,
             .{},
         );
     }
 
+    /// Draw a triangle outline.
     pub fn triangle_outline(self: *Canvas, t: Triangle(f64), thickness: f64, color: Color) !void {
         var path: z2d.StaticPath(3) = .{};
         path.init(); // nodes.len = 0
 
-        path.moveTo(t.p0.x, t.p0.y); // +1, nodes.len = 1
-        path.lineTo(t.p1.x, t.p1.y); // +1, nodes.len = 2
-        path.lineTo(t.p2.x, t.p2.y); // +1, nodes.len = 3
+        path.moveTo(t.p0.x, t.p0.y);
+        path.lineTo(t.p1.x, t.p1.y);
+        path.lineTo(p2.x, p2.y);
 
         try z2d.painter.stroke(
             self.alloc,
@@ -251,8 +235,8 @@ pub const Canvas = struct {
         var path: z2d.StaticPath(2) = .{};
         path.init(); // nodes.len = 0
 
-        path.moveTo(l.p0.x, l.p0.y); // +1, nodes.len = 1
-        path.lineTo(l.p1.x, l.p1.y); // +1, nodes.len = 2
+        path.moveTo(l.p0.x, l.p0.y);
+        path.lineTo(l.p1.x, l.p1.y);
 
         try z2d.painter.stroke(
             self.alloc,
@@ -262,12 +246,13 @@ pub const Canvas = struct {
             } },
             path.wrapped_path.nodes.items,
             .{
-                .line_cap_mode = .round,
                 .line_width = thickness,
+                .line_cap_mode = .round,
             },
         );
     }
 
+    /// Invert the image: each pixel A becomes 255-A.
     pub fn invert(self: *Canvas) void {
         for (std.mem.sliceAsBytes(self.sfc.image_surface_alpha8.buf)) |*v| {
             v.* = 255 - v.*;
