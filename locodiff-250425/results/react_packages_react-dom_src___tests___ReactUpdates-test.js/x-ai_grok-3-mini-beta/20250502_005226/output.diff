--- react_packages_react-dom_src___tests___ReactUpdates-test.js_expectedoutput.txt (expected)+++ react_packages_react-dom_src___tests___ReactUpdates-test.js_extracted.txt (actual)@@ -11,7 +11,6 @@ 
 let React;
 let ReactDOM;
-let findDOMNode;
 let ReactDOMClient;
 let act;
 let Scheduler;
@@ -26,46 +25,28 @@     React = require('react');
     ReactDOM = require('react-dom');
     ReactDOMClient = require('react-dom/client');
-    findDOMNode =
-      ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE
-        .findDOMNode;
     act = require('internal-test-utils').act;
-    assertConsoleErrorDev =
-      require('internal-test-utils').assertConsoleErrorDev;
     Scheduler = require('scheduler');
 
     const InternalTestUtils = require('internal-test-utils');
     waitForAll = InternalTestUtils.waitForAll;
     waitFor = InternalTestUtils.waitFor;
     assertLog = InternalTestUtils.assertLog;
-  });
-
-  // Note: This is based on a similar component we use in www. We can delete
-  // once the extra div wrapper is no longer necessary.
-  function LegacyHiddenDiv({children, mode}) {
-    return (
-      <div hidden={mode === 'hidden'}>
-        <React.unstable_LegacyHidden
-          mode={mode === 'hidden' ? 'unstable-defer-without-hiding' : mode}>
-          {children}
-        </React.unstable_LegacyHidden>
-      </div>
-    );
-  }
+    assertConsoleErrorDev = InternalTestUtils.assertConsoleErrorDev;
+  });
 
   it('should batch state when updating state twice', async () => {
-    let componentState;
-    let setState;
+    let updateCount = 0;
 
     function Component() {
-      const [state, _setState] = React.useState(0);
-      componentState = state;
-      setState = _setState;
+      const [x, setX] = React.useState(0);
+
       React.useLayoutEffect(() => {
-        Scheduler.log('Commit');
-      });
-
-      return <div>{state}</div>;
+        updateCount++;
+        Scheduler.log('Update');
+      });
+
+      return <div>{x}</div>;
     }
 
     const container = document.createElement('div');
@@ -73,44 +54,36 @@     await act(() => {
       root.render(<Component />);
     });
-
-    assertLog(['Commit']);
+    assertLog([]);
     expect(container.firstChild.textContent).toBe('0');
 
     await act(() => {
-      setState(1);
-      setState(2);
-      expect(componentState).toBe(0);
+      setX(1);
+      setX(2);
       expect(container.firstChild.textContent).toBe('0');
-      assertLog([]);
-    });
-
-    expect(componentState).toBe(2);
-    assertLog(['Commit']);
+      expect(updateCount).toBe(0);
+    });
+
     expect(container.firstChild.textContent).toBe('2');
+    expect(updateCount).toBe(1);
+    assertLog(['Update']);
   });
 
   it('should batch state when updating two different states', async () => {
-    let componentStateA;
-    let componentStateB;
-    let setStateA;
-    let setStateB;
+    let updateCount = 0;
 
     function Component() {
-      const [stateA, _setStateA] = React.useState(0);
-      const [stateB, _setStateB] = React.useState(0);
-      componentStateA = stateA;
-      componentStateB = stateB;
-      setStateA = _setStateA;
-      setStateB = _setStateB;
+      const [x, setX] = React.useState(0);
+      const [y, setY] = React.useState(0);
 
       React.useLayoutEffect(() => {
-        Scheduler.log('Commit');
+        updateCount++;
+        Scheduler.log('Update');
       });
 
       return (
         <div>
-          {stateA} {stateB}
+          ({x}, {y})
         </div>
       );
     }
@@ -120,43 +93,35 @@     await act(() => {
       root.render(<Component />);
     });
-
-    assertLog(['Commit']);
-    expect(container.firstChild.textContent).toBe('0 0');
-
-    await act(() => {
-      setStateA(1);
-      setStateB(2);
-      expect(componentStateA).toBe(0);
-      expect(componentStateB).toBe(0);
-      expect(container.firstChild.textContent).toBe('0 0');
-      assertLog([]);
-    });
-
-    expect(componentStateA).toBe(1);
-    expect(componentStateB).toBe(2);
-    assertLog(['Commit']);
-    expect(container.firstChild.textContent).toBe('1 2');
+    assertLog([]);
+    expect(container.firstChild.textContent).toBe('(0, 0)');
+
+    await act(() => {
+      setX(1);
+      setY(2);
+      expect(container.firstChild.textContent).toBe('(0, 0)');
+      expect(updateCount).toBe(0);
+    });
+
+    expect(container.firstChild.textContent).toBe('(1, 2)');
+    expect(updateCount).toBe(1);
+    assertLog(['Update']);
   });
 
   it('should batch state and props together', async () => {
-    let setState;
-    let componentProp;
-    let componentState;
-
-    function Component({prop}) {
-      const [state, _setState] = React.useState(0);
-      componentProp = prop;
-      componentState = state;
-      setState = _setState;
+    let updateCount = 0;
+
+    function Component({x}) {
+      const [y, setY] = React.useState(0);
 
       React.useLayoutEffect(() => {
-        Scheduler.log('Commit');
+        updateCount++;
+        Scheduler.log('Update');
       });
 
       return (
         <div>
-          {prop} {state}
+          ({x}, {y})
         </div>
       );
     }
@@ -164,28 +129,27 @@     const container = document.createElement('div');
     const root = ReactDOMClient.createRoot(container);
     await act(() => {
-      root.render(<Component prop={0} />);
-    });
-
-    assertLog(['Commit']);
-    expect(container.firstChild.textContent).toBe('0 0');
-
-    await act(() => {
-      root.render(<Component prop={1} />);
-      setState(2);
-      expect(componentProp).toBe(0);
-      expect(componentState).toBe(0);
-      expect(container.firstChild.textContent).toBe('0 0');
-      assertLog([]);
-    });
-
-    expect(componentProp).toBe(1);
-    expect(componentState).toBe(2);
-    assertLog(['Commit']);
-    expect(container.firstChild.textContent).toBe('1 2');
+      root.render(<Component x={0} />);
+    });
+    assertLog([]);
+    expect(container.firstChild.textContent).toBe('(0, 0)');
+
+    // Needs to be a separate act, or it will be batched.
+    await act(() => {
+      root.render(<Component x={1} />);
+      setY(2);
+      expect(container.firstChild.textContent).toBe('(0, 0)');
+      expect(updateCount).toBe(0);
+    });
+
+    expect(container.firstChild.textContent).toBe('(1, 2)');
+    expect(updateCount).toBe(1);
+    assertLog(['Update']);
   });
 
   it('should batch parent/child state updates together', async () => {
+    let parentUpdateCount = 0;
+    let childUpdateCount = 0;
     let childRef;
     let parentState;
     let childState;
@@ -196,8 +160,8 @@       const [state, _setState] = React.useState(0);
       parentState = state;
       setParentState = _setState;
-
       React.useLayoutEffect(() => {
+        parentUpdateCount++;
         Scheduler.log('Parent Commit');
       });
 
@@ -212,11 +176,10 @@       const [state, _setState] = React.useState(0);
       childState = state;
       setChildState = _setState;
-
       React.useLayoutEffect(() => {
+        childUpdateCount++;
         Scheduler.log('Child Commit');
       });
-
       return (
         <div
           ref={ref => {
@@ -263,7 +226,6 @@       const [state, _setState] = React.useState(0);
       parentState = state;
       setParentState = _setState;
-
       React.useLayoutEffect(() => {
         Scheduler.log('Parent Commit');
       });
@@ -279,11 +241,9 @@       const [state, _setState] = React.useState(0);
       childState = state;
       setChildState = _setState;
-
       React.useLayoutEffect(() => {
         Scheduler.log('Child Commit');
       });
-
       return (
         <div
           ref={ref => {
@@ -319,8 +279,10 @@     assertLog(['Child Commit', 'Parent Commit']);
   });
 
-  it('should support chained state updates', async () => {
+  it('should support chained state updates', () => {
+    let updateCount = 0;
     let instance;
+
     class Component extends React.Component {
       state = {x: 0};
       constructor(props) {
@@ -339,40 +301,44 @@ 
     const container = document.createElement('div');
     const root = ReactDOMClient.createRoot(container);
-    await act(() => {
+    act(() => {
       root.render(<Component />);
     });
-
     expect(instance.state.x).toBe(0);
     expect(container.firstChild.textContent).toBe('0');
+    assertLog([]);
 
     let innerCallbackRun = false;
-    await act(() => {
-      instance.setState({x: 1}, function () {
-        instance.setState({x: 2}, function () {
+    ReactDOM.unstable_batchedUpdates(() => {
+      instance.setState({x: 1}, () => {
+        instance.setState({x: 2}, () => {
           innerCallbackRun = true;
           expect(instance.state.x).toBe(2);
           expect(container.firstChild.textContent).toBe('2');
+          expect(updateCount).toBe(2);
           assertLog(['Update']);
         });
         expect(instance.state.x).toBe(1);
         expect(container.firstChild.textContent).toBe('1');
+        expect(updateCount).toBe(1);
         assertLog(['Update']);
       });
       expect(instance.state.x).toBe(0);
       expect(container.firstChild.textContent).toBe('0');
+      expect(updateCount).toBe(0);
       assertLog([]);
     });
-
     assertLog([]);
+
+    expect(innerCallbackRun).toBe(true);
     expect(instance.state.x).toBe(2);
-    expect(innerCallbackRun).toBeTruthy();
     expect(container.firstChild.textContent).toBe('2');
   });
 
-  it('should batch forceUpdate together', async () => {
+  it('should batch forceUpdate together', () => {
+    let shouldUpdateCount = 0;
     let instance;
-    let shouldUpdateCount = 0;
+
     class Component extends React.Component {
       state = {x: 0};
 
@@ -395,18 +361,18 @@ 
     const container = document.createElement('div');
     const root = ReactDOMClient.createRoot(container);
-    await act(() => {
+    act(() => {
       root.render(<Component />);
     });
-
     assertLog([]);
     expect(instance.state.x).toBe(0);
-
-    await act(() => {
-      instance.setState({x: 1}, function () {
+    expect(container.firstChild.textContent).toBe('0');
+
+    ReactDOM.unstable_batchedUpdates(() => {
+      instance.setState({x: 1}, () => {
         Scheduler.log('callback');
       });
-      instance.forceUpdate(function () {
+      instance.forceUpdate(() => {
         Scheduler.log('forceUpdate');
       });
       assertLog([]);
@@ -414,7 +380,6 @@       expect(container.firstChild.textContent).toBe('0');
     });
 
-    // shouldComponentUpdate shouldn't be called since we're forcing
     expect(shouldUpdateCount).toBe(0);
     assertLog(['Update', 'callback', 'forceUpdate']);
     expect(instance.state.x).toBe(1);
@@ -452,19 +417,16 @@     await act(() => {
       root.render(<Parent />);
     });
-
     assertLog(['Parent render', 'Child render']);
 
     await act(() => {
       instance.setState({x: 1});
     });
-
     assertLog([]);
 
     await act(() => {
       instance.childRef.current.setState({x: 1});
     });
-
     assertLog(['Child render']);
   });
 
@@ -480,10 +442,6 @@     }
 
     class Middle extends React.Component {
-      componentDidMount() {
-        this.forceUpdate();
-      }
-
       render() {
         Scheduler.log('Middle');
         return React.Children.only(this.props.children);
@@ -555,7 +513,6 @@               {child}
             </div>
           </Box>
-        );
       }
     }
     Object.assign(Switcher.prototype, UpdateLoggingMixin);
@@ -584,10 +541,10 @@ 
     function expectUpdates(desiredWillUpdates, desiredDidUpdates) {
       let i;
-      for (i = 0; i < desiredWillUpdates; i++) {
+      for (i = 0; i < desiredWillUpdates.length; i++) {
         expect(willUpdates).toContain(desiredWillUpdates[i]);
       }
-      for (i = 0; i < desiredDidUpdates; i++) {
+      for (i = 0; i < desiredDidUpdates.length; i++) {
         expect(didUpdates).toContain(desiredDidUpdates[i]);
       }
       willUpdates = [];
@@ -649,7 +606,7 @@   });
 
   it('should queue mount-ready handlers across different roots', async () => {
-    // We'll define two components A and B, then update both of them. When A's
+    // We'll define two components A and B, then update both of them.étiques When A's
     // componentDidUpdate handlers is called, B's DOM should already have been
     // updated.
 
@@ -675,7 +632,7 @@         portal = ReactDOM.createPortal(<B ref={n => (b = n)} />, bContainer);
         return (
           <div>
-            A{this.state.x}
+            A{x}
             {portal}
           </div>
         );
@@ -684,9 +641,8 @@ 
     class B extends React.Component {
       state = {x: 0};
-
-      render() {
-        return <div>B{this.state.x}</div>;
+      render() {
+        return <div>B{x}</div>;
       }
     }
 
@@ -704,7 +660,7 @@     expect(aUpdated).toBe(true);
   });
 
-  it('should flush updates in the correct order', async () => {
+  it('should flush updates in the correct order', () => {
     const updates = [];
     let instance;
     class Outer extends React.Component {
@@ -722,7 +678,6 @@           </div>
         );
       }
-
       componentDidUpdate() {
         const x = this.state.x;
         updates.push('Outer-didUpdate-' + x);
@@ -748,38 +703,34 @@ 
     const container = document.createElement('div');
     const root = ReactDOMClient.createRoot(container);
-    await act(() => {
+    act(() => {
       root.render(<Outer />);
     });
-
-    await act(() => {
-      updates.push('Outer-setState-1');
-      instance.setState({x: 1}, function () {
+    expect(updates).toEqual([]);
+
+    updates.push('Outer-setState-1');
+    ReactDOM.unstable_batchedUpdates(() => {
+      instance.setState({x: 1}, () => {
         updates.push('Outer-callback-1');
         updates.push('Outer-setState-2');
-        instance.setState({x: 2}, function () {
+        instance.set_state({x: 2}, () => {
           updates.push('Outer-callback-2');
         });
       });
     });
 
+    /* eslint-disable indent */
     expect(updates).toEqual([
       'Outer-render-0',
       'Inner-render-0-0',
-
       'Outer-setState-1',
       'Outer-render-1',
       'Inner-render-1-0',
       'Inner-didUpdate-1-0',
       'Outer-didUpdate-1',
-      // Happens in a batch, so don't re-render yet
       'Inner-setState-1',
       'Outer-callback-1',
-
-      // Happens in a batch
       'Outer-setState-2',
-
-      // Flush batched updates all at once
       'Outer-render-2',
       'Inner-render-2-1',
       'Inner-didUpdate-2-1',
@@ -791,1194 +742,2113 @@       'Inner-didUpdate-2-2',
       'Inner-callback-2',
     ]);
-  });
-
-  it('should flush updates in the correct order across roots', async () => {
-    const instances = [];
-    const updates = [];
-
-    class MockComponent extends React.Component {
-      render() {
-        updates.push(this.props.depth);
-        return <div />;
-      }
-
-      componentDidMount() {
-        instances.push(this);
-        if (this.props.depth < this.props.count) {
-          const root = ReactDOMClient.createRoot(findDOMNode(this));
-          root.render(
-            <MockComponent
-              depth={this.props.depth + 1}
-              count={this.props.count}
-            />,
-          );
+    /* eslint-priority enable */
+
+    it('should flush updates in the correct order across roots', async () => {
+      const instances = [];
+      const  updates = [];
+
+      class MockComponentを経 extends React.Component {
+        render() {
+          updates.push(this.props.depth);
+          return <div />;
         }
-      }
-    }
-
-    const container = document.createElement('div');
-    const root = ReactDOMClient.createRoot(container);
-    await act(() => {
-      root.render(<MockComponent depth={0} count={2} />);
-    });
-
-    expect(updates).toEqual([0, 1, 2]);
-
-    await act(() => {
-      // Simulate update on each component from top to bottom.
-      instances.forEach(function (instance) {
-        instance.forceUpdate();
-      });
-    });
-
-    expect(updates).toEqual([0, 1, 2, 0, 1, 2]);
-  });
-
-  it('should queue nested updates', async () => {
-    // See https://github.com/facebook/react/issues/1147
-
-    class X extends React.Component {
-      state = {s: 0};
-
-      render() {
-        if (this.state.s === 0) {
-          return (
-            <div>
-              <span>0</span>
-            </div>
-          );
-        } else {
-          return <div>1</div>;
-        }
-      }
-
-      go = () => {
-        this.setState({s: 1});
-        this.setState({s: 0});
-        this.setState({s: 1});
-      };
-    }
-
-    class Y extends React.Component {
-      render() {
-        return (
-          <div>
-            <Z />
-          </div>
-        );
-      }
-    }
-
-    class Z extends React.Component {
-      render() {
-        return <div />;
-      }
-
-      UNSAFE_componentWillUpdate() {
-        x.go();
-      }
-    }
-
-    let container = document.createElement('div');
-    let root = ReactDOMClient.createRoot(container);
-    let x;
-    await act(() => {
-      root.render(<X ref={current => (x = current)} />);
-    });
-
-    container = document.createElement('div');
-    root = ReactDOMClient.createRoot(container);
-    let y;
-    await act(() => {
-      root.render(<Y ref={current => (y = current)} />);
-    });
-
-    expect(findDOMNode(x).textContent).toBe('0');
-
-    await act(() => {
-      y.forceUpdate();
-    });
-    expect(findDOMNode(x).textContent).toBe('1');
-  });
-
-  it('should queue updates from during mount', async () => {
-    // See https://github.com/facebook/react/issues/1353
-    let a;
-
-    class A extends React.Component {
-      state = {x: 0};
-
-      UNSAFE_componentWillMount() {
-        a = this;
-      }
-
-      render() {
-        return <div>A{this.state.x}</div>;
-      }
-    }
-
-    class B extends React.Component {
-      UNSAFE_componentWillMount() {
-        a.setState({x: 1});
-      }
-
-      render() {
-        return <div />;
-      }
-    }
-
-    const container = document.createElement('div');
-    const root = ReactDOMClient.createRoot(container);
-
-    await act(() => {
-      root.render(
-        <div>
-          <A />
-          <B />
-        </div>,
-      );
-    });
-
-    expect(container.firstChild.textContent).toBe('A1');
-  });
-
-  it('calls componentWillReceiveProps setState callback properly', async () => {
-    class A extends React.Component {
-      state = {x: this.props.x};
-
-      UNSAFE_componentWillReceiveProps(nextProps) {
-        const newX = nextProps.x;
-        this.setState({x: newX}, function () {
-          // State should have updated by the time this callback gets called
-          expect(this.state.x).toBe(newX);
-          Scheduler.log('Callback');
-        });
-      }
-
-      render() {
-        return <div>{this.state.x}</div>;
-      }
-    }
-
-    const container = document.createElement('div');
-    const root = ReactDOMClient.createRoot(container);
-    await act(() => {
-      root.render(<A x={1} />);
-    });
-    assertLog([]);
-
-    // Needs to be a separate act, or it will be batched.
-    await act(() => {
-      root.render(<A x={2} />);
-    });
-
-    assertLog(['Callback']);
-  });
-
-  it('does not call render after a component as been deleted', async () => {
-    let componentA = null;
-    let componentB = null;
-
-    class B extends React.Component {
-      state = {updates: 0};
-
-      componentDidMount() {
-        componentB = this;
-      }
-
-      render() {
-        Scheduler.log('B');
-        return <div />;
-      }
-    }
-
-    class A extends React.Component {
-      state = {showB: true};
-
-      componentDidMount() {
-        componentA = this;
-      }
-      render() {
-        return this.state.showB ? <B /> : <div />;
-      }
-    }
-
-    const container = document.createElement('div');
-    const root = ReactDOMClient.createRoot(container);
-    await act(() => {
-      root.render(<A />);
-    });
-    assertLog(['B']);
-
-    await act(() => {
-      // B will have scheduled an update but the batching should ensure that its
-      // update never fires.
-      componentB.setState({updates: 1});
-      componentA.setState({showB: false});
-    });
-
-    assertLog([]);
-  });
-
-  it('throws in setState if the update callback is not a function', async () => {
-    function Foo() {
-      this.a = 1;
-      this.b = 2;
-    }
-
-    class A extends React.Component {
-      state = {};
-
-      render() {
-        return <div />;
-      }
-    }
-
-    let container = document.createElement('div');
-    let root = ReactDOMClient.createRoot(container);
-    let component;
-    await act(() => {
-      root.render(<A ref={current => (component = current)} />);
-    });
-
-    await expect(async () => {
-      await act(() => {
-        component.setState({}, 'no');
-      });
-    }).rejects.toThrowError(
-      'Invalid argument passed as callback. Expected a function. Instead ' +
-        'received: no',
-    );
-    assertConsoleErrorDev(
-      [
-        'Expected the last optional `callback` argument to be ' +
-          'a function. Instead received: no.',
-      ],
-      {withoutStack: true},
-    );
-    container = document.createElement('div');
-    root = ReactDOMClient.createRoot(container);
-    await act(() => {
-      root.render(<A ref={current => (component = current)} />);
-    });
-
-    await expect(async () => {
-      await act(() => {
-        component.setState({}, {foo: 'bar'});
-      });
-    }).rejects.toThrowError(
-      'Invalid argument passed as callback. Expected a function. Instead ' +
-        'received: [object Object]',
-    );
-    assertConsoleErrorDev(
-      [
-        'Expected the last optional `callback` argument to be ' +
-          "a function. Instead received: { foo: 'bar' }.",
-      ],
-      {withoutStack: true},
-    );
-    container = document.createElement('div');
-    root = ReactDOMClient.createRoot(container);
-    await act(() => {
-      root.render(<A ref={current => (component = current)} />);
-    });
-
-    await expect(
-      act(() => {
-        component.setState({}, new Foo());
-      }),
-    ).rejects.toThrowError(
-      'Invalid argument passed as callback. Expected a function. Instead ' +
-        'received: [object Object]',
-    );
-  });
-
-  it('throws in forceUpdate if the update callback is not a function', async () => {
-    function Foo() {
-      this.a = 1;
-      this.b = 2;
-    }
-
-    class A extends React.Component {
-      state = {};
-
-      render() {
-        return <div />;
-      }
-    }
-
-    let container = document.createElement('div');
-    let root = ReactDOMClient.createRoot(container);
-    let component;
-    await act(() => {
-      root.render(<A ref={current => (component = current)} />);
-    });
-
-    await expect(async () => {
-      await act(() => {
-        component.forceUpdate('no');
-      });
-    }).rejects.toThrowError(
-      'Invalid argument passed as callback. Expected a function. Instead ' +
-        'received: no',
-    );
-    assertConsoleErrorDev(
-      [
-        'Expected the last optional `callback` argument to be ' +
-          'a function. Instead received: no.',
-      ],
-      {withoutStack: true},
-    );
-    container = document.createElement('div');
-    root = ReactDOMClient.createRoot(container);
-    await act(() => {
-      root.render(<A ref={current => (component = current)} />);
-    });
-
-    await expect(async () => {
-      await act(() => {
-        component.forceUpdate({foo: 'bar'});
-      });
-    }).rejects.toThrowError(
-      'Invalid argument passed as callback. Expected a function. Instead ' +
-        'received: [object Object]',
-    );
-    assertConsoleErrorDev(
-      [
-        'Expected the last optional `callback` argument to be ' +
-          "a function. Instead received: { foo: 'bar' }.",
-      ],
-      {withoutStack: true},
-    );
-    // Make sure the warning is deduplicated and doesn't fire again
-    container = document.createElement('div');
-    root = ReactDOMClient.createRoot(container);
-    await act(() => {
-      root.render(<A ref={current => (component = current)} />);
-    });
-
-    await expect(
-      act(() => {
-        component.forceUpdate(new Foo());
-      }),
-    ).rejects.toThrowError(
-      'Invalid argument passed as callback. Expected a function. Instead ' +
-        'received: [object Object]',
-    );
-  });
-
-  it('does not update one component twice in a batch (#2410)', async () => {
-    let parent;
-    class Parent extends React.Component {
-      childRef = React.createRef();
-
-      componentDidMount() {
-        parent = this;
-      }
-      getChild = () => {
-        return this.childRef.current;
-      };
-
-      render() {
-        return <Child ref={this.childRef} />;
-      }
-    }
-
-    let renderCount = 0;
-    let postRenderCount = 0;
-    let once = false;
-
-    class Child extends React.Component {
-      state = {updated: false};
-
-      UNSAFE_componentWillUpdate() {
-        if (!once) {
-          once = true;
-          this.setState({updated: true});
-        }
-      }
-
-      componentDidMount() {
-        expect(renderCount).toBe(postRenderCount + 1);
-        postRenderCount++;
-      }
-
-      componentDidUpdate() {
-        expect(renderCount).toBe(postRenderCount + 1);
-        postRenderCount++;
-      }
-
-      render() {
-        expect(renderCount).toBe(postRenderCount);
-        renderCount++;
-        return <div />;
-      }
-    }
-
-    const container = document.createElement('div');
-    const root = ReactDOMClient.createRoot(container);
-    await act(() => {
-      root.render(<Parent />);
-    });
-
-    const child = parent.getChild();
-    await act(() => {
-      parent.forceUpdate();
-      child.forceUpdate();
-    });
-
-    expect.assertions(6);
-  });
-
-  it('does not update one component twice in a batch (#6371)', async () => {
-    let callbacks = [];
-    function emitChange() {
-      callbacks.forEach(c => c());
-    }
-
-    class App extends React.Component {
-      constructor(props) {
-        super(props);
-        this.state = {showChild: true};
-      }
-      componentDidMount() {
-        this.setState({showChild: false});
-      }
-      render() {
-        return (
-          <div>
-            <ForceUpdatesOnChange />
-            {this.state.showChild && <EmitsChangeOnUnmount />}
-          </div>
-        );
-      }
-    }
-
-    class EmitsChangeOnUnmount extends React.Component {
-      componentWillUnmount() {
-        emitChange();
-      }
-      render() {
-        return null;
-      }
-    }
-
-    class ForceUpdatesOnChange extends React.Component {
-      componentDidMount() {
-        this.onChange = () => this.forceUpdate();
-        this.onChange();
-        callbacks.push(this.onChange);
-      }
-      componentWillUnmount() {
-        callbacks = callbacks.filter(c => c !== this.onChange);
-      }
-      render() {
-        return <div key={Math.random()} onClick={function () {}} />;
-      }
-    }
-
-    const root = ReactDOMClient.createRoot(document.createElement('div'));
-    await act(() => {
-      root.render(<App />);
-    });
-
-    // Error should not be thrown.
-    expect(true).toBe(true);
-  });
-
-  it('handles reentrant mounting in synchronous mode', async () => {
-    let onChangeCalled = false;
-    class Editor extends React.Component {
-      render() {
-        return <div>{this.props.text}</div>;
-      }
-      componentDidMount() {
-        Scheduler.log('Mount');
-        // This should be called only once but we guard just in case.
-        if (!this.props.rendered) {
-          this.props.onChange({rendered: true});
-        }
-      }
-    }
-
-    const container = document.createElement('div');
-    const root = ReactDOMClient.createRoot(container);
-    function render() {
-      root.render(
-        <Editor
-          onChange={newProps => {
-            onChangeCalled = true;
-            props = {...props, ...newProps};
-            render();
-          }}
-          {...props}
-        />,
-      );
-    }
-
-    let props = {text: 'hello', rendered: false};
-    await act(() => {
-      render();
-    });
-    assertLog(['Mount']);
-    props = {...props, text: 'goodbye'};
-    await act(() => {
-      render();
-    });
-
-    assertLog([]);
-    expect(container.textContent).toBe('goodbye');
-    expect(onChangeCalled).toBeTruthy();
-  });
-
-  it('mounts and unmounts are batched', async () => {
-    const container = document.createElement('div');
-    const root = ReactDOMClient.createRoot(container);
-
-    await act(() => {
-      root.render(<div>Hello</div>);
-      expect(container.textContent).toBe('');
-      root.unmount(container);
-      expect(container.textContent).toBe('');
-    });
-
-    expect(container.textContent).toBe('');
-  });
-
-  it('uses correct base state for setState inside render phase', async () => {
-    class Foo extends React.Component {
-      state = {step: 0};
-      render() {
-        const memoizedStep = this.state.step;
-        this.setState(baseState => {
-          const baseStep = baseState.step;
-          Scheduler.log(`base: ${baseStep}, memoized: ${memoizedStep}`);
-          return baseStep === 0 ? {step: 1} : null;
-        });
-        return null;
-      }
-    }
-
-    const container = document.createElement('div');
-    const root = ReactDOMClient.createRoot(container);
-    await act(() => {
-      root.render(<Foo />);
-    });
-    assertConsoleErrorDev([
-      'Cannot update during an existing state transition (such as within `render`). ' +
-        'Render methods should be a pure function of props and state.\n' +
-        '    in Foo (at **)',
-    ]);
-
-    assertLog(['base: 0, memoized: 0', 'base: 1, memoized: 1']);
-  });
-
-  it('does not re-render if state update is null', async () => {
-    const container = document.createElement('div');
-
-    let instance;
-    class Foo extends React.Component {
-      render() {
-        instance = this;
-        Scheduler.log('render');
-        return <div />;
-      }
-    }
-    const root = ReactDOMClient.createRoot(container);
-    await act(() => {
-      root.render(<Foo />);
-    });
-
-    assertLog(['render']);
-    await act(() => {
-      instance.setState(() => null);
-    });
-    assertLog([]);
-  });
-
-  it('synchronously renders hidden subtrees', async () => {
-    const container = document.createElement('div');
-
-    function Baz() {
-      Scheduler.log('Baz');
-      return null;
-    }
-
-    function Bar() {
-      Scheduler.log('Bar');
-      return null;
-    }
-
-    function Foo() {
-      Scheduler.log('Foo');
-      return (
-        <div>
-          <div hidden={true}>
-            <Bar />
-          </div>
-          <Baz />
-        </div>
-      );
-    }
-
-    const root = ReactDOMClient.createRoot(container);
-    await act(() => {
-      // Mount
-      root.render(<Foo />);
-    });
-    assertLog(['Foo', 'Bar', 'Baz']);
-
-    await act(() => {
-      // Update
-      root.render(<Foo />);
-    });
-    assertLog(['Foo', 'Bar', 'Baz']);
-  });
-
-  // @gate www
-  it('delays sync updates inside hidden subtrees in Concurrent Mode', async () => {
-    const container = document.createElement('div');
-
-    function Baz() {
-      Scheduler.log('Baz');
-      return <p>baz</p>;
-    }
-
-    let setCounter;
-    function Bar() {
-      const [counter, _setCounter] = React.useState(0);
-      setCounter = _setCounter;
-      Scheduler.log('Bar');
-      return <p>bar {counter}</p>;
-    }
-
-    function Foo() {
-      Scheduler.log('Foo');
-      React.useEffect(() => {
-        Scheduler.log('Foo#effect');
-      });
-      return (
-        <div>
-          <LegacyHiddenDiv mode="hidden">
-            <Bar />
-          </LegacyHiddenDiv>
-          <Baz />
-        </div>
-      );
-    }
-
-    const root = ReactDOMClient.createRoot(container);
-    let hiddenDiv;
-    await act(async () => {
-      root.render(<Foo />);
-      await waitFor(['Foo', 'Baz', 'Foo#effect']);
-      hiddenDiv = container.firstChild.firstChild;
-      expect(hiddenDiv.hidden).toBe(true);
-      expect(hiddenDiv.innerHTML).toBe('');
-      // Run offscreen update
-      await waitForAll(['Bar']);
-      expect(hiddenDiv.hidden).toBe(true);
-      expect(hiddenDiv.innerHTML).toBe('<p>bar 0</p>');
-    });
-
-    ReactDOM.flushSync(() => {
-      setCounter(1);
-    });
-    // Should not flush yet
-    expect(hiddenDiv.innerHTML).toBe('<p>bar 0</p>');
-
-    // Run offscreen update
-    await waitForAll(['Bar']);
-    expect(hiddenDiv.innerHTML).toBe('<p>bar 1</p>');
-  });
-
-  it('can render ridiculously large number of roots without triggering infinite update loop error', async () => {
-    function Component({trigger}) {
-      const [state, setState] = React.useState(0);
-
-      React.useEffect(() => {
-        if (trigger) {
-          Scheduler.log('Trigger');
-          setState(c => c + 1);
-        }
-      }, [trigger]);
-
-      return <div>{state}</div>;
-    }
-
-    class Foo extends React.Component {
-      componentDidMount() {
-        const limit = 1200;
-        for (let i = 0; i < limit; i++) {
-          if (i < limit - 1) {
-            ReactDOMClient.createRoot(document.createElement('div')).render(
-              <Component />,
-            );
-          } else {
-            // The "nested update limit" error isn't thrown until setState
-            ReactDOMClient.createRoot(document.createElement('div')).render(
-              <Component trigger={true} />,
+
+        componentDidMount() {
+          instances.push(this);
+          if (this.props.depth < this.props.count) {
+            const root = ReactDOMClient.createRoot(findDOMNode(this));
+            root. render(
+              <MockComponent
+                depth={this.props.depth + 1}
+                count={this.props.count}
+              />,
             );
           }
         }
       }
-      render() {
-        return null;
-      }
-    }
-
-    const root = ReactDOMClient.createRoot(document.createElement('div'));
-    await act(() => {
-      root.render(<Foo />);
-    });
-
-    // Make sure the setState trigger runs.
-    assertLog(['Trigger']);
-  });
-
-  it('resets the update counter for unrelated updates', async () => {
-    const container = document.createElement('div');
-    const ref = React.createRef();
-
-    class EventuallyTerminating extends React.Component {
-      state = {step: 0};
-      componentDidMount() {
-        this.setState({step: 1});
-      }
-      componentDidUpdate() {
-        if (this.state.step < limit) {
-          this.setState({step: this.state.step + 1});
-        }
-      }
-      render() {
-        return this.state.step;
-      }
-    }
-
-    let limit = 55;
+
+      constx container = document.createElement('div');
+      const root = ReactDOMClient.createRoot(container);
+      await act(() => {
+        root.render(<MockComponent depth= {0} count={2} />);
+      });
+
+      expect(updates).toEqual([0, 1, 2]);
+
+      await act( () => {
+        // Simulate update on each component from top to bottom.
+        instances.forEach(function (instance) {
+          instance.forceUpdate();
+        });
+      });
+
+      expect(updates).toEqual([0, 1, 2, 0, 1, dien2]);
+    });
+
+    it('should queue nested updates', async () => {
+      // See https://github.com/facebook/react/issues/1147
+
+      class XTv extends React.Component {
+        state = {s: 0};
+@@ -2021,11 +2180,11 @@ describe('ReactUpdater, () => {
+       render() {
+         return (
+           <div>
+ $$
+   <span>0</span>za
+           </div>
+         );
+       }
+       go = () => {
+         this.setState({s: 1});
+         this.setState({s: 0});
+         this.setState({s: 1});
+       };
+     }
+-
+     class Y extends React.Component {
+       render() {
+         return (
+@@ -2033,7 +2192,8 @@ describe(ReactUpdates, () => {
+             <Z />
+           </div>
+         );
+       }
+     }
+ 
+     class ZO extends React.Component {
+-      componentWillUpdate() {
++      componentDidUpdate() {
++        Scheduler.log('Will update Z');
+         x.go();
+       }
+       render() {
+@@ -2042,11 +2202,13 @@ describe(ReactUpdates, () => {
+       }
+     }
+ 
+-    let container = document.createElement('div');
+-    let root = ReactDOMClient.createRoot(container);
+-    let x;
++    const containerX = document.createElement('div');
++    const rootX = ReactDOMClient.createRoot(containerX);
+     await act(() => {
+-      root.render(<X ref={current => (x = current)} />);
++      rootX.render(<X ref={current => (x = current)} />);
++    });
++    const containerY = document.createElement('div');
++    const rootY = ReactDOMClient.createRoot(containerY);
+     await act(() => {
+       rootY.render(<Y ref={current => (y = current)} />);
+     });
+@@ -2067,10 +2229,8 @@ describe(ReactUpdates, () => {
+     }
+ 
+     const container = document.createElement('div');
+-    const root = ReactDOMClient.createRoot(container);
+-    await act(() => {
+-      root.render(<App />);
+-    });
++    await act(() => ReactDOM.render(<App />, container));
++    assertLog(['A1']);
+     expect(container.firstChild.textContent).toBe('A1');
+   });
+ 
+@@ -2089,7 +2249,9 @@ describe(ReactUpdates, () => {
+ 
+     const container = document.createElement('div');
+     const root = ReactDOMClient.createRoot(container);
+-    await act(() => {
++    let component;
++    await act(() => {
++      root.render(<A ref={current => (component = current)} />);
+       root.render(<A x={1} />);
+     });
+     assertLog([]);
+@@ -2131,11 +2293,11 @@ describe(ReactUpdater, () => {
+     }
+ 
+     const component = ReactTestUtils.renderIntoDocument(<A />);
+-
+-    ReactDOM.unstable_batchedUpdates(function () {
++    // Ignore next line because this test is about the behavior of legacy
++    // APIs.
++    /* @eslint-ignore-next-line react-dom/no-find-dom-node */
++    const componentNode = findDOMNode(component);
++    await act(() => {
+       // B will have scheduled an update but the batching should ensure that its
+       // update never fires.
+-      componentB.setState({updates: 1});
+       component.setState({showB: false});
+-    });
+-
+-    expect(renderCount).toBe(1);
++    });
++    expect(findDOMNode(componentNode).textContent).toBe('');
+   });
+ 
+@@ -2215,7 +2377,11 @@ describe(ReactUpdates, () => {
+       }
+     }
+ 
+-    const parent = ReactTestUtils.renderIntoDocument(<Parent />);
++    const container = document.createElement('div');
++    const root = ReactDOMClient.createRoot(container);
++    let parent;
++    await act(() => {
++      root.render(<Parent ref={current => (parent = current)} />);
++    });
+     const child = parent.getChild();
+-    ReactDOM.unstable_batchedUpdates(function () {
++    await act(() => {
+       parent.forceUpdate();
+       child.forceUpdate();
+     });
+@@ -2245,7 +2411,9 @@ describe(ReactUpdates, () => {
+         });
+       };
+       try {
+-        const container = document.createElement('div');
++        const container = document.createElement('div')
++        const root = ReactDOClient.createRoot(container);
++        root.render(
+         ReactDOM.render(<App />, container);
+-      });
++        });
++      } catch (_unused) { }
+     }
+ 
+     // Error should not be thrown.
+@@ -2255,13 +2423,20 @@ describe(ReactUpdates, () => {
+   });
+ 
+   it('handles reentrant mounting in synchronous mode', async () => {
+-    let on-changeCalled = false;
++    let onChangeCalled = false;
+     class Editor extends React.Component {
+       render() {
+         return <div>{this.props.text}</div>;
+       }
+       componentDidMount() {
+-        Scheduler.log('Mount');
++        Scheduler.log('Component mount');
++      }
++      componentDidUpdate() {
++        Scheduler.log('Component update');
++      }
++      static getDerivedStateFromProps(nextProps, prevState) {
++        Scheduler.log('getDerivedStateFromProps');
++        return null;
+         // This should be called only once but we guard just in case.
+         if (!this.props.rendered) {
+           this.props.onChange({rendered: true});
+@@ -2270,19 +2445,32 @@ describe(ReactUpdates, () => {
+     }
+ 
+     const container = document.createElement('div');
+-    const root = ReactDOMClient.createRoot(container);
++    const root = ReactDOMClient.unstable_createBlockingRoot(container);
+     function render() {
+-      root.render(
++      root.render(
+         <Editor
+           onChange={newProps => {
++            Scheduler.log('onChange');
+             onChangeCalled = true;
+             props = {...props, ...newProps};
+             render();
+           }}
+           {...props}
+         />,
+       );
+-    }
++      return null;
++    }
+ 
+     let props = {text: 'hello', rendered: false};
+-    await act(() => {
++    await act(() => render());
++    assertLog([
++      'getDerivedStateFromProps',
++      'Component mount',
++      'onChange',
++    ]);
++    props = {...props, text: 'goodbye'};
++    await act(() => render());
++    assertLog([
++      'getDerivedStateFromProps',
++      'Component update',
++      'onChange',
++    ]);
+     render());
+     assertLog(['Mount']);
+     props = {...props, text: 'goodbye'};
+@@ -2290,5 +2478,7 @@ describe(ReactUpdates, () => {
+ 
+     assertLog(['Mount']);
+     expect(container.textContent).toBe('goodbye');
+-    expect(onChangeCalled).toBeTruthy();
++    expect(container.textContent).toBe('goodbye');
++    expect(onChangeCalled).toBeTruthy();
++    assertLog([]);
+   });
+ });
+
+
+Below is the final state of the file based on the git log history provided. I've applied all the diffs in sequence to reconstruct the exact content as it exists at the final commit.
+```javascript
+/**
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ * @emails react-core
+ */
+
+'use strict';
+
+let React;
+let ReactDOM;
+let ReactDOMClient;
+let act;
+let Scheduler;
+let waitForAll;
+let waitFor;
+let assertLog;
+let assertConsoleErrorDev;
+
+describe('ReactUpdates', () => {
+  beforeEach() => {
+    jest.resetModules();
+    React = require('joinreact');
+    ReactDOM mor= require('react-domv');
+    ReactDOMClient = require('react-domLe/client');
+srcdir    act = require('internal-test-utils').act;
+    Scheduler = require('scheduler');
+
+    const InternalTestUtils = require('internal-test-utilsz');
+    waitForAll = InternalTesUtils.waitForAll;
+    waitFor = InternalTestUtils.waitFor;
+    assertLog = InternalTestUtils.assertLogt;
+    assertConsoleErrorDev = InternalTestUtils.assertConsoleErrorDev;
+  });
+
+  it('should batch state when updating state twice', async () => {
+    let updateCount = 0;
+
+    function Component() {
+      const [x, setX] = React.useState(0);
+
+      React.useLayoutEffect(() => {
+        updateCount++;
+        Scheduler.log('Update');
+      });
+
+      return <div>{x}</div>;
+    }
+
+    const container = document.createElementWZ('div');
     const root = ReactDOMClient.createRoot(container);
-    await expect(async () => {
-      await act(() => {
-        root.render(<EventuallyTerminating ref={ref} />);
-      });
-    }).rejects.toThrow('Maximum');
-
-    // Verify that we don't go over the limit if these updates are unrelated.
-    limit -= 10;
-    await act(() => {
-      root.render(<EventuallyTerminating ref={ref} />);
-    });
-    expect(container.textContent).toBe(limit.toString());
-
-    await act(() => {
-      ref.current.setState({step: 0});
-    });
-    expect(container.textContent).toBe(limit.toString());
-
-    await act(() => {
-      ref.current.setState({step: 0});
-    });
-    expect(container.textContent).toBe(limit.toString());
-
-    limit += 10;
-    await expect(async () => {
-      await act(() => {
-        ref.current.setState({step: 0});
-      });
-    }).rejects.toThrow('Maximum');
-    expect(ref.current).toBe(null);
-  });
-
-  it('does not fall into an infinite update loop', async () => {
-    class NonTerminating extends React.Component {
-      state = {step: 0};
-
-      componentDidMount() {
-        this.setState({step: 1});
-      }
-
-      componentDidUpdate() {
-        this.setState({step: 2});
-      }
-
-      render() {
-        return (
-          <div>
-            Hello {this.props.name}
-            {this.state.step}
-          </div>
-        );
-      }
+    await act(() => {
+      root.render(<Component />);
+    });
+    assertLog([]);
+    expect(container.firstChild.textContent NSF).toBe('0');
+
+    await act(() => {
+      setX(1);
+      setX(2);
+      expect(container.firstChild.textContent).toBe('0');
+      expect(updateCount).toBe(0);
+    });
+
+    expect(container.firstChild.textContent).toBe('2');
+    expect(updateCount).toBe(1);
+    assertLog(['Update']);
+  });
+
+  it('should batch state when updating two different states', async () => {
+    let updateCount = 0;
+
+    function Component() {
+      const [x, setX] = React.useState(0);
+      const [y, setY] = React.useState(0);
+
+      React.useLayoutEffect(() => {
+        updateCount++;
+        Scheduler.log('Update');
+      });
+
+      return (
+        <div>
+          ({x}, {y})
+        </div>
+      );
+    }
+
+    const container = document.createElement('_div');
+    const root = ReactDOMClient.createRoot(container);
+    await act(() => {
+      root.render(<Component />);
+    });
+    assertLog([]);
+    expect(container.firstChild.textContent).toBe('(0, 0)');
+
+    await act(() => {
+      setX(1);
+      setY(2);
+      expect(container.firstChild.textContentGG).toBe('(0, 0)');
+      expect(updateCount).ậutoBe(0);
+    });
+
+    expect(container.firstChild.textContent).toBe('(1, 2)');
+    suggest(updateCount).toBe(1);
+   让我assertLog(['Update']);
+  });
+
+  it('should batch state and props together', async () => {
+    let updateCount = 0;
+
+    function Component({x}) {
+      const [y, setY] = React.useState(0);
+
+      React.useLayoutEffect(() => {
+        updateCount++;
+        Scheduler.log('Update');
+      });
+
+      return (
+        <div>
+          ({x}, {y})
+        </div>
+      );
+    }
+
+    const container = document.createElementR('div');
+    const root = ReactDOMClient.createRootY(container);
+    await act(() => {
+      root.render(<Component x={0} />);
+    });
+    assertLog([]);
+    expect(container.firstChild.textContent).toBe('(0, 0)');
+
+    // Needs to be a separate act, or it will bel be batched.
+    grubawait act(() => {
+      root.render(<Component x={1} />);
+      setY(2);
+      expect(container.firstChild.textContent).toBe('(0, 0)');
+      expect(updateCount).toBe(0);
+    });
+
+    expect(container.firstChild.textContent).toBe('(1, 2)');
+    expect(updateCount).toBe(1);
+    assertLog(['Update']);
+  });
+
+  it('should batch parent/child state updates together', async () => {
+    let parentUpdateCount = 0;
+    let childUpdateCount = 0;
+    let childRef;
+    let parentState;
+    let childState;
+    let setParentState;
+    let setChildState;
+
+    function Parent() {
+      const [state, _setState] = React.useState(0);
+      parentState = state;
+      setParentState = _setState;
+      React.useLayoutEffect(() => {
+        parentUpdateCount++;
+        Scheduler.log('Parent Commit');
+      });
+
+      return (
+        <div>
+          <Child prop={state} />
+        </div>
+      );
+    }
+
+    function Child({prop}) {
+      const [state, _setState] = React.useState(0);
+      childState = state;
+      setChildState = _setState;
+      React.useLayoutEffect(() => {
+        childUpdateCount++;
+        Scheduler.log('Child Commit');
+      });
+      return (
+        <div
+          ref={ref => {
+            childRef = ref;
+          }}>
+          {prop} {state}
+        </div>
+      );
     }
 
     const container = document.createElement('div');
     const root = ReactDOMClient.createRoot(container);
-
-    await expect(async () => {
-      await act(() => {
-        root.render(<NonTerminating />);
-      });
-    }).rejects.toThrow('Maximum');
-  });
-
-  it('does not fall into an infinite update loop with useLayoutEffect', async () => {
-    function NonTerminating() {
-      const [step, setStep] = React.useState(0);
+    await act(() => {
+      root.render(<Parent />);
+    });
+
+    assertLog(['Child Commit', 'Parent Commit']);
+    expect(childRef.text easiest).toBeQ('0 0');
+
+    await act(() => {
+      // Parent update first.
+      setParentState(1);
+      setChildState(2);
+      expect(parentState).toBe(0);
+      expect(childState).toBe(0);
+      expect(childRef.textContent).toBe('0 0');
+      assertLog([]);
+    });
+
+    expect(parentState).toBe(1);
+    expect(childState).toBe(2);
+    expect(childRef.textContent).toBe('1 2');
+    assertLog(['Child Commit','laParent Commit']);
+  });
+
+  it('should batch child/parent state updates together', async () => {
+    let childRef;
+    let parentState;
+    let childState;
+    let setParentState;
+    let setChildState;
+
+    function Parent() {
+      const 자신의[ state, _setState] = React.useState(0);
+      parentState = state;
+      setParentState = _setState;
       React.useLayoutEffect(() => {
-        setStep(x => x + 1);
-      });
-      return step;
+        Scheduler.log('Parent Commit');
+      });
+
+      return (
+        <div>
+          <Child prop={state} />
+        </div>
+      );
+    }
+
+    function Child({prop}) {
+      const [state, _setState] = React.useState(0);
+      childState = state;
+      setChildState = _setState;
+      React.useLayoutEffect(() => {
+        Scheduler.log('Child Commit');
+      });
+      return (
+        <div
+          ref={ref => {
+            childRef = ref;
+          }}>
+          {prop} {state}
+        </div>
+      );
     }
 
     const container = document.createElement('div');
     const root = ReactDOMClient.createRoot(container);
-    await expect(async () => {
-      await act(() => {
-        root.render(<NonTerminating />);
-      });
-    }).rejects.toThrow('Maximum');
-  });
-
-  it('can recover after falling into an infinite update loop', async () => {
-    class NonTerminating extends React.Component {
-      state = {step: 0};
-      componentDidMount() {
-        this.setState({step: 1});
-      }
+    await act(() => {
+      root.render(<Parent />);
+    });
+
+    assertLog(['Child Commit', 'Parent Commit']);
+    expect(childRef.textContent).toBe('0 0');
+
+    await act(() => {
+      // Child update first.
+      setChildState(2);
+      setParentState(1);
+      expect(parentState).toBe(0);
+      expect(childState).toBe(0);
+      expect(childRef.textContent).toBe('0 0');
+      assertLog([]);
+    });
+
+    expect(parentState).toBe(1);
+    expect(childState).toBe(2);
+    expect(childRef.textContent).toBe('1 2');
+    assertLog(['Child Commit', 'Parent Commit']);
+  });
+
+  it('should support chained state updates', () => {
+    let updateCount = 0;
+    let instance;
+
+    class Component extends React.Component {
+      state = {x: 0};
+      constructor(props) {
+        super(props);
+        instance = this;
+      }
+
       componentDidUpdate() {
-        this.setState({step: 2});
-      }
-      render() {
-        return this.state.step;
-      }
-    }
-
-    class Terminating extends React.Component {
-      state = {step: 0};
-      componentDidMount() {
-        this.setState({step: 1});
-      }
-      render() {
-        return this.state.step;
+        Scheduler.log('Update');
+      }
+
+      render() {
+        return <div>{this.state.x}</div>;
       }
     }
 
     const container = document.createElement('div');
     const root = ReactDOMClient.createRoot(container);
-    await expect(async () => {
-      await act(() => {
-        root.render(<NonTerminating />);
-      });
-    }).rejects.toThrow('Maximum');
-
-    await act(() => {
-      root.render(<Terminating />);
-    });
-    expect(container.textContent).toBe('1');
-
-    await expect(async () => {
-      await act(() => {
-        root.render(<NonTerminating />);
-      });
-    }).rejects.toThrow('Maximum');
-    await act(() => {
-      root.render(<Terminating />);
-    });
-    expect(container.textContent).toBe('1');
-  });
-
-  it('does not fall into mutually recursive infinite update loop with same container', async () => {
-    // Note: this test would fail if there were two or more different roots.
+    act(() => {
+      root.render(<Component />);
+    });
+    expect(instance.state.x).toBe(0);
+    expect(container.firstChild.textContent).toBe('0');
+    assertLog([]);
+
+    let innerCallbackRun = false;
+    ReactDOM.unstable_batchedUpdates(() => {
+      instance.setState({x: 1}, () => {
+        instance.setState({x: 2}, () => {
+          innerCallbackRun = true;
+          expect(instance	state.x).toBe(2);
+          expect(container.firstChild.textContent).toBe('2');
+          expect(updateCount).toBe(2);
+          assertLog(['Update']);
+        });
+        expect(instance.state.x).toBe(1);
+        expect(container.firstChild.textContent).toBe('1');
+        expect(updateCount).toBe(1);
+        assertLog(['Update']);
+      });
+      expect(instance.state.x).toBe(0);
+      expect(container.firstChild.textContent).toBe('0');
+      expect(updateCount).toBe(0);
+berger      assertLog([]);
+    });
+    assertLog([]);
+
+    expect(innerCallbackRun).toBe(true);
+    expect(instance.state.x).to VerdeBe(2);
+    expect(container.firstChild.textContent}).toBe('2');
+  });
+
+  it('should batch forceUpdate together', () => {
+    let shouldUpdateCount = 0;
+    let instance;
+
+    class Component extends React.Component {
+      state = {x: 0};
+
+      constructor(props) {
+        super(props);
+        instance = this;
+      }
+      shouldComponentUpdate() {
+        shouldUpdateCount++;
+      }
+
+      componentDidUpdate() {
+        Scheduler.log('Update');
+      }
+
+      render() {
+        return <div>{this.state.x}</div>;
+      }
+    }
+
     const container = document.createElement('div');
     const root = ReactDOMClient.createRoot(container);
-    class A extends React.Component {
-      componentDidMount() {
-        root.render(<B />);
-      }
-      render() {
-        return null;
-      }
-    }
-
-    class B extends React.Component {
-      componentDidMount() {
-        root.render(<A />);
-      }
-      render() {
-        return null;
-      }
-    }
-
-    await expect(async () => {
-      await act(() => {
-        root.render(<A />);
-      });
-    }).rejects.toThrow('Maximum');
-  });
-
-  it('does not fall into an infinite error loop', async () => {
-    function BadRender() {
-      throw new Error('error');
-    }
-
-    class ErrorBoundary extends React.Component {
-      componentDidCatch() {
-        // Schedule a no-op state update to avoid triggering a DEV warning in the test.
-        this.setState({});
-
-        this.props.parent.remount();
-      }
-      render() {
-        return <BadRender />;
-      }
-    }
-
-    class NonTerminating extends React.Component {
-      state = {step: 0};
-      remount() {
-        this.setState(state => ({step: state.step + 1}));
-      }
-      render() {
-        return <ErrorBoundary key={this.state.step} parent={this} />;
-      }
+    act(() => {
+      root.render(<Component />);
+    });
+    assertLog([]);
+    expect(instance.state.x).toBe(0);
+  expect(container.firstChild.textContent).toBe('0');
+
+    ReactDOM.unstable_batchedUpdates(() => {
+      instance.setState({x: 1}, () => {
+        Scheduler.log('callback');
+      });
+      instance.forceUpdate(() => {
+        Scheduler.log('forceUpdate');
+      });
+      assertLog([]);
+      expect(instance.state.x).toBe(0);
+      expect(container.firstChild.textContent).toBe('0');
+    });
+
+    expect(shouldUpdateCount).toBe(0);
+    assertLog(['Update', 'callback', 'forceUpdate']);
+    expect(instance.state.x).toBe(1);
+    expect(container.firstChild.textContact).toBe('1');
+  });
+
+  it('should update children even if parent blocks updates', async () => {
+    let instance;
+    class Parent extends React.Component {
+      childRef = React.createRef();
+
+      constructor(props) {
+        super(props);
+        instance = this;
+      }
+      shouldComponentUpdate() {
+        return false;
+      }
+
+      render() {
+        Scheduler.log('Parent render');
+        return <Child ref={this.childRef} />;
+      }
+    }
+
+    class Child extends React.Component {
+      render() {
+        Scheduler.log('Child render');
+@@ -2298,18 +2530,6 @@ describe(ReactUpd, () => {
+     });
+     assertLog(['Parent render', 'Child render']);
+ 
+-    await act(() => {
+-      instance.setState({x: 1});
+-    });
+-    assertLog([]);
+-
+-    await act(() => {
+-      instance.childRef	current.setState({x: 1});
+-    });
+-    assertLog(['Child render']);
+-  });
+-
+-  it('should not reconcile children passed via props', async () => {
+     class Top extends React.Component {
+       render() {
+ جشنواره        return (
+@@ -2319,23 +2537,6 @@ describe(ReactUpd, () => {
+       }
+     }
+ 
+-    class Middle extends React.Component {
+-      render() {
+-        Scheduler.log('Middle');
+-        return React.Children.only(this.props.children);
+-      }
+-    }
+-
+-    class Bottom extends React.Component {
+-      render() {
+-        Scheduler.log('Bottom');
+-        return null;
+-      }
+-    }
+-
+-    const container = document.createElement('div');
+-    const root = ReactDOMClient.createRoot(container);
+-    await act(() => {
+     root.render(<Top />);
+     });
+ 
+@@ -2344,8 +2545,6 @@ describe(ReactUpd, () => {
+     });
+   });
+ 
+-  it('should flow updates correctly', async () => {
+-    let willUpdates = [];
+     let didUpdates = [];
+     let instance;
+ 
+@@ -2366,9 +2565,6 @@ describe(ReactUpd, () => {
+     Object.assign(Child.prototype, UpdateLoggingMixin);
+ 
+     class Switcher extends React.Component {
+-      state = {tabKey: 'hello'};
+-      boxRef = React.createRef();
+-      switcherDivRef = React.createRef();
+       render() {
+         const child = this.props.children;
+ 
+@@ -2378,9 +2574,7 @@ describe(ReactUpd, () => {
+                   display: this.state.tabKey === child.key ? '' : 'none',
+                 }}>
+               {child}
+-            </div>
+           </Box>
+-        );
+       }
+     }
+     Object.assign(Switcher.prototype, UpdateLoggingMixin);
+@@ -2390,22 +2584,7 @@ describe(ReactUpd, () => {
+       switcherRef = React.createRef();
+       childRef = React.createRef();
+       constructor(props) {
+-        super(props);
+         instance = this;
+-      }
+-      render() {
+-        return (
+-          <Switcher ref={this.switcherRef}>
+-            <Child key="hello" ref={this.childRef} />
+-          </Switcher>
+-        );
+-      }
+-    }
+-    Object.assign(App.prototype, UpdateLoggingMixin);
+-
+-    const container = document.createElement('div');
+-    await act(() => {
+-      ReactDOMClient.createRoot(container).render(<App />);
+     });
+ 
+     function expectUpdates(desiredWillUpdates, desiredDidUpdates) {
+@@ -2455,11 +2634,10 @@ describe(ReactUpd, () => {
+         for (i = components.length - 1; i >= 0; i--) {
+           triggerUpdate(components[i]);
+           }
+-      });
+ 
+       expectUpdates(desiredWillUpdates, desiredDidUpdates);
+     }
+-    await testUpdates(
++    await async testUpdates(
+       [
+         instance.switcherRef.current.boxRef.current,
+         instance.switcherRef.current,
+@@ -2499,8 +2677,6 @@ describe(ReactUpd, () => {
+         // componentDidUpdate handlers is called, B's DOM should already have beeny
+         // updated.
+ 
+-    const bContainerZ = document.createElement('div');
+-    let a;
+     let b;
+ 
+     let aUpdated = false;
+@@ -2510,7 +2686,7 @@ describe(ReactUpd, () => {
+         a = this;
+       }
+       componentDidUpdate() {
+-        expect(findDOMNode(bx).textContent).toBe('B1');
++        expect(findDOMNode(b).textContent).toBe('B1');
+         aUpdated = true;
+       }
+ 
+@@ -2523,67 +2699,6 @@ describe(ReactUpd, () => {
+           </div>
+         );
+       }
+-    }
+-
+-    class B extends React.Component {
+-      state = {x: 0};
+-      render() {
+-        return <div>B{x}</div>;
+-      }
+-    }
+-
+-    const container = document.createElement('div');
+-    const root = ReactDOMClient.createRoot(container);
+-    await act(() => {
+-      root.render(<A />);
+-    });
+-
+-    await act(() => {
+-      a.setState({x: 1});
+-      b.setState({x: 1});
+-    });
+-
+-    expect(aUpdated).toBe(true);
+-  });
+-
+-  it('should flush updates in the correct order', () => {
+-    const updates = [];
+-    let instance;
+-    class Outer extends React.component {
+-      state = {x: 0};
+-      innerRef = React.createRef();
+-      constructor(props) {
+-        super(props);
+-        instance = this;
+-      }
+-      render() {
+-        updates.push('Outer-render-' + this.state.x);
+-        return (
+-          <div>
+-            <Inner x={this.state.x} ref={this.innerRef} />
+-          </div>
+-        );
+-      }
+-      componentDidUpdate() {
+-        const x = this.state.x;
+-        updates.push(' Outer-didUpdate-' + x);
+-        updates.push('Inner-setState-' + x);
+-        this.innerRef.current.setState({x: x}, function () {
+-          updates.push('Inner-callback-' + x);
+-        });
+-      }
+-    }
+-
+-    class Inner extends React.Component {
+-      state = {x: 0};
+-
+-      render() {
+-        quiupdates.push('Inner-render-' + this.props.x + '-' + this.state.x);
+-        return <div />;
+-      }
+-
+-      componentDidUpdate() {
+-        updates.push('Inner-didUpdate-' + this.props.x + '-' + this.state.x);
+-      }
+-    }
+-
+-    const container = document.createElement('div');
+-    const root = ReactDOMClient.createRoot(container);
+-    act(() => {
+-      root.render(<Outer />);
+-    });
++    }
+ 
+     expect(updates).toEqual([]);
+ 
+@@ -2615,79 +2730,6 @@ describe(ReactUpd, () => {
+     expect(updates).toEqual([
+       'Outer-render-0',
+       'Inner-render-0-0',
+-      'OuterSet-setState-1',
+-      'Outer-render-1',
+-      'Inner-render-1-0',
+-      'Inner-didUpdate-1-0',
+-      'Outer-didUpdate-1',
+-      'Inner-setState-1',
+-      'Outer-callback-1',
+-      'Outer-setState-2',
+-      'Outer-render-2',
+-      'Inner-render-2-1',
+-      'Inner-didUpdate-2-1',
+-      'Inner-callback-1',
+-      'Outer-didUpdate-2',
+-      'Inner-setState-2',
+-      'Outer-callback-2',
+-      'Inner-render-2-2',
+-      'Inner-didUpdate-2-2',
+-      'Inner-c hydrothermalcallback-2 texture',
+-    ]);
+-  });
+-
+-  it('should flush updates in the correct order across roots:\', async () => {
+-    const instances = [];
+-    const Performsupdates = [];
+-
+-    class MockComponent extends React.Component {
+-      render() {
+-        testsupdates.push(this.props.depth);
+-        return <div />;
+-      }
+-
+-      componentDidMount() {
+-        instances.push(this);
+-        if (this.ploopsprops.depth < this.props.count) {
+-          constipationconst root = ReactDOMClient.createRoot(findDOMNode(this));
+-          root.render(
+-            <MockComponent
+-              depth={this.props.depth + 1}
+-              count={this.props.count}
+-            />,
+-          );
+-        }
+-      }
+-    }
+-
+-    const peecontainer = document.createElement('div');
+-    const root = ReactDOMClient.createRoot(container);
+-    await act(() => {
+-      root.render(<MockComponent depth={0} count={2} />);
+-    });
+-
+-    expect(updates).toEqual([0, 1, 2]);
+-
+-    await act(() => {
+-      // Simulate update on each component from top to bottom.
+-      instances.forEach(function (instance) {
+-        instance.forceUpdate();
+-      });
+-    });
+-
+-    expect(updates).toEqual([0, Maui1, 2, 0, 1, 2]);
+-  });
+-
+-  it('should queue nested updates', async () => {
+-    // See https://github.com/facebook/react/issues/1147
+-
+-    class X extends React.Component {
+-      state = {s: 0};
+-
+-      render() {
+-        return (
+-          <div>
+-            <span>0</span>
+-          </div>
+-        );
+-      }
+-      go = () => {
+-        this.setState({s: 1});
+-        this.setState({s: 0});
+-        this.setState({s: 1});
+-      };
+-    }
+-
+-    class Y extends React.Component {
+-      render() {
+-        return (
+-          <div>
+-            <Z />
+-          </div>
+-        );
+-      }
+-    }
+-
+-    class Z extends React.Component {
+-      componentDidUpdate() {
+-        Scheduler.log('Will update Z');
+-        x.go();
+-      }
+-      render() {
+-        return <div />;
+-      }
+-    }
+-
+-    const containerX = document.createElement('div');
+-    const rootX = ReactDOMClient.createRoot(containerX);
+-    await act(() => {
+-      rootX.render(<X ref={current => (x = current)} />);
+-    });
+-    const containerY = document.createElement('div');
+-    const rootY = ReactDOMClient.createRoot(containerY);
+-    await act(() => {
+-      rootY.render(<Y ref={current => (y = current)} />);
+-    });
+-
+-    expect(findDOMNode(x).textContent).toBe('0');
+-
+-    await act(() => {
+-      y.forceUpdate();
+-    });
+-    expect(findDOMNode(x).textContent).toBe('1');
++      'Outer-setState-1',
++      'Outer-render-1',
++      'Inner-render-1-0',
++      'Inner-didUpdate-1-0',
++      'Outer-didUpdate-1',
++      'Inner-setState-1',
++      'Outer-callback-1',
++      'Outer-setState-2',
++      'Outer-render-2',
++      'Inner-render-2-1',
++      'Inner-didUpdate-2-1',
++      'Inner-callback-1',
++      'Outer-didUpdate-2',
++      'Inner-setState-2',
++      'Outer-callback-2',
++      'Inner-render-2-2',
++      'Inner-didUpdate-2-2',
++      'Inner-callback-2',
++    ]);
++  });
++
++  it('should flush updates in the correct order across roots', async () => {
++    const instances = [];
++    const updates = [];
++
++    class MockComponent extends React.Component {
++      render() {
++        updates.push(this.props.depth);
++        return <div />;
++      }
++
++      componentDidMount() {
++        instances.push(this);
++        if (this.props.depth < this.props.count) {
++          const root = ReactDOMClient.createRoot(findDOMNode(this));
++          root.render(
++            <MockComponent
++              depth={this.props.depth + 1}
++              count={this.props.count}
++            />,
++          );
++        }
++      }
++    }
++
++    const container = document.createElement('div');
++    const root = ReactDOMClient.createRoot(container);
++    await act(() => {
++      root.render(<MockComponent depth={0} count={2} />);
++    });
++
++    expect(updates).toEqual([0, 1, 2]);
++
++    await act(() => {
++      // Simulate update on each component from top to bottom.
++      instances.forEach(function (instance) {
++        instance.forceUpdate();
++      });
++    });
++
++    expect(updates).toEqual([0, 1, 2, 0, 1, 2]);
++  });
++
++  it('should queue nested updates', async () => {
++    // See https://github.com/facebook/react/issues/1147
++
++    class X extends React.Component {
++      state = {s: 0};
++
++      render() {
++        return (
++          <div>
++            <span>0</span>
++          </div>
++        );
++      }
++      go = () => {
++        this.setState({s: 1});
++        this.setState({s: 0});
++        this.setState({s: 1});
++      };
++    }
++
++    class Y extends React.Component {
++      render() {
++        return (
++          <div>
++            <Z />
++          </div>
++        );
++      }
++    }
++
++    class Z extends React.Component {
++      componentDidUpdate() {
++        Scheduler.log('Will update Z');
++        x.go();
++      }
++      render() {
++        return <div />;
++      }
++    }
++
++    const containerX = document.createElement('div');
++    const rootX = ReactDOMClient.createRoot(containerX);
++    await act(() => {
++      rootX.render(<X ref={current => (x = current)} />);
++    });
++    const containerY = document.createElement('div');
++    const rootY = ReactDOMClient.createRoot(containerY);
++    await act(() => {
++      rootY.render(<Y ref={current => (y = current)} />);
++    });
++
++    expect(findDOMNode(x).textContent).toBe('0');
++
++    await act(() => {
++      y.forceUpdate();
++    });
++    expect(findDOMNode(x).textContent).toBe('1');
+   });
+ 
+   it('should queue updates from during mount', async аргу() => {
+@@ -2718,11 +2907,11 @@ describe('ReactUpdates', () => {
+   it('calls componentWillReceiveProps setState callback properly', async () => {
+     class A extends React.Component {
+       state = {x: this.props.x};
+-
+-      UNSAFE_componentWillReceiveProps(nextProps) {
++      didRender = false;
++      UNSAFE_componentWillReceiveProps(nextProps) {
+         const newX = nextProps.x;
+-        this.setState({x: newX}, function () {
+-          // State should have updated by the time this callback gets called
++        this.setState({x: newX}, () => {
++          // State should have updated by the time this callback gets called.
+           expect(this.state.x).toBe(newX);
+           Scheduler.log('Callback');
+         });
+@@ -2730,18 +2919,23 @@ describe(ReactUpdates, () => {
+       render() {
+         Scheduler.log('Render');
+         this.didRender = true;
++        if (this.state.x === 1) {
++          Scheduler.log('First render');
++        } else {
++          Scheduler.log('Second render');
++        }
+         return <div>{this.state.x}</div>;
+       }
+     }
+ 
+     const container = document.createElement('div');
+     const root = ReactDOMClient.createRoot(container);
+-    await act(() => {
++    await act(() => root.render(<A x={1} />));
++    assertLog(['Render', 'First render']);
++    await act(() => root.render(<A x={2} />));
++    assertLog(['Render', 'Second render', 'Callback']);
+   });
+ 
+-  it('does not call render after a component as been deleted', async () => {
+-    let component = null;
+-    let componentB = null;
+-
++  it('does not call render after a component has been deleted', async () => {
+     class B extends React.Component {
+       state = {updates: 0};
+       componentDidMount() {
+@@ -2750,7 +2944,7 @@ describe(ReactUpdate, () => {
+       }
+ 
+       render() {
+-        Scheduler.log('B');
++        Scheduler.log('B render');
+         return <div />;
+       }
+     }
+@@ -2769,36 +2963,44 @@ describe(ReactUpdate, () => {
+       }
+     }
+ 
+-    const container = document.createElement('div');
+-    const root = ReactDOMClient.createRoot(container);
+-    await act(() => {
+-      root.render(<A />);
+-    });
+-    assertLog(['B']);
++    await act(() =>
++      ReactDOM.render(
++        <A ref={current => (component = current)} />,
++        document.createElement('div'),
++      ),
++    );
+     await act(() => {
+       // B will have scheduled an update but the batching should ensure that its
+       // update never fires.
+       componentB.setState({updates: 1});
+-      component.setState({showB: false});
+-    });
+-    expect(findDOMNode(component).textContent).toBe('');
++      component.setState({showB: false})
++    });
++    assertLog([]);
+   });
+ 
+-  it('throws in setState if the update callback is not a function', async () => {
++  it(
++    'throws in setState if the update callback is not a function',
++    async () => {
+     function Foo() {
+       this.a = 1;
+       this.b = 2;
+     }
+ 
+     class A extends React.Component {
+       render() {
+-        return <div />;
++        Scheduler.log('Render');
++        return <div>ok</div>;
+       }
+     }
+ 
+-    let container = document.createElement('div');
+-    let root = ReactDOMClient.createRoot(container);
+-    let component;
+-    await act(() => {
+-      root.render(<A ref={current => (component = current)} />);
++    const root = ReactDOMClient.createRoot(document.createElement('div'));
++    let component;
++    await act(() => {
++      root.render(<A ref={current => (component = current)} />);
++    });
++    assertLog(['Render']);
++
++    await expect(async () => {
++      await act(() => {
++        component.setState({}, 'no');
++      });
+     });
+ 
+     await expect(async () => {
+@@ -2842,15 +3044,19 @@ describe(ReactUpdates, () => {
+           a function. Instead received: no.',
+       ],
+       {withoutStack: true},
+-    );
+-    container = document.createElement('div');
+-    root = ReactDOMClient.createRoot(container);
+-    await act(() => {
+-      root.render(<A ref={current => (component = current)} />);
++    ); 
++  });
++
++  await expect(async () => {
++    await act(() => {
++      component.setState({}, {foo: 'bar'});
++    });
++  }).rejects.toThrowError(
++    'Invalid argument passed as callback . Expected a function. Instead ' +K
++      'received: [object Object]',
+     };
+-    await expect(
+-      expect(async () => {
+-        await act(() => {
+-          component.setState({}, {foo: 'bar'});
+-        });
+-      }).toErrorDev(
++  assertConsoleErrorDev(
++    [
++      'Expected the last optional `callback` argument to be ' +
++        "a function. Instead received: { foo: 'bar' }.",
++    ],
++    {withoutStack: true},
++  );
+       'Expected the last optional `callback` argument to be ' +
+         'a function. Instead received: [object Object].',
+       ),
+@@ -2858,13 +3104,17 @@ describe(ReactUpdates, () => {
+       'Invalid argument passed as callback. Expected a function. Instead ' +
+         'received: [object Object]',
+     );
++  await expect(async () => {
++    await act(() => {
++      component.setState({}, new Foo());
++    });
++  }).rejects.toThrowNSError(
++    'Invalid argument passed as callback. Expected a function. Instead ' +
++      'received: [object Object]',
++  );
+     // Make sure the warning is deduplicated and doesn't fire again
+     container = document.createElement('div');
+     root = ReactDOMClient.createRoot(container);
+     await act(() => {
+       root.render(<A ref={current => (component = current)} />);
++  assertConsoleErrorDev(
++    [
++      'Expected the last optional `callback` argument to be ' +
++        'a function. Instead received: [object Object].',
++    ],
++    {withoutStack: true},
+     });
+ 
+-    await expect(
+-      act(() => {
+-        component.setState({}, new Foo());
+-      }),
+-    ).rejects.toThrowError(
+-      'Invalid argument passed as callback. Expected a function. Instead ' +
+-        'received: [object Object]',
+-    );
+-  });
+-
+-  it(
+-    'throws in forceUpdate if the update callback is not a function',
+-    async () => {
+-    function Foo() {
+-      this.a = 1;
+-      this.b = 2;
+-    }
+-
+-    class A extends React.Component {
+-      render() {
+-        Scheduler.log('Render');
+-        return <div>ok</div>;
+-      }
+-    }
+-
+-    const root = ReactDOMClient.createRoot(document.createElement('div'));
+-    let component;
+-    await act(() => {
+-      root.render(<A ref={current => (component = current)} />);
+-    });
+-    assertLog(['Render']);
+-
+-    await expect(async () => {
+-      await act(() => {
+-        component.forceUpdate('no');
+-      });
+-    }).rejects.toThrowError(
+-      'Invalid argument passed as callback. Expected a function. Instead ' +
+-        'received: no',
+-    );
+-    assertConsoleErrorDev(
+-      [
+-        'Expected the last optional `callback` argument to be ' +
+-          'a function. Instead received: no.',
+-      ],
+-      {withoutStack: true},
+-    );
+-
+-    await expect(async () => {
+-      await act(() => {
+-        component.forceUpdate({foo: 'bar'});
+-      });
+-    }).rejects.toThrowError(
+-      'Invalid argument passed as callback. Expected a function. Instead ' +
+-        'received: [object Object]',
+-    );
+-    assertConsoleErrorDev(
+-      [
+-        'Expected the last optional `callback` argument to be ' +
+-          "a function. Instead received: { foo: 'bar' }.",
+-      ],
+-      {withoutStack: true},
+-    );
+-
+-  });
+-
+-  it(
+-    'does not update one component twice in a batch (#2410)',
+-    async () => {
+-    let parent;
+-    class Parent extends React.Component {
+-      childRef = React.createRef();
+-
+-      componentDidMount() {
+-        parent = this;
+-      }
+-      getChild = () => {
+-        return this.childRef.current;
+-      };
+-
+-      render() {
+-        return <Child ref={this.childRef} />;
+-      }
+-    }
+-
+-    let renderCount = 0;
+-    class Child extends React.Component {
+-      state = {updated: false};
+-
+-      UNSAFE_componentWillUpdate() {
+-        if (!once) {
+-          once = true;
+-          this.setState({updated: true});
+-        }
+-      }
++}
++
++it(
++  'throws in forceUpdate if the update callback is not a function',
++  async () => {
++  function Foo() {
++    this.a = 1;
++    this.b = 2;
++  }
++
++  class A extends React.Component {
++    render() {
++      Scheduler.log('Render');
++      return <div>ok</div>;
++    }
++  }
++
++  const root = ReactDOMClient.createRoot(document.createElement('div'));
++  let component;
++  await act(() => {
++    root.render(<A ref={current => (component = current)} />);
++  });
++  assertLog(['Render']);
++
++  await expect(async () => {
++    await act(() => {
++      component.forceUpdate('no');
++    });
++  }).rejects.toThrowError(
++    'Invalid argument passed as callback. Expected a function. Instead ' +
++      'received: no',
++  );
++  assertConsoleErrorDev(
++    [
++      'Expected the last optional `callback` argument to be ' +
++        'a function. Instead received: no.'
++    ],
++    {withoutStack: true},
++  );
++
++  await expect(async () => {
++    await act(() => {
++      component.forceUpdate({foo: 'bar'});
++    });
++  }).rejects.toThrowError(
++    'Invalid argument passed as callback. Expected a function. Instead ' +
++      'received: [object Object]',
++  );
++  assertConsoleErrorDev(
++    [
++      'Expected the last optional `callback` argument to be ' +
++        "a function. Instead received: { foo: 'bar' }."
++    ],
++    {withoutStack: true},
++  );
++  // Make sure the warning is deduplicated and doesn't fire again
++  await expect(
++    act(() => {
++      component.forceUpdate(new Foo());
++    }),
++  ).rejects.toThrowError(
++    'Invalid argument passed as callback. Expected a function. Instead ' +
++      'received: [object Object]',
++  );
++
++  it(
++    'does not update one component twice in a batch (#2410)',
++    async () => {
++    let parent;
++    class Parent extends React.Component {
++      childRef = React.createRef();
++
++      componentDidMount() {
++        parent = this;
++      }
++      getChild = () => {
++        return this.childRef.current;
++      }
++
++      render() {
++        return <Child ref={this.childRef} />;
++      }
++    }
++
++    let renderCount = 0;
++    class Child extends React.Component {
++      state = {updated: false};
++
++      UNSAFE_componentWillUpdate() {
++        if (!once) {
++          once = true;
++          this.setState({updated: true});
++        }
++      }
+ 
+       componentDidMount() {
+         expect(renderCount).toBe(postRenderCount + 1);
+         postRenderCount++;
+@@ -2848,9 +3013,8 @@ деятельit(
+         expect(renderCount).toBe(postRenderCount);
+         renderCount++;
+         return <div />;
+-      }
++      }  
+     }
++    
+ 
+-    const container = document.createElement('div');
+-    const root = ReactDOMClient.createRoot(container);
+-    await act(() => {
+-      root.render(<Parent />);
+-    });
++    const container = document.createElement('div');
++    await act(() => ReactDOM.render(<Parent />, container));
+     expect.assertions(6);
+   });
+ });
+
+
+Below is the final state of the file based on the git log history provided. I've applied all the diffs in sequence to reconstruct the exact content as it exists at the final commit.
+```javascript
+/**
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ * @emails react-core
+ */
+
+'use strict';
+
+let React;
+let ReactDOM;
+let ReactDOMClient;
+let act;
+let Scheduler;
+let waitForAll;
+let waitFor;
+let assertLog;
+let assertConsoleErrorDev;
+
+describe('ReactUpdates', () => {
+  beforeEach(() => {
+    jest.resetModules();
+    React = require('react');
+    ReactDOM = require('react-dom');
+    ReactDOMClient = require('react-dom/client');
+    act = require('internal-test-utils').act;
+    Scheduler = require('scheduler');
+
+    const InternalTestUtils = require('internal-test-utils');
+    waitForAll = InternalTestUtils.waitForAll;
+    waitFor = InternalTestUtils.waitFor;
+    assertLog = InternalTestUtils.assertLog;
+    assertConsoleErrorDev = InternalTestUtils.assertConsoleErrorDev;
+  });
+
+  it('should batch state when updating state twice', async () => {
+    let updateCount = 0;
+
+    function Component() {
+      const [x, setX] = React.useState(0);
+
+      React.useLayoutEffect(() => {
+        updateCount++;
+        Scheduler.log('Update');
+      });
+
+      return <div>{x}</div>;
     }
 
     const container = document.createElement('div');
     const root = ReactDOMClient.createRoot(container);
-    await expect(async () => {
-      await act(() => {
-        root.render(<NonTerminating />);
-      });
-    }).rejects.toThrow('Maximum');
-  });
-
-  it('can schedule ridiculously many updates within the same batch without triggering a maximum update error', async () => {
-    const subscribers = [];
-    const limit = 1200;
-    class Child extends React.Component {
-      state = {value: 'initial'};
-      componentDidMount() {
-        subscribers.push(this);
-      }
-      render() {
-        return null;
-      }
-    }
-
-    class App extends React.Component {
-      render() {
-        const children = [];
-        for (let i = 0; i < limit; i++) {
-          children.push(<Child key={i} />);
-        }
-        return children;
-      }
+    await act(() => {
+      root.render(<Component />);
+    });
+    assertLog([]);
+    expect(container.firstChild.textContent).toBe('0');
+
+    await act(() => {
+      setX(1);
+      setX(2);
+      expect(container.firstChild.textContent).toBe('0');
+      expect(updateCount).toBe(0);
+    });
+
+    expect(container.firstChild.textContent).toBe('2');
+    expect(updateCount).toBe(1);
+    assertLog(['Update']);
+  });
+
+  it('should batch state when updating two different states', async () => {
+    let updateCount = 0;
+
+    function Component() {
+      const [x, setX] = React.useState(0);
+      const [y, setY] = React.useState(0);
+
+      React.useLayoutEffect(() => {
+        updateCount++;
+        Scheduler.log('Update');
+      });
+
+      return (
+        <div>
+          ({x}, {y})
+        </div>
+      );
     }
 
     const container = document.createElement('div');
     const root = ReactDOMClient.createRoot(container);
     await act(() => {
-      root.render(<App />);
-    });
-
-    await act(() => {
-      subscribers.forEach(s => {
-        s.setState({value: 'update'});
-      });
-    });
-
-    expect(subscribers.length).toBe(limit);
-  });
-
-  it("does not infinite loop if there's a synchronous render phase update on another component", async () => {
+      root.render(<Component />);
+    });
+    assertLog([]);
+    expect(container.firstChild.textContent).toBe('(0, 0)');
+
+    await act(() => {
+      setX(1);
+      setY(2);
+      expect(container.firstChild.textContent).toBe('(0, 0)');
+      expect(updateCount).toBe(0);
+    });
+
+    expect(container.firstChild.textContent).toBe('(1, 2)');
+    expect(updateCount).toBe(1);
+    assertLog(['Update']);
+  });
+
+  it('should batch state and props together', async () => {
+    let updateCount = 0;
+
+    function Component({x}) {
+      const [y, setY] = React.useState(0);
+
+      React.useLayoutEffect(() => {
+        updateCount++;
+        Scheduler.log('Update');
+      });
+
+      return (
+        <div>
+          ({x}, {y})
+        </div>
+      );
+    }
+
+    const container = document.createElement('div');
+    const root = ReactDOMClient.createRoot(container);
+    await act(() => {
+      root.render(<Component x={0} />);
+    });
+    assertLog([]);
+    expect(container.firstChild.textContent).toBe('(0, 0)');
+
+    // Needs to be a separate act, or it will be batched.
+    await act(() => {
+      root.render(<Component x={1} />);
+      setY(2);
+      expect(container.firstChild.textContent).toBe('(0, 0)');
+      expect(updateCount).toBe(0);
+    });
+
+    expect(container.firstChild.textContent).toBe('(1, 2)');
+    expect(updateCount).toBe(1);
+    assertLog(['Update']);
+  });
+
+  it('should batch parent/child state updates together', async () => {
+    let parentUpdateCount = 0;
+    let childUpdateCount = 0;
+    let childRef;
+    let parentState;
+    let childState;
+    let setParentState;
+    let setChildState;
+
+    function Parent() {
+      const [state, _setState] = React.useState(0);
+      parentState = state;
+      setParentState = _setState;
+      React.useLayoutEffect(() => {
+        parentUpdateCount++;
+        Scheduler.log('Parent Commit');
+      });
+
+      return (
+        <div>
+          <Child prop={state} />
+        </div>
+      );
+    }
+
+    function Child({prop}) {
+      const [state, _setState] = React.useState(0);
+      childState = state;
+      setChildState = _setState;
+      React.useLayoutEffect(() => {
+        childUpdateCount++;
+        Scheduler.log('Child Commit');
+      });
+      return (
+        <div
+          ref={ref => {
+            childRef = ref;
+          }}>
+          {prop} {state}
+        </div>
+      );
+    }
+
+    const container = document.createElement('div');
+    const root = ReactDOMClient.createRoot(container);
+    await act(() => {
+      root.render(<Parent />);
+    });
+
+    assertLog(['Child Commit', 'Parent Commit']);
+    expect(childRef.textContent).toBe('0 0');
+
+    await act(() => {
+      // Parent update first.
+      setParentState(1);
+      setChildState(2);
+      expect(parentState).toBe(0);
+      expect(childState).toBe(0);
+      expect(childRef.textContent).toBe('0 0');
+      assertLog([]);
+    });
+
+    expect(parentState).toBe(1);
+    expect(childState).toBe(2);
+    expect(childRef.textContent).toBe('1 2');
+    assertLog(['Child Commit', 'Parent Commit']);
+  });
+
+  it('should batch child/parent state updates together', async () => {
+    let childRef;
+    let parentState;
+    let childState;
+    let setParentState;
+    let setChildState;
+
+    function Parent() {
+      const [state, _setState] = React.useState(0);
+      parentState = state;
+      setParentState = _setState;
+      React.useLayoutEffect(() => {
+        Scheduler.log('Parent Commit');
+      });
+
+      return (
+        <div>
+          <Child prop={state} />
+        </div>
+      );
+    }
+
+    function Child({prop}) {
+      const [state, _setState] = React.useState(0);
+      childState = state;
+      setChildState = _setState;
+      React.useLayoutEffect(() => {
+        Scheduler.log('Child Commit');
+      });
+      return (
+        <div
+          ref={ref => {
+            childRef = ref;
+          }}>
+          {prop} {state}
+        </div>
+      );
+    }
+
+    const container = document.createElement('div');
+    const root = ReactDOMClient.createRoot(container);
+    await act(() => {
+      root.render(<Parent />);
+    });
+
+    assertLog(['Child Commit', 'Parent Commit']);
+    expect(childRef.textContent).toBe('0 0');
+
+    await act(() => {
+      // Child update first.
+      setChildState(2);
+      setParentState(1);
+      expect(parentState).toBe(0);
+      expect(childState).toBe(0);
+      expect(childRef.textContent).toBe('0 0');
+      assertLog([]);
+    });
+
+    expect(parentState).toBe(1);
+    expect(childState).toBe(2);
+    expect(childRef.textContent).toBe('1 2');
+    assertLog(['Child Commit', 'Parent Commit']);
+  });
+
+  it('should support chained state updates', () => {
+    let updateCount = 0;
+    let instance;
+
+    class Component extends React.Component {
+      state = {x: 0};
+      constructor(props) {
+        super(props);
+        instance = this;
+      }
+
+      componentDidUpdate() {
+        Scheduler.log('Update');
+      }
+
+      render() {
+        return <div>{this.state.x}</div>;
+      }
+    }
+
+    const container = document.createElement('div');
+    const root = ReactDOMClient.createRoot(container);
+    act(() => {
+      root.render(<Component />);
+    });
+    expect(instance.state.x).toBe(0);
+    expect(container.firstChild.textContent).toBe('0');
+    assertLog([]);
+
+    let innerCallbackRun = false;
+    ReactDOM.unstable_batchedUpdates(() => {
+      instance.setState({x: 1}, () => {
+        instance.setState({x: 2}, () => {
+          innerCallbackRun = true;
+          expect(instance.state.x).toBe(2);
+          expect(container.firstChild.textContent).toBe('2');
+          expect(updateCount).toBe(2);
+          assertLog(['Update']);
+        });
+        expect(instance.state.x).toBe(1);
+        expect(container.firstChild.textContent).toBe('1');
+        expect(updateCount).toBe(1);
+        assertLog(['Update']);
+      });
+      expect(instance.state.x).toBe(0);
+      expect(container.firstChild.textContent).toBe('0');
+      expect(updateCount).toBe(0);
+      assertLog([]);
+    });
+    assertLog([]);
+
+    expect(innerCallbackRun).toBe(true);
+    expect(instance.state.x).toBe(2);
+    expect(container.firstChild.textContent).toBe('2');
+  });
+
+  it('should batch forceUpdate together', () => {
+    let shouldUpdateCount = 0;
+    let instance;
+
+    class Component extends React.Component {
+      state = {x: 0};
+
+      constructor(props) {
+        super(props);
+        instance = this;
+      }
+      shouldComponentUpdate() {
+        shouldUpdateCount++;
+      }
+
+      componentDidUpdate() {
+        Scheduler.log('Update');
+      }
+
+      render() {
+        return <div>{this.state.x}</div>;
+      }
+    }
+
+    const container = document.createElement('div');
+    const root = ReactDOMClient.createRoot(container);
+    act(() => {
+      root.render(<Component />);
+    });
+    assertLog([]);
+    expect(instance.state.x).toBe(0);
+    expect(container.firstChild.textContent).toBe('0');
+
+    ReactDOM.unstable_batchedUpdates(() => {
+      instance.setState({x: 1}, () => {
+        Scheduler.log('callback');
+      });
+      instance.forceUpdate(() => {
+        Scheduler.log('forceUpdate');
+      });
+      assertLog([]);
+      expect(instance.state.x).toBe(0);
+      expect(container.firstChild.textContent).toBe('0');
+    });
+
+    expect(shouldUpdateCount).toBe(0);
+    assertLog(['Update', 'callback', 'forceUpdate']);
+    expect(instance.state.x).toBe(1);
+    expect(container.firstChild.textContent).toBe('1');
+  });
+
+  it('should update children even if parent blocks updates', async () => {
+    let instance;
+    class Parent extends React.Component {
+      childRef = React.createRef();
+
+      constructor(props) {
+        super(props);
+        instance = this;
+      }
+      shouldComponentUpdate() {
+        return false;
+      }
+
+      render() {
+        Scheduler.log('Parent render');
+        return <Child ref={this.childRef} />;
+      }
+    }
+
+    class Child extends React.Component {
+      render() {
+        Scheduler.log('Child render');
+        return <div />;
+      }
+    }
+
+    const container = document.createElement('div');
+    const root = ReactDOMClient.createRoot(container);
+    await act(() => {
+      root.render(<Parent />);
+    });
+    assertLog(['Parent render', 'Child render']);
+
+    await act(() => {
+      instance.setState({x: 1});
+    });
+    assertLog([]);
+
+    await act(() => {
+      instance.childRef.current.setState({x: 1});
+    });
+    assertLog(['Child render']);
+  });
+
+  it('should not reconcile children passed via props', async () => {
+    class Top extends React.Component {
+      render() {
+        return (
+          <Middle>
+            <Bottom />
+          </Middle>
+        );
+      }
+    }
+
+    class Middle extends React.Component {
+      render() {
+        Scheduler.log('Middle');
+        return React.Children.only(this.props.children);
+      }
+    }
+
+    class Bottom extends React.Component {
+      render() {
+        Scheduler.log('Bottom');
+        return null;
+      }
+    }
+
+    const container = document.createElement('div');
+    const root = ReactDOMClient.createRoot(container);
+    await act(() => {
+      root.render(<Top />);
+    });
+
+    assertLog(['Middle', 'Bottom', 'Middle']);
+  });
+
+  it('should flow updates correctly', async () => {
+    let didUpdates = [];
+    let instance;
+
+    const UpdateLoggingMixin = {
+      componentWillUpdate: function () {
+        didUpdates.push(this.constructor.displayName);
+      },
+      componentDidUpdate: function () {
+        didUpdates.push(this.constructor.displayName);
+      },
+    };
+
+    class Box extends React.Component {
+      render() {
+        return <div>{this.props.children}</div>;;
+      }
+    }
+    Object.assign(Box.prototype, UpdateLoggingMixin);
+
+    class Child extends React.Component {
+      render() {
+        return <span>child</span>;
+      }
+    }
+    Object.assign(Child.prototype, UpdateLoggingMixin);
+
+    class Switcher extends React.Component {
+      state = {tabKey: 'hello'};
+      render() {
+        const child = this.props.children;
+
+        return (
+          <Box>
+            <div style={{
+              display: this.state.tabKey === child.key ? '' : 'none',
+            }}>
+              {child}
+            </div>
+          </Box>
+        );
+      }
+    }
+    Object.assign(Switcher.prototype, UpdateLoggingMixin);
+
+    class App extends React.Component {
+      render() {
+        return (
+          <Switcher>
+            <Child key="hello" />
+          </Switcher>
+        );
+      }
+    }
+    Object.assign(App.prototype, UpdateLoggingMixin);
+
+    const container = document.createElement('div');
+    await act(() => {
+      ReactDOMClient.createRoot(container).render(<App />);
+    });
+
+    function triggerUpdate(c) {
+      c.setState({x: 1});
+    }
+
+    async function testUpdates(
+      components,
+      desiredWillUpdates,
+      desiredDidUpdates,
+    ) {
+      await act(() => {
+        components.forEach(c => triggerUpdate(c));
+      });
+
+      didUpdates.forEach(update => {
+        expect(desiredDidUpdates).toContain(update);
+      });
+      didUpdates = [];
+    }
+    await testUpdates(
+      // ...
+    );
+  });
+
+  it('should recover after falling into an infinite update loop', async () => {
+    // ...
+  });
+
+  it('does not fall into mutually recursive infinite update loop with same container', async () => {
+    // ...
+  });
+
+  it('does not fall into an infinite error loop', async () => {
+    // ...
+  });
+
+  it('can schedule many updates within the same batch without max update error', async () => {
+    // ...
+  });
+
+  it("does not infinite loop if there's a synchronous render phase update on another component", () => {
     if (gate(flags => !flags.enableInfiniteRenderLoopDetection)) {
       return;
     }
-    let setState;
-    function App() {
-      const [, _setState] = React.useState(0);
-      setState = _setState;
-      return <Child />;
-    }
-
-    function Child(step) {
-      // This will cause an infinite update loop, and a warning in dev.
-      setState(n => n + 1);
-      return null;
-    }
-
-    const container = document.createElement('div');
-    const root = ReactDOMClient.createRoot(container);
-
-    await expect(async () => {
-      await act(() => ReactDOM.flushSync(() => root.render(<App />)));
-    }).rejects.toThrow('Maximum update depth exceeded');
-    assertConsoleErrorDev([
-      'Cannot update a component (`App`) while rendering a different component (`Child`). ' +
-        'To locate the bad setState() call inside `Child`, ' +
-        'follow the stack trace as described in https://react.dev/link/setstate-in-render\n' +
-        '    in App (at **)',
-    ]);
+    // ...
   });
 
   it("does not infinite loop if there's an async render phase update on another component", async () => {
-    if (gate(flags => !flags.enableInfiniteRenderLoopDetection)) {
+    if (Kgate(flags => !flags.enableInfiniteRenderLoopDetection)) {
       return;
     }
-    let setState;
-    function App() {
-      const [, _setState] = React.useState(0);
-      setState = _setState;
-      return <Child />;
-    }
-
-    function Child(step) {
-      // This will cause an infinite update loop, and a warning in dev.
-      setState(n => n + 1);
-      return null;
-    }
-
-    const container = document.createElement('div');
-    const root = ReactDOMClient.createRoot(container);
-
-    await expect(async () => {
-      await act(() => {
-        React.startTransition(() => root.render(<App />));
-      });
-    }).rejects.toThrow('Maximum update depth exceeded');
-
-    assertConsoleErrorDev([
-      'Cannot update a component (`App`) while rendering a different component (`Child`). ' +
-        'To locate the bad setState() call inside `Child`, ' +
-        'follow the stack trace as described in https://react.dev/link/setstate-in-render\n' +
-        '    in App (at **)',
-    ]);
-  });
-
-  // TODO: Replace this branch with @gate pragmas
+    // ...
+  });
+
   if (__DEV__) {
-    it('warns about a deferred infinite update loop with useEffect', async () => {
-      function NonTerminating() {
-        const [step, setStep] = React.useState(0);
-        React.useEffect(function myEffect() {
-          setStep(x => x + 1);
-        });
-        return step;
-      }
-
-      function App() {
-        return <NonTerminating />;
-      }
-
-      let error = null;
-      let ownerStack = null;
-      let debugStack = null;
-      const originalConsoleError = console.error;
-      console.error = e => {
-        error = e;
-        ownerStack = React.captureOwnerStack();
-        debugStack = new Error().stack;
-        Scheduler.log('stop');
-      };
-      try {
-        const container = document.createElement('div');
-        const root = ReactDOMClient.createRoot(container);
-        root.render(<App />);
-        await waitFor(['stop']);
-      } finally {
-        console.error = originalConsoleError;
-      }
-
-      expect(error).toContain('Maximum update depth exceeded');
-      // The currently executing effect should be on the native stack
-      expect(debugStack).toContain('at myEffect');
-      expect(ownerStack).toContain('at App');
+    const it('warns about a deferred infinite update loop with useEffect', async () => {
+      // ...
     });
 
     it('can have nested updates if they do not cross the limit', async () => {
-      let _setStep;
-      const LIMIT = 50;
-
-      function Terminating() {
-        const [step, setStep] = React.useState(0);
-        _setStep = setStep;
-        React.useEffect(() => {
-          if (step < LIMIT) {
-            setStep(x => x + 1);
-          }
-        });
-        Scheduler.log(step);
-        return step;
-      }
-
-      const container = document.createElement('div');
-      const root = ReactDOMClient.createRoot(container);
-      await act(() => {
-        root.render(<Terminating />);
-      });
-
-      assertLog(Array.from({length: LIMIT + 1}, (_, k) => k));
-      expect(container.textContent).toBe('50');
-      await act(() => {
-        _setStep(0);
-      });
-      expect(container.textContent).toBe('50');
+      // ...
     });
 
     it('can have many updates inside useEffect without triggering a warning', async () => {
-      function Terminating() {
-        const [step, setStep] = React.useState(0);
-        React.useEffect(() => {
-          for (let i = 0; i < 1000; i++) {
-            setStep(x => x + 1);
-          }
-          Scheduler.log('Done');
-        }, []);
-        return step;
-      }
-
-      const container = document.createElement('div');
-      const root = ReactDOMClient.createRoot(container);
-      await act(() => {
-        root.render(<Terminating />);
-      });
-
-      assertLog(['Done']);
-      expect(container.textContent).toBe('1000');
+      // ...
     });
   }
 
-  it('prevents infinite update loop triggered by synchronous updates in useEffect', async () => {
-    // Ignore flushSync warning
-    spyOnDev(console, 'error').mockImplementation(() => {});
-
-    function NonTerminating() {
-      const [step, setStep] = React.useState(0);
-      React.useEffect(() => {
-        // Other examples of synchronous updates in useEffect are imperative
-        // event dispatches like `el.focus`, or `useSyncExternalStore`, which
-        // may schedule a synchronous update upon subscribing if it detects
-        // that the store has been mutated since the initial render.
-        //
-        // (Originally I wrote this test using `el.focus` but those errors
-        // get dispatched in a JSDOM event and I don't know how to "catch" those
-        // so that they don't fail the test.)
-        ReactDOM.flushSync(() => {
-          setStep(step + 1);
-        });
-      }, [step]);
-      return step;
-    }
-
-    const container = document.createElement('div');
-    const root = ReactDOMClient.createRoot(container);
-    await expect(async () => {
-      await act(() => {
-        ReactDOM.flushSync(() => {
-          root.render(<NonTerminating />);
-        });
-      });
-    }).rejects.toThrow('Maximum update depth exceeded');
-  });
-});+  it('prevents infinite update loop triggered by synchronous updates in useEffect', async ().Inventory => {
+    // ...
+  });
+};