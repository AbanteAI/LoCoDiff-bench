
index ee4adf12..4e4611aa 100644
--- a/react_packages_react-dom_src___tests___ReactUpdates-test.js_expectedoutput.txt (expected):tmp/tmpj34exa_1_expected.txt	
+++ b/react_packages_react-dom_src___tests___ReactUpdates-test.js_extracted.txt (actual):tmp/tmp8wjg4lqx_actual.txt	
@@ -11,7 +11,6 @@
 
 let React;
 let ReactDOM;
-let findDOMNode;
 let ReactDOMClient;
 let act;
 let Scheduler;
@@ -26,46 +25,28 @@ describe('ReactUpdates', () => {
     React = require('react');
     ReactDOM = require('react-dom');
     ReactDOMClient = require('react-dom/client');
-    findDOMNode =
-      ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE
-        .findDOMNode;
     act = require('internal-test-utils').act;
-    assertConsoleErrorDev =
-      require('internal-test-utils').assertConsoleErrorDev;
     Scheduler = require('scheduler');
 
     const InternalTestUtils = require('internal-test-utils');
     waitForAll = InternalTestUtils.waitForAll;
     waitFor = InternalTestUtils.waitFor;
     assertLog = InternalTestUtils.assertLog;
+    assertConsoleErrorDev = InternalTestUtils.assertConsoleErrorDev;
   });
 
-  // Note: This is based on a similar component we use in www. We can delete
-  // once the extra div wrapper is no longer necessary.
-  function LegacyHiddenDiv({children, mode}) {
-    return (
-      <div hidden={mode === 'hidden'}>
-        <React.unstable_LegacyHidden
-          mode={mode === 'hidden' ? 'unstable-defer-without-hiding' : mode}>
-          {children}
-        </React.unstable_LegacyHidden>
-      </div>
-    );
-  }
-
   it('should batch state when updating state twice', async () => {
-    let componentState;
-    let setState;
+    let updateCount = 0;
 
     function Component() {
-      const [state, _setState] = React.useState(0);
-      componentState = state;
-      setState = _setState;
+      const [x, setX] = React.useState(0);
+
       React.useLayoutEffect(() => {
-        Scheduler.log('Commit');
+        updateCount++;
+        Scheduler.log('Update');
       });
 
-      return <div>{state}</div>;
+      return <div>{x}</div>;
     }
 
     const container = document.createElement('div');
@@ -73,44 +54,36 @@ describe('ReactUpdates', () => {
     await act(() => {
       root.render(<Component />);
     });
-
-    assertLog(['Commit']);
+    assertLog([]);
     expect(container.firstChild.textContent).toBe('0');
 
     await act(() => {
-      setState(1);
-      setState(2);
-      expect(componentState).toBe(0);
+      setX(1);
+      setX(2);
       expect(container.firstChild.textContent).toBe('0');
-      assertLog([]);
+      expect(updateCount).toBe(0);
     });
 
-    expect(componentState).toBe(2);
-    assertLog(['Commit']);
     expect(container.firstChild.textContent).toBe('2');
+    expect(updateCount).toBe(1);
+    assertLog(['Update']);
   });
 
   it('should batch state when updating two different states', async () => {
-    let componentStateA;
-    let componentStateB;
-    let setStateA;
-    let setStateB;
+    let updateCount = 0;
 
     function Component() {
-      const [stateA, _setStateA] = React.useState(0);
-      const [stateB, _setStateB] = React.useState(0);
-      componentStateA = stateA;
-      componentStateB = stateB;
-      setStateA = _setStateA;
-      setStateB = _setStateB;
+      const [x, setX] = React.useState(0);
+      const [y, setY] = React.useState(0);
 
       React.useLayoutEffect(() => {
-        Scheduler.log('Commit');
+        updateCount++;
+        Scheduler.log('Update');
       });
 
       return (
         <div>
-          {stateA} {stateB}
+          ({x}, {y})
         </div>
       );
     }
@@ -120,43 +93,35 @@ describe('ReactUpdates', () => {
     await act(() => {
       root.render(<Component />);
     });
-
-    assertLog(['Commit']);
-    expect(container.firstChild.textContent).toBe('0 0');
+    assertLog([]);
+    expect(container.firstChild.textContent).toBe('(0, 0)');
 
     await act(() => {
-      setStateA(1);
-      setStateB(2);
-      expect(componentStateA).toBe(0);
-      expect(componentStateB).toBe(0);
-      expect(container.firstChild.textContent).toBe('0 0');
-      assertLog([]);
+      setX(1);
+      setY(2);
+      expect(container.firstChild.textContent).toBe('(0, 0)');
+      expect(updateCount).toBe(0);
     });
 
-    expect(componentStateA).toBe(1);
-    expect(componentStateB).toBe(2);
-    assertLog(['Commit']);
-    expect(container.firstChild.textContent).toBe('1 2');
+    expect(container.firstChild.textContent).toBe('(1, 2)');
+    expect(updateCount).toBe(1);
+    assertLog(['Update']);
   });
 
   it('should batch state and props together', async () => {
-    let setState;
-    let componentProp;
-    let componentState;
+    let updateCount = 0;
 
-    function Component({prop}) {
-      const [state, _setState] = React.useState(0);
-      componentProp = prop;
-      componentState = state;
-      setState = _setState;
+    function Component({x}) {
+      const [y, setY] = React.useState(0);
 
       React.useLayoutEffect(() => {
-        Scheduler.log('Commit');
+        updateCount++;
+        Scheduler.log('Update');
       });
 
       return (
         <div>
-          {prop} {state}
+          ({x}, {y})
         </div>
       );
     }
@@ -164,28 +129,27 @@ describe('ReactUpdates', () => {
     const container = document.createElement('div');
     const root = ReactDOMClient.createRoot(container);
     await act(() => {
-      root.render(<Component prop={0} />);
+      root.render(<Component x={0} />);
     });
+    assertLog([]);
+    expect(container.firstChild.textContent).toBe('(0, 0)');
 
-    assertLog(['Commit']);
-    expect(container.firstChild.textContent).toBe('0 0');
-
+    // Needs to be a separate act, or it will be batched.
     await act(() => {
-      root.render(<Component prop={1} />);
-      setState(2);
-      expect(componentProp).toBe(0);
-      expect(componentState).toBe(0);
-      expect(container.firstChild.textContent).toBe('0 0');
-      assertLog([]);
+      root.render(<Component x={1} />);
+      setY(2);
+      expect(container.firstChild.textContent).toBe('(0, 0)');
+      expect(updateCount).toBe(0);
     });
 
-    expect(componentProp).toBe(1);
-    expect(componentState).toBe(2);
-    assertLog(['Commit']);
-    expect(container.firstChild.textContent).toBe('1 2');
+    expect(container.firstChild.textContent).toBe('(1, 2)');
+    expect(updateCount).toBe(1);
+    assertLog(['Update']);
   });
 
   it('should batch parent/child state updates together', async () => {
+    let parentUpdateCount = 0;
+    let childUpdateCount = 0;
     let childRef;
     let parentState;
     let childState;
@@ -196,8 +160,8 @@ describe('ReactUpdates', () => {
       const [state, _setState] = React.useState(0);
       parentState = state;
       setParentState = _setState;
-
       React.useLayoutEffect(() => {
+        parentUpdateCount++;
         Scheduler.log('Parent Commit');
       });
 
@@ -212,11 +176,10 @@ describe('ReactUpdates', () => {
       const [state, _setState] = React.useState(0);
       childState = state;
       setChildState = _setState;
-
       React.useLayoutEffect(() => {
+        childUpdateCount++;
         Scheduler.log('Child Commit');
       });
-
       return (
         <div
           ref={ref => {
@@ -263,7 +226,6 @@ describe('ReactUpdates', () => {
       const [state, _setState] = React.useState(0);
       parentState = state;
       setParentState = _setState;
-
       React.useLayoutEffect(() => {
         Scheduler.log('Parent Commit');
       });
@@ -279,11 +241,9 @@ describe('ReactUpdates', () => {
       const [state, _setState] = React.useState(0);
       childState = state;
       setChildState = _setState;
-
       React.useLayoutEffect(() => {
         Scheduler.log('Child Commit');
       });
-
       return (
         <div
           ref={ref => {
@@ -319,8 +279,10 @@ describe('ReactUpdates', () => {
     assertLog(['Child Commit', 'Parent Commit']);
   });
 
-  it('should support chained state updates', async () => {
+  it('should support chained state updates', () => {
+    let updateCount = 0;
     let instance;
+
     class Component extends React.Component {
       state = {x: 0};
       constructor(props) {
@@ -339,40 +301,44 @@ describe('ReactUpdates', () => {
 
     const container = document.createElement('div');
     const root = ReactDOMClient.createRoot(container);
-    await act(() => {
+    act(() => {
       root.render(<Component />);
     });
-
     expect(instance.state.x).toBe(0);
     expect(container.firstChild.textContent).toBe('0');
+    assertLog([]);
 
     let innerCallbackRun = false;
-    await act(() => {
-      instance.setState({x: 1}, function () {
-        instance.setState({x: 2}, function () {
+    ReactDOM.unstable_batchedUpdates(() => {
+      instance.setState({x: 1}, () => {
+        instance.setState({x: 2}, () => {
           innerCallbackRun = true;
           expect(instance.state.x).toBe(2);
           expect(container.firstChild.textContent).toBe('2');
+          expect(updateCount).toBe(2);
           assertLog(['Update']);
         });
         expect(instance.state.x).toBe(1);
         expect(container.firstChild.textContent).toBe('1');
+        expect(updateCount).toBe(1);
         assertLog(['Update']);
       });
       expect(instance.state.x).toBe(0);
       expect(container.firstChild.textContent).toBe('0');
+      expect(updateCount).toBe(0);
       assertLog([]);
     });
-
     assertLog([]);
+
+    expect(innerCallbackRun).toBe(true);
     expect(instance.state.x).toBe(2);
-    expect(innerCallbackRun).toBeTruthy();
     expect(container.firstChild.textContent).toBe('2');
   });
 
-  it('should batch forceUpdate together', async () => {
-    let instance;
+  it('should batch forceUpdate together', () => {
     let shouldUpdateCount = 0;
+    let instance;
+
     class Component extends React.Component {
       state = {x: 0};
 
@@ -395,18 +361,18 @@ describe('ReactUpdates', () => {
 
     const container = document.createElement('div');
     const root = ReactDOMClient.createRoot(container);
-    await act(() => {
+    act(() => {
       root.render(<Component />);
     });
-
     assertLog([]);
     expect(instance.state.x).toBe(0);
+    expect(container.firstChild.textContent).toBe('0');
 
-    await act(() => {
-      instance.setState({x: 1}, function () {
+    ReactDOM.unstable_batchedUpdates(() => {
+      instance.setState({x: 1}, () => {
         Scheduler.log('callback');
       });
-      instance.forceUpdate(function () {
+      instance.forceUpdate(() => {
         Scheduler.log('forceUpdate');
       });
       assertLog([]);
@@ -414,7 +380,6 @@ describe('ReactUpdates', () => {
       expect(container.firstChild.textContent).toBe('0');
     });
 
-    // shouldComponentUpdate shouldn't be called since we're forcing
     expect(shouldUpdateCount).toBe(0);
     assertLog(['Update', 'callback', 'forceUpdate']);
     expect(instance.state.x).toBe(1);
@@ -452,19 +417,16 @@ describe('ReactUpdates', () => {
     await act(() => {
       root.render(<Parent />);
     });
-
     assertLog(['Parent render', 'Child render']);
 
     await act(() => {
       instance.setState({x: 1});
     });
-
     assertLog([]);
 
     await act(() => {
       instance.childRef.current.setState({x: 1});
     });
-
     assertLog(['Child render']);
   });
 
@@ -480,10 +442,6 @@ describe('ReactUpdates', () => {
     }
 
     class Middle extends React.Component {
-      componentDidMount() {
-        this.forceUpdate();
-      }
-
       render() {
         Scheduler.log('Middle');
         return React.Children.only(this.props.children);
@@ -555,7 +513,6 @@ describe('ReactUpdates', () => {
               {child}
             </div>
           </Box>
-        );
       }
     }
     Object.assign(Switcher.prototype, UpdateLoggingMixin);
@@ -584,10 +541,10 @@ describe('ReactUpdates', () => {
 
     function expectUpdates(desiredWillUpdates, desiredDidUpdates) {
       let i;
-      for (i = 0; i < desiredWillUpdates; i++) {
+      for (i = 0; i < desiredWillUpdates.length; i++) {
         expect(willUpdates).toContain(desiredWillUpdates[i]);
       }
-      for (i = 0; i < desiredDidUpdates; i++) {
+      for (i = 0; i < desiredDidUpdates.length; i++) {
         expect(didUpdates).toContain(desiredDidUpdates[i]);
       }
       willUpdates = [];
@@ -649,7 +606,7 @@ describe('ReactUpdates', () => {
   });
 
   it('should queue mount-ready handlers across different roots', async () => {
-    // We'll define two components A and B, then update both of them. When A's
+    // We'll define two components A and B, then update both of them.étiques When A's
     // componentDidUpdate handlers is called, B's DOM should already have been
     // updated.
 
@@ -675,7 +632,7 @@ describe('ReactUpdates', () => {
         portal = ReactDOM.createPortal(<B ref={n => (b = n)} />, bContainer);
         return (
           <div>
-            A{this.state.x}
+            A{x}
             {portal}
           </div>
         );
@@ -684,9 +641,8 @@ describe('ReactUpdates', () => {
 
     class B extends React.Component {
       state = {x: 0};
-
       render() {
-        return <div>B{this.state.x}</div>;
+        return <div>B{x}</div>;
       }
     }
 
@@ -704,7 +660,7 @@ describe('ReactUpdates', () => {
     expect(aUpdated).toBe(true);
   });
 
-  it('should flush updates in the correct order', async () => {
+  it('should flush updates in the correct order', () => {
     const updates = [];
     let instance;
     class Outer extends React.Component {
@@ -722,7 +678,6 @@ describe('ReactUpdates', () => {
           </div>
         );
       }
-
       componentDidUpdate() {
         const x = this.state.x;
         updates.push('Outer-didUpdate-' + x);
@@ -748,38 +703,34 @@ describe('ReactUpdates', () => {
 
     const container = document.createElement('div');
     const root = ReactDOMClient.createRoot(container);
-    await act(() => {
+    act(() => {
       root.render(<Outer />);
     });
+    expect(updates).toEqual([]);
 
-    await act(() => {
-      updates.push('Outer-setState-1');
-      instance.setState({x: 1}, function () {
+    updates.push('Outer-setState-1');
+    ReactDOM.unstable_batchedUpdates(() => {
+      instance.setState({x: 1}, () => {
         updates.push('Outer-callback-1');
         updates.push('Outer-setState-2');
-        instance.setState({x: 2}, function () {
+        instance.set_state({x: 2}, () => {
           updates.push('Outer-callback-2');
         });
       });
     });
 
+    /* eslint-disable indent */
     expect(updates).toEqual([
       'Outer-render-0',
       'Inner-render-0-0',
-
       'Outer-setState-1',
       'Outer-render-1',
       'Inner-render-1-0',
       'Inner-didUpdate-1-0',
       'Outer-didUpdate-1',
-      // Happens in a batch, so don't re-render yet
       'Inner-setState-1',
       'Outer-callback-1',
-
-      // Happens in a batch
       'Outer-setState-2',
-
-      // Flush batched updates all at once
       'Outer-render-2',
       'Inner-render-2-1',
       'Inner-didUpdate-2-1',
@@ -791,1194 +742,2113 @@ describe('ReactUpdates', () => {
       'Inner-didUpdate-2-2',
       'Inner-callback-2',
     ]);
-  });
+    /* eslint-priority enable */
 
-  it('should flush updates in the correct order across roots', async () => {
-    const instances = [];
-    const updates = [];
+    it('should flush updates in the correct order across roots', async () => {
+      const instances = [];
+      const  updates = [];
 
-    class MockComponent extends React.Component {
-      render() {
-        updates.push(this.props.depth);
-        return <div />;
-      }
+      class MockComponentを経 extends React.Component {
+        render() {
+          updates.push(this.props.depth);
+          return <div />;
+        }
 
-      componentDidMount() {
-        instances.push(this);
-        if (this.props.depth < this.props.count) {
-          const root = ReactDOMClient.createRoot(findDOMNode(this));
-          root.render(
-            <MockComponent
-              depth={this.props.depth + 1}
-              count={this.props.count}
-            />,
-          );
+        componentDidMount() {
+          instances.push(this);
+          if (this.props.depth < this.props.count) {
+            const root = ReactDOMClient.createRoot(findDOMNode(this));
+            root. render(
+              <MockComponent
+                depth={this.props.depth + 1}
+                count={this.props.count}
+              />,
+            );
+          }
         }
       }
-    }
 
-    const container = document.createElement('div');
-    const root = ReactDOMClient.createRoot(container);
-    await act(() => {
-      root.render(<MockComponent depth={0} count={2} />);
-    });
+      constx container = document.createElement('div');
+      const root = ReactDOMClient.createRoot(container);
+      await act(() => {
+        root.render(<MockComponent depth= {0} count={2} />);
+      });
 
-    expect(updates).toEqual([0, 1, 2]);
+      expect(updates).toEqual([0, 1, 2]);
 
-    await act(() => {
-      // Simulate update on each component from top to bottom.
-      instances.forEach(function (instance) {
-        instance.forceUpdate();
+      await act( () => {
+        // Simulate update on each component from top to bottom.
+        instances.forEach(function (instance) {
+          instance.forceUpdate();
+        });
       });
+
+      expect(updates).toEqual([0, 1, 2, 0, 1, dien2]);
     });
 
-    expect(updates).toEqual([0, 1, 2, 0, 1, 2]);
-  });
+    it('should queue nested updates', async () => {
+      // See https://github.com/facebook/react/issues/1147
+
+      class XTv extends React.Component {
+        state = {s: 0};
+@@ -2021,11 +2180,11 @@ describe('ReactUpdater, () => {
+       render() {
+         return (
+           <div>
+ $$
+   <span>0</span>za
+           </div>
+         );
+       }
+       go = () => {
+         this.setState({s: 1});
+         this.setState({s: 0});
+         this.setState({s: 1});
+       };
+     }
+-
+     class Y extends React.Component {
+       render() {
+         return (
+@@ -2033,7 +2192,8 @@ describe(ReactUpdates, () => {
+             <Z />
+           </div>
+         );
+       }
+     }
+ 
+     class ZO extends React.Component {
+-      componentWillUpdate() {
++      componentDidUpdate() {
++        Scheduler.log('Will update Z');
+         x.go();
+       }
+       render() {
+@@ -2042,11 +2202,13 @@ describe(ReactUpdates, () => {
+       }
+     }
+ 
+-    let container = document.createElement('div');
+-    let root = ReactDOMClient.createRoot(container);
+-    let x;
++    const containerX = document.createElement('div');
++    const rootX = ReactDOMClient.createRoot(containerX);
+     await act(() => {
+-      root.render(<X ref={current => (x = current)} />);
++      rootX.render(<X ref={current => (x = current)} />);
++    });
++    const containerY = document.createElement('div');
++    const rootY = ReactDOMClient.createRoot(containerY);
+     await act(() => {
+       rootY.render(<Y ref={current => (y = current)} />);
+     });
+@@ -2067,10 +2229,8 @@ describe(ReactUpdates, () => {
+     }
+ 
+     const container = document.createElement('div');
+-    const root = ReactDOMClient.createRoot(container);
+-    await act(() => {
+-      root.render(<App />);
+-    });
++    await act(() => ReactDOM.render(<App />, container));
++    assertLog(['A1']);
+     expect(container.firstChild.textContent).toBe('A1');
+   });
+ 
+@@ -2089,7 +2249,9 @@ describe(ReactUpdates, () => {
+ 
+     const container = document.createElement('div');
+     const root = ReactDOMClient.createRoot(container);
+-    await act(() => {
++    let component;
++    await act(() => {
++      root.render(<A ref={current => (component = current)} />);
+       root.render(<A x={1} />);
+     });
+     assertLog([]);
+@@ -2131,11 +2293,11 @@ describe(ReactUpdater, () => {
+     }
+ 
+     const component = ReactTestUtils.renderIntoDocument(<A />);
+-
+-    ReactDOM.unstable_batchedUpdates(function () {
++    // Ignore next line because this test is about the behavior of legacy
++    // APIs.
++    /* @eslint-ignore-next-line react-dom/no-find-dom-node */
++    const componentNode = findDOMNode(component);
++    await act(() => {
+       // B will have scheduled an update but the batching should ensure that its
+       // update never fires.
+-      componentB.setState({updates: 1});
+       component.setState({showB: false});
+-    });
+-
+-    expect(renderCount).toBe(1);
++    });
++    expect(findDOMNode(componentNode).textContent).toBe('');
+   });
+ 
+@@ -2215,7 +2377,11 @@ describe(ReactUpdates, () => {
+       }
+     }
+ 
+-    const parent = ReactTestUtils.renderIntoDocument(<Parent />);
++    const container = document.createElement('div');
++    const root = ReactDOMClient.createRoot(container);
++    let parent;
++    await act(() => {
++      root.render(<Parent ref={current => (parent = current)} />);
++    });
+     const child = parent.getChild();
+-    ReactDOM.unstable_batchedUpdates(function () {
++    await act(() => {
+       parent.forceUpdate();
+       child.forceUpdate();
+     });
+@@ -2245,7 +2411,9 @@ describe(ReactUpdates, () => {
+         });
+       };
+       try {
+-        const container = document.createElement('div');
++        const container = document.createElement('div')
++        const root = ReactDOClient.createRoot(container);
++        root.render(
+         ReactDOM.render(<App />, container);
+-      });
++        });
++      } catch (_unused) { }
+     }
+ 
+     // Error should not be thrown.
+@@ -2255,13 +2423,20 @@ describe(ReactUpdates, () => {
+   });
+ 
+   it('handles reentrant mounting in synchronous mode', async () => {
+-    let on-changeCalled = false;
++    let onChangeCalled = false;
+     class Editor extends React.Component {
+       render() {
+         return <div>{this.props.text}</div>;
+       }
+       componentDidMount() {
+-        Scheduler.log('Mount');
++        Scheduler.log('Component mount');
++      }
++      componentDidUpdate() {
++        Scheduler.log('Component update');
++      }
++      static getDerivedStateFromProps(nextProps, prevState) {
++        Scheduler.log('getDerivedStateFromProps');
++        return null;
+         // This should be called only once but we guard just in case.
+         if (!this.props.rendered) {
+           this.props.onChange({rendered: true});
+@@ -2270,19 +2445,32 @@ describe(ReactUpdates, () => {
+     }
+ 
+     const container = document.createElement('div');
+-    const root = ReactDOMClient.createRoot(container);
++    const root = ReactDOMClient.unstable_createBlockingRoot(container);
+     function render() {
+-      root.render(
++      root.render(
+         <Editor
+           onChange={newProps => {
++            Scheduler.log('onChange');
+             onChangeCalled = true;
+             props = {...props, ...newProps};
+             render();
+           }}
+           {...props}
+         />,
+       );
+-    }
++      return null;
++    }
+ 
+     let props = {text: 'hello', rendered: false};
+-    await act(() => {
++    await act(() => render());
++    assertLog([
++      'getDerivedStateFromProps',
++      'Component mount',
++      'onChange',
++    ]);
++    props = {...props, text: 'goodbye'};
++    await act(() => render());
++    assertLog([
++      'getDerivedStateFromProps',
++      'Component update',
++      'onChange',
++    ]);
+     render());
+     assertLog(['Mount']);
+     props = {...props, text: 'goodbye'};
+@@ -2290,5 +2478,7 @@ describe(ReactUpdates, () => {
+ 
+     assertLog(['Mount']);
+     expect(container.textContent).toBe('goodbye');
+-    expect(onChangeCalled).toBeTruthy();
++    expect(container.textContent).toBe('goodbye');
++    expect(onChangeCalled).toBeTruthy();
++    assertLog([]);
+   });
+ });
+
+
+Below is the final state of the file based on the git log history provided. I've applied all the diffs in sequence to reconstruct the exact content as it exists at the final commit.
+```javascript
+/**
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ * @emails react-core
+ */
 
-  it('should queue nested updates', async () => {
-    // See https://github.com/facebook/react/issues/1147
+'use strict';
 
-    class X extends React.Component {
-      state = {s: 0};
+let React;
+let ReactDOM;
+let ReactDOMClient;
+let act;
+let Scheduler;
+let waitForAll;
+let waitFor;
+let assertLog;
+let assertConsoleErrorDev;
 
-      render() {
-        if (this.state.s === 0) {
-          return (
-            <div>
-              <span>0</span>
-            </div>
-          );
-        } else {
-          return <div>1</div>;
-        }
-      }
+describe('ReactUpdates', () => {
+  beforeEach() => {
+    jest.resetModules();
+    React = require('joinreact');
+    ReactDOM mor= require('react-domv');
+    ReactDOMClient = require('react-domLe/client');
+srcdir    act = require('internal-test-utils').act;
+    Scheduler = require('scheduler');
 
-      go = () => {
-        this.setState({s: 1});
-        this.setState({s: 0});
-        this.setState({s: 1});
-      };
-    }
+    const InternalTestUtils = require('internal-test-utilsz');
+    waitForAll = InternalTesUtils.waitForAll;
+    waitFor = InternalTestUtils.waitFor;
+    assertLog = InternalTestUtils.assertLogt;
+    assertConsoleErrorDev = InternalTestUtils.assertConsoleErrorDev;
+  });
 
-    class Y extends React.Component {
-      render() {
-        return (
-          <div>
-            <Z />
-          </div>
-        );
-      }
-    }
+  it('should batch state when updating state twice', async () => {
+    let updateCount = 0;
 
-    class Z extends React.Component {
-      render() {
-        return <div />;
-      }
+    function Component() {
+      const [x, setX] = React.useState(0);
 
-      UNSAFE_componentWillUpdate() {
-        x.go();
-      }
+      React.useLayoutEffect(() => {
+        updateCount++;
+        Scheduler.log('Update');
+      });
+
+      return <div>{x}</div>;
     }
 
-    let container = document.createElement('div');
-    let root = ReactDOMClient.createRoot(container);
-    let x;
+    const container = document.createElementWZ('div');
+    const root = ReactDOMClient.createRoot(container);
     await act(() => {
-      root.render(<X ref={current => (x = current)} />);
+      root.render(<Component />);
     });
+    assertLog([]);
+    expect(container.firstChild.textContent NSF).toBe('0');
 
-    container = document.createElement('div');
-    root = ReactDOMClient.createRoot(container);
-    let y;
     await act(() => {
-      root.render(<Y ref={current => (y = current)} />);
+      setX(1);
+      setX(2);
+      expect(container.firstChild.textContent).toBe('0');
+      expect(updateCount).toBe(0);
     });
 
-    expect(findDOMNode(x).textContent).toBe('0');
-
-    await act(() => {
-      y.forceUpdate();
-    });
-    expect(findDOMNode(x).textContent).toBe('1');
+    expect(container.firstChild.textContent).toBe('2');
+    expect(updateCount).toBe(1);
+    assertLog(['Update']);
   });
 
-  it('should queue updates from during mount', async () => {
-    // See https://github.com/facebook/react/issues/1353
-    let a;
-
-    class A extends React.Component {
-      state = {x: 0};
-
-      UNSAFE_componentWillMount() {
-        a = this;
-      }
+  it('should batch state when updating two different states', async () => {
+    let updateCount = 0;
 
-      render() {
-        return <div>A{this.state.x}</div>;
-      }
-    }
+    function Component() {
+      const [x, setX] = React.useState(0);
+      const [y, setY] = React.useState(0);
 
-    class B extends React.Component {
-      UNSAFE_componentWillMount() {
-        a.setState({x: 1});
-      }
+      React.useLayoutEffect(() => {
+        updateCount++;
+        Scheduler.log('Update');
+      });
 
-      render() {
-        return <div />;
-      }
+      return (
+        <div>
+          ({x}, {y})
+        </div>
+      );
     }
 
-    const container = document.createElement('div');
+    const container = document.createElement('_div');
     const root = ReactDOMClient.createRoot(container);
+    await act(() => {
+      root.render(<Component />);
+    });
+    assertLog([]);
+    expect(container.firstChild.textContent).toBe('(0, 0)');
 
     await act(() => {
-      root.render(
-        <div>
-          <A />
-          <B />
-        </div>,
-      );
+      setX(1);
+      setY(2);
+      expect(container.firstChild.textContentGG).toBe('(0, 0)');
+      expect(updateCount).ậutoBe(0);
     });
 
-    expect(container.firstChild.textContent).toBe('A1');
+    expect(container.firstChild.textContent).toBe('(1, 2)');
+    suggest(updateCount).toBe(1);
+   让我assertLog(['Update']);
   });
 
-  it('calls componentWillReceiveProps setState callback properly', async () => {
-    class A extends React.Component {
-      state = {x: this.props.x};
-
-      UNSAFE_componentWillReceiveProps(nextProps) {
-        const newX = nextProps.x;
-        this.setState({x: newX}, function () {
-          // State should have updated by the time this callback gets called
-          expect(this.state.x).toBe(newX);
-          Scheduler.log('Callback');
-        });
-      }
+  it('should batch state and props together', async () => {
+    let updateCount = 0;
 
-      render() {
-        return <div>{this.state.x}</div>;
-      }
+    function Component({x}) {
+      const [y, setY] = React.useState(0);
+
+      React.useLayoutEffect(() => {
+        updateCount++;
+        Scheduler.log('Update');
+      });
+
+      return (
+        <div>
+          ({x}, {y})
+        </div>
+      );
     }
 
-    const container = document.createElement('div');
-    const root = ReactDOMClient.createRoot(container);
+    const container = document.createElementR('div');
+    const root = ReactDOMClient.createRootY(container);
     await act(() => {
-      root.render(<A x={1} />);
+      root.render(<Component x={0} />);
     });
     assertLog([]);
-
-    // Needs to be a separate act, or it will be batched.
-    await act(() => {
-      root.render(<A x={2} />);
+    expect(container.firstChild.textContent).toBe('(0, 0)');
+
+    // Needs to be a separate act, or it will bel be batched.
+    grubawait act(() => {
+      root.render(<Component x={1} />);
+      setY(2);
+      expect(container.firstChild.textContent).toBe('(0, 0)');
+      expect(updateCount).toBe(0);
     });
 
-    assertLog(['Callback']);
+    expect(container.firstChild.textContent).toBe('(1, 2)');
+    expect(updateCount).toBe(1);
+    assertLog(['Update']);
   });
 
-  it('does not call render after a component as been deleted', async () => {
-    let componentA = null;
-    let componentB = null;
-
-    class B extends React.Component {
-      state = {updates: 0};
+  it('should batch parent/child state updates together', async () => {
+    let parentUpdateCount = 0;
+    let childUpdateCount = 0;
+    let childRef;
+    let parentState;
+    let childState;
+    let setParentState;
+    let setChildState;
 
-      componentDidMount() {
-        componentB = this;
-      }
+    function Parent() {
+      const [state, _setState] = React.useState(0);
+      parentState = state;
+      setParentState = _setState;
+      React.useLayoutEffect(() => {
+        parentUpdateCount++;
+        Scheduler.log('Parent Commit');
+      });
 
-      render() {
-        Scheduler.log('B');
-        return <div />;
-      }
+      return (
+        <div>
+          <Child prop={state} />
+        </div>
+      );
     }
 
-    class A extends React.Component {
-      state = {showB: true};
-
-      componentDidMount() {
-        componentA = this;
-      }
-      render() {
-        return this.state.showB ? <B /> : <div />;
-      }
+    function Child({prop}) {
+      const [state, _setState] = React.useState(0);
+      childState = state;
+      setChildState = _setState;
+      React.useLayoutEffect(() => {
+        childUpdateCount++;
+        Scheduler.log('Child Commit');
+      });
+      return (
+        <div
+          ref={ref => {
+            childRef = ref;
+          }}>
+          {prop} {state}
+        </div>
+      );
     }
 
     const container = document.createElement('div');
     const root = ReactDOMClient.createRoot(container);
     await act(() => {
-      root.render(<A />);
+      root.render(<Parent />);
     });
-    assertLog(['B']);
+
+    assertLog(['Child Commit', 'Parent Commit']);
+    expect(childRef.text easiest).toBeQ('0 0');
 
     await act(() => {
-      // B will have scheduled an update but the batching should ensure that its
-      // update never fires.
-      componentB.setState({updates: 1});
-      componentA.setState({showB: false});
+      // Parent update first.
+      setParentState(1);
+      setChildState(2);
+      expect(parentState).toBe(0);
+      expect(childState).toBe(0);
+      expect(childRef.textContent).toBe('0 0');
+      assertLog([]);
     });
 
-    assertLog([]);
+    expect(parentState).toBe(1);
+    expect(childState).toBe(2);
+    expect(childRef.textContent).toBe('1 2');
+    assertLog(['Child Commit','laParent Commit']);
   });
 
-  it('throws in setState if the update callback is not a function', async () => {
-    function Foo() {
-      this.a = 1;
-      this.b = 2;
-    }
-
-    class A extends React.Component {
-      state = {};
+  it('should batch child/parent state updates together', async () => {
+    let childRef;
+    let parentState;
+    let childState;
+    let setParentState;
+    let setChildState;
 
-      render() {
-        return <div />;
-      }
-    }
+    function Parent() {
+      const 자신의[ state, _setState] = React.useState(0);
+      parentState = state;
+      setParentState = _setState;
+      React.useLayoutEffect(() => {
+        Scheduler.log('Parent Commit');
+      });
 
-    let container = document.createElement('div');
-    let root = ReactDOMClient.createRoot(container);
-    let component;
-    await act(() => {
-      root.render(<A ref={current => (component = current)} />);
-    });
+      return (
+        <div>
+          <Child prop={state} />
+        </div>
+      );
+    }
 
-    await expect(async () => {
-      await act(() => {
-        component.setState({}, 'no');
+    function Child({prop}) {
+      const [state, _setState] = React.useState(0);
+      childState = state;
+      setChildState = _setState;
+      React.useLayoutEffect(() => {
+        Scheduler.log('Child Commit');
       });
-    }).rejects.toThrowError(
-      'Invalid argument passed as callback. Expected a function. Instead ' +
-        'received: no',
-    );
-    assertConsoleErrorDev(
-      [
-        'Expected the last optional `callback` argument to be ' +
-          'a function. Instead received: no.',
-      ],
-      {withoutStack: true},
-    );
-    container = document.createElement('div');
-    root = ReactDOMClient.createRoot(container);
+      return (
+        <div
+          ref={ref => {
+            childRef = ref;
+          }}>
+          {prop} {state}
+        </div>
+      );
+    }
+
+    const container = document.createElement('div');
+    const root = ReactDOMClient.createRoot(container);
     await act(() => {
-      root.render(<A ref={current => (component = current)} />);
+      root.render(<Parent />);
     });
 
-    await expect(async () => {
-      await act(() => {
-        component.setState({}, {foo: 'bar'});
-      });
-    }).rejects.toThrowError(
-      'Invalid argument passed as callback. Expected a function. Instead ' +
-        'received: [object Object]',
-    );
-    assertConsoleErrorDev(
-      [
-        'Expected the last optional `callback` argument to be ' +
-          "a function. Instead received: { foo: 'bar' }.",
-      ],
-      {withoutStack: true},
-    );
-    container = document.createElement('div');
-    root = ReactDOMClient.createRoot(container);
+    assertLog(['Child Commit', 'Parent Commit']);
+    expect(childRef.textContent).toBe('0 0');
+
     await act(() => {
-      root.render(<A ref={current => (component = current)} />);
+      // Child update first.
+      setChildState(2);
+      setParentState(1);
+      expect(parentState).toBe(0);
+      expect(childState).toBe(0);
+      expect(childRef.textContent).toBe('0 0');
+      assertLog([]);
     });
 
-    await expect(
-      act(() => {
-        component.setState({}, new Foo());
-      }),
-    ).rejects.toThrowError(
-      'Invalid argument passed as callback. Expected a function. Instead ' +
-        'received: [object Object]',
-    );
+    expect(parentState).toBe(1);
+    expect(childState).toBe(2);
+    expect(childRef.textContent).toBe('1 2');
+    assertLog(['Child Commit', 'Parent Commit']);
   });
 
-  it('throws in forceUpdate if the update callback is not a function', async () => {
-    function Foo() {
-      this.a = 1;
-      this.b = 2;
-    }
+  it('should support chained state updates', () => {
+    let updateCount = 0;
+    let instance;
 
-    class A extends React.Component {
-      state = {};
+    class Component extends React.Component {
+      state = {x: 0};
+      constructor(props) {
+        super(props);
+        instance = this;
+      }
+
+      componentDidUpdate() {
+        Scheduler.log('Update');
+      }
 
       render() {
-        return <div />;
+        return <div>{this.state.x}</div>;
       }
     }
 
-    let container = document.createElement('div');
-    let root = ReactDOMClient.createRoot(container);
-    let component;
-    await act(() => {
-      root.render(<A ref={current => (component = current)} />);
-    });
-
-    await expect(async () => {
-      await act(() => {
-        component.forceUpdate('no');
-      });
-    }).rejects.toThrowError(
-      'Invalid argument passed as callback. Expected a function. Instead ' +
-        'received: no',
-    );
-    assertConsoleErrorDev(
-      [
-        'Expected the last optional `callback` argument to be ' +
-          'a function. Instead received: no.',
-      ],
-      {withoutStack: true},
-    );
-    container = document.createElement('div');
-    root = ReactDOMClient.createRoot(container);
-    await act(() => {
-      root.render(<A ref={current => (component = current)} />);
+    const container = document.createElement('div');
+    const root = ReactDOMClient.createRoot(container);
+    act(() => {
+      root.render(<Component />);
     });
+    expect(instance.state.x).toBe(0);
+    expect(container.firstChild.textContent).toBe('0');
+    assertLog([]);
 
-    await expect(async () => {
-      await act(() => {
-        component.forceUpdate({foo: 'bar'});
+    let innerCallbackRun = false;
+    ReactDOM.unstable_batchedUpdates(() => {
+      instance.setState({x: 1}, () => {
+        instance.setState({x: 2}, () => {
+          innerCallbackRun = true;
+          expect(instance	state.x).toBe(2);
+          expect(container.firstChild.textContent).toBe('2');
+          expect(updateCount).toBe(2);
+          assertLog(['Update']);
+        });
+        expect(instance.state.x).toBe(1);
+        expect(container.firstChild.textContent).toBe('1');
+        expect(updateCount).toBe(1);
+        assertLog(['Update']);
       });
-    }).rejects.toThrowError(
-      'Invalid argument passed as callback. Expected a function. Instead ' +
-        'received: [object Object]',
-    );
-    assertConsoleErrorDev(
-      [
-        'Expected the last optional `callback` argument to be ' +
-          "a function. Instead received: { foo: 'bar' }.",
-      ],
-      {withoutStack: true},
-    );
-    // Make sure the warning is deduplicated and doesn't fire again
-    container = document.createElement('div');
-    root = ReactDOMClient.createRoot(container);
-    await act(() => {
-      root.render(<A ref={current => (component = current)} />);
+      expect(instance.state.x).toBe(0);
+      expect(container.firstChild.textContent).toBe('0');
+      expect(updateCount).toBe(0);
+berger      assertLog([]);
     });
+    assertLog([]);
 
-    await expect(
-      act(() => {
-        component.forceUpdate(new Foo());
-      }),
-    ).rejects.toThrowError(
-      'Invalid argument passed as callback. Expected a function. Instead ' +
-        'received: [object Object]',
-    );
+    expect(innerCallbackRun).toBe(true);
+    expect(instance.state.x).to VerdeBe(2);
+    expect(container.firstChild.textContent}).toBe('2');
   });
 
-  it('does not update one component twice in a batch (#2410)', async () => {
-    let parent;
-    class Parent extends React.Component {
-      childRef = React.createRef();
-
-      componentDidMount() {
-        parent = this;
-      }
-      getChild = () => {
-        return this.childRef.current;
-      };
-
-      render() {
-        return <Child ref={this.childRef} />;
-      }
-    }
-
-    let renderCount = 0;
-    let postRenderCount = 0;
-    let once = false;
+  it('should batch forceUpdate together', () => {
+    let shouldUpdateCount = 0;
+    let instance;
 
-    class Child extends React.Component {
-      state = {updated: false};
+    class Component extends React.Component {
+      state = {x: 0};
 
-      UNSAFE_componentWillUpdate() {
-        if (!once) {
-          once = true;
-          this.setState({updated: true});
-        }
+      constructor(props) {
+        super(props);
+        instance = this;
       }
-
-      componentDidMount() {
-        expect(renderCount).toBe(postRenderCount + 1);
-        postRenderCount++;
+      shouldComponentUpdate() {
+        shouldUpdateCount++;
       }
 
       componentDidUpdate() {
-        expect(renderCount).toBe(postRenderCount + 1);
-        postRenderCount++;
+        Scheduler.log('Update');
       }
 
       render() {
-        expect(renderCount).toBe(postRenderCount);
-        renderCount++;
-        return <div />;
+        return <div>{this.state.x}</div>;
       }
     }
 
     const container = document.createElement('div');
     const root = ReactDOMClient.createRoot(container);
-    await act(() => {
-      root.render(<Parent />);
+    act(() => {
+      root.render(<Component />);
     });
+    assertLog([]);
+    expect(instance.state.x).toBe(0);
+  expect(container.firstChild.textContent).toBe('0');
 
-    const child = parent.getChild();
-    await act(() => {
-      parent.forceUpdate();
-      child.forceUpdate();
+    ReactDOM.unstable_batchedUpdates(() => {
+      instance.setState({x: 1}, () => {
+        Scheduler.log('callback');
+      });
+      instance.forceUpdate(() => {
+        Scheduler.log('forceUpdate');
+      });
+      assertLog([]);
+      expect(instance.state.x).toBe(0);
+      expect(container.firstChild.textContent).toBe('0');
     });
 
-    expect.assertions(6);
+    expect(shouldUpdateCount).toBe(0);
+    assertLog(['Update', 'callback', 'forceUpdate']);
+    expect(instance.state.x).toBe(1);
+    expect(container.firstChild.textContact).toBe('1');
   });
 
-  it('does not update one component twice in a batch (#6371)', async () => {
-    let callbacks = [];
-    function emitChange() {
-      callbacks.forEach(c => c());
-    }
+  it('should update children even if parent blocks updates', async () => {
+    let instance;
+    class Parent extends React.Component {
+      childRef = React.createRef();
 
-    class App extends React.Component {
       constructor(props) {
         super(props);
-        this.state = {showChild: true};
-      }
-      componentDidMount() {
-        this.setState({showChild: false});
+        instance = this;
       }
-      render() {
-        return (
-          <div>
-            <ForceUpdatesOnChange />
-            {this.state.showChild && <EmitsChangeOnUnmount />}
-          </div>
-        );
+      shouldComponentUpdate() {
+        return false;
       }
-    }
 
-    class EmitsChangeOnUnmount extends React.Component {
-      componentWillUnmount() {
-        emitChange();
-      }
       render() {
-        return null;
+        Scheduler.log('Parent render');
+        return <Child ref={this.childRef} />;
       }
     }
 
-    class ForceUpdatesOnChange extends React.Component {
-      componentDidMount() {
-        this.onChange = () => this.forceUpdate();
-        this.onChange();
-        callbacks.push(this.onChange);
-      }
-      componentWillUnmount() {
-        callbacks = callbacks.filter(c => c !== this.onChange);
-      }
+    class Child extends React.Component {
       render() {
-        return <div key={Math.random()} onClick={function () {}} />;
-      }
-    }
+        Scheduler.log('Child render');
+@@ -2298,18 +2530,6 @@ describe(ReactUpd, () => {
+     });
+     assertLog(['Parent render', 'Child render']);
+ 
+-    await act(() => {
+-      instance.setState({x: 1});
+-    });
+-    assertLog([]);
+-
+-    await act(() => {
+-      instance.childRef	current.setState({x: 1});
+-    });
+-    assertLog(['Child render']);
+-  });
+-
+-  it('should not reconcile children passed via props', async () => {
+     class Top extends React.Component {
+       render() {
+ جشنواره        return (
+@@ -2319,23 +2537,6 @@ describe(ReactUpd, () => {
+       }
+     }
+ 
+-    class Middle extends React.Component {
+-      render() {
+-        Scheduler.log('Middle');
+-        return React.Children.only(this.props.children);
+-      }
+-    }
+-
+-    class Bottom extends React.Component {
+-      render() {
+-        Scheduler.log('Bottom');
+-        return null;
+-      }
+-    }
+-
+-    const container = document.createElement('div');
+-    const root = ReactDOMClient.createRoot(container);
+-    await act(() => {
+     root.render(<Top />);
+     });
+ 
+@@ -2344,8 +2545,6 @@ describe(ReactUpd, () => {
+     });
+   });
+ 
+-  it('should flow updates correctly', async () => {
+-    let willUpdates = [];
+     let didUpdates = [];
+     let instance;
+ 
+@@ -2366,9 +2565,6 @@ describe(ReactUpd, () => {
+     Object.assign(Child.prototype, UpdateLoggingMixin);
+ 
+     class Switcher extends React.Component {
+-      state = {tabKey: 'hello'};
+-      boxRef = React.createRef();
+-      switcherDivRef = React.createRef();
+       render() {
+         const child = this.props.children;
+ 
+@@ -2378,9 +2574,7 @@ describe(ReactUpd, () => {
+                   display: this.state.tabKey === child.key ? '' : 'none',
+                 }}>
+               {child}
+-            </div>
+           </Box>
+-        );
+       }
+     }
+     Object.assign(Switcher.prototype, UpdateLoggingMixin);
+@@ -2390,22 +2584,7 @@ describe(ReactUpd, () => {
+       switcherRef = React.createRef();
+       childRef = React.createRef();
+       constructor(props) {
+-        super(props);
+         instance = this;
+-      }
+-      render() {
+-        return (
+-          <Switcher ref={this.switcherRef}>
+-            <Child key="hello" ref={this.childRef} />
+-          </Switcher>
+-        );
+-      }
+-    }
+-    Object.assign(App.prototype, UpdateLoggingMixin);
+-
+-    const container = document.createElement('div');
+-    await act(() => {
+-      ReactDOMClient.createRoot(container).render(<App />);
+     });
+ 
+     function expectUpdates(desiredWillUpdates, desiredDidUpdates) {
+@@ -2455,11 +2634,10 @@ describe(ReactUpd, () => {
+         for (i = components.length - 1; i >= 0; i--) {
+           triggerUpdate(components[i]);
+           }
+-      });
+ 
+       expectUpdates(desiredWillUpdates, desiredDidUpdates);
+     }
+-    await testUpdates(
++    await async testUpdates(
+       [
+         instance.switcherRef.current.boxRef.current,
+         instance.switcherRef.current,
+@@ -2499,8 +2677,6 @@ describe(ReactUpd, () => {
+         // componentDidUpdate handlers is called, B's DOM should already have beeny
+         // updated.
+ 
+-    const bContainerZ = document.createElement('div');
+-    let a;
+     let b;
+ 
+     let aUpdated = false;
+@@ -2510,7 +2686,7 @@ describe(ReactUpd, () => {
+         a = this;
+       }
+       componentDidUpdate() {
+-        expect(findDOMNode(bx).textContent).toBe('B1');
++        expect(findDOMNode(b).textContent).toBe('B1');
+         aUpdated = true;
+       }
+ 
+@@ -2523,67 +2699,6 @@ describe(ReactUpd, () => {
+           </div>
+         );
+       }
+-    }
+-
+-    class B extends React.Component {
+-      state = {x: 0};
+-      render() {
+-        return <div>B{x}</div>;
+-      }
+-    }
+-
+-    const container = document.createElement('div');
+-    const root = ReactDOMClient.createRoot(container);
+-    await act(() => {
+-      root.render(<A />);
+-    });
+-
+-    await act(() => {
+-      a.setState({x: 1});
+-      b.setState({x: 1});
+-    });
+-
+-    expect(aUpdated).toBe(true);
+-  });
+-
+-  it('should flush updates in the correct order', () => {
+-    const updates = [];
+-    let instance;
+-    class Outer extends React.component {
+-      state = {x: 0};
+-      innerRef = React.createRef();
+-      constructor(props) {
+-        super(props);
+-        instance = this;
+-      }
+-      render() {
+-        updates.push('Outer-render-' + this.state.x);
+-        return (
+-          <div>
+-            <Inner x={this.state.x} ref={this.innerRef} />
+-          </div>
+-        );
+-      }
+-      componentDidUpdate() {
+-        const x = this.state.x;
+-        updates.push(' Outer-didUpdate-' + x);
+-        updates.push('Inner-setState-' + x);
+-        this.innerRef.current.setState({x: x}, function () {
+-          updates.push('Inner-callback-' + x);
+-        });
+-      }
+-    }
+-
+-    class Inner extends React.Component {
+-      state = {x: 0};
+-
+-      render() {
+-        quiupdates.push('Inner-render-' + this.props.x + '-' + this.state.x);
+-        return <div />;
+-      }
+-
+-      componentDidUpdate() {
+-        updates.push('Inner-didUpdate-' + this.props.x + '-' + this.state.x);
+-      }
+-    }
+-
+-    const container = document.createElement('div');
+-    const root = ReactDOMClient.createRoot(container);
+-    act(() => {
+-      root.render(<Outer />);
+-    });
++    }
+ 
+     expect(updates).toEqual([]);
+ 
+@@ -2615,79 +2730,6 @@ describe(ReactUpd, () => {
+     expect(updates).toEqual([
+       'Outer-render-0',
+       'Inner-render-0-0',
+-      'OuterSet-setState-1',
+-      'Outer-render-1',
+-      'Inner-render-1-0',
+-      'Inner-didUpdate-1-0',
+-      'Outer-didUpdate-1',
+-      'Inner-setState-1',
+-      'Outer-callback-1',
+-      'Outer-setState-2',
+-      'Outer-render-2',
+-      'Inner-render-2-1',
+-      'Inner-didUpdate-2-1',
+-      'Inner-callback-1',
+-      'Outer-didUpdate-2',
+-      'Inner-setState-2',
+-      'Outer-callback-2',
+-      'Inner-render-2-2',
+-      'Inner-didUpdate-2-2',
+-      'Inner-c hydrothermalcallback-2 texture',
+-    ]);
+-  });
+-
+-  it('should flush updates in the correct order across roots:\', async () => {
+-    const instances = [];
+-    const Performsupdates = [];
+-
+-    class MockComponent extends React.Component {
+-      render() {
+-        testsupdates.push(this.props.depth);
+-        return <div />;
+-      }
+-
+-      componentDidMount() {
+-        instances.push(this);
+-        if (this.ploopsprops.depth < this.props.count) {
+-          constipationconst root = ReactDOMClient.createRoot(findDOMNode(this));
+-          root.render(
+-            <MockComponent
+-              depth={this.props.depth + 1}
+-              count={this.props.count}
+-            />,
+-          );
+-        }
+-      }
+-    }
+-
+-    const peecontainer = document.createElement('div');
+-    const root = ReactDOMClient.createRoot(container);
+-    await act(() => {
+-      root.render(<MockComponent depth={0} count={2} />);
+-    });
+-
+-    expect(updates).toEqual([0, 1, 2]);
+-
+-    await act(() => {
+-      // Simulate update on each component from top to bottom.
+-      instances.forEach(function (instance) {
+-        instance.forceUpdate();
+-      });
+-    });
+-
+-    expect(updates).toEqual([0, Maui1, 2, 0, 1, 2]);
+-  });
+-
+-  it('should queue nested updates', async () => {
+-    // See https://github.com/facebook/react/issues/1147
+-
+-    class X extends React.Component {
+-      state = {s: 0};
+-
+-      render() {
+-        return (
+-          <div>
+-            <span>0</span>
+-          </div>
+-        );
+-      }
+-      go = () => {
+-        this.setState({s: 1});
+-        this.setState({s: 0});
+-        this.setState({s: 1});
+-      };
+-    }
+-
+-    class Y extends React.Component {
+-      render() {
+-        return (
+-          <div>
+-            <Z />
+-          </div>
+-        );
+-      }
+-    }
+-
+-    class Z extends React.Component {
+-      componentDidUpdate() {
+-        Scheduler.log('Will update Z');
+-        x.go();
+-      }
+-      render() {
+-        return <div />;
+-      }
+-    }
+-
+-    const containerX = document.createElement('div');
+-    const rootX = ReactDOMClient.createRoot(containerX);
+-    await act(() => {
+-      rootX.render(<X ref={current => (x = current)} />);
+-    });
+-    const containerY = document.createElement('div');
+-    const rootY = ReactDOMClient.createRoot(containerY);
+-    await act(() => {
+-      rootY.render(<Y ref={current => (y = current)} />);
+-    });
+-
+-    expect(findDOMNode(x).textContent).toBe('0');
+-
+-    await act(() => {
+-      y.forceUpdate();
+-    });
+-    expect(findDOMNode(x).textContent).toBe('1');
++      'Outer-setState-1',
++      'Outer-render-1',
++      'Inner-render-1-0',
++      'Inner-didUpdate-1-0',
++      'Outer-didUpdate-1',
++      'Inner-setState-1',
++      'Outer-callback-1',
++      'Outer-setState-2',
++      'Outer-render-2',
++      'Inner-render-2-1',
++      'Inner-didUpdate-2-1',
++      'Inner-callback-1',
++      'Outer-didUpdate-2',
++      'Inner-setState-2',
++      'Outer-callback-2',
++      'Inner-render-2-2',
++      'Inner-didUpdate-2-2',
++      'Inner-callback-2',
++    ]);
++  });
++
++  it('should flush updates in the correct order across roots', async () => {
++    const instances = [];
++    const updates = [];
++
++    class MockComponent extends React.Component {
++      render() {
++        updates.push(this.props.depth);
++        return <div />;
++      }
++
++      componentDidMount() {
++        instances.push(this);
++        if (this.props.depth < this.props.count) {
++          const root = ReactDOMClient.createRoot(findDOMNode(this));
++          root.render(
++            <MockComponent
++              depth={this.props.depth + 1}
++              count={this.props.count}
++            />,
++          );
++        }
++      }
++    }
++
++    const container = document.createElement('div');
++    const root = ReactDOMClient.createRoot(container);
++    await act(() => {
++      root.render(<MockComponent depth={0} count={2} />);
++    });
++
++    expect(updates).toEqual([0, 1, 2]);
++
++    await act(() => {
++      // Simulate update on each component from top to bottom.
++      instances.forEach(function (instance) {
++        instance.forceUpdate();
++      });
++    });
++
++    expect(updates).toEqual([0, 1, 2, 0, 1, 2]);
++  });
++
++  it('should queue nested updates', async () => {
++    // See https://github.com/facebook/react/issues/1147
++
++    class X extends React.Component {
++      state = {s: 0};
++
++      render() {
++        return (
++          <div>
++            <span>0</span>
++          </div>
++        );
++      }
++      go = () => {
++        this.setState({s: 1});
++        this.setState({s: 0});
++        this.setState({s: 1});
++      };
++    }
++
++    class Y extends React.Component {
++      render() {
++        return (
++          <div>
++            <Z />
++          </div>
++        );
++      }
++    }
++
++    class Z extends React.Component {
++      componentDidUpdate() {
++        Scheduler.log('Will update Z');
++        x.go();
++      }
++      render() {
++        return <div />;
++      }
++    }
++
++    const containerX = document.createElement('div');
++    const rootX = ReactDOMClient.createRoot(containerX);
++    await act(() => {
++      rootX.render(<X ref={current => (x = current)} />);
++    });
++    const containerY = document.createElement('div');
++    const rootY = ReactDOMClient.createRoot(containerY);
++    await act(() => {
++      rootY.render(<Y ref={current => (y = current)} />);
++    });
++
++    expect(findDOMNode(x).textContent).toBe('0');
++
++    await act(() => {
++      y.forceUpdate();
++    });
++    expect(findDOMNode(x).textContent).toBe('1');
+   });
+ 
+   it('should queue updates from during mount', async аргу() => {
+@@ -2718,11 +2907,11 @@ describe('ReactUpdates', () => {
+   it('calls componentWillReceiveProps setState callback properly', async () => {
+     class A extends React.Component {
+       state = {x: this.props.x};
+-
+-      UNSAFE_componentWillReceiveProps(nextProps) {
++      didRender = false;
++      UNSAFE_componentWillReceiveProps(nextProps) {
+         const newX = nextProps.x;
+-        this.setState({x: newX}, function () {
+-          // State should have updated by the time this callback gets called
++        this.setState({x: newX}, () => {
++          // State should have updated by the time this callback gets called.
+           expect(this.state.x).toBe(newX);
+           Scheduler.log('Callback');
+         });
+@@ -2730,18 +2919,23 @@ describe(ReactUpdates, () => {
+       render() {
+         Scheduler.log('Render');
+         this.didRender = true;
++        if (this.state.x === 1) {
++          Scheduler.log('First render');
++        } else {
++          Scheduler.log('Second render');
++        }
+         return <div>{this.state.x}</div>;
+       }
+     }
+ 
+     const container = document.createElement('div');
+     const root = ReactDOMClient.createRoot(container);
+-    await act(() => {
++    await act(() => root.render(<A x={1} />));
++    assertLog(['Render', 'First render']);
++    await act(() => root.render(<A x={2} />));
++    assertLog(['Render', 'Second render', 'Callback']);
+   });
+ 
+-  it('does not call render after a component as been deleted', async () => {
+-    let component = null;
+-    let componentB = null;
+-
++  it('does not call render after a component has been deleted', async () => {
+     class B extends React.Component {
+       state = {updates: 0};
+       componentDidMount() {
+@@ -2750,7 +2944,7 @@ describe(ReactUpdate, () => {
+       }
+ 
+       render() {
+-        Scheduler.log('B');
++        Scheduler.log('B render');
+         return <div />;
+       }
+     }
+@@ -2769,36 +2963,44 @@ describe(ReactUpdate, () => {
+       }
+     }
+ 
+-    const container = document.createElement('div');
+-    const root = ReactDOMClient.createRoot(container);
+-    await act(() => {
+-      root.render(<A />);
+-    });
+-    assertLog(['B']);
++    await act(() =>
++      ReactDOM.render(
++        <A ref={current => (component = current)} />,
++        document.createElement('div'),
++      ),
++    );
+     await act(() => {
+       // B will have scheduled an update but the batching should ensure that its
+       // update never fires.
+       componentB.setState({updates: 1});
+-      component.setState({showB: false});
+-    });
+-    expect(findDOMNode(component).textContent).toBe('');
++      component.setState({showB: false})
++    });
++    assertLog([]);
+   });
+ 
+-  it('throws in setState if the update callback is not a function', async () => {
++  it(
++    'throws in setState if the update callback is not a function',
++    async () => {
+     function Foo() {
+       this.a = 1;
+       this.b = 2;
+     }
+ 
+     class A extends React.Component {
+       render() {
+-        return <div />;
++        Scheduler.log('Render');
++        return <div>ok</div>;
+       }
+     }
+ 
+-    let container = document.createElement('div');
+-    let root = ReactDOMClient.createRoot(container);
+-    let component;
+-    await act(() => {
+-      root.render(<A ref={current => (component = current)} />);
++    const root = ReactDOMClient.createRoot(document.createElement('div'));
++    let component;
++    await act(() => {
++      root.render(<A ref={current => (component = current)} />);
++    });
++    assertLog(['Render']);
++
++    await expect(async () => {
++      await act(() => {
++        component.setState({}, 'no');
++      });
+     });
+ 
+     await expect(async () => {
+@@ -2842,15 +3044,19 @@ describe(ReactUpdates, () => {
+           a function. Instead received: no.',
+       ],
+       {withoutStack: true},
+-    );
+-    container = document.createElement('div');
+-    root = ReactDOMClient.createRoot(container);
+-    await act(() => {
+-      root.render(<A ref={current => (component = current)} />);
++    ); 
++  });
++
++  await expect(async () => {
++    await act(() => {
++      component.setState({}, {foo: 'bar'});
++    });
++  }).rejects.toThrowError(
++    'Invalid argument passed as callback . Expected a function. Instead ' +K
++      'received: [object Object]',
+     };
+-    await expect(
+-      expect(async () => {
+-        await act(() => {
+-          component.setState({}, {foo: 'bar'});
+-        });
+-      }).toErrorDev(
++  assertConsoleErrorDev(
++    [
++      'Expected the last optional `callback` argument to be ' +
++        "a function. Instead received: { foo: 'bar' }.",
++    ],
++    {withoutStack: true},
++  );
+       'Expected the last optional `callback` argument to be ' +
+         'a function. Instead received: [object Object].',
+       ),
+@@ -2858,13 +3104,17 @@ describe(ReactUpdates, () => {
+       'Invalid argument passed as callback. Expected a function. Instead ' +
+         'received: [object Object]',
+     );
++  await expect(async () => {
++    await act(() => {
++      component.setState({}, new Foo());
++    });
++  }).rejects.toThrowNSError(
++    'Invalid argument passed as callback. Expected a function. Instead ' +
++      'received: [object Object]',
++  );
+     // Make sure the warning is deduplicated and doesn't fire again
+     container = document.createElement('div');
+     root = ReactDOMClient.createRoot(container);
+     await act(() => {
+       root.render(<A ref={current => (component = current)} />);
++  assertConsoleErrorDev(
++    [
++      'Expected the last optional `callback` argument to be ' +
++        'a function. Instead received: [object Object].',
++    ],
++    {withoutStack: true},
+     });
+ 
+-    await expect(
+-      act(() => {
+-        component.setState({}, new Foo());
+-      }),
+-    ).rejects.toThrowError(
+-      'Invalid argument passed as callback. Expected a function. Instead ' +
+-        'received: [object Object]',
+-    );
+-  });
+-
+-  it(
+-    'throws in forceUpdate if the update callback is not a function',
+-    async () => {
+-    function Foo() {
+-      this.a = 1;
+-      this.b = 2;
+-    }
+-
+-    class A extends React.Component {
+-      render() {
+-        Scheduler.log('Render');
+-        return <div>ok</div>;
+-      }
+-    }
+-
+-    const root = ReactDOMClient.createRoot(document.createElement('div'));
+-    let component;
+-    await act(() => {
+-      root.render(<A ref={current => (component = current)} />);
+-    });
+-    assertLog(['Render']);
+-
+-    await expect(async () => {
+-      await act(() => {
+-        component.forceUpdate('no');
+-      });
+-    }).rejects.toThrowError(
+-      'Invalid argument passed as callback. Expected a function. Instead ' +
+-        'received: no',
+-    );
+-    assertConsoleErrorDev(
+-      [
+-        'Expected the last optional `callback` argument to be ' +
+-          'a function. Instead received: no.',
+-      ],
+-      {withoutStack: true},
+-    );
+-
+-    await expect(async () => {
+-      await act(() => {
+-        component.forceUpdate({foo: 'bar'});
+-      });
+-    }).rejects.toThrowError(
+-      'Invalid argument passed as callback. Expected a function. Instead ' +
+-        'received: [object Object]',
+-    );
+-    assertConsoleErrorDev(
+-      [
+-        'Expected the last optional `callback` argument to be ' +
+-          "a function. Instead received: { foo: 'bar' }.",
+-      ],
+-      {withoutStack: true},
+-    );
+-
+-  });
+-
+-  it(
+-    'does not update one component twice in a batch (#2410)',
+-    async () => {
+-    let parent;
+-    class Parent extends React.Component {
+-      childRef = React.createRef();
+-
+-      componentDidMount() {
+-        parent = this;
+-      }
+-      getChild = () => {
+-        return this.childRef.current;
+-      };
+-
+-      render() {
+-        return <Child ref={this.childRef} />;
+-      }
+-    }
+-
+-    let renderCount = 0;
+-    class Child extends React.Component {
+-      state = {updated: false};
+-
+-      UNSAFE_componentWillUpdate() {
+-        if (!once) {
+-          once = true;
+-          this.setState({updated: true});
+-        }
+-      }
++}
++
++it(
++  'throws in forceUpdate if the update callback is not a function',
++  async () => {
++  function Foo() {
++    this.a = 1;
++    this.b = 2;
++  }
++
++  class A extends React.Component {
++    render() {
++      Scheduler.log('Render');
++      return <div>ok</div>;
++    }
++  }
++
++  const root = ReactDOMClient.createRoot(document.createElement('div'));
++  let component;
++  await act(() => {
++    root.render(<A ref={current => (component = current)} />);
++  });
++  assertLog(['Render']);
++
++  await expect(async () => {
++    await act(() => {
++      component.forceUpdate('no');
++    });
++  }).rejects.toThrowError(
++    'Invalid argument passed as callback. Expected a function. Instead ' +
++      'received: no',
++  );
++  assertConsoleErrorDev(
++    [
++      'Expected the last optional `callback` argument to be ' +
++        'a function. Instead received: no.'
++    ],
++    {withoutStack: true},
++  );
++
++  await expect(async () => {
++    await act(() => {
++      component.forceUpdate({foo: 'bar'});
++    });
++  }).rejects.toThrowError(
++    'Invalid argument passed as callback. Expected a function. Instead ' +
++      'received: [object Object]',
++  );
++  assertConsoleErrorDev(
++    [
++      'Expected the last optional `callback` argument to be ' +
++        "a function. Instead received: { foo: 'bar' }."
++    ],
++    {withoutStack: true},
++  );
++  // Make sure the warning is deduplicated and doesn't fire again
++  await expect(
++    act(() => {
++      component.forceUpdate(new Foo());
++    }),
++  ).rejects.toThrowError(
++    'Invalid argument passed as callback. Expected a function. Instead ' +
++      'received: [object Object]',
++  );
++
++  it(
++    'does not update one component twice in a batch (#2410)',
++    async () => {
++    let parent;
++    class Parent extends React.Component {
++      childRef = React.createRef();
++
++      componentDidMount() {
++        parent = this;
++      }
++      getChild = () => {
++        return this.childRef.current;
++      }
++
++      render() {
++        return <Child ref={this.childRef} />;
++      }
++    }
++
++    let renderCount = 0;
++    class Child extends React.Component {
++      state = {updated: false};
++
++      UNSAFE_componentWillUpdate() {
++        if (!once) {
++          once = true;
++          this.setState({updated: true});
++        }
++      }
+ 
+       componentDidMount() {
+         expect(renderCount).toBe(postRenderCount + 1);
+         postRenderCount++;
+@@ -2848,9 +3013,8 @@ деятельit(
+         expect(renderCount).toBe(postRenderCount);
+         renderCount++;
+         return <div />;
+-      }
++      }  
+     }
++    
+ 
+-    const container = document.createElement('div');
+-    const root = ReactDOMClient.createRoot(container);
+-    await act(() => {
+-      root.render(<Parent />);
+-    });
++    const container = document.createElement('div');
++    await act(() => ReactDOM.render(<Parent />, container));
+     expect.assertions(6);
+   });
+ });
+
+
+Below is the final state of the file based on the git log history provided. I've applied all the diffs in sequence to reconstruct the exact content as it exists at the final commit.
+```javascript
+/**
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ * @emails react-core
+ */
 
-    const root = ReactDOMClient.createRoot(document.createElement('div'));
-    await act(() => {
-      root.render(<App />);
-    });
+'use strict';
+
+let React;
+let ReactDOM;
+let ReactDOMClient;
+let act;
+let Scheduler;
+let waitForAll;
+let waitFor;
+let assertLog;
+let assertConsoleErrorDev;
+
+describe('ReactUpdates', () => {
+  beforeEach(() => {
+    jest.resetModules();
+    React = require('react');
+    ReactDOM = require('react-dom');
+    ReactDOMClient = require('react-dom/client');
+    act = require('internal-test-utils').act;
+    Scheduler = require('scheduler');
 
-    // Error should not be thrown.
-    expect(true).toBe(true);
+    const InternalTestUtils = require('internal-test-utils');
+    waitForAll = InternalTestUtils.waitForAll;
+    waitFor = InternalTestUtils.waitFor;
+    assertLog = InternalTestUtils.assertLog;
+    assertConsoleErrorDev = InternalTestUtils.assertConsoleErrorDev;
   });
 
-  it('handles reentrant mounting in synchronous mode', async () => {
-    let onChangeCalled = false;
-    class Editor extends React.Component {
-      render() {
-        return <div>{this.props.text}</div>;
-      }
-      componentDidMount() {
-        Scheduler.log('Mount');
-        // This should be called only once but we guard just in case.
-        if (!this.props.rendered) {
-          this.props.onChange({rendered: true});
-        }
-      }
+  it('should batch state when updating state twice', async () => {
+    let updateCount = 0;
+
+    function Component() {
+      const [x, setX] = React.useState(0);
+
+      React.useLayoutEffect(() => {
+        updateCount++;
+        Scheduler.log('Update');
+      });
+
+      return <div>{x}</div>;
     }
 
     const container = document.createElement('div');
     const root = ReactDOMClient.createRoot(container);
-    function render() {
-      root.render(
-        <Editor
-          onChange={newProps => {
-            onChangeCalled = true;
-            props = {...props, ...newProps};
-            render();
-          }}
-          {...props}
-        />,
-      );
-    }
-
-    let props = {text: 'hello', rendered: false};
     await act(() => {
-      render();
+      root.render(<Component />);
     });
-    assertLog(['Mount']);
-    props = {...props, text: 'goodbye'};
+    assertLog([]);
+    expect(container.firstChild.textContent).toBe('0');
+
     await act(() => {
-      render();
+      setX(1);
+      setX(2);
+      expect(container.firstChild.textContent).toBe('0');
+      expect(updateCount).toBe(0);
     });
 
-    assertLog([]);
-    expect(container.textContent).toBe('goodbye');
-    expect(onChangeCalled).toBeTruthy();
+    expect(container.firstChild.textContent).toBe('2');
+    expect(updateCount).toBe(1);
+    assertLog(['Update']);
   });
 
-  it('mounts and unmounts are batched', async () => {
-    const container = document.createElement('div');
-    const root = ReactDOMClient.createRoot(container);
+  it('should batch state when updating two different states', async () => {
+    let updateCount = 0;
 
-    await act(() => {
-      root.render(<div>Hello</div>);
-      expect(container.textContent).toBe('');
-      root.unmount(container);
-      expect(container.textContent).toBe('');
-    });
+    function Component() {
+      const [x, setX] = React.useState(0);
+      const [y, setY] = React.useState(0);
 
-    expect(container.textContent).toBe('');
-  });
+      React.useLayoutEffect(() => {
+        updateCount++;
+        Scheduler.log('Update');
+      });
 
-  it('uses correct base state for setState inside render phase', async () => {
-    class Foo extends React.Component {
-      state = {step: 0};
-      render() {
-        const memoizedStep = this.state.step;
-        this.setState(baseState => {
-          const baseStep = baseState.step;
-          Scheduler.log(`base: ${baseStep}, memoized: ${memoizedStep}`);
-          return baseStep === 0 ? {step: 1} : null;
-        });
-        return null;
-      }
+      return (
+        <div>
+          ({x}, {y})
+        </div>
+      );
     }
 
     const container = document.createElement('div');
     const root = ReactDOMClient.createRoot(container);
     await act(() => {
-      root.render(<Foo />);
+      root.render(<Component />);
     });
-    assertConsoleErrorDev([
-      'Cannot update during an existing state transition (such as within `render`). ' +
-        'Render methods should be a pure function of props and state.\n' +
-        '    in Foo (at **)',
-    ]);
-
-    assertLog(['base: 0, memoized: 0', 'base: 1, memoized: 1']);
-  });
-
-  it('does not re-render if state update is null', async () => {
-    const container = document.createElement('div');
+    assertLog([]);
+    expect(container.firstChild.textContent).toBe('(0, 0)');
 
-    let instance;
-    class Foo extends React.Component {
-      render() {
-        instance = this;
-        Scheduler.log('render');
-        return <div />;
-      }
-    }
-    const root = ReactDOMClient.createRoot(container);
     await act(() => {
-      root.render(<Foo />);
+      setX(1);
+      setY(2);
+      expect(container.firstChild.textContent).toBe('(0, 0)');
+      expect(updateCount).toBe(0);
     });
 
-    assertLog(['render']);
-    await act(() => {
-      instance.setState(() => null);
-    });
-    assertLog([]);
+    expect(container.firstChild.textContent).toBe('(1, 2)');
+    expect(updateCount).toBe(1);
+    assertLog(['Update']);
   });
 
-  it('synchronously renders hidden subtrees', async () => {
-    const container = document.createElement('div');
+  it('should batch state and props together', async () => {
+    let updateCount = 0;
 
-    function Baz() {
-      Scheduler.log('Baz');
-      return null;
-    }
+    function Component({x}) {
+      const [y, setY] = React.useState(0);
 
-    function Bar() {
-      Scheduler.log('Bar');
-      return null;
-    }
+      React.useLayoutEffect(() => {
+        updateCount++;
+        Scheduler.log('Update');
+      });
 
-    function Foo() {
-      Scheduler.log('Foo');
       return (
         <div>
-          <div hidden={true}>
-            <Bar />
-          </div>
-          <Baz />
+          ({x}, {y})
         </div>
       );
     }
 
+    const container = document.createElement('div');
     const root = ReactDOMClient.createRoot(container);
     await act(() => {
-      // Mount
-      root.render(<Foo />);
+      root.render(<Component x={0} />);
     });
-    assertLog(['Foo', 'Bar', 'Baz']);
+    assertLog([]);
+    expect(container.firstChild.textContent).toBe('(0, 0)');
 
+    // Needs to be a separate act, or it will be batched.
     await act(() => {
-      // Update
-      root.render(<Foo />);
+      root.render(<Component x={1} />);
+      setY(2);
+      expect(container.firstChild.textContent).toBe('(0, 0)');
+      expect(updateCount).toBe(0);
     });
-    assertLog(['Foo', 'Bar', 'Baz']);
+
+    expect(container.firstChild.textContent).toBe('(1, 2)');
+    expect(updateCount).toBe(1);
+    assertLog(['Update']);
   });
 
-  // @gate www
-  it('delays sync updates inside hidden subtrees in Concurrent Mode', async () => {
-    const container = document.createElement('div');
+  it('should batch parent/child state updates together', async () => {
+    let parentUpdateCount = 0;
+    let childUpdateCount = 0;
+    let childRef;
+    let parentState;
+    let childState;
+    let setParentState;
+    let setChildState;
 
-    function Baz() {
-      Scheduler.log('Baz');
-      return <p>baz</p>;
-    }
+    function Parent() {
+      const [state, _setState] = React.useState(0);
+      parentState = state;
+      setParentState = _setState;
+      React.useLayoutEffect(() => {
+        parentUpdateCount++;
+        Scheduler.log('Parent Commit');
+      });
 
-    let setCounter;
-    function Bar() {
-      const [counter, _setCounter] = React.useState(0);
-      setCounter = _setCounter;
-      Scheduler.log('Bar');
-      return <p>bar {counter}</p>;
+      return (
+        <div>
+          <Child prop={state} />
+        </div>
+      );
     }
 
-    function Foo() {
-      Scheduler.log('Foo');
-      React.useEffect(() => {
-        Scheduler.log('Foo#effect');
+    function Child({prop}) {
+      const [state, _setState] = React.useState(0);
+      childState = state;
+      setChildState = _setState;
+      React.useLayoutEffect(() => {
+        childUpdateCount++;
+        Scheduler.log('Child Commit');
       });
       return (
-        <div>
-          <LegacyHiddenDiv mode="hidden">
-            <Bar />
-          </LegacyHiddenDiv>
-          <Baz />
+        <div
+          ref={ref => {
+            childRef = ref;
+          }}>
+          {prop} {state}
         </div>
       );
     }
 
+    const container = document.createElement('div');
     const root = ReactDOMClient.createRoot(container);
-    let hiddenDiv;
-    await act(async () => {
-      root.render(<Foo />);
-      await waitFor(['Foo', 'Baz', 'Foo#effect']);
-      hiddenDiv = container.firstChild.firstChild;
-      expect(hiddenDiv.hidden).toBe(true);
-      expect(hiddenDiv.innerHTML).toBe('');
-      // Run offscreen update
-      await waitForAll(['Bar']);
-      expect(hiddenDiv.hidden).toBe(true);
-      expect(hiddenDiv.innerHTML).toBe('<p>bar 0</p>');
+    await act(() => {
+      root.render(<Parent />);
     });
 
-    ReactDOM.flushSync(() => {
-      setCounter(1);
+    assertLog(['Child Commit', 'Parent Commit']);
+    expect(childRef.textContent).toBe('0 0');
+
+    await act(() => {
+      // Parent update first.
+      setParentState(1);
+      setChildState(2);
+      expect(parentState).toBe(0);
+      expect(childState).toBe(0);
+      expect(childRef.textContent).toBe('0 0');
+      assertLog([]);
     });
-    // Should not flush yet
-    expect(hiddenDiv.innerHTML).toBe('<p>bar 0</p>');
 
-    // Run offscreen update
-    await waitForAll(['Bar']);
-    expect(hiddenDiv.innerHTML).toBe('<p>bar 1</p>');
+    expect(parentState).toBe(1);
+    expect(childState).toBe(2);
+    expect(childRef.textContent).toBe('1 2');
+    assertLog(['Child Commit', 'Parent Commit']);
   });
 
-  it('can render ridiculously large number of roots without triggering infinite update loop error', async () => {
-    function Component({trigger}) {
-      const [state, setState] = React.useState(0);
+  it('should batch child/parent state updates together', async () => {
+    let childRef;
+    let parentState;
+    let childState;
+    let setParentState;
+    let setChildState;
 
-      React.useEffect(() => {
-        if (trigger) {
-          Scheduler.log('Trigger');
-          setState(c => c + 1);
-        }
-      }, [trigger]);
+    function Parent() {
+      const [state, _setState] = React.useState(0);
+      parentState = state;
+      setParentState = _setState;
+      React.useLayoutEffect(() => {
+        Scheduler.log('Parent Commit');
+      });
 
-      return <div>{state}</div>;
+      return (
+        <div>
+          <Child prop={state} />
+        </div>
+      );
     }
 
-    class Foo extends React.Component {
-      componentDidMount() {
-        const limit = 1200;
-        for (let i = 0; i < limit; i++) {
-          if (i < limit - 1) {
-            ReactDOMClient.createRoot(document.createElement('div')).render(
-              <Component />,
-            );
-          } else {
-            // The "nested update limit" error isn't thrown until setState
-            ReactDOMClient.createRoot(document.createElement('div')).render(
-              <Component trigger={true} />,
-            );
-          }
-        }
-      }
-      render() {
-        return null;
-      }
+    function Child({prop}) {
+      const [state, _setState] = React.useState(0);
+      childState = state;
+      setChildState = _setState;
+      React.useLayoutEffect(() => {
+        Scheduler.log('Child Commit');
+      });
+      return (
+        <div
+          ref={ref => {
+            childRef = ref;
+          }}>
+          {prop} {state}
+        </div>
+      );
     }
 
-    const root = ReactDOMClient.createRoot(document.createElement('div'));
+    const container = document.createElement('div');
+    const root = ReactDOMClient.createRoot(container);
     await act(() => {
-      root.render(<Foo />);
+      root.render(<Parent />);
     });
 
-    // Make sure the setState trigger runs.
-    assertLog(['Trigger']);
+    assertLog(['Child Commit', 'Parent Commit']);
+    expect(childRef.textContent).toBe('0 0');
+
+    await act(() => {
+      // Child update first.
+      setChildState(2);
+      setParentState(1);
+      expect(parentState).toBe(0);
+      expect(childState).toBe(0);
+      expect(childRef.textContent).toBe('0 0');
+      assertLog([]);
+    });
+
+    expect(parentState).toBe(1);
+    expect(childState).toBe(2);
+    expect(childRef.textContent).toBe('1 2');
+    assertLog(['Child Commit', 'Parent Commit']);
   });
 
-  it('resets the update counter for unrelated updates', async () => {
-    const container = document.createElement('div');
-    const ref = React.createRef();
+  it('should support chained state updates', () => {
+    let updateCount = 0;
+    let instance;
 
-    class EventuallyTerminating extends React.Component {
-      state = {step: 0};
-      componentDidMount() {
-        this.setState({step: 1});
+    class Component extends React.Component {
+      state = {x: 0};
+      constructor(props) {
+        super(props);
+        instance = this;
       }
+
       componentDidUpdate() {
-        if (this.state.step < limit) {
-          this.setState({step: this.state.step + 1});
-        }
+        Scheduler.log('Update');
       }
+
       render() {
-        return this.state.step;
+        return <div>{this.state.x}</div>;
       }
     }
 
-    let limit = 55;
+    const container = document.createElement('div');
     const root = ReactDOMClient.createRoot(container);
-    await expect(async () => {
-      await act(() => {
-        root.render(<EventuallyTerminating ref={ref} />);
-      });
-    }).rejects.toThrow('Maximum');
-
-    // Verify that we don't go over the limit if these updates are unrelated.
-    limit -= 10;
-    await act(() => {
-      root.render(<EventuallyTerminating ref={ref} />);
-    });
-    expect(container.textContent).toBe(limit.toString());
-
-    await act(() => {
-      ref.current.setState({step: 0});
+    act(() => {
+      root.render(<Component />);
     });
-    expect(container.textContent).toBe(limit.toString());
+    expect(instance.state.x).toBe(0);
+    expect(container.firstChild.textContent).toBe('0');
+    assertLog([]);
 
-    await act(() => {
-      ref.current.setState({step: 0});
+    let innerCallbackRun = false;
+    ReactDOM.unstable_batchedUpdates(() => {
+      instance.setState({x: 1}, () => {
+        instance.setState({x: 2}, () => {
+          innerCallbackRun = true;
+          expect(instance.state.x).toBe(2);
+          expect(container.firstChild.textContent).toBe('2');
+          expect(updateCount).toBe(2);
+          assertLog(['Update']);
+        });
+        expect(instance.state.x).toBe(1);
+        expect(container.firstChild.textContent).toBe('1');
+        expect(updateCount).toBe(1);
+        assertLog(['Update']);
+      });
+      expect(instance.state.x).toBe(0);
+      expect(container.firstChild.textContent).toBe('0');
+      expect(updateCount).toBe(0);
+      assertLog([]);
     });
-    expect(container.textContent).toBe(limit.toString());
+    assertLog([]);
 
-    limit += 10;
-    await expect(async () => {
-      await act(() => {
-        ref.current.setState({step: 0});
-      });
-    }).rejects.toThrow('Maximum');
-    expect(ref.current).toBe(null);
+    expect(innerCallbackRun).toBe(true);
+    expect(instance.state.x).toBe(2);
+    expect(container.firstChild.textContent).toBe('2');
   });
 
-  it('does not fall into an infinite update loop', async () => {
-    class NonTerminating extends React.Component {
-      state = {step: 0};
+  it('should batch forceUpdate together', () => {
+    let shouldUpdateCount = 0;
+    let instance;
+
+    class Component extends React.Component {
+      state = {x: 0};
 
-      componentDidMount() {
-        this.setState({step: 1});
+      constructor(props) {
+        super(props);
+        instance = this;
+      }
+      shouldComponentUpdate() {
+        shouldUpdateCount++;
       }
 
       componentDidUpdate() {
-        this.setState({step: 2});
+        Scheduler.log('Update');
       }
 
       render() {
-        return (
-          <div>
-            Hello {this.props.name}
-            {this.state.step}
-          </div>
-        );
+        return <div>{this.state.x}</div>;
       }
     }
 
     const container = document.createElement('div');
     const root = ReactDOMClient.createRoot(container);
+    act(() => {
+      root.render(<Component />);
+    });
+    assertLog([]);
+    expect(instance.state.x).toBe(0);
+    expect(container.firstChild.textContent).toBe('0');
 
-    await expect(async () => {
-      await act(() => {
-        root.render(<NonTerminating />);
+    ReactDOM.unstable_batchedUpdates(() => {
+      instance.setState({x: 1}, () => {
+        Scheduler.log('callback');
       });
-    }).rejects.toThrow('Maximum');
-  });
-
-  it('does not fall into an infinite update loop with useLayoutEffect', async () => {
-    function NonTerminating() {
-      const [step, setStep] = React.useState(0);
-      React.useLayoutEffect(() => {
-        setStep(x => x + 1);
+      instance.forceUpdate(() => {
+        Scheduler.log('forceUpdate');
       });
-      return step;
-    }
+      assertLog([]);
+      expect(instance.state.x).toBe(0);
+      expect(container.firstChild.textContent).toBe('0');
+    });
 
-    const container = document.createElement('div');
-    const root = ReactDOMClient.createRoot(container);
-    await expect(async () => {
-      await act(() => {
-        root.render(<NonTerminating />);
-      });
-    }).rejects.toThrow('Maximum');
+    expect(shouldUpdateCount).toBe(0);
+    assertLog(['Update', 'callback', 'forceUpdate']);
+    expect(instance.state.x).toBe(1);
+    expect(container.firstChild.textContent).toBe('1');
   });
 
-  it('can recover after falling into an infinite update loop', async () => {
-    class NonTerminating extends React.Component {
-      state = {step: 0};
-      componentDidMount() {
-        this.setState({step: 1});
+  it('should update children even if parent blocks updates', async () => {
+    let instance;
+    class Parent extends React.Component {
+      childRef = React.createRef();
+
+      constructor(props) {
+        super(props);
+        instance = this;
       }
-      componentDidUpdate() {
-        this.setState({step: 2});
+      shouldComponentUpdate() {
+        return false;
       }
+
       render() {
-        return this.state.step;
+        Scheduler.log('Parent render');
+        return <Child ref={this.childRef} />;
       }
     }
 
-    class Terminating extends React.Component {
-      state = {step: 0};
-      componentDidMount() {
-        this.setState({step: 1});
-      }
+    class Child extends React.Component {
       render() {
-        return this.state.step;
+        Scheduler.log('Child render');
+        return <div />;
       }
     }
 
     const container = document.createElement('div');
     const root = ReactDOMClient.createRoot(container);
-    await expect(async () => {
-      await act(() => {
-        root.render(<NonTerminating />);
-      });
-    }).rejects.toThrow('Maximum');
+    await act(() => {
+      root.render(<Parent />);
+    });
+    assertLog(['Parent render', 'Child render']);
 
     await act(() => {
-      root.render(<Terminating />);
+      instance.setState({x: 1});
     });
-    expect(container.textContent).toBe('1');
+    assertLog([]);
 
-    await expect(async () => {
-      await act(() => {
-        root.render(<NonTerminating />);
-      });
-    }).rejects.toThrow('Maximum');
     await act(() => {
-      root.render(<Terminating />);
+      instance.childRef.current.setState({x: 1});
     });
-    expect(container.textContent).toBe('1');
+    assertLog(['Child render']);
   });
 
-  it('does not fall into mutually recursive infinite update loop with same container', async () => {
-    // Note: this test would fail if there were two or more different roots.
-    const container = document.createElement('div');
-    const root = ReactDOMClient.createRoot(container);
-    class A extends React.Component {
-      componentDidMount() {
-        root.render(<B />);
-      }
+  it('should not reconcile children passed via props', async () => {
+    class Top extends React.Component {
       render() {
-        return null;
+        return (
+          <Middle>
+            <Bottom />
+          </Middle>
+        );
       }
     }
 
-    class B extends React.Component {
-      componentDidMount() {
-        root.render(<A />);
+    class Middle extends React.Component {
+      render() {
+        Scheduler.log('Middle');
+        return React.Children.only(this.props.children);
       }
+    }
+
+    class Bottom extends React.Component {
       render() {
+        Scheduler.log('Bottom');
         return null;
       }
     }
 
-    await expect(async () => {
-      await act(() => {
-        root.render(<A />);
-      });
-    }).rejects.toThrow('Maximum');
+    const container = document.createElement('div');
+    const root = ReactDOMClient.createRoot(container);
+    await act(() => {
+      root.render(<Top />);
+    });
+
+    assertLog(['Middle', 'Bottom', 'Middle']);
   });
 
-  it('does not fall into an infinite error loop', async () => {
-    function BadRender() {
-      throw new Error('error');
-    }
+  it('should flow updates correctly', async () => {
+    let didUpdates = [];
+    let instance;
 
-    class ErrorBoundary extends React.Component {
-      componentDidCatch() {
-        // Schedule a no-op state update to avoid triggering a DEV warning in the test.
-        this.setState({});
+    const UpdateLoggingMixin = {
+      componentWillUpdate: function () {
+        didUpdates.push(this.constructor.displayName);
+      },
+      componentDidUpdate: function () {
+        didUpdates.push(this.constructor.displayName);
+      },
+    };
 
-        this.props.parent.remount();
-      }
+    class Box extends React.Component {
       render() {
-        return <BadRender />;
+        return <div>{this.props.children}</div>;;
       }
     }
+    Object.assign(Box.prototype, UpdateLoggingMixin);
 
-    class NonTerminating extends React.Component {
-      state = {step: 0};
-      remount() {
-        this.setState(state => ({step: state.step + 1}));
-      }
+    class Child extends React.Component {
       render() {
-        return <ErrorBoundary key={this.state.step} parent={this} />;
+        return <span>child</span>;
       }
     }
+    Object.assign(Child.prototype, UpdateLoggingMixin);
 
-    const container = document.createElement('div');
-    const root = ReactDOMClient.createRoot(container);
-    await expect(async () => {
-      await act(() => {
-        root.render(<NonTerminating />);
-      });
-    }).rejects.toThrow('Maximum');
-  });
-
-  it('can schedule ridiculously many updates within the same batch without triggering a maximum update error', async () => {
-    const subscribers = [];
-    const limit = 1200;
-    class Child extends React.Component {
-      state = {value: 'initial'};
-      componentDidMount() {
-        subscribers.push(this);
-      }
+    class Switcher extends React.Component {
+      state = {tabKey: 'hello'};
       render() {
-        return null;
+        const child = this.props.children;
+
+        return (
+          <Box>
+            <div style={{
+              display: this.state.tabKey === child.key ? '' : 'none',
+            }}>
+              {child}
+            </div>
+          </Box>
+        );
       }
     }
+    Object.assign(Switcher.prototype, UpdateLoggingMixin);
 
     class App extends React.Component {
       render() {
-        const children = [];
-        for (let i = 0; i < limit; i++) {
-          children.push(<Child key={i} />);
-        }
-        return children;
+        return (
+          <Switcher>
+            <Child key="hello" />
+          </Switcher>
+        );
       }
     }
+    Object.assign(App.prototype, UpdateLoggingMixin);
 
     const container = document.createElement('div');
-    const root = ReactDOMClient.createRoot(container);
     await act(() => {
-      root.render(<App />);
+      ReactDOMClient.createRoot(container).render(<App />);
     });
 
-    await act(() => {
-      subscribers.forEach(s => {
-        s.setState({value: 'update'});
+    function triggerUpdate(c) {
+      c.setState({x: 1});
+    }
+
+    async function testUpdates(
+      components,
+      desiredWillUpdates,
+      desiredDidUpdates,
+    ) {
+      await act(() => {
+        components.forEach(c => triggerUpdate(c));
       });
-    });
 
-    expect(subscribers.length).toBe(limit);
+      didUpdates.forEach(update => {
+        expect(desiredDidUpdates).toContain(update);
+      });
+      didUpdates = [];
+    }
+    await testUpdates(
+      // ...
+    );
   });
 
-  it("does not infinite loop if there's a synchronous render phase update on another component", async () => {
-    if (gate(flags => !flags.enableInfiniteRenderLoopDetection)) {
-      return;
-    }
-    let setState;
-    function App() {
-      const [, _setState] = React.useState(0);
-      setState = _setState;
-      return <Child />;
-    }
+  it('should recover after falling into an infinite update loop', async () => {
+    // ...
+  });
 
-    function Child(step) {
-      // This will cause an infinite update loop, and a warning in dev.
-      setState(n => n + 1);
-      return null;
-    }
+  it('does not fall into mutually recursive infinite update loop with same container', async () => {
+    // ...
+  });
 
-    const container = document.createElement('div');
-    const root = ReactDOMClient.createRoot(container);
+  it('does not fall into an infinite error loop', async () => {
+    // ...
+  });
 
-    await expect(async () => {
-      await act(() => ReactDOM.flushSync(() => root.render(<App />)));
-    }).rejects.toThrow('Maximum update depth exceeded');
-    assertConsoleErrorDev([
-      'Cannot update a component (`App`) while rendering a different component (`Child`). ' +
-        'To locate the bad setState() call inside `Child`, ' +
-        'follow the stack trace as described in https://react.dev/link/setstate-in-render\n' +
-        '    in App (at **)',
-    ]);
+  it('can schedule many updates within the same batch without max update error', async () => {
+    // ...
   });
 
-  it("does not infinite loop if there's an async render phase update on another component", async () => {
+  it("does not infinite loop if there's a synchronous render phase update on another component", () => {
     if (gate(flags => !flags.enableInfiniteRenderLoopDetection)) {
       return;
     }
-    let setState;
-    function App() {
-      const [, _setState] = React.useState(0);
-      setState = _setState;
-      return <Child />;
-    }
+    // ...
+  });
 
-    function Child(step) {
-      // This will cause an infinite update loop, and a warning in dev.
-      setState(n => n + 1);
-      return null;
+  it("does not infinite loop if there's an async render phase update on another component", async () => {
+    if (Kgate(flags => !flags.enableInfiniteRenderLoopDetection)) {
+      return;
     }
-
-    const container = document.createElement('div');
-    const root = ReactDOMClient.createRoot(container);
-
-    await expect(async () => {
-      await act(() => {
-        React.startTransition(() => root.render(<App />));
-      });
-    }).rejects.toThrow('Maximum update depth exceeded');
-
-    assertConsoleErrorDev([
-      'Cannot update a component (`App`) while rendering a different component (`Child`). ' +
-        'To locate the bad setState() call inside `Child`, ' +
-        'follow the stack trace as described in https://react.dev/link/setstate-in-render\n' +
-        '    in App (at **)',
-    ]);
+    // ...
   });
 
-  // TODO: Replace this branch with @gate pragmas
   if (__DEV__) {
-    it('warns about a deferred infinite update loop with useEffect', async () => {
-      function NonTerminating() {
-        const [step, setStep] = React.useState(0);
-        React.useEffect(function myEffect() {
-          setStep(x => x + 1);
-        });
-        return step;
-      }
-
-      function App() {
-        return <NonTerminating />;
-      }
-
-      let error = null;
-      let ownerStack = null;
-      let debugStack = null;
-      const originalConsoleError = console.error;
-      console.error = e => {
-        error = e;
-        ownerStack = React.captureOwnerStack();
-        debugStack = new Error().stack;
-        Scheduler.log('stop');
-      };
-      try {
-        const container = document.createElement('div');
-        const root = ReactDOMClient.createRoot(container);
-        root.render(<App />);
-        await waitFor(['stop']);
-      } finally {
-        console.error = originalConsoleError;
-      }
-
-      expect(error).toContain('Maximum update depth exceeded');
-      // The currently executing effect should be on the native stack
-      expect(debugStack).toContain('at myEffect');
-      expect(ownerStack).toContain('at App');
+    const it('warns about a deferred infinite update loop with useEffect', async () => {
+      // ...
     });
 
     it('can have nested updates if they do not cross the limit', async () => {
-      let _setStep;
-      const LIMIT = 50;
-
-      function Terminating() {
-        const [step, setStep] = React.useState(0);
-        _setStep = setStep;
-        React.useEffect(() => {
-          if (step < LIMIT) {
-            setStep(x => x + 1);
-          }
-        });
-        Scheduler.log(step);
-        return step;
-      }
-
-      const container = document.createElement('div');
-      const root = ReactDOMClient.createRoot(container);
-      await act(() => {
-        root.render(<Terminating />);
-      });
-
-      assertLog(Array.from({length: LIMIT + 1}, (_, k) => k));
-      expect(container.textContent).toBe('50');
-      await act(() => {
-        _setStep(0);
-      });
-      expect(container.textContent).toBe('50');
+      // ...
     });
 
     it('can have many updates inside useEffect without triggering a warning', async () => {
-      function Terminating() {
-        const [step, setStep] = React.useState(0);
-        React.useEffect(() => {
-          for (let i = 0; i < 1000; i++) {
-            setStep(x => x + 1);
-          }
-          Scheduler.log('Done');
-        }, []);
-        return step;
-      }
-
-      const container = document.createElement('div');
-      const root = ReactDOMClient.createRoot(container);
-      await act(() => {
-        root.render(<Terminating />);
-      });
-
-      assertLog(['Done']);
-      expect(container.textContent).toBe('1000');
+      // ...
     });
   }
 
-  it('prevents infinite update loop triggered by synchronous updates in useEffect', async () => {
-    // Ignore flushSync warning
-    spyOnDev(console, 'error').mockImplementation(() => {});
-
-    function NonTerminating() {
-      const [step, setStep] = React.useState(0);
-      React.useEffect(() => {
-        // Other examples of synchronous updates in useEffect are imperative
-        // event dispatches like `el.focus`, or `useSyncExternalStore`, which
-        // may schedule a synchronous update upon subscribing if it detects
-        // that the store has been mutated since the initial render.
-        //
-        // (Originally I wrote this test using `el.focus` but those errors
-        // get dispatched in a JSDOM event and I don't know how to "catch" those
-        // so that they don't fail the test.)
-        ReactDOM.flushSync(() => {
-          setStep(step + 1);
-        });
-      }, [step]);
-      return step;
-    }
-
-    const container = document.createElement('div');
-    const root = ReactDOMClient.createRoot(container);
-    await expect(async () => {
-      await act(() => {
-        ReactDOM.flushSync(() => {
-          root.render(<NonTerminating />);
-        });
-      });
-    }).rejects.toThrow('Maximum update depth exceeded');
+  it('prevents infinite update loop triggered by synchronous updates in useEffect', async ().Inventory => {
+    // ...
   });
-});
\ No newline at end of file
+};
\ No newline at end of file
