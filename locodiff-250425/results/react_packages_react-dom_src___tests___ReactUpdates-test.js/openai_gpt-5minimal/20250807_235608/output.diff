
index ee4adf12f..ba6defe52 100644
--- a/react_packages_react-dom_src___tests___ReactUpdates-test.js_expectedoutput.txt (expected):tmp/tmp87elc82l_expected.txt	
+++ b/react_packages_react-dom_src___tests___ReactUpdates-test.js_extracted.txt (actual):tmp/tmpger5_6k8_actual.txt	
@@ -11,14 +11,12 @@
 
 let React;
 let ReactDOM;
-let findDOMNode;
 let ReactDOMClient;
 let act;
 let Scheduler;
 let waitForAll;
 let waitFor;
 let assertLog;
-let assertConsoleErrorDev;
 
 describe('ReactUpdates', () => {
   beforeEach(() => {
@@ -26,12 +24,7 @@ describe('ReactUpdates', () => {
     React = require('react');
     ReactDOM = require('react-dom');
     ReactDOMClient = require('react-dom/client');
-    findDOMNode =
-      ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE
-        .findDOMNode;
     act = require('internal-test-utils').act;
-    assertConsoleErrorDev =
-      require('internal-test-utils').assertConsoleErrorDev;
     Scheduler = require('scheduler');
 
     const InternalTestUtils = require('internal-test-utils');
@@ -666,7 +659,7 @@ describe('ReactUpdates', () => {
         a = this;
       }
       componentDidUpdate() {
-        expect(findDOMNode(b).textContent).toBe('B1');
+        expect(ReactDOM.findDOMNode(b).textContent).toBe('B1');
         aUpdated = true;
       }
 
@@ -763,6 +756,7 @@ describe('ReactUpdates', () => {
       });
     });
 
+    /* eslint-disable indent */
     expect(updates).toEqual([
       'Outer-render-0',
       'Inner-render-0-0',
@@ -791,6 +785,7 @@ describe('ReactUpdates', () => {
       'Inner-didUpdate-2-2',
       'Inner-callback-2',
     ]);
+    /* eslint-enable indent */
   });
 
   it('should flush updates in the correct order across roots', async () => {
@@ -806,7 +801,7 @@ describe('ReactUpdates', () => {
       componentDidMount() {
         instances.push(this);
         if (this.props.depth < this.props.count) {
-          const root = ReactDOMClient.createRoot(findDOMNode(this));
+          const root = ReactDOMClient.createRoot(ReactDOM.findDOMNode(this));
           root.render(
             <MockComponent
               depth={this.props.depth + 1}
@@ -894,12 +889,12 @@ describe('ReactUpdates', () => {
       root.render(<Y ref={current => (y = current)} />);
     });
 
-    expect(findDOMNode(x).textContent).toBe('0');
+    expect(ReactDOM.findDOMNode(x).textContent).toBe('0');
 
     await act(() => {
       y.forceUpdate();
     });
-    expect(findDOMNode(x).textContent).toBe('1');
+    expect(ReactDOM.findDOMNode(x).textContent).toBe('1');
   });
 
   it('should queue updates from during mount', async () => {
@@ -1042,20 +1037,18 @@ describe('ReactUpdates', () => {
       root.render(<A ref={current => (component = current)} />);
     });
 
-    await expect(async () => {
-      await act(() => {
-        component.setState({}, 'no');
-      });
-    }).rejects.toThrowError(
-      'Invalid argument passed as callback. Expected a function. Instead ' +
-        'received: no',
-    );
-    assertConsoleErrorDev(
-      [
+    await expect(
+      expect(async () => {
+        await act(() => {
+          component.setState({}, 'no');
+        });
+      }).toErrorDev(
         'Expected the last optional `callback` argument to be ' +
           'a function. Instead received: no.',
-      ],
-      {withoutStack: true},
+      ),
+    ).rejects.toThrowError(
+      'Invalid argument passed as callback. Expected a function. Instead ' +
+        'received: no',
     );
     container = document.createElement('div');
     root = ReactDOMClient.createRoot(container);
@@ -1063,21 +1056,19 @@ describe('ReactUpdates', () => {
       root.render(<A ref={current => (component = current)} />);
     });
 
-    await expect(async () => {
-      await act(() => {
-        component.setState({}, {foo: 'bar'});
-      });
-    }).rejects.toThrowError(
+    await expect(
+      expect(async () => {
+        await act(() => {
+          component.setState({}, {foo: 'bar'});
+        });
+      }).toErrorDev(
+        'Expected the last optional `callback` argument to be ' +
+          'a function. Instead received: [object Object].',
+      ),
+    ).rejects.toThrowError(
       'Invalid argument passed as callback. Expected a function. Instead ' +
         'received: [object Object]',
     );
-    assertConsoleErrorDev(
-      [
-        'Expected the last optional `callback` argument to be ' +
-          "a function. Instead received: { foo: 'bar' }.",
-      ],
-      {withoutStack: true},
-    );
     container = document.createElement('div');
     root = ReactDOMClient.createRoot(container);
     await act(() => {
@@ -1115,20 +1106,18 @@ describe('ReactUpdates', () => {
       root.render(<A ref={current => (component = current)} />);
     });
 
-    await expect(async () => {
-      await act(() => {
-        component.forceUpdate('no');
-      });
-    }).rejects.toThrowError(
-      'Invalid argument passed as callback. Expected a function. Instead ' +
-        'received: no',
-    );
-    assertConsoleErrorDev(
-      [
+    await expect(
+      expect(async () => {
+        await act(() => {
+          component.forceUpdate('no');
+        });
+      }).toErrorDev(
         'Expected the last optional `callback` argument to be ' +
           'a function. Instead received: no.',
-      ],
-      {withoutStack: true},
+      ),
+    ).rejects.toThrowError(
+      'Invalid argument passed as callback. Expected a function. Instead ' +
+        'received: no',
     );
     container = document.createElement('div');
     root = ReactDOMClient.createRoot(container);
@@ -1136,21 +1125,19 @@ describe('ReactUpdates', () => {
       root.render(<A ref={current => (component = current)} />);
     });
 
-    await expect(async () => {
-      await act(() => {
-        component.forceUpdate({foo: 'bar'});
-      });
-    }).rejects.toThrowError(
+    await expect(
+      expect(async () => {
+        await act(() => {
+          component.forceUpdate({foo: 'bar'});
+        });
+      }).toErrorDev(
+        'Expected the last optional `callback` argument to be ' +
+          'a function. Instead received: [object Object].',
+      ),
+    ).rejects.toThrowError(
       'Invalid argument passed as callback. Expected a function. Instead ' +
         'received: [object Object]',
     );
-    assertConsoleErrorDev(
-      [
-        'Expected the last optional `callback` argument to be ' +
-          "a function. Instead received: { foo: 'bar' }.",
-      ],
-      {withoutStack: true},
-    );
     // Make sure the warning is deduplicated and doesn't fire again
     container = document.createElement('div');
     root = ReactDOMClient.createRoot(container);
@@ -1362,14 +1349,11 @@ describe('ReactUpdates', () => {
 
     const container = document.createElement('div');
     const root = ReactDOMClient.createRoot(container);
-    await act(() => {
-      root.render(<Foo />);
-    });
-    assertConsoleErrorDev([
-      'Cannot update during an existing state transition (such as within `render`). ' +
-        'Render methods should be a pure function of props and state.\n' +
-        '    in Foo (at **)',
-    ]);
+    await expect(async () => {
+      await act(() => {
+        root.render(<Foo />);
+      });
+    }).toErrorDev('Cannot update during an existing state transition');
 
     assertLog(['base: 0, memoized: 0', 'base: 1, memoized: 1']);
   });
@@ -1558,11 +1542,11 @@ describe('ReactUpdates', () => {
 
     let limit = 55;
     const root = ReactDOMClient.createRoot(container);
-    await expect(async () => {
-      await act(() => {
+    expect(() => {
+      ReactDOM.flushSync(() => {
         root.render(<EventuallyTerminating ref={ref} />);
       });
-    }).rejects.toThrow('Maximum');
+    }).toThrow('Maximum');
 
     // Verify that we don't go over the limit if these updates are unrelated.
     limit -= 10;
@@ -1575,22 +1559,21 @@ describe('ReactUpdates', () => {
       ref.current.setState({step: 0});
     });
     expect(container.textContent).toBe(limit.toString());
-
     await act(() => {
       ref.current.setState({step: 0});
     });
     expect(container.textContent).toBe(limit.toString());
 
     limit += 10;
-    await expect(async () => {
-      await act(() => {
+    expect(() => {
+      ReactDOM.flushSync(() => {
         ref.current.setState({step: 0});
       });
-    }).rejects.toThrow('Maximum');
+    }).toThrow('Maximum');
     expect(ref.current).toBe(null);
   });
 
-  it('does not fall into an infinite update loop', async () => {
+  it('does not fall into an infinite update loop', () => {
     class NonTerminating extends React.Component {
       state = {step: 0};
 
@@ -1615,29 +1598,47 @@ describe('ReactUpdates', () => {
     const container = document.createElement('div');
     const root = ReactDOMClient.createRoot(container);
 
-    await expect(async () => {
-      await act(() => {
+    expect(() => {
+      ReactDOM.flushSync(() => {
         root.render(<NonTerminating />);
       });
-    }).rejects.toThrow('Maximum');
+    }).toThrow('Maximum');
   });
 
-  it('does not fall into an infinite update loop with useLayoutEffect', async () => {
-    function NonTerminating() {
-      const [step, setStep] = React.useState(0);
-      React.useLayoutEffect(() => {
-        setStep(x => x + 1);
-      });
-      return step;
+  it('does not fall into an infinite error loop', () => {
+    function BadRender() {
+      throw new Error('error');
+    }
+
+    class ErrorBoundary extends React.Component {
+      componentDidCatch() {
+        // Schedule a no-op state update to avoid triggering a DEV warning in the test.
+        this.setState({});
+
+        this.props.parent.remount();
+      }
+      render() {
+        return <BadRender />;
+      }
+    }
+
+    class NonTerminating extends React.Component {
+      state = {step: 0};
+      remount() {
+        this.setState(state => ({step: state.step + 1}));
+      }
+      render() {
+        return <ErrorBoundary key={this.state.step} parent={this} />;
+      }
     }
 
     const container = document.createElement('div');
     const root = ReactDOMClient.createRoot(container);
-    await expect(async () => {
-      await act(() => {
+    expect(() => {
+      ReactDOM.flushSync(() => {
         root.render(<NonTerminating />);
       });
-    }).rejects.toThrow('Maximum');
+    }).toThrow('Maximum');
   });
 
   it('can recover after falling into an infinite update loop', async () => {
@@ -1666,29 +1667,29 @@ describe('ReactUpdates', () => {
 
     const container = document.createElement('div');
     const root = ReactDOMClient.createRoot(container);
-    await expect(async () => {
-      await act(() => {
+    expect(() => {
+      ReactDOM.flushSync(() => {
         root.render(<NonTerminating />);
       });
-    }).rejects.toThrow('Maximum');
+    }).toThrow('Maximum');
 
     await act(() => {
       root.render(<Terminating />);
     });
     expect(container.textContent).toBe('1');
 
-    await expect(async () => {
-      await act(() => {
+    expect(() => {
+      ReactDOM.flushSync(() => {
         root.render(<NonTerminating />);
       });
-    }).rejects.toThrow('Maximum');
+    }).toThrow('Maximum');
     await act(() => {
       root.render(<Terminating />);
     });
     expect(container.textContent).toBe('1');
   });
 
-  it('does not fall into mutually recursive infinite update loop with same container', async () => {
+  it('does not fall into mutually recursive infinite update loop with same container', () => {
     // Note: this test would fail if there were two or more different roots.
     const container = document.createElement('div');
     const root = ReactDOMClient.createRoot(container);
@@ -1710,150 +1711,11 @@ describe('ReactUpdates', () => {
       }
     }
 
-    await expect(async () => {
-      await act(() => {
+    expect(() => {
+      ReactDOM.flushSync(() => {
         root.render(<A />);
       });
-    }).rejects.toThrow('Maximum');
-  });
-
-  it('does not fall into an infinite error loop', async () => {
-    function BadRender() {
-      throw new Error('error');
-    }
-
-    class ErrorBoundary extends React.Component {
-      componentDidCatch() {
-        // Schedule a no-op state update to avoid triggering a DEV warning in the test.
-        this.setState({});
-
-        this.props.parent.remount();
-      }
-      render() {
-        return <BadRender />;
-      }
-    }
-
-    class NonTerminating extends React.Component {
-      state = {step: 0};
-      remount() {
-        this.setState(state => ({step: state.step + 1}));
-      }
-      render() {
-        return <ErrorBoundary key={this.state.step} parent={this} />;
-      }
-    }
-
-    const container = document.createElement('div');
-    const root = ReactDOMClient.createRoot(container);
-    await expect(async () => {
-      await act(() => {
-        root.render(<NonTerminating />);
-      });
-    }).rejects.toThrow('Maximum');
-  });
-
-  it('can schedule ridiculously many updates within the same batch without triggering a maximum update error', async () => {
-    const subscribers = [];
-    const limit = 1200;
-    class Child extends React.Component {
-      state = {value: 'initial'};
-      componentDidMount() {
-        subscribers.push(this);
-      }
-      render() {
-        return null;
-      }
-    }
-
-    class App extends React.Component {
-      render() {
-        const children = [];
-        for (let i = 0; i < limit; i++) {
-          children.push(<Child key={i} />);
-        }
-        return children;
-      }
-    }
-
-    const container = document.createElement('div');
-    const root = ReactDOMClient.createRoot(container);
-    await act(() => {
-      root.render(<App />);
-    });
-
-    await act(() => {
-      subscribers.forEach(s => {
-        s.setState({value: 'update'});
-      });
-    });
-
-    expect(subscribers.length).toBe(limit);
-  });
-
-  it("does not infinite loop if there's a synchronous render phase update on another component", async () => {
-    if (gate(flags => !flags.enableInfiniteRenderLoopDetection)) {
-      return;
-    }
-    let setState;
-    function App() {
-      const [, _setState] = React.useState(0);
-      setState = _setState;
-      return <Child />;
-    }
-
-    function Child(step) {
-      // This will cause an infinite update loop, and a warning in dev.
-      setState(n => n + 1);
-      return null;
-    }
-
-    const container = document.createElement('div');
-    const root = ReactDOMClient.createRoot(container);
-
-    await expect(async () => {
-      await act(() => ReactDOM.flushSync(() => root.render(<App />)));
-    }).rejects.toThrow('Maximum update depth exceeded');
-    assertConsoleErrorDev([
-      'Cannot update a component (`App`) while rendering a different component (`Child`). ' +
-        'To locate the bad setState() call inside `Child`, ' +
-        'follow the stack trace as described in https://react.dev/link/setstate-in-render\n' +
-        '    in App (at **)',
-    ]);
-  });
-
-  it("does not infinite loop if there's an async render phase update on another component", async () => {
-    if (gate(flags => !flags.enableInfiniteRenderLoopDetection)) {
-      return;
-    }
-    let setState;
-    function App() {
-      const [, _setState] = React.useState(0);
-      setState = _setState;
-      return <Child />;
-    }
-
-    function Child(step) {
-      // This will cause an infinite update loop, and a warning in dev.
-      setState(n => n + 1);
-      return null;
-    }
-
-    const container = document.createElement('div');
-    const root = ReactDOMClient.createRoot(container);
-
-    await expect(async () => {
-      await act(() => {
-        React.startTransition(() => root.render(<App />));
-      });
-    }).rejects.toThrow('Maximum update depth exceeded');
-
-    assertConsoleErrorDev([
-      'Cannot update a component (`App`) while rendering a different component (`Child`). ' +
-        'To locate the bad setState() call inside `Child`, ' +
-        'follow the stack trace as described in https://react.dev/link/setstate-in-render\n' +
-        '    in App (at **)',
-    ]);
+    }).toThrow('Maximum');
   });
 
   // TODO: Replace this branch with @gate pragmas
@@ -1861,7 +1723,7 @@ describe('ReactUpdates', () => {
     it('warns about a deferred infinite update loop with useEffect', async () => {
       function NonTerminating() {
         const [step, setStep] = React.useState(0);
-        React.useEffect(function myEffect() {
+        React.useEffect(() => {
           setStep(x => x + 1);
         });
         return step;
@@ -1872,13 +1734,11 @@ describe('ReactUpdates', () => {
       }
 
       let error = null;
-      let ownerStack = null;
-      let debugStack = null;
+      let stack = null;
       const originalConsoleError = console.error;
-      console.error = e => {
+      console.error = (e, s) => {
         error = e;
-        ownerStack = React.captureOwnerStack();
-        debugStack = new Error().stack;
+        stack = s;
         Scheduler.log('stop');
       };
       try {
@@ -1891,9 +1751,7 @@ describe('ReactUpdates', () => {
       }
 
       expect(error).toContain('Maximum update depth exceeded');
-      // The currently executing effect should be on the native stack
-      expect(debugStack).toContain('at myEffect');
-      expect(ownerStack).toContain('at App');
+      expect(stack).toContain('at NonTerminating');
     });
 
     it('can have nested updates if they do not cross the limit', async () => {
@@ -1913,12 +1771,9 @@ describe('ReactUpdates', () => {
       }
 
       const container = document.createElement('div');
-      const root = ReactDOMClient.createRoot(container);
       await act(() => {
-        root.render(<Terminating />);
+        ReactDOM.render(<Terminating />, container);
       });
-
-      assertLog(Array.from({length: LIMIT + 1}, (_, k) => k));
       expect(container.textContent).toBe('50');
       await act(() => {
         _setStep(0);
@@ -1939,9 +1794,8 @@ describe('ReactUpdates', () => {
       }
 
       const container = document.createElement('div');
-      const root = ReactDOMClient.createRoot(container);
       await act(() => {
-        root.render(<Terminating />);
+        ReactDOM.render(<Terminating />, container);
       });
 
       assertLog(['Done']);
@@ -1949,7 +1803,7 @@ describe('ReactUpdates', () => {
     });
   }
 
-  it('prevents infinite update loop triggered by synchronous updates in useEffect', async () => {
+  it('prevents infinite update loop triggered by synchronous updates in useEffect', () => {
     // Ignore flushSync warning
     spyOnDev(console, 'error').mockImplementation(() => {});
 
@@ -1973,12 +1827,112 @@ describe('ReactUpdates', () => {
 
     const container = document.createElement('div');
     const root = ReactDOMClient.createRoot(container);
+    expect(() => {
+      ReactDOM.flushSync(() => {
+        root.render(<NonTerminating />);
+      });
+    }).toThrow('Maximum update depth exceeded');
+  });
+
+  it('can schedule ridiculously many updates within the same batch without triggering a maximum update error', async () => {
+    const subscribers = [];
+    const limit = 1200;
+    class Child extends React.Component {
+      state = {value: 'initial'};
+      componentDidMount() {
+        subscribers.push(this);
+      }
+      render() {
+        return null;
+      }
+    }
+
+    class App extends React.Component {
+      render() {
+        const children = [];
+        for (let i = 0; i < limit; i++) {
+          children.push(<Child key={i} />);
+        }
+        return children;
+      }
+    }
+
+    const container = document.createElement('div');
+    const root = ReactDOMClient.createRoot(container);
+    await act(() => {
+      root.render(<App />);
+    });
+
+    await act(() => {
+      subscribers.forEach(s => {
+        s.setState({value: 'update'});
+      });
+    });
+
+    expect(subscribers.length).toBe(limit);
+  });
+
+  it("does not infinite loop if there's a synchronous render phase update on another component", () => {
+    if (gate(flags => !flags.enableInfiniteRenderLoopDetection)) {
+      return;
+    }
+    let setState;
+    function App() {
+      const [, _setState] = React.useState(0);
+      setState = _setState;
+      return <Child />;
+    }
+
+    function Child(step) {
+      // This will cause an infinite update loop, and a warning in dev.
+      setState(n => n + 1);
+      return null;
+    }
+
+    const container = document.createElement('div');
+    const root = ReactDOMClient.createRoot(container);
+
+    expect(() => {
+      expect(() => ReactDOM.flushSync(() => root.render(<App />))).toThrow(
+        'Maximum update depth exceeded',
+      );
+    }).toErrorDev(
+      'Warning: Cannot update a component (`App`) while rendering a different component (`Child`)',
+    );
+  });
+
+  it("does not infinite loop if there's an async render phase update on another component", async () => {
+    if (gate(flags => !flags.enableInfiniteRenderLoopDetection)) {
+      return;
+    }
+    let setState;
+    function App() {
+      const [, _setState] = React.useState(0);
+      setState = _setState;
+      return <Child />;
+    }
+
+    function Child(step) {
+      // This will cause an infinite update loop, and a warning in dev.
+      setState(n => n + 1);
+      return null;
+    }
+
+    const container = document.createElement('div');
+    const root = ReactDOMClient.createRoot(container);
+
     await expect(async () => {
-      await act(() => {
-        ReactDOM.flushSync(() => {
-          root.render(<NonTerminating />);
+      let error;
+      try {
+        await act(() => {
+          React.startTransition(() => root.render(<App />));
         });
-      });
-    }).rejects.toThrow('Maximum update depth exceeded');
+      } catch (e) {
+        error = e;
+      }
+      expect(error.message).toMatch('Maximum update depth exceeded');
+    }).toErrorDev(
+      'Warning: Cannot update a component (`App`) while rendering a different component (`Child`)',
+    );
   });
 });
\ No newline at end of file
