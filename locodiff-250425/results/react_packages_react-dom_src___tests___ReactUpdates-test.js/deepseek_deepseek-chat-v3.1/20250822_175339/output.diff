
index ee4adf12f..79b08d692 100644
--- a/react_packages_react-dom_src___tests___ReactUpdates-test.js_expectedoutput.txt (expected):tmp/tmpl73m_fb7_expected.txt	
+++ b/react_packages_react-dom_src___tests___ReactUpdates-test.js_extracted.txt (actual):tmp/tmp5cvjd_4d_actual.txt	
@@ -737,12 +737,16 @@ describe('ReactUpdates', () => {
       state = {x: 0};
 
       render() {
-        updates.push('Inner-render-' + this.props.x + '-' + this.state.x);
+        updates.push(
+          'Inner-render-' + this.props.x + '-' + this.state.x,
+        );
         return <div />;
       }
 
       componentDidUpdate() {
-        updates.push('Inner-didUpdate-' + this.props.x + '-' + this.state.x);
+        updates.push(
+          'Inner-didUpdate-' + this.props.x + '-' + this.state.x,
+        );
       }
     }
 
@@ -1378,6 +1382,7 @@ describe('ReactUpdates', () => {
     const container = document.createElement('div');
 
     let instance;
+    let ops = [];
     class Foo extends React.Component {
       render() {
         instance = this;
@@ -1470,14 +1475,14 @@ describe('ReactUpdates', () => {
 
     const root = ReactDOMClient.createRoot(container);
     let hiddenDiv;
-    await act(async () => {
+    await act(() => {
       root.render(<Foo />);
-      await waitFor(['Foo', 'Baz', 'Foo#effect']);
+      expect(Scheduler).toFlushAndYieldThrough(['Foo', 'Baz', 'Foo#effect']);
       hiddenDiv = container.firstChild.firstChild;
       expect(hiddenDiv.hidden).toBe(true);
       expect(hiddenDiv.innerHTML).toBe('');
       // Run offscreen update
-      await waitForAll(['Bar']);
+      expect(Scheduler).toFlushAndYield(['Bar']);
       expect(hiddenDiv.hidden).toBe(true);
       expect(hiddenDiv.innerHTML).toBe('<p>bar 0</p>');
     });
@@ -1497,7 +1502,7 @@ describe('ReactUpdates', () => {
     function Component({trigger}) {
       const [state, setState] = React.useState(0);
 
-      React.useEffect(() => {
+      React.useEffect() {
         if (trigger) {
           Scheduler.log('Trigger');
           setState(c => c + 1);
@@ -1791,71 +1796,6 @@ describe('ReactUpdates', () => {
     expect(subscribers.length).toBe(limit);
   });
 
-  it("does not infinite loop if there's a synchronous render phase update on another component", async () => {
-    if (gate(flags => !flags.enableInfiniteRenderLoopDetection)) {
-      return;
-    }
-    let setState;
-    function App() {
-      const [, _setState] = React.useState(0);
-      setState = _setState;
-      return <Child />;
-    }
-
-    function Child(step) {
-      // This will cause an infinite update loop, and a warning in dev.
-      setState(n => n + 1);
-      return null;
-    }
-
-    const container = document.createElement('div');
-    const root = ReactDOMClient.createRoot(container);
-
-    await expect(async () => {
-      await act(() => ReactDOM.flushSync(() => root.render(<App />)));
-    }).rejects.toThrow('Maximum update depth exceeded');
-    assertConsoleErrorDev([
-      'Cannot update a component (`App`) while rendering a different component (`Child`). ' +
-        'To locate the bad setState() call inside `Child`, ' +
-        'follow the stack trace as described in https://react.dev/link/setstate-in-render\n' +
-        '    in App (at **)',
-    ]);
-  });
-
-  it("does not infinite loop if there's an async render phase update on another component", async () => {
-    if (gate(flags => !flags.enableInfiniteRenderLoopDetection)) {
-      return;
-    }
-    let setState;
-    function App() {
-      const [, _setState] = React.useState(0);
-      setState = _setState;
-      return <Child />;
-    }
-
-    function Child(step) {
-      // This will cause an infinite update loop, and a warning in dev.
-      setState(n => n + 1);
-      return null;
-    }
-
-    const container = document.createElement('div');
-    const root = ReactDOMClient.createRoot(container);
-
-    await expect(async () => {
-      await act(() => {
-        React.startTransition(() => root.render(<App />));
-      });
-    }).rejects.toThrow('Maximum update depth exceeded');
-
-    assertConsoleErrorDev([
-      'Cannot update a component (`App`) while rendering a different component (`Child`). ' +
-        'To locate the bad setState() call inside `Child`, ' +
-        'follow the stack trace as described in https://react.dev/link/setstate-in-render\n' +
-        '    in App (at **)',
-    ]);
-  });
-
   // TODO: Replace this branch with @gate pragmas
   if (__DEV__) {
     it('warns about a deferred infinite update loop with useEffect', async () => {
@@ -1923,62 +1863,4 @@ describe('ReactUpdates', () => {
       await act(() => {
         _setStep(0);
       });
-      expect(container.textContent).toBe('50');
-    });
-
-    it('can have many updates inside useEffect without triggering a warning', async () => {
-      function Terminating() {
-        const [step, setStep] = React.useState(0);
-        React.useEffect(() => {
-          for (let i = 0; i < 1000; i++) {
-            setStep(x => x + 1);
-          }
-          Scheduler.log('Done');
-        }, []);
-        return step;
-      }
-
-      const container = document.createElement('div');
-      const root = ReactDOMClient.createRoot(container);
-      await act(() => {
-        root.render(<Terminating />);
-      });
-
-      assertLog(['Done']);
-      expect(container.textContent).toBe('1000');
-    });
-  }
-
-  it('prevents infinite update loop triggered by synchronous updates in useEffect', async () => {
-    // Ignore flushSync warning
-    spyOnDev(console, 'error').mockImplementation(() => {});
-
-    function NonTerminating() {
-      const [step, setStep] = React.useState(0);
-      React.useEffect(() => {
-        // Other examples of synchronous updates in useEffect are imperative
-        // event dispatches like `el.focus`, or `useSyncExternalStore`, which
-        // may schedule a synchronous update upon subscribing if it detects
-        // that the store has been mutated since the initial render.
-        //
-        // (Originally I wrote this test using `el.focus` but those errors
-        // get dispatched in a JSDOM event and I don't know how to "catch" those
-        // so that they don't fail the test.)
-        ReactDOM.flushSync(() => {
-          setStep(step + 1);
-        });
-      }, [step]);
-      return step;
-    }
-
-    const container = document.createElement('div');
-    const root = ReactDOMClient.createRoot(container);
-    await expect(async () => {
-      await act(() => {
-        ReactDOM.flushSync(() => {
-          root.render(<NonTerminating />);
-        });
-      });
-    }).rejects.toThrow('Maximum update depth exceeded');
-  });
-});
\ No newline at end of file
+      expect
\ No newline at end of file
