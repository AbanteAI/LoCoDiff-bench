
index c9341cb38..a6f772ba2 100644
--- a/qdrant_lib_collection_src_shards_local_shard_mod.rs_expectedoutput.txt (expected):tmp/tmp5rr6bg5r_expected.txt	
+++ b/qdrant_lib_collection_src_shards_local_shard_mod.rs_extracted.txt (actual):tmp/tmptsec01tg_actual.txt	
@@ -11,8 +11,8 @@ mod telemetry;
 use std::collections::{BTreeSet, HashMap};
 use std::ops::Deref;
 use std::path::{Path, PathBuf};
-use std::sync::Arc;
 use std::sync::atomic::{AtomicBool, AtomicUsize};
+use std::sync::Arc;
 use std::thread;
 use std::time::{Duration, Instant};
 
@@ -37,7 +37,7 @@ use segment::types::{
 use tokio::fs::{create_dir_all, remove_dir_all, remove_file};
 use tokio::runtime::Handle;
 use tokio::sync::mpsc::Sender;
-use tokio::sync::{Mutex, RwLock as TokioRwLock, mpsc, oneshot};
+use tokio::sync::{mpsc, oneshot, Mutex, RwLock as TokioRwLock};
 use wal::{Wal, WalOptions};
 
 use self::clock_map::{ClockMap, RecoveryPoint};
@@ -52,17 +52,17 @@ use crate::collection_manager::optimizers::TrackerLog;
 use crate::collection_manager::segments_searcher::SegmentsSearcher;
 use crate::common::file_utils::{move_dir, move_file};
 use crate::config::CollectionConfigInternal;
-use crate::operations::OperationWithClockTag;
 use crate::operations::shared_storage_config::SharedStorageConfig;
 use crate::operations::types::{
-    CollectionError, CollectionResult, OptimizersStatus, ShardInfoInternal, ShardStatus,
-    check_sparse_compatible_with_segment_config,
+    check_sparse_compatible_with_segment_config, CollectionError, CollectionResult,
+    OptimizersStatus, ShardInfoInternal, ShardStatus,
 };
-use crate::optimizers_builder::{OptimizersConfig, build_optimizers, clear_temp_segments};
+use crate::operations::OperationWithClockTag;
+use crate::optimizers_builder::{build_optimizers, clear_temp_segments, OptimizersConfig};
 use crate::save_on_disk::SaveOnDisk;
-use crate::shards::CollectionId;
 use crate::shards::shard::ShardId;
 use crate::shards::shard_config::ShardConfig;
+use crate::shards::CollectionId;
 use crate::update_handler::{Optimizer, UpdateHandler, UpdateSignal};
 use crate::wal::SerdeWal;
 use crate::wal_delta::{LockedWal, RecoverableWal};
@@ -698,7 +698,6 @@ impl LocalShard {
                     }
                 }
             }
-
             // Force a flush after re-applying WAL operations, to ensure we maintain on-disk data
             // consistency, if we happened to only apply *past* operations to a segment with newer
             // version.
@@ -720,35 +719,6 @@ impl LocalShard {
         Ok(())
     }
 
-    /// Check data consistency for all segments
-    ///
-    /// Returns an error at the first inconsistent segment
-    pub fn check_data_consistency(&self) -> CollectionResult<()> {
-        log::info!("Checking data consistency for shard {:?}", self.path);
-        let segments = self.segments.read();
-        for (_idx, segment) in segments.iter() {
-            match segment {
-                LockedSegment::Original(raw_segment) => {
-                    let segment_guard = raw_segment.read();
-                    if let Err(err) = segment_guard.check_data_consistency() {
-                        log::error!(
-                            "Segment {:?} is inconsistent: {}",
-                            segment_guard.current_path,
-                            err
-                        );
-                        return Err(err.into());
-                    }
-                }
-                LockedSegment::Proxy(_) => {
-                    return Err(CollectionError::service_error(
-                        "Proxy segment found in check_data_consistency",
-                    ));
-                }
-            }
-        }
-        Ok(())
-    }
-
     pub async fn on_optimizer_config_update(&self) -> CollectionResult<()> {
         let config = self.collection_config.read().await;
         let mut update_handler = self.update_handler.lock().await;
@@ -847,7 +817,7 @@ impl LocalShard {
         Ok(())
     }
 
-    /// Create snapshot for local shard into `target_path`
+    /// Create snapshot for local shard into `tar`
     pub async fn create_snapshot(
         &self,
         temp_path: &Path,
@@ -868,7 +838,6 @@ impl LocalShard {
             rx.await?;
         }
 
-        let segments_path = Self::segments_path(&self.path);
         let collection_params = self.collection_config.read().await.params.clone();
         let temp_path = temp_path.to_owned();
         let payload_index_schema = self.payload_index_schema.clone();
@@ -878,7 +847,7 @@ impl LocalShard {
             // Do not change segments while snapshotting
             SegmentHolder::snapshot_all_segments(
                 segments.clone(),
-                &segments_path,
+                &LocalShard::segments_path(&temp_path),
                 Some(&collection_params),
                 &payload_index_schema.read().clone(),
                 &temp_path,
@@ -982,9 +951,9 @@ impl LocalShard {
             .map_err(CollectionError::from)
     }
 
-    pub fn estimate_cardinality<'a>(
-        &'a self,
-        filter: Option<&'a Filter>,
+    pub fn estimate_cardinality(
+        &self,
+        filter: Option<&Filter>,
         hw_counter: &HardwareCounterCell,
     ) -> CollectionResult<CardinalityEstimation> {
         let segments = self.segments().read();
@@ -1007,9 +976,9 @@ impl LocalShard {
         Ok(cardinality)
     }
 
-    pub async fn read_filtered<'a>(
-        &'a self,
-        filter: Option<&'a Filter>,
+    pub async fn read_filtered(
+        &self,
+        filter: Option<&Filter>,
         runtime_handle: &Handle,
         hw_counter: HwMeasurementAcc,
     ) -> CollectionResult<BTreeSet<PointIdType>> {
@@ -1154,6 +1123,35 @@ impl LocalShard {
         }
         Ok(())
     }
+
+    /// Check data consistency for all segments
+    ///
+    /// Returns an error at the first inconsistent segment
+    pub fn check_data_consistency(&self) -> CollectionResult<()> {
+        log::info!("Checking data consistency for shard {:?}", self.path);
+        let segments = self.segments.read();
+        for (_idx, segment) in segments.iter() {
+            match segment {
+                LockedSegment::Original(raw_segment) => {
+                    let segment_guard = raw_segment.read();
+                    if let Err(err) = segment_guard.check_data_consistency() {
+                        log::error!(
+                            "Segment {:?} is inconsistent: {}",
+                            segment_guard.current_path,
+                            err
+                        );
+                        return Err(err.into());
+                    }
+                }
+                LockedSegment::Proxy(_) => {
+                    return Err(CollectionError::service_error(
+                        "Proxy segment found in check_data_consistency",
+                    ));
+                }
+            }
+        }
+        Ok(())
+    }
 }
 
 impl Drop for LocalShard {
