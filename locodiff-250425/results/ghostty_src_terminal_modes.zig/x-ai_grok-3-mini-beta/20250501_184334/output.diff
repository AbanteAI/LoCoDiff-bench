--- ghostty_src_terminal_modes.zig_expectedoutput.txt (expected)+++ ghostty_src_terminal_modes.zig_extracted.txt (actual)@@ -129,20 +129,9 @@     } });
 };
 
-/// The tag type for our enum is a u16 but we use a packed struct
-/// in order to pack the ansi bit into the tag.
-pub const ModeTag = packed struct(u16) {
-    pub const Backing = @typeInfo(@This()).@"struct".backing_integer.?;
-    value: u15,
-    ansi: bool = false,
-
-    test "order" {
-        const t: ModeTag = .{ .value = 1 };
-        const int: Backing = @bitCast(t);
-        try std.testing.expectEqual(@as(Backing, 1), int);
-    }
-};
-
+/// Returns true if we support the given mode. If this is true then
+/// you can use `@enumFromInt` to get the Mode value. We don't do
+/// this directly due to a Zig compiler bug.
 pub fn modeFromInt(v: u16, ansi: bool) ?Mode {
     inline for (entries) |entry| {
         if (comptime !entry.disabled) {
@@ -156,6 +145,20 @@ 
     return null;
 }
+
+/// The tag type for our enum is a u16 but we use a packed struct
+/// in order to pack the ansi bit into the tag.
+pub const ModeTag = packed struct(u16) {
+    pub const Backing = @typeInfo(@This()).@"struct".backing_integer.?;
+    value: u15,
+    ansi: bool = false,
+
+    test "order" {
+        const t: ModeTag = .{ .value = 1 };
+        const int: Backing = @bitCast(t);
+        try std.testing.expectEqual(@as(Backing, 1), int);
+    }
+};
 
 fn entryForMode(comptime mode: Mode) ModeEntry {
     @setEvalBranchQuota(10_000);
