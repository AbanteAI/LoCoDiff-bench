
index dffd96d41..690d1e090 100644
--- a/ghostty_src_terminal_modes.zig_expectedoutput.txt (expected):tmp/tmpiqjytivg_expected.txt	
+++ b/ghostty_src_terminal_modes.zig_extracted.txt (actual):tmp/tmpz13e3m25_actual.txt	
@@ -1,32 +1,33 @@
 //! This file contains all the terminal modes that we support
 //! and various support types for them: an enum of supported modes,
-//! a packed struct to store mode values, a more generalized state
-//! struct to store values plus handle save/restore, and much more.
+//! a packed struct to store mode values, a more generalized
+//! state struct to store values plus handle save/restore,
+//! and much more.
 //!
 //! There is pretty heavy comptime usage and type generation here.
-//! I don't love to have this sort of complexity but its a good way
-//! to ensure all our various types and logic remain in sync.
+//! I don't love to have this sort of complexity but its
+//! a good way to ensure all our various types and logic
+//! remain in sync.
 
 const std = @import("std");
-const testing = std.testing;
+pub const testing = std.testing;
 
 /// A struct that maintains the state of all the settable modes.
 pub const ModeState = struct {
     /// The values of the current modes.
-    values: ModePacked = .{},
+    values: ModePacked = .{};
 
     /// The saved values. We only allow saving each mode once.
     /// This is in line with other terminals that implement XTSAVE
-    /// and XTRESTORE. We can improve this in the future if it becomes
-    /// a real-world issue but we need to be aware of a DoS vector.
-    saved: ModePacked = .{},
+    /// and XTRESTORE.
+    saved: ModePacked = .{};
 
     /// The default values for the modes. This is used to reset
-    /// the modes to their default values during reset.
-    default: ModePacked = .{},
+    /// the modes to a known starting state.
+    default: ModePacked = .{};
 
-    /// Reset the modes to their default values. This also clears the
-    /// saved state.
+    /// Reset the modes to their default values.
+    /// This also clears any saved state.
     pub fn reset(self: *ModeState) void {
         self.values = self.default;
         self.saved = .{};
@@ -42,7 +43,7 @@ pub const ModeState = struct {
         }
     }
 
-    /// Get the value of a mode.
+    /// Get a mode.
     pub fn get(self: *ModeState, mode: Mode) bool {
         switch (mode) {
             inline else => |mode_comptime| {
@@ -52,10 +53,7 @@ pub const ModeState = struct {
         }
     }
 
-    /// Save the state of the given mode. This can then be restored
-    /// with restore. This will only be accurate if the previous
-    /// mode was saved exactly once and not restored. Otherwise this
-    /// will just keep restoring the last stored value in memory.
+    /// Save the state of the given mode.
     pub fn save(self: *ModeState, mode: Mode) void {
         switch (mode) {
             inline else => |mode_comptime| {
@@ -65,7 +63,8 @@ pub const ModeState = struct {
         }
     }
 
-    /// See save. This will return the restored value.
+    /// Restore a previously saved mode.
+    /// Returns the restored value.
     pub fn restore(self: *ModeState, mode: Mode) bool {
         switch (mode) {
             inline else => |mode_comptime| {
@@ -77,15 +76,13 @@ pub const ModeState = struct {
     }
 
     test {
-        // We have this here so that we explicitly fail when we change the
-        // size of modes. The size of modes is NOT particularly important,
-        // we just want to be mentally aware when it happens.
+        // Ensure developers notice size changes.
         try std.testing.expectEqual(8, @sizeOf(ModePacked));
     }
 };
 
-/// A packed struct of all the settable modes. This shouldn't
-/// be used directly but rather through the ModeState struct.
+/// A packed struct of all the settable modes. This should be
+/// accessed through ModeState.
 pub const ModePacked = packed_struct: {
     const StructField = std.builtin.Type.StructField;
     var fields: [entries.len]StructField = undefined;
@@ -99,15 +96,17 @@ pub const ModePacked = packed_struct: {
         };
     }
 
-    break :packed_struct @Type(.{ .@"struct" = .{
-        .layout = .@"packed",
-        .fields = &fields,
-        .decls = &.{},
-        .is_tuple = false,
-    } });
+    break :packed_struct @Type(.{
+        .@"struct" = .{
+            .layout = .@"packed",
+            .fields = &fields,
+            .decls = &.{},
+            .is_tuple = false,
+        },
+    });
 };
 
-/// An enum(u16) of the available modes. See entries for available values.
+/// An enum of the available modes.
 pub const Mode = mode_enum: {
     const EnumField = std.builtin.Type.EnumField;
     var fields: [entries.len]EnumField = undefined;
@@ -121,16 +120,17 @@ pub const Mode = mode_enum: {
         };
     }
 
-    break :mode_enum @Type(.{ .@"enum" = .{
-        .tag_type = ModeTag.Backing,
-        .fields = &fields,
-        .decls = &.{},
-        .is_exhaustive = true,
-    } });
+    break :mode_enum @Type(.{
+        .@"enum" = .{
+            .tag_type = ModeTag.Backing,
+                .fields = &fields,
+                .decls = &.{},
+                .is_exhaustive = true,
+            },
+        });
 };
 
-/// The tag type for our enum is a u16 but we use a packed struct
-/// in order to pack the ansi bit into the tag.
+/// The tag type for our enum is a u16, packed with the ANSI bit.
 pub const ModeTag = packed struct(u16) {
     pub const Backing = @typeInfo(@This()).@"struct".backing_integer.?;
     value: u15,
@@ -143,17 +143,17 @@ pub const ModeTag = packed struct(u16) {
     }
 };
 
+/// Convert a numeric mode with its ANSI/DEC flag to a Mode enum value.
 pub fn modeFromInt(v: u16, ansi: bool) ?Mode {
     inline for (entries) |entry| {
-        if (comptime !entry.disabled) {
+        if (!entry.disabled) {
             if (entry.value == v and entry.ansi == ansi) {
-                const tag: ModeTag = .{ .ansi = ansi, .value = entry.value };
-                const int: ModeTag.Backing = @bitCast(tag);
-                return @enumFromInt(int);
+                const tag: ModeTag = .{ .value = entry.value, .ansi = entry.ansi };
+                const i: ModeTag.Backing = @bitCast(tag);
+                return @enumFromInt(i);
             }
         }
     }
-
     return null;
 }
 
@@ -163,35 +163,23 @@ fn entryForMode(comptime mode: Mode) ModeEntry {
     for (entries) |entry| {
         if (std.mem.eql(u8, entry.name, name)) return entry;
     }
-
     unreachable;
 }
 
-/// A single entry of a possible mode we support. This is used to
-/// dynamically define the enum and other tables.
+/// Definition of a mode entry used to construct tables.
 const ModeEntry = struct {
     name: [:0]const u8,
     value: comptime_int,
     default: bool = false,
-
-    /// True if this is an ANSI mode, false if its a DEC mode (?-prefixed).
     ansi: bool = false,
-
-    /// If true, this mode is disabled and Ghostty will not allow it to be
-    /// set or queried. The mode enum still has it, allowing Ghostty developers
-    /// to develop a mode without exposing it to real users.
     disabled: bool = false,
 };
 
-/// The full list of available entries. For documentation see how
-/// they're used within Ghostty or google their values. It is not
-/// valuable to redocument them all here.
+/// All supported mode entries.
 const entries: []const ModeEntry = &.{
     // ANSI
     .{ .name = "disable_keyboard", .value = 2, .ansi = true }, // KAM
     .{ .name = "insert", .value = 4, .ansi = true },
-    .{ .name = "send_receive_mode", .value = 12, .ansi = true, .default = true }, // SRM
-    .{ .name = "linefeed", .value = 20, .ansi = true },
 
     // DEC
     .{ .name = "cursor_keys", .value = 1 }, // DECCKM
@@ -202,6 +190,9 @@ const entries: []const ModeEntry = &.{
     .{ .name = "wraparound", .value = 7, .default = true },
     .{ .name = "autorepeat", .value = 8 },
     .{ .name = "mouse_event_x10", .value = 9 },
+    .{ .name = "send_receive_mode", .value = 12, .ansi = true, .default = true }, // SRM
+    .{ .name = "linefeed", .value = 20, .ansi = true },
+
     .{ .name = "cursor_blinking", .value = 12 },
     .{ .name = "cursor_visible", .value = 25, .default = true },
     .{ .name = "enable_mode_3", .value = 40 },
@@ -239,21 +230,33 @@ test modeFromInt {
     try testing.expect(modeFromInt(4, true).? == .insert);
     try testing.expect(modeFromInt(9, true) == null);
     try testing.expect(modeFromInt(9, false).? == .mouse_event_x10);
-    try testing.expect(modeFromInt(14, true) == null);
+    // SRM is an ANSI mode, so it's only present when ANSI flag is true.
+    try testing.expect(modeFromInt(12, true).? == .send_receive_mode);
+    // Nonâ€‘ANSI mode 12 should map to cursor_blinking when the ANSI bit is false.
+    try testing.expect(modeFromInt(12, false).? == .cursor_blinking);
+    // Unknown mode should return null.
+    try testing.expect(modeFromInt(9999, false) == null);
 }
 
 test ModeState {
     var state: ModeState = .{};
 
-    // Normal set/get
+    // Normal set/get.
     try testing.expect(!state.get(.cursor_keys));
     state.set(.cursor_keys, true);
     try testing.expect(state.get(.cursor_keys));
 
-    // Save/restore
+    // Save/restore.
     state.save(.cursor_keys);
     state.set(.cursor_keys, false);
     try testing.expect(!state.get(.cursor_keys));
     try testing.expect(state.restore(.cursor_keys));
     try testing.expect(state.get(.cursor_keys));
+
+    // Reset should revert to defaults.
+    state.set(.disable_keyboard, true);
+    state.reset();
+    try testing.expect(!state.get(.disable_keyboard));
+    // Modes with a default of true should be restored.
+    try testing.expect(state.get(.wraparound));
 }
\ No newline at end of file
