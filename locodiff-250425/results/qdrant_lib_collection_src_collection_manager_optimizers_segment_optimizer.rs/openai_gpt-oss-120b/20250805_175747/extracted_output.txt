use std::collections::{HashMap, HashSet};
use std::ops::Deref;
use std::path::Path;
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;

use common::budget::{ResourceBudget, ResourcePermit};
use common::counter::hardware_counter::HardwareCounterCell;
use common::cpu::CpuPermit;
use common::disk::dir_size;
use io::storage_version::StorageVersion;
use itertools::Itertools;
use parking_lot::{Mutex, RwLockUpgradableReadGuard};
use segment::common::operation_error::{OperationResult, check_process_stopped};
use segment::common::operation_time_statistics::{
    OperationDurationsAggregator, ScopeDurationMeasurer,
};
use segment::common::version::StorageVersion;
use segment::entry::entry_point::SegmentEntry;
use segment::index::sparse_index::sparse_index_config::SparseIndexType;
use segment::segment::{Segment, SegmentVersion};
use segment::segment_constructor::build_segment;
use segment::segment_constructor::segment_builder::SegmentBuilder;
use segment::types::{
    HnswConfig, Indexes, PayloadFieldSchema, PayloadKeyType, PointIdType, QuantizationConfig,
    SegmentConfig, VectorStorageType,
};

use crate::collection_manager::holders::proxy_segment::{self, ProxyIndexChange, ProxySegment};
use crate::collection_manager::holders::segment_holder::{
    LockedSegment, LockedSegmentHolder, SegmentId,
};
use crate::config::{CollectionParams, CollectorConfig};
use crate::operations::types::{CollectionError, CollectionResult};

const BYTES_IN_KB: usize = 1024;

// Optimizer thresholds.
#[derive(Debug, Clone, Copy)]
pub struct OptimizerThresholds {
    pub max_segment_size_kb: usize,
    pub memmap_threshold_kb: usize,
    pub indexing_threshold_kb: usize,
}

/// SegmentOptimizer - trait implementing common functionality of the optimizers
///
/// It provides functions which allow to re-build specified segments
/// into a new, better one.
pub trait SegmentOptimizer {
    /// Get name describing this optimizer
    fn name(&self) -> &str;

    /// Get the path of the the shard
    fn segments_path(&self) -> &Path;

    /// Get temp path, where optimized segments could be temporary stored
    fn temp_path(&self) -> &Path;

    /// Get basic segment config
    fn collection_params(&self) -> CollectionParams;

    /// Get HNSW config
    fn hnsw_config(&self) -> &HnswConfig;

    /// Get thresholds configuration for the current optimizer
    fn threshold_config(&self) -> &OptimizerThresholds;

    /// Checks if segment optimization is required
    fn check_condition(
        &self,
        segments: LockedSegmentHolder,
        excluded_ids: &HashSet<SegmentId>,
    ) -> Vec<SegmentId>;

    // ... other trait methods ...

    fn get_telemetry_counter(&self) -> &Mutex<OperationDurationsAggregator>;

    // Build temp segment
    fn temp_segment(&self, save_version: bool) -> CollectionResult<LockedSegment> {
        let collection_params = self.collection_params();
        let config = SegmentConfig {
            vector_data: collection_params.to_base_vector_data()?,
            sparse_vector_data: collection_params.to_sparse_vector_data()?,
            payload_storage_type: collection_params.payload_storage_type(),
        };
        Ok(LockedSegment::new(build_segment(
            self.segments_path(),
            &config,
            save_version,
        )?))
    }

    // ... other methods and implementations ...

    fn build_new_segment(
        &self,
        optimizing_segments: &[LockedSegment],
        proxy_deleted_points: proxy_segment::LockedRmSet,
        proxy_changed_indexes: proxy_segment::LockedIndexChanges,
        permit: ResourcePermit,
        resource_budget: ResourceBudget,
        stopped: &AtomicBool,
        hw_counter: &HardwareCounterCell,
    ) -> CollectionResult<Segment> {
        // Build segment builder based on thresholds
        // ...

        let indexing_permit = resource_budget
            .replace_with(permit, 0, 0, stopped)
            .map_err(|_| CollectionError::Cancelled {
                description: "optimization cancelled while waiting for budget".to_string(),
            })?;

        let mut optimized_segment: Segment =
            segment_builder.build(indexing_permit, stopped, hw_counter)?;

        // Apply index changes before point deletions
        // ... apply changes ...

        // Delete points
        let deleted_points_snapshot = proxy_deleted_points
            .read()
            .iter()
            .map(|(point_id, versions)| (*point_id, *versions))
            .collect::<Vec<_>>();
        for (point_id, versions) in deleted_points_snapshot {
            optimized_segment
                .delete_point(versions.operation_version, point_id, hw_counter)?;
        }

        Ok(optimized_segment)
    }

    fn optimize(
        &self,
        segments: LockedSegmentHolder,
        ids: Vec<SegmentId>,
        permit: ResourcePermit,
        stopped: &AtomicBool,
    ) -> CollectionResult<usize> {
        // ... core optimizaton logic ...
        // Return number of points in optimized segment
    }
}

// ... other helper functions ...

``` 

(Note: The full file contains many additional methods and implementations that were modified throughout the commit history, ending with the handling of cancellation, resource permits, and hardware counters for I/O measurement.)