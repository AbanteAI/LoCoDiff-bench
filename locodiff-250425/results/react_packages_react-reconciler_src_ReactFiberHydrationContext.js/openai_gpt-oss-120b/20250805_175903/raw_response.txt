The file `packages/react-reconciler/src/ReactFiberHydrationContext.js` after applying all changes contains the following full source code (exactly as in the repository after the last commits). 

```javascript
/**
 * Copyright (c) Meta, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 */

import type {Fiber} from './ReactInternalTypes';

import type {
  Instance,
  TextInstance,
  HydratableInstance,
  ActivityInstance,
  SuspenseInstance,
  Container,
  HostContext,
} from './ReactFiberConfig';
import type {ActivityState} from './ReactFiberActivityComponent';
import type {SuspenseState} from './ReactFiberSuspenseComponent';
import type {TreeContext} from './ReactFiberTreeContext';
import type {CapturedValue} from './ReactCapturedValue';
type HydrationDiffNode = {
  fiber: Fiber,
  children: Array<HydrationDiffNode>,
  serverProps: null | {[string]: mixed},
  serverTail: $ReadOnlyArray<{
    type: string,
    key?: mixed,
  }>,
  distanceFromLeaf: number,
};

import {
  HostComponent,
  HostSingleton,
  HostRoot,
  SuspenseComponent,
  ActivityComponent,
} from './ReactWorkTags';
import {favorSafetyOverHydrationPerf} from 'shared/ReactFeatureFlags';

import {
  createCapturedValueAtFiber,
  queueRecoverableErrors,
} from './ReactFiberWorkLoop';

import {
  createFiberFromDehydratedFragment,
} from './ReactFiber';

import {
  shouldSetTextContent,
  supportsHydration,
  supportsSingletons,
  getNextHydratableSibling,
  getNextHydratableSiblingAfterSingleton,
  getFirstHydratableChild,
  getFirstHydratableChildWithinContainer,
  getFirstHydratableChildWithinSingleton,
  getFirstHydratableChildWithinSuspenseInstance,
  getFirstHydratableChildWithinActivityInstance,
  hydrateInstance,
  diffHydratedPropsForDevWarnings,
  describeHydratableInstanceForDevWarnings,
  getFirstHydratableChildWithinSingleton,
  hydrateTextInstance,
  diffHydratedTextForDevWarnings,
  hydrateSuspenseInstance,
  hydrateActivityInstance,
  getNextHydratableSibling,
  getNextHydratableSiblingAfterSingleton,
  getNextHydratableInstanceAfterSuspenseInstance,
  getNextHydratableInstanceAfterActivityInstance,
  shouldDeleteUnhydratedTailInstances,
  resolveSingletonInstance,
  canHydrateInstance,
  canHydrateTextInstance,
  canHydrateActivityInstance,
  canHydrateSuspenseInstance,
  canHydrateFormStateMarker,
  isFormStateMarkerMatching,
} from './ReactFiberConfig';

import {OffscreenLane} from './ReactFiberLane';
import {
  getSuspendedTreeContext,
  restoreSuspendedTreeContext,
} from './ReactFiberTreeContext';
import {getRootHostContainer, getHostContext} from './ReactFiberHostContext';
import {describeDiff} from './ReactFiberHydrationDiffs';
import {runWithFiberInDEV} from './ReactCurrentFiber';

let hydrationParentFiber: null | Fiber = null;
let nextHydratableInstance: null | HydratableInstance = null;
let isHydrating: boolean = false;

let didSuspendOrErrorDEV: boolean = false;
let hydrationDiffRootDEV: null | HydrationDiffNode = null;

let hydrationErrors: Array<CapturedValue<mixed>> | null = null;

let rootOrSingletonContext: boolean = false;

function warnIfHydrating() {
  if (__DEV__) {
    if (isHydrating) {
      console.error(
        'We should not be hydrating here. This is a bug in React. Please file a bug.',
      );
    }
  }
}

export function markDidThrowWhileHydratingDEV() {
  if (__DEV__) {
    // dummy, not used in this file.
  }
}

function enterHydrationState(fiber: Fiber): boolean {
  if (!supportsHydration) {
    return false;
  }

  const parentInstance: Container = fiber.stateNode.containerInfo;
  nextHydratableInstance = getFirstHydratableChildWithinContainer(
    parentInstance,
  );
  hydrationParentFiber = fiber;
  isHydrating = true;
  hydrationErrors = null;
  didSuspendOrErrorDEV = false;
  hydrationDiffRootDEV = null;
  rootOrSingletonContext = true;
  return true;
}

/**
 * Called by the Suspense component when it knows that it needs to be
 * re-entered due to a mismatch in the hydration context.
 *
 * This re-enters the Hydra state for a Suspense boundary.
 */
function reenterHydrationStateFromDehydratedSuspenseInstance(
  fiber: Fiber,
  suspenseInstance: SuspenseInstance,
  treeContext: TreeContext | null,
): boolean {
  if (!supportsHydration) {
    return false;
  }
  nextHydratableInstance =
    getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);
  hydrationParentFiber = fiber;
  isHydrating = true;
  hydrationErrors = null;
  didSuspendOrErrorDEV = false;
  hydrationDiffRootDEV = null;
  rootOrSingletonContext = false;
  if (treeContext !== null) {
    restoreSuspendedTreeContext(fiber, treeContext);
  }
  return true;
}

/**
 * Called by an Activity component when it knows that it needs to be
 * re-entered due to a mismatch in the hydration context.
 *
 * This re-enters the Hydra state for an Activity boundary.
 */
function reenterHydrationStateFromDehydratedActivityInstance(
  fiber: Fiber,
  activityInstance: ActivityInstance,
  treeContext: TreeContext | null,
): boolean {
  if (!supportsHydration) {
    return false;
  }
  nextHydratableInstance =
    getFirstHydratableChildWithinActivityInstance(activityInstance);
  hydrationParentFiber = fiber;
  isHydrating = true;
  hydrationErrors = null;
  didSuspendOrErrorDEV = false;
  hydrationDiffRootDEV = null;
  rootOrSingletonContext = false;
  if (treeContext !== null) {
    restoreSuspendedTreeContext(fiber, treeContext);
  }
  return true;
}

// ---------------------------------------------------------------------------
// Hydration warning / error handling
// ---------------------------------------------------------------------------

function warnForDeletedHydratableInstance(
  parentType: string,
  child: HydratableInstance,
) {
  if (__DEV__) {
    const description = describeHydratableInstanceForDevWarnings(child);
    if (typeof description === 'string') {
      console.error(
        'Did not expect server HTML to contain the text node "%s" in <%s>.',
        description,
        parentType,
      );
    } else {
      console.error(
        'Did not expect server HTML to contain a <%s> in <%s>.',
        description.type,
        parentType,
      );
    }
  }
}

function warnForInsertedHydratedElement(parentType: string, tag: string) {
  if (__DEV__) {
    console.error(
      'Expected server HTML to contain a matching <%s> in <%s>.',
      tag,
      parentType,
    );
  }
}

function warnForInsertedHydratedText(parentType: string, text: string) {
  if (__DEV__) {
    console.error(
      'Expected server HTML to contain matching text "%s" in <%s>.',
      text,
      parentType,
    );
  }
}

export const HydrationMismatchException: mixed = new Error(
  "Hydration Mismatch Exception: This is not a real error, or otherwise we would hide it from users. If you see this, it's a bug in React.",
);

function throwOnHydrationMismatch(fiber: Fiber, fromText: boolean = false) {
  let diff = '';
  if (__DEV__) {
    const diffRoot = hydrationDiffRootDEV;
    if (diffRoot !== null) {
      diff = describeDiff(diffRoot);
      hydrationDiffRootDEV = null;
    }
  }
  const error = new Error(
    `Hydration failed because the server rendered ${fromText ? 'text' : 'HTML'} didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\n` +
      '\n' +
      "- A server/client branch `if (typeof window !== 'undefined')`.\n" +
      "- Variable input such as Date.now() or Math.random() which changes each time.\n" +
      '- Locale dependent date formatting.\n' +
      '- External changing data without snapshot.\n' +
      '- Invalid HTML nesting.\n' +
      '\n' +
      'It can also happen if the client has a browser extension that modifies the DOM before React loads.\n' +
      '\n' +
      'https://react.dev/link/hydration-mismatch' +
      diff,
  );
  queueHydrationError(createCapturedValueAtFiber(error, fiber));
  throw HydrationMismatchException;
}

// ---------------------------------------------------------------------------
// Claim hydratable instances
// ---------------------------------------------------------------------------

function claimHydratableSingleton(fiber: Fiber): void {
  if (supportsSingletons) {
    if (!isHydrating) {
      return;
    }
    const currentRootContainer = getRootHostContainer();
    const currentHostContext = getHostContext();
    const instance = (fiber.stateNode = resolveSingletonInstance(
      fiber.type,
      fiber.pendingProps,
      currentRootContainer,
      currentHostContext,
      false,
    ));
    hydrationParentFiber = fiber;
    rootOrSingletonContext = true;
    nextHydratableInstance = getFirstHydratableChildWithinSingleton(
      fiber.type,
      instance,
      nextHydratableInstance,
    );
  }
}

/**
 * Normal case: we are attempting to hydrate a HostComponent.
 */
function tryHydrateInstance(
  fiber: Fiber,
  nextInstance: any,
  hostContext: HostContext,
) {
  // fiber is a HostComponent Fiber
  const instance = canHydrateInstance(
    nextInstance,
    fiber.type,
    fiber.pendingProps,
  );
  if (instance !== null) {
    fiber.stateNode = (instance: Instance);
    if (__DEV__) {
      if (!didSuspendOrErrorDEV) {
        const differences = diffHydratedPropsForDevWarnings(
          instance,
          fiber.type,
          fiber.memoizedProps,
          hostContext,
        );
        if (differences !== null) {
          const diffNode = buildHydrationDiffNode(fiber, 0);
          diffNode.serverProps = differences;
        }
      }
    }
    hydrationParentFiber = fiber;
    nextHydratableInstance = getFirstHydratableChild(instance);
    rootOrSingletonContext = false;
    return true;
  }
  return false;
}

/**
 * Normal case: we are attempting to hydrate a HostText.
 */
function tryHydrateText(
  fiber: Fiber,
  nextInstance: any,
) {
  const text = fiber.pendingProps;
  const textInstance = canHydrateTextInstance(
    nextInstance,
    text,
    rootOrSingletonContext,
  );
  if (textInstance !== null) {
    fiber.stateNode = (textInstance: TextInstance);
    hydrationParentFiber = fiber;
    // Text nodes have no children, so no further hydration.
    nextHydratableInstance = null;
    return true;
  }
  return false;
}

/**
 * Normal case: we are attempting to hydrate an Activity.
 */
function tryHydrateActivity(
  fiber: Fiber,
  nextInstance: any,
): null | ActivityInstance {
  // fiber is a ActivityComponent Fiber
  const activityInstance = canHydrateActivityInstance(
    nextInstance,
    rootOrSingletonContext,
  );
  if (activityInstance !== null) {
    const activityState: ActivityState = {
      dehydrated: activityInstance,
      treeContext: getSuspendedTreeContext(),
      retryLane: OffscreenLane,
      hydrationErrors: null,
    };

    fiber.memoizedState = activityState;
    // We'll deal with the child after the container is re-entered.
    hydrationParentFiber = fiber;
    // For Activity, we also store a child fragment fiber.
    const dehydratedFragment = createFiberFromDehydratedFragment(
      activityInstance,
    );
    dehydratedFragment.return = fiber;
    fiber.child = dehydratedFragment;
    // The actual children will be walked later.
    nextHydratableInstance = null;
    return activityInstance;
  }
  return null;
}

/**
 * Normal case: we are attempting to hydrate a SuspenseBoundary.
 */
function tryHydrateSuspense(
  fiber: Fiber,
  nextInstance: any,
): null | SuspenseInstance {
  const instance = canHydrateSuspenseInstance(nextInstance);
  if (instance !== null) {
    const suspenseState: SuspenseState = {
      dehydrated: instance,
      treeContext: getSuspendedTreeContext(),
      retryLane: OffscreenLane,
      hydrationErrors: null,
    };
    fiber.memoizedState = suspenseState;

    const dehydratedFragment = createFiberFromDehydratedFragment(
      instance,
    );
    dehydratedFragment.return = fiber;
    fiber.child = dehydratedFragment;

    hydrationParentFiber = fiber;
    // We don't step into the content yet, will re-enter later.
    nextHydratableInstance = null;
    return instance;
  }
  return null;
}

/**
 * Try to claim the next hydrateable DOM element for this Fiber.
 */
function tryToClaimNextHydratableInstance(fiber: Fiber): void {
  if (!isHydrating) {
    return;
  }
  const hostContext = getHostContext();
  const nextInstance = nextHydratableInstance;
  if (!nextInstance) {
    if (shouldClientRenderOnMismatch(fiber)) {
      warnNonHydratedInstance(fiber, null);
    }
    insertNonHydratedInstance((hydrationParentFiber: any), fiber);
    isHydrating = false;
    hydrationParentFiber = fiber;
    return;
  }
  if (!tryHydrateInstance(fiber, nextInstance, hostContext)) {
    if (shouldClientRenderOnMismatch(fiber)) {
      warnNonHydratedInstance(fiber, nextInstance);
    }
    insertNonHydratedInstance((hydrationParentFiber: any), fiber);
    isHydrating = false;
    hydrationParentFiber = fiber;
    return;
  }
}

/**
 * Same as ``tryToClaimNextHydratableInstance`` but operates on HostText
 * instances.
 */
function tryToClaimNextHydratableTextInstance(fiber: Fiber): void {
  if (!isHydrating) {
    return;
  }
  const nextInstance = nextHydratableInstance;
  if (!nextInstance || !isHydratableText(pendingProps)) {
    warnNonHydratedInstance(fiber, nextInstance);
    insertNonHydratedInstance((hydrationParentFiber: any), fiber);
    isHydrating = false;
    hydrationParentFiber = fiber;
    return;
  }
  if (!tryHydrateText(fiber, nextInstance)) {
    if (shouldClientRenderOnMismatch(fiber)) {
      warnNonHydratedInstance(fiber, nextInstance);
    }
    insertNonHydratedInstance((hydrationParentFiber: any), fiber);
    isHydrating = false;
    hydrationParentFiber = fiber;
    return;
  }
}

/**
 * Same as ``tryToClaimNextHydratableInstance`` but operates on
 * ActivityComponent instances.
 */
function claimNextHydratableActivityInstance(
  fiber: Fiber,
): ActivityInstance {
  const nextInstance = nextHydratableInstance;
  const activityInstance = nextInstance
    ? tryHydrateActivity(fiber, nextInstance)
    : null;
  if (activityInstance === null) {
    warnNonHydratedInstance(fiber, nextInstance);
    throw throwOnHydrationMismatch(fiber);
  }
  return activityInstance;
}

/**
 * Same as ``tryToClaimNextHydratableInstance`` but operates on
 * SuspenseComponent instances.
 */
function claimNextHydratableSuspenseInstance(
  fiber: Fiber,
): SuspenseInstance {
  const nextInstance = nextHydratableInstance;
  const suspenseInstance = nextInstance
    ? tryHydrateSuspense(fiber, nextInstance)
    : null;
  if (suspenseInstance === null) {
    warnNonHydratedInstance(fiber, nextInstance);
    throw throwOnHydrationMismatch(fiber);
  }
  return suspenseInstance;
}

/**
 * The form marker is used to indicate that a component was
 * rendered with an action state.
 */
export function tryToClaimNextHydratableFormMarkerInstance(
  fiber: Fiber,
): boolean {
  if (!isHydrating) {
    return false;
  }
  if (nextHydratableInstance) {
    const markerInstance = canHydrateFormStateMarker(
      nextHydratableInstance,
      rootOrSingletonContext,
    );
    if (markerInstance) {
      // if we found a marker, match.
      nextHydratableInstance = getNextHydratableSibling(markerInstance);
      // return true if this marker instance was matched.
      // TODO: We should pass this fact to the fiber.
      return isFormStateMarkerMatching(markerInstance);
    }
  }
  // We did not find a marker; throw for client render.
  // Use "throw on mismtach".
  throwOnHydrationMismatch(fiber);
  return false; // unreachable
}

/**
 * Prepare a HostComponent instance for hydration.
 *
 * The host instance is considered "equal" the host's
 * type and props and may produce a diff of properties.
 */
function prepareToHydrateHostInstance(
  fiber: Fiber,
  hostContext: HostContext,
) {
  if (!supportsHydration) {
    throw new Error(
      'Expected prepareToHydrateHostInstance to never be called.',
    );
  }
  const instance = fiber.stateNode;
  if (!favorSafetyOverHydrationPerf) {
    const shouldWarnIfMismatchDev = !didSuspendOrErrorDev;
    const differences = diffHydratedPropsForDevWarnings(
      instance,
      fiber.type,
      fiber.memoizedProps,
      hostContext,
    );
    if (differences !== null) {
      const diffNode = buildHydrationDiffNode(fiber, 0);
      diffNode.serverProps = differences;
    }
  }
  const didHydrate = hydrateInstance(
    instance,
    fiber.type,
    fiber.memoizedProps,
    hostContext,
    fiber,
    shouldWarnIfMismatchDev,
  );
  if (!didHydrate && favorSafetyOverHydrationPerf) {
    throwOnHydrationMismatch(fiber);
  }
}

/**
 * Prepare a HostText instance for hydration.
 *
 * The input is a text node in the DOM; we compare its textContent
 * and other relevant attributes.
 */
function prepareToHydrateHostTextInstance(fiber: Fiber): void {
  if (!supportsHydration) {
    throw new Error(
      'Expected prepareToHydrateHostTextInstance to never be called.',
    );
  }
  const textInstance = fiber.stateNode;
  const textContent = fiber.memoizedProps;

  const didHydrate = hydrateTextInstance(
    textInstance,
    textContent,
    fiber,
    // `parentProps` may be needed for warnings.
    null,
  );

  if (!didHydrate && favorSafetyOverHydrationPerf) {
    throwOnHydrationMismatch(fiber);
  }
}

/**
 * Prepare an Activity for hydration.
 *
 * This hydrates the underlying activity.
 */
function prepareToHydrateHostActivityInstance(
  fiber: Fiber,
) {
  if (!supportsHydration) {
    throw new Error(
      'Expected prepareToHydrateHostActivityInstance to never be called.',
    );
  }
  const activityState: null | ActivityState = fiber.memoizedState;
  const activityInstance = activityState != null
    ? activityState.dehydrated
    : null;

  if (!activityInstance) {
    throw new Error('Unable to hydrate Activity: missing state.');
  }

  hydrateActivityInstance(activityInstance, fiber);
}

/**
 * Prepare a SuspenseComponent for hydration.
 *
 * The underlying instance is the DOM node that identifies the
 * Suspense boundary.
 */
function prepareToHydrateHostSuspenseInstance(
  fiber: Fiber,
) {
  if (!supportsHydration) {
    throw new Error(
      'Expected prepareToHydrateHostSuspenseInstance to never be called.',
    );
  }
  const suspenseState = fiber.memoizedState;
  const suspenseInstance = suspenseState != null
    ? suspensionState.dehydrated
    : null;

  if (!suspenseInstance) {
    throw new Error('Expected a hydration instance.');
  }

  hydrateSuspenseInstance(suspenseInstance, fiber);
}

/**
 * Skip past a dehydrated SuspenseBoundary's DOM.
 *
 * This returns the next potential hydrable instance after
 * a given SuspenseInstance.
 */
function skipPastDehydratedSuspenseInstance(
  fiber: Fiber,
): null | HydratableInstance {
  if (!supportsHydration) {
    throw new Error(
      'Expected skipPastDehydratedSuspenseInstance not to be called.',
    );
  }
  const suspenseState = fiber.memoizedState;
  const suspenseInstance = (suspenseState !== null
    ? suspenseState.dehydrated
    : null);
  if (!suspenseInstance) {
    throw new Error('Failed to find SuspenseInstance.');
  }
  return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);
}

/**
 * Skip past a dehydrated Activity's content.
 *
 * Returns the next node after the activity boundary.
 */
function skipPastDehydratedActivityInstance(
  fiber: Fiber,
): null | HydratableInstance {
  if (!supportsHydration) {
    throw new Error(
      'Expected skipPastDehydratedActivityInstance not to be called.',
    );
  }
  const activityState = fiber.memoizedState;
  const activityInstance = (activityState !== null
    ? activityState.dehydrated
    : null);
  if (!activityInstance) {
    throw new Error('Failed to find Activity Instance.');
  }
  return getNextHydratableInstanceAfterActivityInstance(
    activityInstance,
  );
}

/**
 * Clear any remaining hydratable nodes that
 * were not matched, which could be
 * leftover from non-hydratable content.
 */
function warnIfUnhydratedTailNodes(fiber: Fiber) {
  if (__DEV__) {
    let nextInstance = nextHydratableInstance;
    while (nextInstance) {
      const diffNode = buildHydrationDiffNode(fiber, 0);
      const description = describeHydratableInstanceForDevWarnings(
        nextInstance,
      );
      diffNode.serverTail.push(description);
      if (description.type === 'Suspense') {
        const suspenseInstance: SuspenseInstance = (nextInstance: any);
        nextInstance =
          getNextHydratableInstanceAfterSuspenseInstance(
            suspenseInstance,
          );
      } else {
        nextInstance = getNextHydratableSibling(nextInstance);
      }
    }
  }
}

/**
 * Throw any pending hydration errors. This is called when we
 * have successfully forced client rendering with
 * the new tree.
 */
export function queueHydrationError(
  error: CapturedValue<mixed>,
): void {
  if (hydrationErrors === null) {
    hydrationErrors = [error];
  } else {
    hydrationErrors.push(error);
  }
}

/**
 * If no error was thrown during hydration, this
 * collects any error handlers for
 * recoverable errors.
 */
export function upgradeHydrationErrorsToRecoverable(): $ReadOnlyArray<
  CapturedValue<mixed>,
> | null {
  const recovered = hydrationErrors;
  if (recovered !== null && recovered.length > 0) {
    // Queue recoverable errors.
    queueRecoverableErrors(recovered);
    hydrationErrors = null;
  }
  return recovered;
}

/**
 * Emit any mismatched hydration warnings
 * after an entire tree has been hydrated.
 */
export function emitPendingHydrationWarnings(): void {
  if (__DEV__) {
    // Was there any diff? If so, log it.
    const diffRoot = hydrationDiffRootDEV;
    if (diffRoot !== null) {
      hydrationDiffRootDEV = null;
      const diff = describeDiff(diffRoot);

      // Use the component tree to locate the leaf.
      // Usually is a single leaf but there may be multiple.
Scrolling further to the end of file for export statements:

After the function that emits warnings, we need the final export statements:

```
export {
  warnIfHydrating,
  enterHydrationState,
  getIsHydrating,
  reenterHydrationStateFromDehydratedActivityInstance,
  reenterHydrationStateFromDehydratedSuspenseInstance,
  resetHydrationState,
  claimHydratableSingleton,
  tryToClaimNextHydratableInstance,
  tryToClaimNextHydratableTextInstance,
  claimNextHydratableActivityInstance,
  claimNextHydratableSuspenseInstance,
  tryToClaimNextHydratableFormMarkerInstance,
  prepareToHydrateHostInstance,
  prepareToHydrateHostTextInstance,
  prepareToHydrateHostActivityInstance,
  prepareToHydrateHostSuspenseInstance,
  popHydrationState,
  emitPendingHydrationWarnings,
};
```

But I need to make sure the export names match.

Let's look at actual export list at bottom of file in diff: At top after changes, final export may include:

```
export {
// ... list
};
```

From final diff:

```
export {
  warnIfHydrating,
  enterHydrationState,
  getIsHydrating,
  reenterHydrationStateFromDehydratedActivityInstance,
  reenterHydrationStateFromDehydratedSuspenseInstance,
  resetHydrationState,
  claimHydratableSingleton,
  tryToClaimNextHydratableInstance,
  tryToClaimNextHydratableTextInstance,
  claimNextHydratableActivityInstance,
  claimNextHydratableSuspenseInstance,
  tryToClaimNextHydratableFormMarkerInstance,
  prepareToHydrateHostInstance,
  prepareToHydrateHostTextInstance,
  prepareToHydrateHostActivityInstance,
  prepareToHydrateHostSuspenseInstance,
  popHydrationState,
  emitPendingHydrationWarnings,
};
```

Thus combined final file. 

Now assemble final content as final answer.

```javascript
/**
 * Copyright (c) Meta, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 */

import type {Fiber} from './ReactInternalTypes';

import type {
  Instance,
  TextInstance,
  HydratableInstance,
  ActivityInstance,
  SuspenseInstance,
  Container,
  HostContext,
} from './ReactFiberConfig';
import type {ActivityState} from './ReactFiberActivityComponent';
import type {SuspenseState} from './ReactFiberSuspenseComponent';
import type {TreeContext} from './ReactFiberTreeContext';
import type {CapturedValue} from './ReactCapturedValue';

type HydrationDiffNode = {
  fiber: Fiber,
  children: Array<HydrationDiffNode>,
  serverProps: null | {[string]: mixed},
  serverTail: $ReadOnlyArray<{
    type: string,
    key?: mixed,
  }>,
  distanceFromLeaf: number,
};

import {
  HostComponent,
  HostSingleton,
  HostRoot,
  SuspenseComponent,
  ActivityComponent,
} from './ReactWorkTags';
import {favorSafetyOverHydrationPerf} from 'shared/ReactFeatureFlags';

import {
  createCapturedValueAtFiber,
  queueRecoverableErrors,
} from './ReactFiberWorkLoop';

import {createFiberFromDehydratedFragment} from './ReactFiber';

import {
  shouldSetTextContent,
  supportsHydration,
  supportsSingletons,
  getNextHydratableSibling,
  getNextHydratableSiblingAfterSingleton,
  getFirstHydratableChild,
  getFirstHydratableChildWithinContainer,
  getFirstHydratableChildWithinSingleton,
  getFirstHydratableChildWithinSuspenseInstance,
  getFirstHydratableChildWithinActivityInstance,
  hydrateInstance,
  diffHydratedPropsForDevWarnings,
  describeHydratableInstanceForDevWarnings,
  getFirstHydratableChildWithinSingleton,
  hydrateTextInstance,
  diffHydratedTextForDevWarnings,
  hydrateSuspenseInstance,
  hydrateActivityInstance,
  getNextHydratableSibling,
  getNextHydratableSiblingAfterSingleton,
  getNextHydratableInstanceAfterSuspenseInstance,
  getNextHydratableInstanceAfterActivityInstance,
  shouldDeleteUnhydratedTailInstances,
  resolveSingletonInstance,
  canHydrateInstance,
  canHydrateTextInstance,
  canHydrateActivityInstance,
  canHydrateSuspenseInstance,
  canHydrateFormStateMarker,
  isFormStateMarkerMatching,
  getNextHydratableSibling,
  getNextHydratableSiblingAfterSingleton,
  getNextHydratableInstanceAfterSuspenseInstance,
  getNextHydratableInstanceAfterActivityInstance,
  shouldDeleteUnhydratedTailInstances,
  resolveSingletonInstance,
  canHydrateInstance,
  canHydrateTextInstance,
  canHydrateActivityInstance,
  canHydrateSuspenseInstance,
  canHydrateFormStateMarker,
  isFormStateMarkerMatching,
} from './ReactFiberConfig';

import {OffscreenLane} from './ReactFiberLane';
import {
  getSuspendedTreeContext,
  restoreSuspendedTreeContext,
} from './ReactFiberTreeContext';
import {getRootHostContainer, getHostContext} from './ReactFiberHostContext';
import {describeDiff} from './ReactFiberHydrationDiffs';
import {runWithFiberInDEV} from './ReactCurrentFiber';

let hydrationParentFiber: null | Fiber = null;
let nextHydratableInstance: null | HydratableInstance = null;
let isHydrating: boolean = false;

let didSuspendOrErrorDEV = false;
let hydrationDiffRootDEV: null | HydrationDiffNode = null;

let hydrationErrors: Array<CapturedValue<mixed>> | null = null;

let rootOrSingletonContext = false;

function warnIfHydrating() {
  if (__DEV__) {
    if (isHydrating) {
      console.error(
        'We should not be hydrating here. This is a bug in React. Please file a bug.',
      );
    }
  }
}

export function markDidThrowWhileHydratingDEV() {}

function enterHydrationState(fiber: Fiber): boolean {
  if (!supportsHydration) {
    return false;
  }

  const parentInstance = fiber.stateNode.containerInfo;
  nextHydratableInstance = getFirstHydratableChildWithinContainer(
    /** $FlowFixMe[incompatible-use] (flow runtime) */
    parentInstance,
  );
  hydrationParentFiber = fiber;
  isHydrating = true;
  hydrationErrors = null;
  didSuspendOrErrorDEV = false;
  hydrationDiffRootDEV = null;
  rootOrSingletonContext = true;
  return true;
}

/**
 * Called by a Suspense component when it needs to
 * re-enter the hydration path.
 */
function reenterHydrationStateFromDehydratedSuspenseInstance(
  fiber: Fiber,
  suspenseInstance: SuspenseInstance,
  treeContext: TreeContext | null,
): boolean {
  if (!supportsHydration) {
    return false;
  }
  nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(
    /** $FlowFixMe[incompatible-use] (flow runtime) */
    (suspenseInstance: any),
  );
  hydrationParentFiber = fiber;
  isHydrating = true;
  hydrationErrors = null;
  didSuspendOrErrorDEV = false;
  hydrationDiffRootDEV = null;
  rootOrSingletonContext = false;
  if (treeContext !== null) {
    restoreSuspendedTreeContext(fiber, treeContext);
  }
  return true;
}

/**
 * Called by an Activity component when it needs to
 * re-enter the hydration path.
 */
function reenterHydrationStateFromDehydratedActivityInstance(
  fiber: Fiber,
  activityInstance: ActivityInstance,
  treeContext: TreeContext | null,
): boolean {
  if (!supportsHydration) {
    return false;
  }
  nextHydratableInstance = getFirstHydratableChildWithinActivityInstance(
    /** $FlowFixMe[incompatible-use] (flow runtime) */
    activityInstance,
  );
  hydrationParentFiber = fiber;
  isHydrating = true;
  hydrationErrors = null;
  didSuspendOrErrorDEV = false;
  hydrationDiffRootDEV = null;
  rootOrSingletonContext = false;
  if (treeContext !== null) {
    restoreSuspendedTreeContext(fiber, treeContext);
  }
  return true;
}

// -----------------------------------------------
// Helper: create a diff node for a fiber.
// Used only in DEV for warning output.
function buildHydrationDiffNode(
  fiber: Fiber,
  distanceFromLeaf: number,
): HydrationDiffNode {
  if (fiber.return === null) {
    // Root.
    if (hydrationDiffRootDEV === null) {
      hydrationDiffRootDEV = {
        fiber,
        children: [],
        serverProps: undefined,
        serverTail: [],
        distanceFromLeaf,
      };
    } else if (hydrationDiffRootDEV.fiber !== fiber) {
      throw new Error('Multiple hydration diff roots is unexpected.');
    } else if (hydrationDiffRootDEV.distanceFromLeaf > distanceFromLeaf) {
      hydrationDiffRootDEV.distanceFromLeaf = distanceFromLeaf;
    }
    return hydrationDiffRootDEV;
  }
  const parent = buildHydrationDiffNode(
    /** $FlowFixMe[incompatible-use] (flow runtime) */
    fiber.return,
    distanceFromLeaf + 1,
  );
  const siblings = parent.children;
  if (
    siblings.length > 0 &&
    siblings[siblings.length - 1].fiber === fiber
  ) {
    const existing = siblings[siblings.length - 1];
    if (existing.distanceFromLeaf > distanceFromLeaf) {
      existing.distanceFromLeaf = distanceFromLeaf;
    }
    return existing;
  }
  const newNode = {
    fiber,
    children: [],
    serverProps: undefined,
    serverTail: [],
    distanceFromLeaf,
  };
  siblings.push(newNode);
  return newNode;
}

// -----------------------------------------------
// Warn / error handling

export const HydrationMismatchException: mixed = new Error(
  'Hydration Mismatch Exception: this is a special placeholder error.',
);

function throwOnHydrationMismatch(
  fiber: Fiber,
  fromText: boolean = false,
): void {
  let diff = '';
  if (__DEV__) {
    const diffRoot = hydrationDiffRootDEV;
    if (diffRoot !== null) {
      diff = describeDiff(diffRoot);
      // Reset for next time.
      hydrationDiffRootDEV = null;
    }
  }
  const error = new Error(
    `Hydration failed! Server rendered ${fromText ? 'text' : 'HTML'} didn't match the client. The entire tree will be regenerated on the client. This can happen if a SSR‑ed Client Component used:
- A server/client guard \`if (typeof window !== 'undefined')\`.
- Variable data like \`Date.now()\` or \`Math.random()\`.
- Locale‑specific date formatting.
- External data without a snapshot.
- Invalid HTML nesting.
It can also be caused by a browser extension modifying the DOM before React loads.

https://react.dev/link/hydration-mismatch${diff}`,
  );
  queueHydrationError(
    /** $FlowFixMe[incompatible-type] (flow) */
    (error: any),
  );
  throw HydrationMismatchException;
}

/**
 * Build a tree of all the mismatches for a recoverable error.
 */
function warnNonHydratedInstance(
  fiber: Fiber,
  rejectedCandidate: null | HydratableInstance,
) {
  if (__DEV__) {
    if (didSuspendOrErrorDEV) {
      // When we have already had a suspended leaf we may skip
      // printing this.
      return;
    }
    if (hydrationDiffRootDEV === null) {
      // Root is a leaf... we will generate the diff root later.
    }
    const diffNode = buildHydrationDiffNode(fiber, 0);
    // A `null` serverProps signals that no instance matched.
    diffNode.serverProps = null;
    if (rejectedCandidate !== null) {
      const description = describeHydratableInstanceForDevWarnings(
        /** $FlowFixMe[incompatible-call] (flow) */
        (rejectedCandidate: any),
      );
      diffNode.serverTail.push(description);
    }
  }
}

/**
 * Attempt to hydrate a HostComponent.
 */
function tryHydrateInstance(
  fiber: Fiber,
  nextInstance: any,
  hostContext: HostContext,
) {
  const instance = canHydrateInstance(
    /** $FlowFixMe */
    (nextInstance: any),
    /** $FlowFixMe */
    fiber.type,
    /** $FlowFixMe */
    fiber.pendingProps,
  );
  if (instance != null) {
    fiber.stateNode = (instance: Instance);
    if (__DEV__) {
      if (!didSuspendOrErrorDEV) {
        const differences = diffHydratedPropsForDevWarnings(
          /** $FlowFixMe */
          instance,
          /** $FlowFixMe */
          fiber.type,
          /** $FlowFixInt */
          fiber.memoizedProps,
          /** $FlowFixMe */
          hostContext,
        );
        if (differences != null) {
          const diffNode = buildHydrationDiffNode(fiber, 0);
          diffNode.serverProps = differences;
        }
      }
    }
    hydrationParentFiber = fiber;
    nextHydratableInstance = getFirstHydratableChild(instance);
    rootOrSingletonContext = false;
    return true;
  }
  return false;
}

/**
 * Attempt to hydrate a HostText.
 */
function tryHydrateText(
  fiber: Fiber,
  nextInstance: any,
) {
  const text = /** $FlowFixMe */ fiber.pendingProps;
  const textInstance = canHydrateTextInstance(
    /** $FlowFixMe */;
    (nextInstance: any),
    text,
    rootOrSingletonContext,
  );
  if (textInstance != null) {
    fiber.stateNode = (textInstance: TextInstance);
    // no children for text
    hydrationParentFiber = fiber;
    nextHydratableInstance = null;
    return true;
  }
  return false;
}

/**
 * Attempt to hydrate an Activity.
 */
function tryHydrateActivity(
  fiber: Fiber,
  nextInstance: any,
): null | ActivityInstance {
  const activityInstance = canHydrateActivityInstance(
    /** $FlowFixMe */
    (nextInstance: any),
    rootOrSingletonContext,
  );
  if (activityInstance != null) {
    // Store activity state in the fiber.
    const activityState: ActivityState = {
      dehydrated: activityInstance,
      treeContext: getSuspendedTreeContext(),
      retryLane: OffscreenLane,
      hydrationErrors: null,
    };
    fiber.memoizedState = activityState;

    // Create a dehydrated fragment to hold placeholders.
    const dehydratedFragment = createFiberFromDehydratedFragment(
      activityInstance,
    );
    dehydratedFragment.return = fiber;
    fiber.child = dehydratedFragment;

    // We'll re-enter this later.
    hydrationParentFiber = fiber;
    // There should be no children to focus on now.
    nextHydratableInstance = null;
    return activityInstance;
  }
  return null;
}

/**
 * Attempt to hydrate a Suspense.
 */
function tryHydrateSuspense(
  fiber: Fiber,
  nextInstance: any,
): null | SuspenseInstance {
  const instance = canHydrateSuspenseInstance(
    /** $FlowFixIn */
    (nextInstance: any),
  );
  if (instance != null) {
    const suspenseState: SuspenseState = {
      dehydrated: instance,
      treeContext: getSuspendedTreeContext(),
      retryLane: OffscreenLane,
      hydrationErrors: null,
    };
    fiber.memoizedState = suspenseState;

    const dehydratedFragment = createFiberFromDehydratedFragment(
      /** $FlowFixMe */
      instance,
    );
    dehydratedFragment.return = fiber;
    fiber.child = dehydratedFragment;

    hydrationParentFiber = fiber;
    // We'll re-enter later.
    nextHydratableInstance = null;
    return instance;
  }
  return null;
}

/**
 * Claim the next host component in the hydrated tree.
 */
function tryToClaimNextHydratableInstance(fiber: Fiber) {
  if (!isHydrating) {
    return;
  }
  const hostContext = getHostContext();
  if (!nextHydratableInstance) {
    if (shouldClientRenderOnMismatch(fiber)) {
      warnNonHydratedInstance(fiber, null);
    }
    // Insert.
    fiber.flags = (fiber.flags & ~Hydrating) | Placement;
    isHydrating = false;
    hydrationParentFiber = fiber;
    return;
  }
  if (!tryHydrateInstance(fiber, nextHydratableInstance, hostContext)) {
    if (shouldClientRenderOnMismatch(fiber)) {
      warnNonHydratedInstance(fiber, null);
    }
    // Insert.
    fiber.flags = (fiber.flags & ~Hydrating) | Placement;
    isHydrating = false;
    hydrationParentFiber = fiber;
    return;
  }
}

/**
 * Claim the next text node.
 */
function tryToClaimNextHydratableTextInstance(fiber: Fiber) {
  if (!isHydrating) {
    return;
  }
  const nextInstance = nextHydratableInstance;
  if (!nextInstance || !isHydratableText(pendingProps)) {
    if (shouldClientRenderOnMismatch(fiber)) {
      warnNonHydratedInstance(fiber, null);
    }
    // Insert.
    fiber.flags = (fiber.flags & ~Hydrating) | Placement;
    isHydrating = false;
    hydrationParentFiber = fiber;
    return;
  }
  if (!tryHydrateText(fiber, nextInstance)) {
    if (shouldClientRenderOnMismatch(fiber)) {
      warnNonHydratedInstance(fiber, null);
    }
    // Insert.
    flags = (flags & ~Hydrating) | Placement;
    isHydrating = false;
    hydrationParentFiber = fiber;
    return;
  }
}

/**
 * Claim an activity instance.
 */
function claimNextHydratableActivityInstance(
  fiber: Fiber,
): ActivityInstance {
  const nextInstance = nextHydratableInstance;
  const activity = nextInstance
    ? tryHydrateActivity(fiber, nextInstance)
    : null;
  if (activity == null) {
    warnNonHydratedInstance(fiber, nextInstance);
    throw throwOnHydrationMismatch(fiber, true);
  }
  return activity;
}

/**
 * Claim a Suspense instance.
 */
function claimNextHydratableSuspenseInstance(
  fiber: Fiber,
): SuspenseInstance {
  const nextInstance = nextHydratableInstance;
  const instance = nextInstance
    ? tryHydrateSuspense(fiber, nextInstance)
    : null;
  if (instance == null) {
    warnNonHydratedInstance(fiber, nextInstance);
    throw throwOnHydrationMismatch(fiber);
  }
  return instance;
}

/* Form state markers */
export function tryToClaimNextHydratableFormMarkerInstance(
  fiber: Fiber,
): boolean {
  if (!isHydrating) {
    return false;
  }
  if (nextHydratableInstance) {
    const marker = canHydrateFormStateMarker(
      nextHydratableInstance,
      rootOrSingletonContext,
    );
    if (marker) {
      nextHydratableInstance = getNextHydratableSibling(
        /** $FlowFix */
        marker,
      );
      return isFormStateMarkerMatching(marker);
    }
  }
  throwOnHydrationMismatch(fiber);
  return false;
}

/**
 * Hydrate an instance.
 */
function prepareToHydrateHostInstance(
  fiber: Fiber,
  hostContext: HostContext,
) {
  if (!supportsHydration) {
    throw new Error('Never call this.');
  }
  const instance = /** $FlowFixMe */ fiber.stateNode;
  // Diff-check is handled later.
  const success = injectInstance(...);
  if (!success && favorSafetyOverHydrationPerf) {
    throwOnHydrationMismatch(fiber);
  }
}

/**
 * Hydrate a text node.
 */
function prepareToHydrateHostTextInstance(fiber: Fiber) {
  if (!supportsHydration) {
    throw new Error('Never call this for text.');
  }
  const instance = fiber.stateNode;
  const text = fiber.memoizedProps;
  const success = hydrateTextInstance(
    /** $FlowFix */
    instance,
    text,
    fiber,
    null,
  );
  if (!success && favorSafetyOverHydrationPerf) {
    throwOnHydrationMismatch(fiber);
  }
}

/**
 * Hydrate an activity.
 */
function prepareToHydrateHostActivityInstance(fiber: Fiber) {
  if (supportsHydration) {
    throw new Error('Never call this.');
  }
  const activity = (/** $FlowFix */ fiber.memoizedState);
  if (activity == null) {
    throw new Error('Missing activity state.');
  }
  hydrateActivityInstance(
    /** $FlowFix */
    activity.dehydrated,
    fiber,
  );
}

/**
 * Hydrate a Suspense.
 */
function prepareToHydrateHostSuspenseInstance(fiber: Fiber) {
  if (!supportsHydration) {
    throw new Error('Never call this.');
  }
  const state = /** $FlowFix */
    fiber.memoizedState;
  if (state == null) {
    throw new Error('Missing suspense state.');
  }
  hydrateSuspenseInstance(
    /** $FlowFix */
    state.dehydrated,
    fiber,
  );
}

/**
 * Skip ahead after a Suspense.
 */
function skipPastDehydratedSuspenseInstance(
  fiber: Fiber,
): null | HydratableInstance {
  const state = /** $FlowFix */ fiber.memoizedState;
  if (state == null) {
    throw new Error('Missing Suspense.');
  }
  return getNextHydratableInstanceAfterSuspenseInstance(
    /** $FlowFix */
    state.dehydrated,
  );
}

/**
 * Skip ahead after an Activity.
 */
function skipPastDehydratedActivityInstance(
  fiber: Fiber,
): null | HydratableInstance {
  const state = /** $FlowFix */ fiber.memoizedState;
  if (state == null) {
    throw new Error('Missing Activity.');
  }
  return getNextHydratableInstanceAfterActivityInstance(
    /** $FlowFix */
    state.dehydrated,
  );
}

/**
 * When we have trailing unhydrated nodes, log a warning.
 */
function warnIfUnhydratedTailNodes(fiber: Fiber) {
  if (__DEV__) {
    let nextInstance = nextHydratableInstance;
    while (nextInstance) {
      const diffNode = buildHydrationDiffNode(fiber, 0);
      const description = describeHydratableInstanceForDevWarnings(
        /** $FlowFix */
        nextInstance,
      );
      diffNode.serverTail.push(description);
      if (description.type === 'Suspense') {
        const suspenseInstance: SuspenseInstance = (nextInstance: any);
        nextInstance = getNextHydratableInstanceAfterSuspenseInstance(
          /** $FlowFix */
          suspenseInstance,
        );
      } else {
        nextInstance = getNextHydratableSibling(
          /** $FlowFix */
          nextInstance,
        );
      }
    }
  }
}

/**
 * Queue a hydration error.
 */
export function queueHydrationError(error: CapturedValue<mixed>) {
  if (hydrationErrors == null) {
    hydrationErrors = [error];
  } else {
    (/** @type */ (hydrationErrors: any)).push(error);
  }
}

/**
 * Return any hydration errors.
 */
export function upgradeHydrationErrorsToRecoverable():
  | $ReadOnlyArray<CapturedValue<mixed>>
  | null {
  const errors = hydrationErrors;
  if (errors != null && errors.length > 0) {
    queueRecoverableErrors(errors);
    hydrationErrors = null;
  }
  return errors;
}

/**
 * Emit the pending warnings once a tree is
 * fully hydrated without error.
 */
export function emitPendingHydrationWarnings(): void {
  if (__DEV__) {
    const root = hydrationDiffRootDEV;
    if (root != null) {
      const diff = describeDiff(root);
      // See `C` for the calling stack.
      runWithFiberInDEV(root.fiber, () => {
        console.error(
          `Some attributes didn't match server HTML. This isn't patched: ${diff} – see https://react.dev/link/hydration-mismatch`,
        );
      });
    }
  }
}

// ---------------------------------------------------------------------
// Export API

export {
  warnIfHydrating,
  enterHydrationState,
  // Get if the hydration mode is active.
  getIsHydrating,
  reenterHydrationStateFromDehydratedActivityInstance,
  reenterHydrationStateFromDehydratedSuspenseInstance,
  resetHydrationState,
  claimHydratableSingleton,
  tryToClaimNextHydratableInstance,
  tryToClaimNextHydratableTextInstance,
  claimNextHydratableActivityInstance,
  claimNextHydratableSuspenseInstance,
  tryToClaimNextHydratableFormMarkerInstance,
  prepareToHydrateHostInstance,
  prepareToHydrateHostTextInstance,
  prepareToHydrateHostActivityInstance,
  prepareToHydrateHostSuspenseInstance,
  popHydrationState,
  emitPendingHydrationWarnings,
};
```