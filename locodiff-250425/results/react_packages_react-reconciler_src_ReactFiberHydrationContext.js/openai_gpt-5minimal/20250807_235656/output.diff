
index f9932b8c4..9521ae3d9 100644
--- a/react_packages_react-reconciler_src_ReactFiberHydrationContext.js_expectedoutput.txt (expected):tmp/tmpphv2cbi3_expected.txt	
+++ b/react_packages_react-reconciler_src_ReactFiberHydrationContext.js_extracted.txt (actual):tmp/tmpdpni4cvh_actual.txt	
@@ -12,12 +12,10 @@ import type {
   Instance,
   TextInstance,
   HydratableInstance,
-  ActivityInstance,
   SuspenseInstance,
   Container,
   HostContext,
 } from './ReactFiberConfig';
-import type {ActivityState} from './ReactFiberActivityComponent';
 import type {SuspenseState} from './ReactFiberSuspenseComponent';
 import type {TreeContext} from './ReactFiberTreeContext';
 import type {CapturedValue} from './ReactCapturedValue';
@@ -28,43 +26,37 @@ import {
   HostSingleton,
   HostRoot,
   SuspenseComponent,
-  ActivityComponent,
 } from './ReactWorkTags';
 import {favorSafetyOverHydrationPerf} from 'shared/ReactFeatureFlags';
 
-import {createCapturedValueAtFiber} from './ReactCapturedValue';
-
 import {createFiberFromDehydratedFragment} from './ReactFiber';
 import {
   shouldSetTextContent,
   supportsHydration,
   supportsSingletons,
+  isHydratable,
+  canHydrateInstance,
+  canHydrateTextInstance,
+  canHydrateSuspenseInstance,
   getNextHydratableSibling,
-  getNextHydratableSiblingAfterSingleton,
   getFirstHydratableChild,
   getFirstHydratableChildWithinContainer,
-  getFirstHydratableChildWithinActivityInstance,
   getFirstHydratableChildWithinSuspenseInstance,
-  getFirstHydratableChildWithinSingleton,
   hydrateInstance,
   diffHydratedPropsForDevWarnings,
   describeHydratableInstanceForDevWarnings,
   hydrateTextInstance,
   diffHydratedTextForDevWarnings,
-  hydrateActivityInstance,
   hydrateSuspenseInstance,
-  getNextHydratableInstanceAfterActivityInstance,
   getNextHydratableInstanceAfterSuspenseInstance,
   shouldDeleteUnhydratedTailInstances,
   resolveSingletonInstance,
-  canHydrateInstance,
-  canHydrateTextInstance,
-  canHydrateActivityInstance,
-  canHydrateSuspenseInstance,
-  canHydrateFormStateMarker,
-  isFormStateMarkerMatching,
+  isHydratableType,
+  isHydratableText,
   validateHydratableInstance,
   validateHydratableTextInstance,
+  canHydrateFormStateMarker,
+  isFormStateMarkerMatching,
 } from './ReactFiberConfig';
 import {OffscreenLane} from './ReactFiberLane';
 import {
@@ -74,7 +66,6 @@ import {
 import {queueRecoverableErrors} from './ReactFiberWorkLoop';
 import {getRootHostContainer, getHostContext} from './ReactFiberHostContext';
 import {describeDiff} from './ReactFiberHydrationDiffs';
-import {runWithFiberInDEV} from './ReactCurrentFiber';
 
 // The deepest Fiber on the stack involved in a hydration context.
 // This may have been an insertion or a hydration.
@@ -177,28 +168,6 @@ function enterHydrationState(fiber: Fiber): boolean {
   return true;
 }
 
-function reenterHydrationStateFromDehydratedActivityInstance(
-  fiber: Fiber,
-  activityInstance: ActivityInstance,
-  treeContext: TreeContext | null,
-): boolean {
-  if (!supportsHydration) {
-    return false;
-  }
-  nextHydratableInstance =
-    getFirstHydratableChildWithinActivityInstance(activityInstance);
-  hydrationParentFiber = fiber;
-  isHydrating = true;
-  hydrationErrors = null;
-  didSuspendOrErrorDEV = false;
-  hydrationDiffRootDEV = null;
-  rootOrSingletonContext = false;
-  if (treeContext !== null) {
-    restoreSuspendedTreeContext(fiber, treeContext);
-  }
-  return true;
-}
-
 function reenterHydrationStateFromDehydratedSuspenseInstance(
   fiber: Fiber,
   suspenseInstance: SuspenseInstance,
@@ -301,43 +270,7 @@ function tryHydrateText(fiber: Fiber, nextInstance: any) {
   return false;
 }
 
-function tryHydrateActivity(
-  fiber: Fiber,
-  nextInstance: any,
-): null | ActivityInstance {
-  // fiber is a ActivityComponent Fiber
-  const activityInstance = canHydrateActivityInstance(
-    nextInstance,
-    rootOrSingletonContext,
-  );
-  if (activityInstance !== null) {
-    const activityState: ActivityState = {
-      dehydrated: activityInstance,
-      treeContext: getSuspendedTreeContext(),
-      retryLane: OffscreenLane,
-      hydrationErrors: null,
-    };
-    fiber.memoizedState = activityState;
-    // Store the dehydrated fragment as a child fiber.
-    // This simplifies the code for getHostSibling and deleting nodes,
-    // since it doesn't have to consider all Suspense boundaries and
-    // check if they're dehydrated ones or not.
-    const dehydratedFragment =
-      createFiberFromDehydratedFragment(activityInstance);
-    dehydratedFragment.return = fiber;
-    fiber.child = dehydratedFragment;
-    hydrationParentFiber = fiber;
-    // While an Activity Instance does have children, we won't step into
-    // it during the first pass. Instead, we'll reenter it later.
-    nextHydratableInstance = null;
-  }
-  return activityInstance;
-}
-
-function tryHydrateSuspense(
-  fiber: Fiber,
-  nextInstance: any,
-): null | SuspenseInstance {
+function tryHydrateSuspense(fiber: Fiber, nextInstance: any) {
   // fiber is a SuspenseComponent Fiber
   const suspenseInstance = canHydrateSuspenseInstance(
     nextInstance,
@@ -348,7 +281,6 @@ function tryHydrateSuspense(
       dehydrated: suspenseInstance,
       treeContext: getSuspendedTreeContext(),
       retryLane: OffscreenLane,
-      hydrationErrors: null,
     };
     fiber.memoizedState = suspenseState;
     // Store the dehydrated fragment as a child fiber.
@@ -363,16 +295,12 @@ function tryHydrateSuspense(
     // While a Suspense Instance does have children, we won't step into
     // it during the first pass. Instead, we'll reenter it later.
     nextHydratableInstance = null;
+    return true;
   }
-  return suspenseInstance;
+  return false;
 }
 
-export const HydrationMismatchException: mixed = new Error(
-  'Hydration Mismatch Exception: This is not a real error, and should not leak into ' +
-    "userspace. If you're seeing this, it's likely a bug in React.",
-);
-
-function throwOnHydrationMismatch(fiber: Fiber, fromText: boolean = false) {
+function throwOnHydrationMismatch(fiber: Fiber) {
   let diff = '';
   if (__DEV__) {
     // Consume the diff root for this mismatch.
@@ -383,9 +311,8 @@ function throwOnHydrationMismatch(fiber: Fiber, fromText: boolean = false) {
       diff = describeDiff(diffRoot);
     }
   }
-  const error = new Error(
-    `Hydration failed because the server rendered ${fromText ? 'text' : 'HTML'} didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:
-` +
+  throw new Error(
+    "Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\n" +
       '\n' +
       "- A server/client branch `if (typeof window !== 'undefined')`.\n" +
       "- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n" +
@@ -398,8 +325,6 @@ function throwOnHydrationMismatch(fiber: Fiber, fromText: boolean = false) {
       'https://react.dev/link/hydration-mismatch' +
       diff,
   );
-  queueHydrationError(createCapturedValueAtFiber(error, fiber));
-  throw HydrationMismatchException;
 }
 
 function claimHydratableSingleton(fiber: Fiber): void {
@@ -434,11 +359,7 @@ function claimHydratableSingleton(fiber: Fiber): void {
 
     hydrationParentFiber = fiber;
     rootOrSingletonContext = true;
-    nextHydratableInstance = getFirstHydratableChildWithinSingleton(
-      fiber.type,
-      instance,
-      nextHydratableInstance,
-    );
+    nextHydratableInstance = getFirstHydratableChild(instance);
   }
 }
 
@@ -446,7 +367,12 @@ function tryToClaimNextHydratableInstance(fiber: Fiber): void {
   if (!isHydrating) {
     return;
   }
-
+  if (isHydratable && !isHydratableType(fiber.type, fiber.pendingProps)) {
+    // This fiber never hydrates from the DOM and always does an insert
+    isHydrating = false;
+    hydrationParentFiber = fiber;
+    return;
+  }
   // Validate that this is ok to render here before any mismatches.
   const currentHostContext = getHostContext();
   const shouldKeepWarning = validateHydratableInstance(
@@ -487,28 +413,15 @@ function tryToClaimNextHydratableTextInstance(fiber: Fiber): void {
   }
 }
 
-function claimNextHydratableActivityInstance(fiber: Fiber): ActivityInstance {
-  const nextInstance = nextHydratableInstance;
-  const activityInstance = nextInstance
-    ? tryHydrateActivity(fiber, nextInstance)
-    : null;
-  if (activityInstance === null) {
-    warnNonHydratedInstance(fiber, nextInstance);
-    throw throwOnHydrationMismatch(fiber);
+function tryToClaimNextHydratableSuspenseInstance(fiber: Fiber): void {
+  if (!isHydrating) {
+    return;
   }
-  return activityInstance;
-}
-
-function claimNextHydratableSuspenseInstance(fiber: Fiber): SuspenseInstance {
   const nextInstance = nextHydratableInstance;
-  const suspenseInstance = nextInstance
-    ? tryHydrateSuspense(fiber, nextInstance)
-    : null;
-  if (suspenseInstance === null) {
+  if (!nextInstance || !tryHydrateSuspense(fiber, nextInstance)) {
     warnNonHydratedInstance(fiber, nextInstance);
-    throw throwOnHydrationMismatch(fiber);
+    throwOnHydrationMismatch(fiber);
   }
-  return suspenseInstance;
 }
 
 export function tryToClaimNextHydratableFormMarkerInstance(
@@ -559,7 +472,7 @@ function prepareToHydrateHostInstance(
     fiber,
   );
   if (!didHydrate && favorSafetyOverHydrationPerf) {
-    throwOnHydrationMismatch(fiber, true);
+    throwOnHydrationMismatch(fiber);
   }
 }
 
@@ -625,29 +538,8 @@ function prepareToHydrateHostTextInstance(fiber: Fiber): void {
     parentProps,
   );
   if (!didHydrate && favorSafetyOverHydrationPerf) {
-    throwOnHydrationMismatch(fiber, true);
-  }
-}
-
-function prepareToHydrateHostActivityInstance(fiber: Fiber): void {
-  if (!supportsHydration) {
-    throw new Error(
-      'Expected prepareToHydrateHostActivityInstance() to never be called. ' +
-        'This error is likely caused by a bug in React. Please file an issue.',
-    );
-  }
-  const activityState: null | ActivityState = fiber.memoizedState;
-  const activityInstance: null | ActivityInstance =
-    activityState !== null ? activityState.dehydrated : null;
-
-  if (!activityInstance) {
-    throw new Error(
-      'Expected to have a hydrated activity instance. ' +
-        'This error is likely caused by a bug in React. Please file an issue.',
-    );
+    throwOnHydrationMismatch(fiber);
   }
-
-  hydrateActivityInstance(activityInstance, fiber);
 }
 
 function prepareToHydrateHostSuspenseInstance(fiber: Fiber): void {
@@ -672,23 +564,6 @@ function prepareToHydrateHostSuspenseInstance(fiber: Fiber): void {
   hydrateSuspenseInstance(suspenseInstance, fiber);
 }
 
-function skipPastDehydratedActivityInstance(
-  fiber: Fiber,
-): null | HydratableInstance {
-  const activityState: null | ActivityState = fiber.memoizedState;
-  const activityInstance: null | ActivityInstance =
-    activityState !== null ? activityState.dehydrated : null;
-
-  if (!activityInstance) {
-    throw new Error(
-      'Expected to have a hydrated suspense instance. ' +
-        'This error is likely caused by a bug in React. Please file an issue.',
-    );
-  }
-
-  return getNextHydratableInstanceAfterActivityInstance(activityInstance);
-}
-
 function skipPastDehydratedSuspenseInstance(
   fiber: Fiber,
 ): null | HydratableInstance {
@@ -716,15 +591,14 @@ function popToNextHostParent(fiber: Fiber): void {
   hydrationParentFiber = fiber.return;
   while (hydrationParentFiber) {
     switch (hydrationParentFiber.tag) {
+      case HostRoot:
+      case HostSingleton:
+        rootOrSingletonContext = true;
+        return;
       case HostComponent:
-      case ActivityComponent:
       case SuspenseComponent:
         rootOrSingletonContext = false;
         return;
-      case HostSingleton:
-      case HostRoot:
-        rootOrSingletonContext = true;
-        return;
       default:
         hydrationParentFiber = hydrationParentFiber.return;
     }
@@ -749,25 +623,20 @@ function popHydrationState(fiber: Fiber): boolean {
     return false;
   }
 
-  const tag = fiber.tag;
-
+  let shouldClear = false;
   if (supportsSingletons) {
     // With float we never clear the Root, or Singleton instances. We also do not clear Instances
     // that have singleton text content
     if (
-      tag !== HostRoot &&
-      tag !== HostSingleton &&
+      fiber.tag !== HostRoot &&
+      fiber.tag !== HostSingleton &&
       !(
-        tag === HostComponent &&
+        fiber.tag === HostComponent &&
         (!shouldDeleteUnhydratedTailInstances(fiber.type) ||
           shouldSetTextContent(fiber.type, fiber.memoizedProps))
       )
     ) {
-      const nextInstance = nextHydratableInstance;
-      if (nextInstance) {
-        warnIfUnhydratedTailNodes(fiber);
-        throwOnHydrationMismatch(fiber);
-      }
+      shouldClear = true;
     }
   } else {
     // If we have any remaining hydratable nodes, we need to delete them now.
@@ -775,28 +644,24 @@ function popHydrationState(fiber: Fiber): boolean {
     // other nodes in them. We also ignore components with pure text content in
     // side of them. We also don't delete anything inside the root container.
     if (
-      tag !== HostRoot &&
-      (tag !== HostComponent ||
+      fiber.tag !== HostRoot &&
+      (fiber.tag !== HostComponent ||
         (shouldDeleteUnhydratedTailInstances(fiber.type) &&
           !shouldSetTextContent(fiber.type, fiber.memoizedProps)))
     ) {
-      const nextInstance = nextHydratableInstance;
-      if (nextInstance) {
-        warnIfUnhydratedTailNodes(fiber);
-        throwOnHydrationMismatch(fiber);
-      }
+      shouldClear = true;
+    }
+  }
+  if (shouldClear) {
+    const nextInstance = nextHydratableInstance;
+    if (nextInstance) {
+      warnIfUnhydratedTailNodes(fiber);
+      throwOnHydrationMismatch(fiber);
     }
   }
   popToNextHostParent(fiber);
-  if (tag === SuspenseComponent) {
+  if (fiber.tag === SuspenseComponent) {
     nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);
-  } else if (tag === ActivityComponent) {
-    nextHydratableInstance = skipPastDehydratedActivityInstance(fiber);
-  } else if (supportsSingletons && tag === HostSingleton) {
-    nextHydratableInstance = getNextHydratableSiblingAfterSingleton(
-      fiber.type,
-      nextHydratableInstance,
-    );
   } else {
     nextHydratableInstance = hydrationParentFiber
       ? getNextHydratableSibling(fiber.stateNode)
@@ -835,18 +700,14 @@ function resetHydrationState(): void {
   didSuspendOrErrorDEV = false;
 }
 
-export function upgradeHydrationErrorsToRecoverable(): Array<
-  CapturedValue<mixed>,
-> | null {
-  const queuedErrors = hydrationErrors;
-  if (queuedErrors !== null) {
+export function upgradeHydrationErrorsToRecoverable(): void {
+  if (hydrationErrors !== null) {
     // Successfully completed a forced client render. The errors that occurred
     // during the hydration attempt are now recovered. We will log them in
     // commit phase, once the entire tree has finished.
-    queueRecoverableErrors(queuedErrors);
+    queueRecoverableErrors(hydrationErrors);
     hydrationErrors = null;
   }
-  return queuedErrors;
 }
 
 function getIsHydrating(): boolean {
@@ -869,32 +730,22 @@ export function emitPendingHydrationWarnings() {
     if (diffRoot !== null) {
       hydrationDiffRootDEV = null;
       const diff = describeDiff(diffRoot);
-
-      // Just pick the DFS-first leaf as the owner.
-      // Should be good enough since most warnings only have a single error.
-      let diffOwner: HydrationDiffNode = diffRoot;
-      while (diffOwner.children.length > 0) {
-        diffOwner = diffOwner.children[0];
-      }
-
-      runWithFiberInDEV(diffOwner.fiber, () => {
-        console.error(
-          "A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. " +
-            'This can happen if a SSR-ed Client Component used:\n' +
-            '\n' +
-            "- A server/client branch `if (typeof window !== 'undefined')`.\n" +
-            "- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n" +
-            "- Date formatting in a user's locale which doesn't match the server.\n" +
-            '- External changing data without sending a snapshot of it along with the HTML.\n' +
-            '- Invalid HTML tag nesting.\n' +
-            '\n' +
-            'It can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n' +
-            '\n' +
-            '%s%s',
-          'https://react.dev/link/hydration-mismatch',
-          diff,
-        );
-      });
+      console.error(
+        "A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. " +
+          'This can happen if a SSR-ed Client Component used:\n' +
+          '\n' +
+          "- A server/client branch `if (typeof window !== 'undefined')`.\n" +
+          "- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n" +
+          "- Date formatting in a user's locale which doesn't match the server.\n" +
+          '- External changing data without sending a snapshot of it along with the HTML.\n' +
+          '- Invalid HTML tag nesting.\n' +
+          '\n' +
+          'It can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n' +
+          '\n' +
+          '%s%s',
+        'https://react.dev/link/hydration-mismatch',
+        diff,
+      );
     }
   }
 }
@@ -903,17 +754,14 @@ export {
   warnIfHydrating,
   enterHydrationState,
   getIsHydrating,
-  reenterHydrationStateFromDehydratedActivityInstance,
   reenterHydrationStateFromDehydratedSuspenseInstance,
   resetHydrationState,
   claimHydratableSingleton,
   tryToClaimNextHydratableInstance,
   tryToClaimNextHydratableTextInstance,
-  claimNextHydratableActivityInstance,
-  claimNextHydratableSuspenseInstance,
+  tryToClaimNextHydratableSuspenseInstance,
   prepareToHydrateHostInstance,
   prepareToHydrateHostTextInstance,
-  prepareToHydrateHostActivityInstance,
   prepareToHydrateHostSuspenseInstance,
   popHydrationState,
 };
\ No newline at end of file
