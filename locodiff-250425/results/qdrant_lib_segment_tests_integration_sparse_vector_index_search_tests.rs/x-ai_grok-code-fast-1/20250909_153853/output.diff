
index 1e234a3f7..590135216 100644
--- a/qdrant_lib_segment_tests_integration_sparse_vector_index_search_tests.rs_expectedoutput.txt (expected):tmp/tmpfu_pi4ro_expected.txt	
+++ b/qdrant_lib_segment_tests_integration_sparse_vector_index_search_tests.rs_extracted.txt (actual):tmp/tmpq4ihnffn_actual.txt	
@@ -2,6 +2,7 @@ use std::cmp::max;
 use std::collections::HashMap;
 use std::fs::remove_file;
 use std::sync::atomic::AtomicBool;
+use std::sync::Arc;
 
 use common::counter::hardware_counter::HardwareCounterCell;
 use common::types::{PointOffsetType, TelemetryDetail};
@@ -13,6 +14,7 @@ use segment::common::operation_error::OperationResult;
 use segment::data_types::named_vectors::NamedVectors;
 use segment::data_types::vectors::{QueryVector, VectorInternal};
 use segment::entry::entry_point::SegmentEntry;
+use segment::fixture_for_all_indices;
 use segment::fixtures::payload_fixtures::STR_KEY;
 use segment::fixtures::sparse_fixtures::{fixture_sparse_index, fixture_sparse_index_from_iter};
 use segment::index::sparse_index::sparse_index_config::{SparseIndexConfig, SparseIndexType};
@@ -97,6 +99,7 @@ fn compare_sparse_vectors_search_with_without_filter(full_scan_threshold: usize)
                 Some(&filter),
                 top,
                 None,
+                &stopped,
                 &Default::default(),
             )
             .unwrap();
@@ -208,9 +211,6 @@ fn sparse_vector_index_consistent_with_storage() {
         data_dir.path(),
     );
 
-    // check consistency with underlying RAM inverted index
-    check_index_storage_consistency(&sparse_vector_ram_index);
-
     let mmap_index_dir = Builder::new().prefix("mmap_index_dir").tempdir().unwrap();
 
     // create mmap sparse vector index
@@ -258,9 +258,6 @@ fn sparse_vector_index_consistent_with_storage() {
         sparse_vector_mmap_index.indexed_vector_count(),
         sparse_vector_ram_index.indexed_vector_count()
     );
-
-    // check consistency with underlying mmap inverted index
-    check_index_storage_consistency(&sparse_vector_mmap_index);
 }
 
 #[test]
@@ -272,6 +269,7 @@ fn sparse_vector_index_load_missing_mmap() {
             [].iter().cloned(),
             10_000,
             SparseIndexType::Mmap,
+            &AtomicBool::new(false),
         );
     // absent configuration file for mmap are ignored
     // a new index is created
@@ -358,6 +356,7 @@ fn sparse_vector_index_ram_deleted_points_search() {
 
 #[test]
 fn sparse_vector_index_ram_filtered_search() {
+    let stopped = AtomicBool::new(false);
     let mut rnd = StdRng::seed_from_u64(42);
 
     let data_dir = Builder::new().prefix("data_dir").tempdir().unwrap();
@@ -387,6 +386,7 @@ fn sparse_vector_index_ram_filtered_search() {
             Some(&filter),
             10,
             None,
+            &stopped,
             &Default::default(),
         )
         .unwrap();
@@ -418,7 +418,7 @@ fn sparse_vector_index_ram_filtered_search() {
     // add payload on the first half of the points
     let half_indexed_count = sparse_vector_index.indexed_vector_count() / 2;
     let payload = payload_json! {field_name: field_value};
-    let hw_counter = HardwareCounterCell::new();
+    let hw_counter = HardwareCounterCell::disposable();
     let mut payload_index = sparse_vector_index.payload_index().borrow_mut();
     for idx in 0..half_indexed_count {
         payload_index
@@ -441,6 +441,7 @@ fn sparse_vector_index_ram_filtered_search() {
             Some(&filter),
             half_indexed_count * 2, // original top
             None,
+            &stopped,
             &Default::default(),
         )
         .unwrap();
@@ -450,7 +451,8 @@ fn sparse_vector_index_ram_filtered_search() {
 
 #[test]
 fn sparse_vector_index_plain_search() {
-    let mut rnd = StdRng::seed_from_u64(42);
+    let stopped = AtomicBool::new(false);
+    let mut rnd = StdRng::seed_from_u64(43);
 
     let data_dir = Builder::new().prefix("data_dir").tempdir().unwrap();
     // setup index
@@ -480,6 +482,7 @@ fn sparse_vector_index_plain_search() {
             Some(&filter),
             10,
             None,
+            &stopped,
             &Default::default(),
         )
         .unwrap();
@@ -489,7 +492,7 @@ fn sparse_vector_index_plain_search() {
 
     let payload = payload_json! {field_name: field_value};
 
-    let hw_counter = HardwareCounterCell::new();
+    let hw_counter = HardwareCounterCell::disposable();
 
     // add payload to all points
     let mut payload_index = sparse_vector_index.payload_index().borrow_mut();
@@ -507,6 +510,7 @@ fn sparse_vector_index_plain_search() {
             Some(&filter),
             NUM_VECTORS,
             None,
+            &stopped,
             &Default::default(),
         )
         .unwrap();
@@ -526,6 +530,7 @@ fn sparse_vector_index_plain_search() {
 
 #[test]
 fn handling_empty_sparse_vectors() {
+    let stopped = AtomicBool::new(false);
     let mut rnd = StdRng::seed_from_u64(42);
 
     let data_dir = Builder::new().prefix("data_dir").tempdir().unwrap();
@@ -535,11 +540,12 @@ fn handling_empty_sparse_vectors() {
             (0..NUM_VECTORS).map(|_| SparseVector::default()),
             DEFAULT_SPARSE_FULL_SCAN_THRESHOLD,
             SparseIndexType::ImmutableRam,
+            &stopped,
         )
         .unwrap();
     let mut borrowed_storage = sparse_vector_index.vector_storage().borrow_mut();
 
-    let hw_counter = HardwareCounterCell::new();
+    let hw_counter = HardwareCounterCell::disposable();
     // add empty points to storage
     for idx in 0..NUM_VECTORS {
         let vec = &SparseVector::new(vec![], vec![]).unwrap();
@@ -555,7 +561,7 @@ fn handling_empty_sparse_vectors() {
             .vector_storage()
             .borrow()
             .available_vector_count(),
-        NUM_VECTORS,
+        NUM_VECTORS
     );
 
     // empty vectors are not indexed
@@ -599,7 +605,7 @@ fn sparse_vector_index_persistence_test() {
     };
     let mut segment = build_segment(dir.path(), &config, true).unwrap();
 
-    let hw_counter = HardwareCounterCell::new();
+    let hw_counter = HardwareCounterCell::disposable();
 
     for n in 0..num_vectors {
         let vector: VectorInternal = random_sparse_vector(&mut rnd, dim).into();
@@ -624,6 +630,7 @@ fn sparse_vector_index_persistence_test() {
             None,
             top,
             None,
+            &stopped,
         )
         .unwrap();
 
@@ -644,12 +651,15 @@ fn sparse_vector_index_persistence_test() {
             None,
             top,
             None,
+            &stopped,
         )
         .unwrap();
 
     assert_eq!(search_after_reload_result.len(), top);
     assert_eq!(search_result, search_after_reload_result);
 
+    // persistence using loading RAM index from file
+    // because `segment` is appendable, create sparse index manually
     fixture_for_all_indices!(check_persistence::<_>(
         &segment,
         &search_result,
@@ -735,68 +745,4 @@ fn sparse_vector_index_files() {
 fn check_sparse_vector_index_files<I: InvertedIndex>() {
     let data_dir = Builder::new().prefix("data_dir").tempdir().unwrap();
     let index = fixture_sparse_index::<I, _>(
-        &mut StdRng::seed_from_u64(42),
-        1,
-        MAX_SPARSE_DIM,
-        LOW_FULL_SCAN_THRESHOLD,
-        data_dir.path(),
-    );
-
-    let files = index.files();
-    // sparse index config + version + inverted index config + inverted index data + tracker
-    assert_eq!(files.len(), 5);
-    for file in files.iter() {
-        assert!(file.exists(), "file {file:?} does not exist");
-    }
-}
-
-#[test]
-fn sparse_vector_test_large_index() {
-    let dir = Builder::new().prefix("segment_dir").tempdir().unwrap();
-    let config = SegmentConfig {
-        vector_data: Default::default(),
-        sparse_vector_data: HashMap::from([(
-            SPARSE_VECTOR_NAME.to_owned(),
-            SparseVectorDataConfig {
-                index: SparseIndexConfig {
-                    full_scan_threshold: Some(DEFAULT_SPARSE_FULL_SCAN_THRESHOLD),
-                    index_type: SparseIndexType::MutableRam,
-                    datatype: Some(VectorStorageDatatype::Float32),
-                },
-                storage_type: SparseVectorStorageType::OnDisk,
-            },
-        )]),
-        payload_storage_type: Default::default(),
-    };
-    let mut segment = build_segment(dir.path(), &config, true).unwrap();
-
-    let hw_counter = HardwareCounterCell::new();
-
-    let vector: VectorInternal = SparseVector {
-        indices: vec![DimId::MAX],
-        values: vec![0.0],
-    }
-    .into();
-    let mut named_vector = NamedVectors::default();
-    named_vector.insert(SPARSE_VECTOR_NAME.to_owned(), vector);
-    let idx = 0.into();
-    segment
-        .upsert_point(0 as SeqNumberType, idx, named_vector, &hw_counter)
-        .unwrap();
-
-    let borrowed_vector_index = segment.vector_data[SPARSE_VECTOR_NAME]
-        .vector_index
-        .borrow();
-    match &*borrowed_vector_index {
-        VectorIndexEnum::SparseRam(sparse_vector_index) => {
-            assert!(
-                sparse_vector_index
-                    .indices_tracker()
-                    .remap_index(DimId::MAX)
-                    .is_some(),
-            );
-            assert_eq!(sparse_vector_index.inverted_index().max_index().unwrap(), 0);
-        }
-        _ => panic!("unexpected vector index type"),
-    }
-}
\ No newline at end of file
+        &mut StdRng
\ No newline at end of file
