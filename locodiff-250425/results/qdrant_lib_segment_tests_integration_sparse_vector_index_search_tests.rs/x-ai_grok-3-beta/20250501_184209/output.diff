--- qdrant_lib_segment_tests_integration_sparse_vector_index_search_tests.rs_expectedoutput.txt (expected)+++ qdrant_lib_segment_tests_integration_sparse_vector_index_search_tests.rs_extracted.txt (actual)@@ -143,7 +143,7 @@ #[test]
 fn sparse_vector_index_fallback_plain_search() {
     // very high full scan threshold to force fallback to plain search
-    compare_sparse_vectors_search_with_without_filter(NUM_VECTORS + 1);
+    compare_sparse_vectors_search_with_without_filter(LARGE_FULL_SCAN_THRESHOLD);
 }
 
 /// Checks that the sparse vector index is consistent with the underlying storage
@@ -650,12 +650,7 @@     assert_eq!(search_after_reload_result.len(), top);
     assert_eq!(search_result, search_after_reload_result);
 
-    fixture_for_all_indices!(check_persistence::<_>(
-        &segment,
-        &search_result,
-        &query_vector,
-        top
-    ));
+    fixture_for_all_indices!(check_persistence::<_>(&segment, &search_result, &query_vector, top));
 }
 
 fn check_persistence<TInvertedIndex: InvertedIndex>(
@@ -733,13 +728,12 @@ }
 
 fn check_sparse_vector_index_files<I: InvertedIndex>() {
-    let data_dir = Builder::new().prefix("data_dir").tempdir().unwrap();
     let index = fixture_sparse_index::<I, _>(
         &mut StdRng::seed_from_u64(42),
         1,
         MAX_SPARSE_DIM,
         LOW_FULL_SCAN_THRESHOLD,
-        data_dir.path(),
+        Builder::new().prefix("data_dir").tempdir().unwrap().path(),
     );
 
     let files = index.files();
