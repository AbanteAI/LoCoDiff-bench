
index 42fc8b445..4c3bc9e0d 100644
--- a/aider_aider_coders_editblock_coder.py_expectedoutput.txt (expected):tmp/tmpe9yhjeas_expected.txt	
+++ b/aider_aider_coders_editblock_coder.py_extracted.txt (actual):tmp/tmpqn8zcuy0_actual.txt	
@@ -81,13 +81,15 @@ class EditBlockCoder(Coder):
 
         blocks = "block" if len(failed) == 1 else "blocks"
 
-        res = f"# {len(failed)} SEARCH/REPLACE {blocks} failed to match!\n"
+        res = f"# {len(failed)} SEARCH/REPLACE blocks failed to match!\n"
         for edit in failed:
             path, original, updated = edit
 
             full_path = self.abs_root_path(path)
             content = self.io.read_text(full_path)
 
+            #did_you_mean = find_similar_lines(original, content)
+
             res += f"""
 ## SearchReplaceNoExactMatch: This SEARCH block failed to exactly match lines in {path}
 <<<<<<< SEARCH
@@ -95,16 +97,6 @@ class EditBlockCoder(Coder):
 {updated}>>>>>>> REPLACE
 
 """
-            did_you_mean = find_similar_lines(original, content)
-            if did_you_mean:
-                res += f"""Did you mean to match some of these actual lines from {path}?
-
-{self.fence[0]}
-{did_you_mean}
-{self.fence[1]}
-
-"""
-
             if updated in content and updated:
                 res += f"""Are you sure you need this SEARCH/REPLACE block?
 The REPLACE lines are already in {path}!
@@ -119,7 +111,7 @@ The REPLACE lines are already in {path}!
             res += f"""
 # The other {len(passed)} SEARCH/REPLACE {pblocks} were applied successfully.
 Don't re-send them.
-Just reply with fixed versions of the {blocks} above that failed to match.
+Just reply with fixed versions of the blocks above that failed to match.
 """
         raise ValueError(res)
 
@@ -255,6 +247,11 @@ def replace_part_with_missing_leading_whitespace(whole_lines, part_lines, replac
         part_lines = [p[num_leading:] if p.strip() else p for p in part_lines]
         replace_lines = [p[num_leading:] if p.strip() else p for p in replace_lines]
 
+    # TODO: this logic needs to be fixed
+    # if the max outdent still leaves space
+    if all((not pline or pline[0].isspace()) for pline in part_lines):
+        return
+
     # can we find an exact match not including the leading whitespace
     num_part_lines = len(part_lines)
 
@@ -379,6 +376,8 @@ def do_replace(fname, content, before_text, after_text, fence=None):
         new_content = content + after_text
     else:
         new_content = replace_most_similar_chunk(content, before_text, after_text)
+        if not new_content:
+            return
 
     return new_content
 
@@ -448,7 +447,7 @@ def find_original_update_blocks(content, fence=DEFAULT_FENCE, valid_fnames=None)
     while i < len(lines):
         line = lines[i]
 
-        # Check for shell code blocks
+        # Check for various shell code blocks
         shell_starts = [
             "```bash",
             "```sh",
@@ -605,6 +604,7 @@ def find_similar_lines(search_lines, content_lines, threshold=0.6):
 
     best_ratio = 0
     best_match = None
+    best_match_i = 0
 
     for i in range(len(content_lines) - len(search_lines) + 1):
         chunk = content_lines[i : i + len(search_lines)]
