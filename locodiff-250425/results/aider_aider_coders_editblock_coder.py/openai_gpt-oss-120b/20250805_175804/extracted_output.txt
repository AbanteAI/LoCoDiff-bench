import difflib
import math
import re
import sys
from difflib import SequenceMatcher
from pathlib import Path

from .base_coder import Coder
from .editblock_prompts import EditBlockPrompts

class EditBlockCoder(Coder):
    """A coder that uses search/replace blocks for code modifications."""
    edit_format = "diff"
    gpt_prompts = EditBlockPrompts()

    def get_edits(self):
        content = self.partial_response_content
        edits = list(
            find_original_update_blocks(
                content,
                self.fence,
                self.get_inchat_relative_files(),
            )
        )
        self.shell_commands += [
            edit[1] for edit in edits if edit[0] is None
        ]
        edits = [edit for edit in edits if edit[0] is not None]
        return edits

    def apply_edits(self, edits, dry_run=False):
        failed = []
        passed = []
        updated_edits = []

        for edit in edits:
            path, original, updated = edit
            full_path = self.abs_root_path(path)
            new_content = None
            if Path(full_path).exists():
                content = self.io.read_text(full_path)
                new_content = do_replace(full_path, content, original, updated, self.fence)
            if not new_content and original.strip():
                for alt_path in self.abs_fnames:
                    if Path(alt_path).exists():
                        content = self.io.read_text(alt_path)
                        new_content = do_replace(
                            alt_path,
                            content,
                            original,
                            updated,
                            self.fence,
                        )
                        if new_content:
                            path = self.get_rel_fname(alt_path)
                            break

            if new_content:
                if not dry_run:
                    self.io.write_text(full_path, new_content)
                passed.append(edit)
            else:
                failed.append(edit)

        if dry_run:
            return updated_edits

        if not failed:
            return

        blocks = "block" if len(failed) == 1 else "blocks"
        res = f"# {len(failed)} SEARCH/REPLACE {blocks} failed to match!\n"
        for edit in failed:
            path, original, updated = edit
            res += f"""
## SearchReplaceNoExactMatch: This SEARCH block failed to exactly match lines in {path}
<<<<<<< SEARCH
{original}
=======
{updated}
>>>>>>> REPLACE
"""

        res += (
            "\nThe SEARCH section must exactly match an existing block of lines ...\n"
        )
        passed_b = len(passed)
        if passed_b:
            res += f"\n# The other {passed_b} blocks were applied successfully.\n"
        raise ValueError(res)


DEFAULT_FENCE = ("```", "```")
missing_filename_err = (
    "Bad/missing filename. The filename must be alone on the line before the opening fence"
    " {fence[0]}"
)

triple_backticks = "`" * 3

HEAD = r"^<{5,9} SEARCH\s*$"
DIVIDER = r"^={5,9}\s*$"
UPDATED = r"^>{5,9} REPLACE\s*$"

HEAD_ERR = "<<<<<<< SEARCH"
DIVIDER_ERR = "======="
UPDATED_ERR = ">>>>>>> REPLACE"

HEAD_ERR = "<{5,9} SEARCH"
DIVIDER_ERR = "={5,9}"
UPDATED_ERR = ">{5,9} REPLACE"

HEAD_ERR = "<<<<<<< SEARCH"
DIVIDER_ERR = "======="
UPDATED_ERR = ">>>>>>> REPLACE"

HEAD = r"^<{5,9} SEARCH\s*$"
DIVIDER = r"^={5,9}\s*$"
UPDATED = r"^>{5,9} REPLACE\s*$"

HEAD_ERR = "<<<<<<< SEARCH"
DIVIDER_ERR = "======="
UPDATED_ERR = ">>>>>>> REPLACE"

HEAD = r"^<{5,9} SEARCH\s*$"
DIVIDER = r"^={5,9}\s*$"
UPDATED = r"^>{5,9} REPLACE\s*$"

HEAD_ERR = "<<<<<<< SEARCH"
DIVIDER_ERR = "======="
UPDATED_ERR = ">>>>>>> REPLACE"

HEAD = r"^<{5,9} SEARCH\s*$"
DIVIDER = r"^={5,9}\s*$"
UPDATED = r"^>{5,9} REPLACE\s*$"

HEAD = r"^<{5,9} SEARCH\s*$"
DIVIDER = r"^={5,9}\s*$"
UPDATED = r"^>{5,9} REPLACE\s*$"

head_pattern = re.compile(HEAD)
divider_pattern = re.compile(DIVIDER)
updated_pattern = re.compile(UPDATED)


def strip_filename(filename, fence):
    filename = filename.strip()
    if not filename:
        return

    start_fence = fence[0]
    if filename.startswith(start_fence):
        candidate = filename[len(start_fence) :]
        if candidate and ("." in candidate or "/" in candidate):
            return candidate
        return

    if filename.startswith(triple_backticks):
        candidate = filename[len(triple_backticks) :]
        if candidate and ("." in candidate or "/" in candidate):
            return candidate
        return

    filename = filename.rstrip(":")
    filename = filename.lstrip("#")
    filename = filename.strip("`")
    filename = filename.strip("*")
    return filename


def find_original_update_blocks(content, fence=DEFAULT_FENCE, valid_fnames=None):
    lines = content.splitlines(keepends=True)
    i = 0
    current_filename = None

    head_pattern = re.compile(HEAD)
    divider_pattern = re.compile(DIVIDER)
    updated_pattern = re.compile(UPDATED)

    while i < len(lines):
        line = lines[i]

        # Check for shell code blocks
        shell_starts = [
            "```bash",
            "```sh",
            "```shell",
            "```cmd",
            "```batch",
            "```powershell",
            "```ps1",
            "```zsh",
            "```fish",
            "```ksh",
            "```csh",
            "```tcsh",
        ]
        # Check if the next line or the one after that is an edit block
        next_is_editblock = (
            i + 1 < len(lines) and head_pattern.match(lines[i + 1].strip())
            or i + 2 < len(lines) and head_pattern.match(lines[i + 2].strip())
        )
        if any(line.strip().startswith(start) for start in shell_starts) and not next_is_editblock:
            shell_content = []
            i += 1
            while i < len(lines) and not lines[i].strip().startswith("```"):
                shell_content.append(lines[i])
                i += 1
            if i < len(lines) and lines[i].strip().startswith("```"):
                i += 1
            yield None, "".join(shell_content)
            continue

        # Check for SEARCH/REPLACE blocks
        if head_pattern.match(line.strip()):
            try:
                # if next line after HEAD exists and is DIVIDER, it's a new file
                if i + 1 < len(lines) and divider_pattern.match(
                    lines[i + 1].strip()
                ):
                    filename = find_filename(lines[max(0, i - 3) : i], fence, None)
                else:
                    filename = find_filename(
                        lines[max(0, i - 3) : i], fence, valid_fnames
                    )
                if not filename:
                    if current_filename:
                        filename = current_filename
                    else:
                        raise ValueError(missing_filename_err.format(fence=fence))

                current_filename = filename

                original_text = []
                i += 1
                while i < len(lines) and not divider_pattern.match(
                    lines[i].strip()
                ):
                    original_text.append(lines[i])
                    i += 1

                if i >= len(lines) or not divider_pattern.match(
                    lines[i].strip()
                ):
                    raise ValueError(f"Expected `{DIVIDER}`")

                updated_text = []
                i += 1
                while i < len(lines) and not (
                    updated_pattern.match(lines[i].strip())
                    or divider_pattern.match(lines[i].strip())
                ):
                    updated_text.append(lines[i])
                    i += 1

                if i >= len(lines) or not (
                    updated_pattern.match(
                        lines[i].strip()
                    )
                    or divider_pattern.match(
                        lines[i].strip()
                    )
                ):
                    raise ValueError(f"Expected `{UPDATED_ERR}` or `{DIVIDER_ERR}`")

                yield filename, "".join(original_text), "".join(
                    updated_text
                )
            except ValueError as e:
                processed = "".join(lines[: i + 1])
                err = e.args[0]
                raise ValueError(f"{processed}\n^^^ {err}")

        i += 1


def find_filename(lines, fence, valid_fnames):
    """
    Deepseek Coder v2 has been doing this:

    ```python
    foo.txt
    ```
    ```python
    <<<<<<< SEARCH
```

    This is a more flexible search back for filenames.
    """
    if valid_fnames is None:
        valid_fnames = []

    lines.reverse()
    lines = lines[:3]

    filenames = []
    for line in lines:
        filename = strip_filename(line, fence)
        if filename:
            filenames.append(filename)

        if not line.startswith(fence[0]) and not line.startswith(triple_backticks):
            break

    if not filenames:
        return

    # Check for exact match first
    for fname in filenames:
        if fname in valid_fnames:
            return fname

    # Check for partial match (basename)
    for fname in filenames:
        for vfn in valid_fnames:
            if fname == Path(vfn).name:
                return vfn

    # Perform fuzzy matching with valid_fnames
    for fname in filenames:
        close_matches = difflib.get_close_matches(
            fname, [str(vfn) for vfn in valid_fnames], n=1, cutoff=0.8
        )
        if len(close_matches) == 1:
            return close_matches[0]

    # If no fuzzy match, look for a file w/extension
    for fname in filenames:
        if "." in fname:
            return fname

    return filenames[0] if filenames else None


def find_similar_lines(search_lines, content_lines, threshold=0.6):
    # placeholder for actual implementation
    return ""


def do_replace(fname, content, before_text, after_text, fence=None):
    # placeholder for actual implementation
    return True