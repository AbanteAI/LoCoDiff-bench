
index 0a4e2d762..b3ddaf135 100644
--- a/qdrant_lib_segment_src_index_field_index_map_index_mod.rs_expectedoutput.txt (expected):tmp/tmpqauht04s_expected.txt	
+++ b/qdrant_lib_segment_src_index_field_index_map_index_mod.rs_extracted.txt (actual):tmp/tmp_phk44kp_actual.txt	
@@ -1,8 +1,9 @@
-use std::borrow::Borrow;
+std::borrow::Borrow;
 use std::collections::hash_map::Entry;
 use std::fmt::{Debug, Display};
 use std::hash::{BuildHasher, Hash};
 use std::iter;
+use std::mem::size_of_val;
 use std::path::{Path, PathBuf};
 use std::str::FromStr;
 use std::sync::Arc;
@@ -22,11 +23,11 @@ use uuid::Uuid;
 
 use self::immutable_map_index::ImmutableMapIndex;
 use self::mutable_map_index::MutableMapIndex;
-use super::FieldIndexBuilderTrait;
 use super::facet_index::FacetIndex;
 use super::mmap_point_to_values::MmapValue;
-use crate::common::Flusher;
+use super::FieldIndexBuilderTrait;
 use crate::common::operation_error::{OperationError, OperationResult};
+use crate::common::Flusher;
 use crate::data_types::facets::{FacetHit, FacetValueRef};
 use crate::index::field_index::stat_tools::number_of_selected_points;
 use crate::index::field_index::{
@@ -155,7 +156,7 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         }
     }
 
-    fn get_indexed_points(&self) -> usize {
+    pub fn get_indexed_points(&self) -> usize {
         match self {
             MapIndex::Mutable(index) => index.get_indexed_points(),
             MapIndex::Immutable(index) => index.get_indexed_points(),
@@ -163,7 +164,7 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         }
     }
 
-    fn get_values_count(&self) -> usize {
+    pub fn get_values_count(&self) -> usize {
         match self {
             MapIndex::Mutable(index) => index.get_values_count(),
             MapIndex::Immutable(index) => index.get_values_count(),
@@ -203,14 +204,6 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         }
     }
 
-    pub fn iter_counts_per_value(&self) -> Box<dyn Iterator<Item = (&N, usize)> + '_> {
-        match self {
-            MapIndex::Mutable(index) => Box::new(index.iter_counts_per_value()),
-            MapIndex::Immutable(index) => Box::new(index.iter_counts_per_value()),
-            MapIndex::Mmap(index) => Box::new(index.iter_counts_per_value()),
-        }
-    }
-
     pub fn iter_values_map<'a>(
         &'a self,
         hw_cell: &'a HardwareCounterCell,
@@ -226,6 +219,14 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         format!("{field}_map")
     }
 
+    pub fn recreate(&self) -> OperationResult<()> {
+        match self {
+            MapIndex::Mutable(index) => index.get_db_wrapper().recreate_column_family(),
+            MapIndex::Immutable(index) => index.get_db_wrapper().recreate_column_family(),
+            MapIndex::Mmap(_) => Ok(()),
+        }
+    }
+
     fn flusher(&self) -> Flusher {
         match self {
             MapIndex::Mutable(index) => index.get_db_wrapper().flusher(),
@@ -244,21 +245,10 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         CardinalityEstimation::exact(values_count)
     }
 
-    pub fn get_telemetry_data(&self) -> PayloadIndexTelemetry {
-        PayloadIndexTelemetry {
-            field_name: None,
-            points_count: self.get_indexed_points(),
-            points_values_count: self.get_values_count(),
-            histogram_bucket_size: None,
-            index_type: match self {
-                MapIndex::Mutable(_) => "mutable_map",
-                MapIndex::Immutable(_) => "immutable_map",
-                MapIndex::Mmap(_) => "mmap_map",
-            },
-        }
-    }
-
-    pub fn encode_db_record(value: &N, idx: PointOffsetType) -> String {
+    pub fn encode_db_record(value: &N, idx: PointOffsetType) -> String
+    where
+        N::Owned: Display,
+    {
         format!("{value}/{idx}")
     }
 
@@ -283,33 +273,6 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         self.values_count(idx) == 0
     }
 
-    fn clear(self) -> OperationResult<()> {
-        match self {
-            MapIndex::Mutable(index) => index.get_db_wrapper().recreate_column_family(),
-            MapIndex::Immutable(index) => index.get_db_wrapper().recreate_column_family(),
-            MapIndex::Mmap(index) => index.clear(),
-        }
-    }
-
-    fn remove_point(&mut self, id: PointOffsetType) -> OperationResult<()> {
-        match self {
-            MapIndex::Mutable(index) => index.remove_point(id),
-            MapIndex::Immutable(index) => index.remove_point(id),
-            MapIndex::Mmap(index) => {
-                index.remove_point(id);
-                Ok(())
-            }
-        }
-    }
-
-    fn files(&self) -> Vec<PathBuf> {
-        match self {
-            MapIndex::Mutable(_) => Vec::new(),
-            MapIndex::Immutable(_) => Vec::new(),
-            MapIndex::Mmap(index) => index.files(),
-        }
-    }
-
     /// Estimates cardinality for `except` clause
     ///
     /// # Arguments
@@ -367,14 +330,12 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
 
         let excluded_value_counts: Vec<_> = excluded
             .map(|val| {
-                self.get_count_for_value(val.borrow(), hw_counter)
+                self.get_count_for_value(val, hw_counter)
                     .unwrap_or(0)
             })
             .collect();
         let total_excluded_value_count: usize = excluded_value_counts.iter().sum();
 
-        debug_assert!(total_excluded_value_count <= self.get_values_count());
-
         let non_excluded_values_count = self
             .get_values_count()
             .saturating_sub(total_excluded_value_count);
@@ -384,7 +345,6 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
 
         if max_values_per_point == 0 {
             // All points are excluded, so we can't select any point
-            debug_assert_eq!(non_excluded_values_count, 0);
             return CardinalityEstimation::exact(0);
         }
 
@@ -435,11 +395,44 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         Box::new(
             self.iter_values()
                 .filter(|key| !excluded.contains((*key).borrow()))
-                .flat_map(move |key| self.get_iterator(key.borrow(), hw_counter).copied())
+                .flat_map(move |key| self.get_iterator(key, hw_counter).copied())
                 .unique(),
         )
     }
 
+    pub fn get_telemetry_data(&self) -> PayloadIndexTelemetry {
+        PayloadIndexTelemetry {
+            field_name: None,
+            points_count: self.get_indexed_points(),
+            points_values_count: self.get_values_count(),
+            histogram_bucket_size: None,
+            index_type: match self {
+                MapIndex::Mutable(_) => "mutable_map",
+                MapIndex::Immutable(_) => "immutable_map",
+                MapIndex::Mmap(_) => "mmap_map",
+            },
+        }
+    }
+
+    pub fn clear(self) -> OperationResult<()> {
+        match self {
+            MapIndex::Mutable(index) => index.get_db_wrapper().recreate_column_family(),
+            MapIndex::Immutable(index) => index.get_db_wrapper().recreate_column_family(),
+            MapIndex::Mmap(index) => index.clear(),
+        }
+    }
+
+    fn remove_point(&mut self, id: PointOffsetType) -> OperationResult<()> {
+        match self {
+            MapIndex::Mutable(index) => index.remove_point(id),
+            MapIndex::Immutable(index) => index.remove_point(id),
+            MapIndex::Mmap(index) => {
+                index.remove_point(id);
+                Ok(())
+            }
+        }
+    }
+
     pub fn is_on_disk(&self) -> bool {
         match self {
             MapIndex::Mutable(_) => false,
@@ -584,7 +577,11 @@ impl PayloadFieldIndex for MapIndex<str> {
     }
 
     fn files(&self) -> Vec<PathBuf> {
-        self.files()
+        match self {
+            MapIndex::Mutable(_) => Vec::new(),
+            MapIndex::Immutable(_) => Vec::new(),
+            MapIndex::Mmap(index) => index.files(),
+        }
     }
 
     fn filter<'a>(
@@ -700,7 +697,7 @@ impl PayloadFieldIndex for MapIndex<str> {
     ) -> Box<dyn Iterator<Item = PayloadBlockCondition> + '_> {
         Box::new(
             self.iter_values()
-                .map(|value| {
+                .map(move |value| {
                     (
                         value,
                         self.get_count_for_value(value, &HardwareCounterCell::disposable()) // Payload_blocks only used in HNSW building, which is unmeasured.
@@ -734,7 +731,11 @@ impl PayloadFieldIndex for MapIndex<UuidIntType> {
     }
 
     fn files(&self) -> Vec<PathBuf> {
-        self.files()
+        match self {
+            MapIndex::Mutable(_) => Vec::new(),
+            MapIndex::Immutable(_) => Vec::new(),
+            MapIndex::Mmap(index) => index.files(),
+        }
     }
 
     fn filter<'a>(
@@ -848,9 +849,11 @@ impl PayloadFieldIndex for MapIndex<UuidIntType> {
                 }
                 AnyVariants::Integers(integers) => {
                     if integers.is_empty() {
-                        Some(CardinalityEstimation::exact(0).with_primary_clause(
-                            PrimaryCondition::Condition(Box::new(condition.clone())),
-                        ))
+                        Some(
+                            CardinalityEstimation::exact(0).with_primary_clause(
+                                PrimaryCondition::Condition(Box::new(condition.clone())),
+                            ),
+                        )
                     } else {
                         None
                     }
@@ -925,7 +928,11 @@ impl PayloadFieldIndex for MapIndex<IntPayloadType> {
     }
 
     fn files(&self) -> Vec<PathBuf> {
-        self.files()
+        match self {
+            MapIndex::Mutable(_) => Vec::new(),
+            MapIndex::Immutable(_) => Vec::new(),
+            MapIndex::Mmap(index) => index.files(),
+        }
     }
 
     fn filter<'a>(
@@ -941,7 +948,7 @@ impl PayloadFieldIndex for MapIndex<IntPayloadType> {
                 }
                 ValueVariants::Bool(_) => None,
             },
-            Some(Match::Any(MatchAny { any: any_variant })) => match any_variant {
+            Some(Match::Any(MatchAny { any: any_variants })) => match any_variants {
                 AnyVariants::Strings(keywords) => {
                     if keywords.is_empty() {
                         Some(Box::new(vec![].into_iter()))
@@ -1245,11 +1252,7 @@ mod tests {
         }
     }
 
-    fn load_map_index<N: MapIndexKey + ?Sized>(
-        data: &[Vec<N::Owned>],
-        path: &Path,
-        index_type: IndexType,
-    ) -> MapIndex<N> {
+    fn load_map_index<N: MapIndexKey + ?Sized>(data: &[Vec<N::Owned>], path: &Path, index_type: IndexType) -> MapIndex<N> {
         let mut index = match index_type {
             IndexType::Mutable => {
                 MapIndex::<N>::new_memory(open_db_with_existing_cf(path).unwrap(), FIELD_NAME, true)
@@ -1262,137 +1265,4 @@ mod tests {
             IndexType::Mmap => MapIndex::<N>::new_mmap(path, false).unwrap(),
         };
         index.load_from_db().unwrap();
-        for (idx, values) in data.iter().enumerate() {
-            let index_values: HashSet<N::Owned> = index
-                .get_values(idx as PointOffsetType)
-                .unwrap()
-                .map(|v| N::to_owned(N::from_referenced(&v)))
-                .collect();
-            let index_values: HashSet<&N> = index_values.iter().map(|v| v.borrow()).collect();
-            let check_values: HashSet<&N> = values.iter().map(|v| v.borrow()).collect();
-            assert_eq!(index_values, check_values);
-        }
-
-        index
-    }
-
-    #[test]
-    fn test_index_non_ascending_insertion() {
-        let temp_dir = Builder::new().prefix("store_dir").tempdir().unwrap();
-        let mut builder = MapIndex::<IntPayloadType>::mmap_builder(temp_dir.path(), false);
-        builder.init().unwrap();
-
-        let data = [vec![1, 2, 3, 4, 5, 6], vec![25], vec![10, 11]];
-
-        let hw_counter = HardwareCounterCell::new();
-
-        for (idx, values) in data.iter().enumerate().rev() {
-            let values: Vec<Value> = values.iter().map(|i| (*i).into()).collect();
-            let values: Vec<_> = values.iter().collect();
-            builder
-                .add_point(idx as PointOffsetType, &values, &hw_counter)
-                .unwrap();
-        }
-
-        let index = builder.finalize().unwrap();
-        for (idx, values) in data.iter().enumerate().rev() {
-            let res: Vec<_> = index
-                .get_values(idx as u32)
-                .unwrap()
-                .map(|i| *i as i32)
-                .collect();
-            assert_eq!(res, *values);
-        }
-    }
-
-    #[rstest]
-    #[case(IndexType::Mutable)]
-    #[case(IndexType::Immutable)]
-    #[case(IndexType::Mmap)]
-    fn test_int_disk_map_index(#[case] index_type: IndexType) {
-        let data = vec![
-            vec![1, 2, 3, 4, 5, 6],
-            vec![1, 2, 3, 4, 5, 6],
-            vec![13, 14, 15, 16, 17, 18],
-            vec![19, 20, 21, 22, 23, 24],
-            vec![25],
-        ];
-
-        let temp_dir = Builder::new().prefix("store_dir").tempdir().unwrap();
-        save_map_index::<IntPayloadType>(&data, temp_dir.path(), index_type, |v| (*v).into());
-        let index = load_map_index::<IntPayloadType>(&data, temp_dir.path(), index_type);
-
-        let hw_counter = HardwareCounterCell::new();
-
-        // Ensure cardinality is non zero
-        assert!(
-            !index
-                .except_cardinality(vec![].into_iter(), &hw_counter)
-                .equals_min_exp_max(&CardinalityEstimation::exact(0)),
-        );
-    }
-
-    #[rstest]
-    #[case(IndexType::Mutable)]
-    #[case(IndexType::Immutable)]
-    #[case(IndexType::Mmap)]
-    fn test_string_disk_map_index(#[case] index_type: IndexType) {
-        let data = vec![
-            vec![
-                SmolStr::from("AABB"),
-                SmolStr::from("UUFF"),
-                SmolStr::from("IIBB"),
-            ],
-            vec![
-                SmolStr::from("PPMM"),
-                SmolStr::from("QQXX"),
-                SmolStr::from("YYBB"),
-            ],
-            vec![
-                SmolStr::from("FFMM"),
-                SmolStr::from("IICC"),
-                SmolStr::from("IIBB"),
-            ],
-            vec![
-                SmolStr::from("AABB"),
-                SmolStr::from("UUFF"),
-                SmolStr::from("IIBB"),
-            ],
-            vec![SmolStr::from("PPGG")],
-        ];
-
-        let temp_dir = Builder::new().prefix("store_dir").tempdir().unwrap();
-        save_map_index::<str>(&data, temp_dir.path(), index_type, |v| v.to_string().into());
-        let index = load_map_index::<str>(&data, temp_dir.path(), index_type);
-
-        let hw_counter = HardwareCounterCell::new();
-
-        // Ensure cardinality is non zero
-        assert!(
-            !index
-                .except_cardinality(vec![].into_iter(), &hw_counter)
-                .equals_min_exp_max(&CardinalityEstimation::exact(0)),
-        );
-    }
-
-    #[rstest]
-    #[case(IndexType::Mutable)]
-    #[case(IndexType::Immutable)]
-    #[case(IndexType::Mmap)]
-    fn test_empty_index(#[case] index_type: IndexType) {
-        let data: Vec<Vec<SmolStr>> = vec![];
-
-        let temp_dir = Builder::new().prefix("store_dir").tempdir().unwrap();
-        save_map_index::<str>(&data, temp_dir.path(), index_type, |v| v.to_string().into());
-        let index = load_map_index::<str>(&data, temp_dir.path(), index_type);
-
-        let hw_counter = HardwareCounterCell::new();
-
-        // Ensure cardinality is zero
-        assert!(
-            index
-                .except_cardinality(vec![].into_iter(), &hw_counter)
-                .equals_min_exp_max(&CardinalityEstimation::exact(0)),
-        );
-    }
-}
\ No newline at end of file
+        for (idx, values) in data.iter().enumerate() {
\ No newline at end of file
