
index 0a4e2d762..8de523aca 100644
--- a/qdrant_lib_segment_src_index_field_index_map_index_mod.rs_expectedoutput.txt (expected):tmp/tmp2ml0068d_expected.txt	
+++ b/qdrant_lib_segment_src_index_field_index_map_index_mod.rs_extracted.txt (actual):tmp/tmpb8uiuusb_actual.txt	
@@ -3,6 +3,7 @@ use std::collections::hash_map::Entry;
 use std::fmt::{Debug, Display};
 use std::hash::{BuildHasher, Hash};
 use std::iter;
+use std::mem::size_of_val;
 use std::path::{Path, PathBuf};
 use std::str::FromStr;
 use std::sync::Arc;
@@ -91,6 +92,15 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         }
     }
 
+    fn load_from_db(&mut self) -> OperationResult<bool> {
+        match self {
+            MapIndex::Mutable(index) => index.load_from_db(),
+            MapIndex::Immutable(index) => index.load_from_db(),
+            // mmap index is always loaded
+            MapIndex::Mmap(_) => Ok(true),
+        }
+    }
+
     pub fn new_mmap(path: &Path, is_on_disk: bool) -> OperationResult<Self> {
         Ok(MapIndex::Mmap(Box::new(MmapMapIndex::load(
             path, is_on_disk,
@@ -110,28 +120,6 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         }
     }
 
-    fn load_from_db(&mut self) -> OperationResult<bool> {
-        match self {
-            MapIndex::Mutable(index) => index.load_from_db(),
-            MapIndex::Immutable(index) => index.load_from_db(),
-            // mmap index is always loaded
-            MapIndex::Mmap(_) => Ok(true),
-        }
-    }
-
-    pub fn check_values_any(
-        &self,
-        idx: PointOffsetType,
-        hw_counter: &HardwareCounterCell,
-        check_fn: impl Fn(&N) -> bool,
-    ) -> bool {
-        match self {
-            MapIndex::Mutable(index) => index.check_values_any(idx, check_fn),
-            MapIndex::Immutable(index) => index.check_values_any(idx, check_fn),
-            MapIndex::Mmap(index) => index.check_values_any(idx, hw_counter, check_fn),
-        }
-    }
-
     pub fn get_values(
         &self,
         idx: PointOffsetType,
@@ -155,6 +143,19 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         }
     }
 
+    pub fn check_values_any(
+        &self,
+        idx: PointOffsetType,
+        _hw_counter: &HardwareCounterCell,
+        check_fn: impl Fn(&N) -> bool,
+    ) -> bool {
+        match self {
+            MapIndex::Mutable(index) => index.check_values_any(idx, check_fn),
+            MapIndex::Immutable(index) => index.check_values_any(idx, check_fn),
+            MapIndex::Mmap(index) => index.check_values_any(idx, _hw_counter, check_fn),
+        }
+    }
+
     fn get_indexed_points(&self) -> usize {
         match self {
             MapIndex::Mutable(index) => index.get_indexed_points(),
@@ -302,14 +303,6 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         }
     }
 
-    fn files(&self) -> Vec<PathBuf> {
-        match self {
-            MapIndex::Mutable(_) => Vec::new(),
-            MapIndex::Immutable(_) => Vec::new(),
-            MapIndex::Mmap(index) => index.files(),
-        }
-    }
-
     /// Estimates cardinality for `except` clause
     ///
     /// # Arguments
@@ -584,7 +577,23 @@ impl PayloadFieldIndex for MapIndex<str> {
     }
 
     fn files(&self) -> Vec<PathBuf> {
-        self.files()
+        match self {
+            MapIndex::Mutable(_) => Vec::new(),
+            MapIndex::Immutable(_) => Vec::new(),
+            MapIndex::Mmap(index) => index.files(),
+        }
+    }
+
+    fn is_on_disk(&self) -> bool {
+        self.is_on_disk()
+    }
+
+    fn populate(&self) -> OperationResult<()> {
+        self.populate()
+    }
+
+    fn clear_cache(&self) -> OperationResult<()> {
+        self.clear_cache()
     }
 
     fn filter<'a>(
@@ -734,7 +743,23 @@ impl PayloadFieldIndex for MapIndex<UuidIntType> {
     }
 
     fn files(&self) -> Vec<PathBuf> {
-        self.files()
+        match self {
+            MapIndex::Mutable(_) => Vec::new(),
+            MapIndex::Immutable(_) => Vec::new(),
+            MapIndex::Mmap(index) => index.files(),
+        }
+    }
+
+    fn is_on_disk(&self) -> bool {
+        self.is_on_disk()
+    }
+
+    fn populate(&self) -> OperationResult<()> {
+        self.populate()
+    }
+
+    fn clear_cache(&self) -> OperationResult<()> {
+        self.clear_cache()
     }
 
     fn filter<'a>(
@@ -925,7 +950,23 @@ impl PayloadFieldIndex for MapIndex<IntPayloadType> {
     }
 
     fn files(&self) -> Vec<PathBuf> {
-        self.files()
+        match self {
+            MapIndex::Mutable(_) => Vec::new(),
+            MapIndex::Immutable(_) => Vec::new(),
+            MapIndex::Mmap(index) => index.files(),
+        }
+    }
+
+    fn is_on_disk(&self) -> bool {
+        self.is_on_disk()
+    }
+
+    fn populate(&self) -> OperationResult<()> {
+        self.populate()
+    }
+
+    fn clear_cache(&self) -> OperationResult<()> {
+        self.clear_cache()
     }
 
     fn filter<'a>(
@@ -941,7 +982,7 @@ impl PayloadFieldIndex for MapIndex<IntPayloadType> {
                 }
                 ValueVariants::Bool(_) => None,
             },
-            Some(Match::Any(MatchAny { any: any_variant })) => match any_variant {
+            Some(Match::Any(MatchAny { any: any_variants })) => match any_variants {
                 AnyVariants::Strings(keywords) => {
                     if keywords.is_empty() {
                         Some(Box::new(vec![].into_iter()))
@@ -1263,12 +1304,12 @@ mod tests {
         };
         index.load_from_db().unwrap();
         for (idx, values) in data.iter().enumerate() {
-            let index_values: HashSet<N::Owned> = index
+            let index_values_owned: HashSet<N::Owned> = index
                 .get_values(idx as PointOffsetType)
                 .unwrap()
                 .map(|v| N::to_owned(N::from_referenced(&v)))
                 .collect();
-            let index_values: HashSet<&N> = index_values.iter().map(|v| v.borrow()).collect();
+            let index_values: HashSet<&N> = index_values_owned.iter().map(|v| v.borrow()).collect();
             let check_values: HashSet<&N> = values.iter().map(|v| v.borrow()).collect();
             assert_eq!(index_values, check_values);
         }
