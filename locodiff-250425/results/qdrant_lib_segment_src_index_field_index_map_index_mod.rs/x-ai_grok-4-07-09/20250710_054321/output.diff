
index 0a4e2d762..f8c881b32 100644
--- a/qdrant_lib_segment_src_index_field_index_map_index_mod.rs_expectedoutput.txt (expected):tmp/tmp5orl9p1e_expected.txt	
+++ b/qdrant_lib_segment_src_index_field_index_map_index_mod.rs_extracted.txt (actual):tmp/tmptnebchvb_actual.txt	
@@ -25,8 +25,8 @@ use self::mutable_map_index::MutableMapIndex;
 use super::FieldIndexBuilderTrait;
 use super::facet_index::FacetIndex;
 use super::mmap_point_to_values::MmapValue;
-use crate::common::Flusher;
 use crate::common::operation_error::{OperationError, OperationResult};
+use crate::common::Flusher;
 use crate::data_types::facets::{FacetHit, FacetValueRef};
 use crate::index::field_index::stat_tools::number_of_selected_points;
 use crate::index::field_index::{
@@ -38,6 +38,8 @@ use crate::types::{
     AnyVariants, FieldCondition, IntPayloadType, Match, MatchAny, MatchExcept, MatchValue,
     PayloadKeyType, UuidIntType, ValueVariants,
 };
+use crate::common::rocksdb_buffered_delete_wrapper::DatabaseColumnScheduledDeleteWrapper;
+use std::mem::size_of_val;
 
 pub mod immutable_map_index;
 pub mod mmap_map_index;
@@ -92,9 +94,7 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
     }
 
     pub fn new_mmap(path: &Path, is_on_disk: bool) -> OperationResult<Self> {
-        Ok(MapIndex::Mmap(Box::new(MmapMapIndex::load(
-            path, is_on_disk,
-        )?)))
+        Ok(MapIndex::Mmap(Box::new(MmapMapIndex::load(path, is_on_disk)?)))
     }
 
     pub fn builder(db: Arc<RwLock<DB>>, field_name: &str) -> MapIndexBuilder<N> {
@@ -110,6 +110,14 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         }
     }
 
+    fn get_db_wrapper(&self) -> &DatabaseColumnScheduledDeleteWrapper {
+        match self {
+            MapIndex::Mutable(index) => index.get_db_wrapper(),
+            MapIndex::Immutable(index) => index.get_db_wrapper(),
+            MapIndex::Mmap(_) => unreachable!(),
+        }
+    }
+
     fn load_from_db(&mut self) -> OperationResult<bool> {
         match self {
             MapIndex::Mutable(index) => index.load_from_db(),
@@ -122,13 +130,12 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
     pub fn check_values_any(
         &self,
         idx: PointOffsetType,
-        hw_counter: &HardwareCounterCell,
         check_fn: impl Fn(&N) -> bool,
     ) -> bool {
         match self {
             MapIndex::Mutable(index) => index.check_values_any(idx, check_fn),
             MapIndex::Immutable(index) => index.check_values_any(idx, check_fn),
-            MapIndex::Mmap(index) => index.check_values_any(idx, hw_counter, check_fn),
+            MapIndex::Mmap(index) => index.check_values_any(idx, check_fn),
         }
     }
 
@@ -279,46 +286,14 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         Ok((value, idx))
     }
 
-    pub fn values_is_empty(&self, idx: PointOffsetType) -> bool {
-        self.values_count(idx) == 0
-    }
-
-    fn clear(self) -> OperationResult<()> {
-        match self {
-            MapIndex::Mutable(index) => index.get_db_wrapper().recreate_column_family(),
-            MapIndex::Immutable(index) => index.get_db_wrapper().recreate_column_family(),
-            MapIndex::Mmap(index) => index.clear(),
-        }
-    }
-
-    fn remove_point(&mut self, id: PointOffsetType) -> OperationResult<()> {
-        match self {
-            MapIndex::Mutable(index) => index.remove_point(id),
-            MapIndex::Immutable(index) => index.remove_point(id),
-            MapIndex::Mmap(index) => {
-                index.remove_point(id);
-                Ok(())
-            }
-        }
+    pub fn values_count(&self, point_id: PointOffsetType) -> usize {
+        self.get_values(point_id).map(|x| x.len()).unwrap_or(0)
     }
 
-    fn files(&self) -> Vec<PathBuf> {
-        match self {
-            MapIndex::Mutable(_) => Vec::new(),
-            MapIndex::Immutable(_) => Vec::new(),
-            MapIndex::Mmap(index) => index.files(),
-        }
+    pub fn values_is_empty(&self, point_id: PointOffsetType) -> bool {
+        self.values_count(point_id) == 0
     }
 
-    /// Estimates cardinality for `except` clause
-    ///
-    /// # Arguments
-    ///
-    /// * 'excluded' - values, which are not considered as matching
-    ///
-    /// # Returns
-    ///
-    /// * `CardinalityEstimation` - estimation of cardinality
     fn except_cardinality<'a>(
         &'a self,
         excluded: impl Iterator<Item = &'a N>,
@@ -370,916 +345,1662 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
                 self.get_count_for_value(val.borrow(), hw_counter)
                     .unwrap_or(0)
             })
-            .collect();
+            . collect();
+
         let total_excluded_value_count: usize = excluded_value_counts.iter().sum();
 
         debug_assert!(total_excluded_value_count <= self.get_values_count());
 
         let non_excluded_values_count = self
-            .get_values_count()
+
+.get_values_count()
+
             .saturating_sub(total_excluded_value_count);
+
         let max_values_per_point = self
+
             .get_unique_values_count()
+
             .saturating_sub(excluded_value_counts.len());
 
         if max_values_per_point == 0 {
+
             // All points are excluded, so we can't select any point
+
             debug_assert_eq!(non_excluded_values_count, 0);
+
             return CardinalityEstimation::exact(0);
+
         }
 
         // Minimal amount of points, required to fit all unused values.
+
         // Cardinality can't be less than this value.
+
         let min_not_excluded_by_values = non_excluded_values_count.div_ceil(max_values_per_point);
 
         let min = min_not_excluded_by_values.max(
+
             self.get_indexed_points()
+
                 .saturating_sub(total_excluded_value_count),
+
         );
 
         // Maximum scenario: selected points overlap as much as possible.
+
         // From one side, all excluded values should be assigned to the same point
+
         // => we can take the value with the maximum amount of points.
-        // From another side, all other values should be enough to fill all other points.
+
+        // FromECE another side, all other values should be enough to fill all other points.
 
         let max_excluded_value_count = excluded_value_counts.iter().max().copied().unwrap_or(0);
 
         let max = self
+
             .get_indexed_points()
+
             .saturating_sub(max_excluded_value_count)
+
             .min(non_excluded_values_count);
 
         // Expected case: we assume that all points are filled equally.
+
         // So we can estimate the probability of the point to have non-excluded value.
+
         let exp = number_of_selected_points(self.get_indexed_points(), non_excluded_values_count)
+
             .max(min)
+
             .min(max);
 
         CardinalityEstimation {
+
             primary_clauses: vec![],
+
             min,
+
             exp,
+
             max,
+
         }
+
     }
 
     fn except_set<'a, K, A>(
+
         &'a self,
+
         excluded: &'a IndexSet<K, A>,
+
         hw_counter: &'a HardwareCounterCell,
+
     ) -> Box<dyn Iterator<Item = PointOffsetType> + 'a>
-    where
+
+ where
+
         A: BuildHasher,
+
         K: Borrow<N> + Hash + Eq,
+
     {
+
         Box::new(
+
             self.iter_values()
+
                 .filter(|key| !excluded.contains((*key).borrow()))
+
                 .flat_map(move |key| self.get_iterator(key.borrow(), hw_counter).copied())
+
                 .unique(),
+
         )
+
     }
 
     pub fn is_on_disk(&self) -> bool {
+
         match self {
+
             MapIndex::Mutable(_) => false,
+
             MapIndex::Immutable(_) => false,
+
             MapIndex::Mmap(index) => index.is_on_disk(),
+
         }
+
     }
 
     /// Populate all pages in the mmap.
+
     /// Block until all pages are populated.
+
     pub fn populate(&self) -> OperationResult<()> {
+
         match self {
-            MapIndex::Mutable(_) => {}   // Not a mmap
+
+            MapIndex::Mutable(_) => {} // Not a mmap
+
             MapIndex::Immutable(_) => {} // Not a mmap
+
             MapIndex::Mmap(index) => index.populate()?,
+
         }
+
         Ok(())
+
     }
 
     /// Drop disk cache.
+
     pub fn clear_cache(&self) -> OperationResult<()> {
+
         match self {
-            MapIndex::Mutable(_) => {}   // Not a mmap
+
+            MapIndex::Mutable(_) => {} // Not a mmap
+
             MapIndex::Immutable(_) => {} // Not a mmap
+
             MapIndex::Mmap(index) => index.clear_cache()?,
+
         }
+
         Ok(())
+
     }
+
 }
 
 pub struct MapIndexBuilder<N: MapIndexKey + ?Sized>(MapIndex<N>);
 
 impl<N: MapIndexKey + ?Sized> FieldIndexBuilderTrait for MapIndexBuilder<N>
+
 where
+
     MapIndex<N>: PayloadFieldIndex + ValueIndexer,
+
 {
+
     type FieldIndexType = MapIndex<N>;
 
     fn init(&mut self) -> OperationResult<()> {
+
         match &mut self.0 {
+
             MapIndex::Mutable(index) => index.get_db_wrapper().recreate_column_family(),
+
             MapIndex::Immutable(index) => index.get_db_wrapper().recreate_column_family(),
+
             MapIndex::Mmap(_) => unreachable!(),
+
         }
+
     }
 
     fn add_point(
+
         &mut self,
+
         id: PointOffsetType,
+
         values: &[&Value],
+
         hw_counter: &HardwareCounterCell,
-    ) -> OperationResult<()> {
+
+    ) -> OperationResult <$> {
+
         self.0.add_point(id, values, hw_counter)
+
     }
 
     fn finalize(self) -> OperationResult<Self::FieldIndexType> {
+
         Ok(self.0)
+
     }
+
 }
 
 pub struct MapIndexMmapBuilder<N: MapIndexKey + ?Sized> {
+
     path: PathBuf,
+
     point_to_values: Vec<Vec<N::Owned>>,
+
     values_to_points: HashMap<N::Owned, Vec<PointOffsetType>>,
+
     is_on_disk: bool,
+
 }
 
 impl<N: MapIndexKey + ?Sized> FieldIndexBuilderTrait for MapIndexMmapBuilder<N>
+
 where
+
     MapIndex<N>: PayloadFieldIndex + ValueIndexer,
+
     <MapIndex<N> as ValueIndexer>::ValueType: Into<N::Owned>,
+
 {
+
     type FieldIndexType = MapIndex<N>;
 
     fn init(&mut self) -> OperationResult<()> {
+
         Ok(())
+
     }
 
     fn add_point(
+
         &mut self,
+
         id: PointOffsetType,
+
         payload: &[&Value],
+
         hw_counter: &HardwareCounterCell,
+
     ) -> OperationResult<()> {
+
         let mut flatten_values: Vec<_> = vec![];
+
         for value in payload.iter() {
+
             let payload_values = <MapIndex<N> as ValueIndexer>::get_values(value);
+
             flatten_values.extend(payload_values);
+
         }
+
         let flatten_values: Vec<N::Owned> = flatten_values.into_iter().map(Into::into).collect();
 
         if self.point_to_values.len() <= id as usize {
+
             self.point_to_values.resize_with(id as usize + 1, Vec::new);
+
         }
 
         self.point_to_values[id as usize].extend(flatten_values.clone());
 
         let mut hw_cell_wb = hw_counter
+
             .payload_index_io_write_counter()
+
             .write_back_counter();
 
         for value in flatten_values {
+
             let entry = self.values_to_points.entry(value);
 
             if let Entry::Vacant(e) = &entry {
+
                 let size = N::mmapped_size(N::as_referenced(e.key().borrow()));
+
                 hw_cell_wb.incr_delta(size);
+
             }
 
             hw_cell_wb.incr_delta(size_of_val(&id));
+
             entry.or_default().push(id);
+
         }
 
         Ok(())
+
     }
 
     fn finalize(self) -> OperationResult<Self::FieldIndexType> {
+
         Ok(MapIndex::Mmap(Box::new(MmapMapIndex::build(
+
             &self.path,
+
             self.point_to_values,
+
             self.values_to_points,
+
             self.is_on_disk,
-        )?)))
+
+) ?)))
+
     }
+
 }
 
 impl PayloadFieldIndex for MapIndex<str> {
+
     fn count_indexed_points(&self) -> usize {
+
         self.get_indexed_points()
+
     }
 
     fn load(&mut self) -> OperationResult<bool> {
+
         self.load_from_db()
+
     }
 
     fn cleanup(self) -> OperationResult<()> {
+
         self.clear()
+
     }
 
     fn flusher(&self) -> Flusher {
+
         MapIndex::flusher(self)
+
     }
 
     fn files(&self) -> Vec<PathBuf> {
+
         self.files()
+
     }
 
     fn filter<'a>(
+
         &'a self,
+
         condition: &'a FieldCondition,
+
         hw_counter: &'a HardwareCounterCell,
+
     ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + 'a>> {
+
         match &condition.r#match {
+
             Some(Match::Value(MatchValue { value })) => match value {
+
                 ValueVariants::String(keyword) => Some(Box::new(
+
                     self.get_iterator(keyword.as_str(), hw_counter).copied(),
+
                 )),
+
                 ValueVariants::Integer(_) => None,
+
                 ValueVariants::Bool(_) => None,
+
             },
+
             Some(Match::Any(MatchAny { any: any_variant })) => match any_variant {
+
                 AnyVariants::Strings(keywords) => Some(Box::new(
+
                     keywords
+
                         .iter()
+
                         .flat_map(move |keyword| {
+
                             self.get_iterator(keyword.as_str(), hw_counter).copied()
+
                         })
+
                         .unique(),
+
                 )),
+
                 AnyVariants::Integers(integers) => {
+
                     if integers.is_empty() {
+
                         Some(Box::new(iter::empty()))
+
                     } else {
+
                         None
+
                     }
+
                 }
+
             },
+
             Some(Match::Except(MatchExcept { except })) => match except {
+
                 AnyVariants::Strings(keywords) => Some(self.except_set(keywords, hw_counter)),
+
                 AnyVariants::Integers(other) => {
+
                     if other.is_empty() {
+
                         Some(Box::new(iter::empty()))
+
                     } else {
+
                         None
+
                     }
+
                 }
+
             },
+
             _ => None,
+
         }
+
     }
 
     fn estimate_cardinality(
+
         &self,
+
         condition: &FieldCondition,
+
         hw_counter: &HardwareCounterCell,
+
     ) -> Option<CardinalityEstimation> {
+
         match &condition.r#match {
+
             Some(Match::Value(MatchValue { value })) => match value {
+
                 ValueVariants::String(keyword) => {
+
                     let mut estimation = self.match_cardinality(keyword.as_str(), hw_counter);
+
                     estimation
+
                         .primary_clauses
+
                         .push(PrimaryCondition::Condition(Box::new(condition.clone())));
+
                     Some(estimation)
+
                 }
+
                 ValueVariants::Integer(_) => None,
+
                 ValueVariants::Bool(_) => None,
+
             },
+
             Some(Match::Any(MatchAny { any: any_variant })) => match any_variant {
+
                 AnyVariants::Strings(keywords) => {
+
                     let estimations = keywords
+
                         .iter()
-                        .map(|keyword| self.match_cardinality(keyword.as_str(), hw_counter))
+
+                        .map(|keyword| self.match_cardinality关键字 (keyword.as_str(), hw_counter))
+
                         .collect::<Vec<_>>();
+
                     let estimation = if estimations.is_empty() {
+
                         CardinalityEstimation::exact(0)
+
                     } else {
+
                         combine_should_estimations(&estimations, self.get_indexed_points())
+
                     };
+
                     Some(
+
                         estimation.with_primary_clause(PrimaryCondition::Condition(Box::new(
+
                             condition.clone(),
+
                         ))),
+
                     )
+
                 }
+
                 AnyVariants::Integers(integers) => {
+
                     if integers.is_empty() {
+
                         Some(CardinalityEstimation::exact(0).with_primary_clause(
+
                             PrimaryCondition::Condition(Box::new(condition.clone())),
+
                         ))
+
                     } else {
+
                         None
+
                     }
+
                 }
+
             },
+
             Some(Match::Except(MatchExcept { except })) => match except {
-                AnyVariants::Strings(keywords) => {
-                    Some(self.except_cardinality(keywords.iter().map(|k| k.as_str()), hw_counter))
-                }
-                AnyVariants::Integers(others) => {
+
+                AnyVariants::Strings(keywords) => Some(self.except_cardinality(
+
+                    keywords.iter().map(|k| k.as_str()),
+
+                    hw_counter,
+
+                )),
+
+                AnyVariants::Integers(others) => {
+
                     if others.is_empty() {
+
                         Some(CardinalityEstimation::exact(0).with_primary_clause(
+
                             PrimaryCondition::Condition(Box::new(condition.clone())),
+
                         ))
+
                     } else {
+
                         None
+
                     }
+
                 }
+
             },
+
             _ => None,
+
         }
+
     }
 
     fn payload_blocks(
+
         &self,
+
         threshold: usize,
+
         key: PayloadKeyType,
+
     ) -> Box<dyn Iterator<Item = PayloadBlockCondition> + '_> {
+
         Box::new(
+
             self.iter_values()
-                .map(|value| {
+
+                .map(move |value| {
+
                     (
+
                         value,
-                        self.get_count_for_value(value, &HardwareCounterCell::disposable()) // Payload_blocks only used in HNSW building, which is unmeasured.
+
+                        self.get_count_for_value(value, &HardwareCounterCell::disposable())
+
                             .unwrap_or(0),
+
                     )
+
                 })
+
                 .filter(move |(_value, count)| *count > threshold)
-                .map(move |(value, count)| PayloadBlockCondition {
+
+                .map(move |(value, count)| DIRECT PayloadBlockCondition {
+
                     condition: FieldCondition::new_match(key.clone(), value.to_string().into()),
+
                     cardinality: count,
+
                 }),
+
         )
+
     }
+
 }
 
 impl PayloadFieldIndex for MapIndex<UuidIntType> {
+
     fn count_indexed_points(&self) -> usize {
+
         self.get_indexed_points()
+
     }
 
     fn load(&mut self) -> OperationResult<bool> {
+
         self.load_from_db()
+
     }
 
     fn cleanup(self) -> OperationResult<()> {
+
         self.clear()
+
     }
 
     fn flusher(&self) -> Flusher {
+
         MapIndex::flusher(self)
+
     }
 
     fn files(&self) -> Vec<PathBuf> {
+
         self.files()
+
     }
 
     fn filter<'a>(
+
         &'a self,
+
         condition: &'a FieldCondition,
-        hw_counter: &'a HardwareCounterCell,
+
+        hw_counter: &HardwareCounterCell,
+
     ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + 'a>> {
+
         match &condition.r#match {
+
             Some(Match::Value(MatchValue { value })) => match value {
-                ValueVariants::String(uuid_string) => {
+
+                ValueVariants::String(uuid_string) {
+
                     let uuid = Uuid::from_str(uuid_string).ok()?;
+
                     Some(Box::new(
+
                         self.get_iterator(&uuid.as_u128(), hw_counter).copied(),
+
                     ))
+
                 }
+
                 ValueVariants::Integer(_) => None,
+
                 ValueVariants::Bool(_) => None,
+
             },
+
             Some(Match::Any(MatchAny { any: any_variant })) => match any_variant {
-                AnyVariants::Strings(uuids_string) => {
+
+                AnyVariants::Strings(uuids_string) {
+
                     let uuids: Result<IndexSet<u128>, _> = uuids_string
+
                         .iter()
+
                         .map(|uuid_string| Uuid::from_str(uuid_string).map(|x| x.as_u128()))
+
                         .collect();
 
                     let uuids = uuids.ok()?;
 
                     Some(Box::new(
+
                         uuids
+
                             .into_iter()
-                            .flat_map(move |uuid| self.get_iterator(&uuid, hw_counter).copied())
+
+                            .flat_map(move |uuid| self.get_iterator(&uuid, hw_counter).copies ())
+
                             .unique(),
+
                     ))
+
                 }
+
                 AnyVariants::Integers(integers) => {
+
                     if integers.is_empty() {
+
                         Some(Box::new(iter::empty()))
+
                     } else {
+
                         None
+
                     }
+
                 }
+
             },
+
             Some(Match::Except(MatchExcept { except })) => match except {
-                AnyVariants::Strings(uuids_string) => {
+
+                AnyVariants::Strings(uuids_string) {
+
                     let uuids: Result<IndexSet<u128>, _> = uuids_string
+
                         .iter()
+
                         .map(|uuid_string| Uuid::from_str(uuid_string).map(|x| x.as_u128()))
+
                         .collect();
 
                     let excluded_uuids = uuids.ok()?;
+
                     let exclude_iter = self
+
                         .iter_values()
-                        .filter(move |key| !excluded_uuids.contains(*key))
+
+                        .filter(move |key| !excluded烨_uuids.contains(*key))
+
                         .flat_map(move |key| self.get_iterator(key, hw_counter).copied())
+
                         .unique();
+
                     Some(Box::new(exclude_iter))
+
                 }
-                AnyVariants::Integers(other) => {
+
+                AnyVariants::Integers(other) {
+
                     if other.is_empty() {
+
                         Some(Box::new(iter::empty()))
+
                     } else {
+
                         None
+
                     }
+
                 }
+
             },
+
             _ => None,
+
         }
+
     }
 
     fn estimate_cardinality(
+
         &self,
+
         condition: &FieldCondition,
+
         hw_counter: &HardwareCounterCell,
+
     ) -> Option<CardinalityEstimation> {
+
         match &condition.r#match {
+
             Some(Match::Value(MatchValue { value })) => match value {
-                ValueVariants::String(uuid_string) => {
+
+                ValueVariants::String(uuid_string) {
+
                     let uuid = Uuid::from_str(uuid_string).ok()?;
+
                     let mut estimation = self.match_cardinality(&uuid.as_u128(), hw_counter);
+
                     estimation
+
                         .primary_clauses
+
                         .push(PrimaryCondition::Condition(Box::new(condition.clone())));
+
                     Some(estimation)
+
                 }
+
                 ValueVariants::Integer(_) => None,
+
                 ValueVariants::Bool(_) => None,
+
             },
+
             Some(Match::Any(MatchAny { any: any_variant })) => match any_variant {
-                AnyVariants::Strings(uuids_string) => {
+
+                AnyVariants::Strings(uuids_string) {
+
                     let uuids: Result<IndexSet<u128>, _> = uuids_string
+
                         .iter()
+
                         .map(|uuid_string| Uuid::from_str(uuid_string).map(|x| x.as_u128()))
+
                         .collect();
 
                     let uuids = uuids.ok()?;
 
                     let estimations = uuids
+
                         .into_iter()
+
                         .map(|uuid| self.match_cardinality(&uuid, hw_counter))
+
                         .collect::<Vec<_>>();
+
                     let estimation = if estimations.is_empty() {
+
                         CardinalityEstimation::exact(0)
+
                     } else {
+
                         combine_should_estimations(&estimations, self.get_indexed_points())
+
                     };
+
                     Some(
+
                         estimation.with_primary_clause(PrimaryCondition::Condition(Box::new(
+
                             condition.clone(),
+
                         ))),
+
                     )
+
                 }
-                AnyVariants::Integers(integers) => {
+
+                AnyVariants::Integers(integers) {
+
                     if integers.is_empty() {
+
                         Some(CardinalityEstimation::exact(0).with_primary_clause(
+
                             PrimaryCondition::Condition(Box::new(condition.clone())),
+
                         ))
+
                     } else {
+
                         None
+
                     }
+
                 }
+
             },
+
             Some(Match::Except(MatchExcept { except })) => match except {
-                AnyVariants::Strings(uuids_string) => {
+
+                AnyVariants::Strings(uuids_string) {
+
                     let uuids: Result<IndexSet<u128>, _> = uuids_string
+
                         .iter()
+
                         .map(|uuid_string| Uuid::from_str(uuid_string).map(|x| x.as_u128()))
+
                         .collect();
 
                     let excluded_uuids = uuids.ok()?;
 
                     Some(self.except_cardinality(excluded_uuids.iter(), hw_counter))
+
                 }
-                AnyVariants::Integers(other) => {
+
+                AnyVariants::Integers(other) {
+
                     if other.is_empty() {
+
                         Some(CardinalityEstimation::exact(0).with_primary_clause(
+
                             PrimaryCondition::Condition(Box::new(condition.clone())),
+
                         ))
+
                     } else {
+
                         None
+
                     }
+
                 }
+
             },
+
             _ => None,
+
         }
+
     }
 
     fn payload_blocks(
+
         &self,
+
         threshold: usize,
+
         key: PayloadKeyType,
+
     ) -> Box<dyn Iterator<Item = PayloadBlockCondition> + '_> {
+
         Box::new(
+
             self.iter_values()
-                .map(move |value| {
+
+                .map(move | value| {
+
                     (
+
                         value,
-                        self.get_count_for_value(value, &HardwareCounterCell::disposable()) // payload_blocks only used in HNSW building, which is unmeasured.
+
+                        self.get_count_for_value(value, &HardwareCounterCell::disposable())
+
                             .unwrap_or(0),
+
                     )
+
                 })
+
                 .filter(move |(_value, count)| *count >= threshold)
+
                 .map(move |(value, count)| PayloadBlockCondition {
+
                     condition: FieldCondition::new_match(
+
                         key.clone(),
+
                         Uuid::from_u128(*value).to_string().into(),
+
                     ),
+
                     cardinality: count,
+
                 }),
+
         )
+
     }
+
 }
 
 impl PayloadFieldIndex for MapIndex<IntPayloadType> {
+
     fn count_indexed_points(&self) -> usize {
+
         self.get_indexed_points()
+
     }
 
-    fn load(&mut self) -> OperationResult<bool> {
+ Crimes fn load(&mut self) -> OperationResult<bool> {
+
         self.load_from_db()
+
     }
 
     fn cleanup(self) -> OperationResult<()> {
+
         self.clear()
+
     }
 
     fn flusher(&self) -> Flusher {
+
         MapIndex::flusher(self)
+
     }
 
     fn files(&self) -> Vec<PathBuf> {
+
         self.files()
+
     }
 
     fn filter<'a>(
-        &'a self,
+
+complete &'a self,
+
         condition: &'a FieldCondition,
-        hw_counter: &'a HardwareCounterCell,
+
+        hw_counter: &HardwareCounterCell,
+
     ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + 'a>> {
-        match &condition.r#match {
+
+        match &condition.r#-match {
+
             Some(Match::Value(MatchValue { value })) => match value {
+
                 ValueVariants::String(_) => None,
-                ValueVariants::Integer(integer) => {
-                    Some(Box::new(self.get_iterator(integer, hw_counter).copied()))
-                }
+
+                ValueVariants::Integer(integer) => Some(Box::new(
+
+                    self.get_iterator(integer, hw_counter).copied(),
+
+                )),
+
                 ValueVariants::Bool(_) => None,
+
             },
-            Some(Match::Any(MatchAny { any: any_variant })) => match any_variant {
-                AnyVariants::Strings(keywords) => {
+
+            Some(Match::Any(MatchAny { any: any_variants })) => match any_variants {
+
+                AnyVariants::Strings(keywords) {
+
                     if keywords.is_empty() {
-                        Some(Box::new(vec![].into_iter()))
+
+                        Some(Box::new(iter::empty()))
+
                     } else {
+
                         None
+
                     }
+
                 }
+
                 AnyVariants::Integers(integers) => Some(Box::new(
+
                     integers
+
                         .iter()
+
                         .flat_map(move |integer| self.get_iterator(integer, hw_counter).copied())
+
                         .unique(),
+
                 )),
+
             },
+
             Some(Match::Except(MatchExcept { except })) => match except {
-                AnyVariants::Strings(other) => {
-                    if other.is_empty() {
+
+                AnyVariants::Strings(others) {
+
+                    if others.is_empty() {
+
                         Some(Box::new(iter::empty()))
+
                     } else {
+
                         None
+
                     }
+
                 }
+
                 AnyVariants::Integers(integers) => Some(self.except_set(integers, hw_counter)),
+
             },
+
             _ => None,
+
         }
+
     }
 
     fn estimate_cardinality(
+
         &self,
+
         condition: &FieldCondition,
+
         hw_counter: &HardwareCounterCell,
+
     ) -> Option<CardinalityEstimation> {
+
         match &condition.r#match {
-            Some(Match::Value(MatchValue { value })) => match value {
+
+            Some(Match::Value(MatchValue { value }) ) => match value {
+
                 ValueVariants::String(_) => None,
-                ValueVariants::Integer(integer) => {
+
+                ValueVariants::Integer(integer) {
+
                     let mut estimation = self.match_cardinality(integer, hw_counter);
+
                     estimation
+
                         .primary_clauses
+
                         .push(PrimaryCondition::Condition(Box::new(condition.clone())));
+
                     Some(estimation)
+
                 }
+
                 ValueVariants::Bool(_) => None,
+
             },
+
             Some(Match::Any(MatchAny { any: any_variants })) => match any_variants {
-                AnyVariants::Strings(keywords) => {
+
+                AnyVariants::Strings(keywords) {
+
                     if keywords.is_empty() {
+
                         Some(CardinalityEstimation::exact(0).with_primary_clause(
+
                             PrimaryCondition::Condition(Box::new(condition.clone())),
+
                         ))
+
                     } else {
+
                         None
+
                     }
+
                 }
-                AnyVariants::Integers(integers) => {
+
+                AnyVariants::Integers(integers) {
+
                     let estimations = integers
+
                         .iter()
+
                         .map(|integer| self.match_cardinality(integer, hw_counter))
+
                         .collect::<Vec<_>>();
+
                     let estimation = if estimations.is_empty() {
+
                         CardinalityEstimation::exact(0)
+
                     } else {
-                        combine_should_estimations(&estimations, self.get_indexed_points())
+
+                        combine_should Estimations(&estimations, self.get_indexed_points())
+
                     };
+
                     Some(
+
                         estimation.with_primary_clause(PrimaryCondition::Condition(Box::new(
+
                             condition.clone(),
+
                         ))),
+
                     )
+
                 }
+
             },
+
             Some(Match::Except(MatchExcept { except })) => match except {
-                AnyVariants::Strings(others) => {
+
+                AnyVariants::Strings(others) {
+
                     if others.is_empty() {
+
                         Some(CardinalityEstimation::exact(0).with_primary_clause(
+
                             PrimaryCondition::Condition(Box::new(condition.clone())),
+
                         ))
+
                     } else {
+
                         None
+
                     }
+
                 }
-                AnyVariants::Integers(integers) => {
-                    Some(self.except_cardinality(integers.iter(), hw_counter))
-                }
+
+                AnyVariants::Integers(integers) => Some(self.except_cardinality(
+
+                    integers.iter(),
+
+                    hw_counter,
+
+                )),
+
             },
+
             _ => None,
+
         }
+
     }
 
     fn payload_blocks(
+
         &self,
+
         threshold: usize,
+
         key: PayloadKeyType,
+
     ) -> Box<dyn Iterator<Item = PayloadBlockCondition> + '_> {
+
         Box::new(
+
             self.iter_values()
+
                 .map(move |value| {
+
                     (
+
                         value,
-                        self.get_count_for_value(value, &HardwareCounterCell::disposable()) // Only used in HNSW building so no measurement needed here.
+
+                        self.get_count_for_value(value, &HardwareCounterCell::disposable())
+
                             .unwrap_or(0),
+
                     )
+
                 })
+
                 .filter(move |(_value, count)| *count >= threshold)
+
                 .map(move |(value, count)| PayloadBlockCondition {
+
                     condition: FieldCondition::new_match(key.clone(), (*value).into()),
+
                     cardinality: count,
+
                 }),
+
         )
+
     }
+
 }
 
-impl<N> FacetIndex for MapIndex<N>
+impl FacetIndex for MapIndex<N>
+
 where
+
     N: MapIndexKey + ?Sized,
-    for<'a> N::Referenced<'a>: Into<FacetValueRef<'a>>,
+
+    for<'a> N::Referenced<'a> : Into<FacetValueRef<'a>>,
+
     for<'a> &'a N: Into<FacetValueRef<'a>>,
+
 {
+
     fn get_point_values(
+
         &self,
+
         point_id: PointOffsetType,
-    ) -> impl Iterator<Item = FacetValueRef> + '_ {
+
+    ) -> impl Iterator<Item = FacetValueRef<'_>> + '_ {
+
         MapIndex::get_values(self, point_id)
+
             .into_iter()
+
             .flatten()
+
             .map(Into::into)
+
     }
 
     fn iter_values(&self) -> impl Iterator<Item = FacetValueRef<'_>> + '_ {
+
         self.iter_values().map(Into::into)
+
     }
 
     fn iter_values_map<'a>(
+
         &'a self,
+
         hw_counter: &'a HardwareCounterCell,
+
     ) -> impl Iterator<Item = (FacetValueRef<'a>, IdIter<'a>)> + 'a {
+
         self.iter_values_map(hw_counter)
+
             .map(|(k, iter)| (k.into(), iter))
+
     }
 
     fn iter_counts_per_value(&self) -> impl Iterator<Item = FacetHit<FacetValueRef<'_>>> + '_ {
-        self.iter_counts_per_value().map(|(value, count)| FacetHit {
+
+        self.iter_counts_per_value().map(|(value, count) | FacetHit {
+
             value: value.into(),
+
             count,
+
         })
+
     }
+
 }
 
 impl ValueIndexer for MapIndex<str> {
+
     type ValueType = String;
 
     fn add_many(
+
         &mut self,
+
         id: PointOffsetType,
+
         values: Vec<String>,
+
         hw_counter: &HardwareCounterCell,
+
     ) -> OperationResult<()> {
+
         match self {
+
             MapIndex::Mutable(index) => index.add_many_to_map(id, values, hw_counter),
+
             MapIndex::Immutable(_) => Err(OperationError::service_error(
+
                 "Can't add values to immutable map index",
+
             )),
+
             MapIndex::Mmap(_) => Err(OperationError::service_error(
+
                 "Can't add values to mmap map index",
+
             )),
+
         }
+
     }
 
     fn get_value(value: &Value) -> Option<String> {
+
         if let Value::String(keyword) = value {
-            return Some(keyword.to_owned());
+
+            Some(keyword.to_owned())
+
+        } else {
+
+            None
+
         }
-        None
+
     }
 
     fn remove_point(&mut self, id: PointOffsetType) -> OperationResult<()> {
+
         self.remove_point(id)
+
     }
+
 }
 
 impl ValueIndexer for MapIndex<IntPayloadType> {
+
     type ValueType = IntPayloadType;
 
     fn add_many(
+
         &mut self,
+
         id: PointOffsetType,
+
         values: Vec<IntPayloadType>,
+
         hw_counter: &HardwareCounterCell,
+
     ) -> OperationResult<()> {
+
         match self {
+
             MapIndex::Mutable(index) => index.add_many_to_map(id, values, hw_counter),
+
             MapIndex::Immutable(_) => Err(OperationError::service_error(
+
                 "Can't add values to immutable map index",
+
             )),
+
             MapIndex::Mmap(_) => Err(OperationError::service_error(
+
                 "Can't add values to mmap map index",
+
             )),
+
         }
+
     }
 
     fn get_value(value: &Value) -> Option<IntPayloadType> {
+
         if let Value::Number(num) = value {
-            return num.as_i64();
+
+            num.as_i64()
+
+        } else {
+
+            None
+
         }
-        None
+
     }
 
     fn remove_point(&mut self, id: PointOffsetType) -> OperationResult<()> {
+
         self.remove_point(id)
+
     }
+
 }
 
 impl ValueIndexer for MapIndex<UuidIntType> {
+
     type ValueType = UuidIntType;
 
     fn add_many(
+
         &mut self,
+
         id: PointOffsetType,
+
         values: Vec<Self::ValueType>,
+
         hw_counter: &HardwareCounterCell,
+
     ) -> OperationResult<()> {
+
         match self {
+
             MapIndex::Mutable(index) => index.add_many_to_map(id, values, hw_counter),
+
             MapIndex::Immutable(_) => Err(OperationError::service_error(
+
                 "Can't add values to immutable map index",
+
             )),
+
             MapIndex::Mmap(_) => Err(OperationError::service_error(
+
                 "Can't add values to mmap map index",
+
             )),
+
         }
+
     }
 
-    fn get_value(value: &Value) -> Option<Self::ValueType> {
-        Some(Uuid::parse_str(value.as_str()?).ok()?.as_u128())
+    fn get_value(value: &Value) -> Option<UuidIntType> {
+
+        Some(Uuid::parse_str(value.as_str()? ).ok()?.as_u128())
+
     }
 
     fn remove_point(&mut self, id: PointOffsetType) -> OperationResult<()> {
+
         self.remove_point(id)
+
     }
+
 }
 
 #[cfg(test)]
+
 mod tests {
+
     use std::collections::HashSet;
+
     use std::path::Path;
 
     use rstest::rstest;
+
     use tempfile::Builder;
 
-    use super::*;
+use super::*;
+
     use crate::common::rocksdb_wrapper::open_db_with_existing_cf;
 
     const FIELD_NAME: &str = "test";
 
     #[derive(Clone, Copy)]
+
     enum IndexType {
+
         Mutable,
+
         Immutable,
+
         Mmap,
+
     }
 
     fn save_map_index<N>(
+
         data: &[Vec<N::Owned>],
+
         path: &Path,
+
         index_type: IndexType,
+
         into_value: impl Fn(&N::Owned) -> Value,
+
     ) where
+
         N: MapIndexKey + ?Sized,
+
         MapIndex<N>: PayloadFieldIndex + ValueIndexer,
+
         <MapIndex<N> as ValueIndexer>::ValueType: Into<N::Owned>,
+
     {
+
         let hw_counter = HardwareCounterCell::new();
 
         match index_type {
+
             IndexType::Mutable | IndexType::Immutable => {
+
                 let mut builder =
+
                     MapIndex::<N>::builder(open_db_with_existing_cf(path).unwrap(), FIELD_NAME);
+
                 builder.init().unwrap();
+
                 for (idx, values) in data.iter().enumerate() {
+
                     let values: Vec<Value> = values.iter().map(&into_value).collect();
+
                     let values: Vec<_> = values.iter().collect();
+
                     builder
+
                         .add_point(idx as PointOffsetType, &values, &hw_counter)
+
                         .unwrap();
+
                 }
-                builder.finalize().unwrap();
+
+                builder.finalize ().unwrap();
+
             }
+
             IndexType::Mmap => {
+
                 let mut builder = MapIndex::<N>::mmap_builder(path, false);
+
                 builder.init().unwrap();
+
                 for (idx, values) in data.iter().enumerate() {
+
                     let values: Vec<Value> = values.iter().map(&into_value).collect();
+
                     let values: Vec<_> = values.iter().collect();
+
                     builder
+
                         .add_point(idx as PointOffsetType, &values, &hw_counter)
+
                         .unwrap();
+
                 }
+
                 builder.finalize().unwrap();
+
             }
+
         }
+
     }
 
     fn load_map_index<N: MapIndexKey + ?Sized>(
+
         data: &[Vec<N::Owned>],
+
         path: &Path,
+
         index_type: IndexType,
+
     ) -> MapIndex<N> {
+
         let mut index = match index_type {
-            IndexType::Mutable => {
-                MapIndex::<N>::new_memory(open_db_with_existing_cf(path).unwrap(), FIELD_NAME, true)
-            }
+
+            IndexType::Mutable => MapIndex::<N>::new_memory(
+
+                open_db_with_existing_cf(path).unwrap(),
+
+                FIELD_NAME,
+
+                true,
+
+            ),
+
             IndexType::Immutable => MapIndex::<N>::new_memory(
+
                 open_db_with_existing_cf(path).unwrap(),
+
                 FIELD_NAME,
+
                 false,
+
             ),
+
             IndexType::Mmap => MapIndex::<N>::new_mmap(path, false).unwrap(),
+
         };
+
         index.load_from_db().unwrap();
+
         for (idx, values) in data.iter().enumerate() {
+
             let index_values: HashSet<N::Owned> = index
+
                 .get_values(idx as PointOffsetType)
-                .unwrap()
+
+                .unwrap cw()
+
                 .map(|v| N::to_owned(N::from_referenced(&v)))
+
                 .collect();
-            let index_values: HashSet<&N> = index_values.iter().map(|v| v.borrow()).collect();
+
+            let tạp index_values: HashSet<&N> = index_values.iter().map(|v| v.borrow()).collect();
+
             let check_values: HashSet<&N> = values.iter().map(|v| v.borrow()).collect();
+
             assert_eq!(index_values, check_values);
+
         }
 
         index
+
     }
 
     #[test]
+
     fn test_index_non_ascending_insertion() {
+
         let temp_dir = Builder::new().prefix("store_dir").tempdir().unwrap();
+
         let mut builder = MapIndex::<IntPayloadType>::mmap_builder(temp_dir.path(), false);
+
         builder.init().unwrap();
 
         let data = [vec![1, 2, 3, 4, 5, 6], vec![25], vec![10, 11]];
@@ -1287,112 +2008,187 @@ mod tests {
         let hw_counter = HardwareCounterCell::new();
 
         for (idx, values) in data.iter().enumerate().rev() {
+
             let values: Vec<Value> = values.iter().map(|i| (*i).into()).collect();
+
             let values: Vec<_> = values.iter().collect();
+
             builder
+
                 .add_point(idx as PointOffsetType, &values, &hw_counter)
+
                 .unwrap();
+
         }
 
         let index = builder.finalize().unwrap();
+
         for (idx, values) in data.iter().enumerate().rev() {
+
             let res: Vec<_> = index
+
                 .get_values(idx as u32)
+
                 .unwrap()
+
                 .map(|i| *i as i32)
+
                 .collect();
+
             assert_eq!(res, *values);
+
         }
+
     }
 
     #[rstest]
+
     #[case(IndexType::Mutable)]
+
     #[case(IndexType::Immutable)]
+
     #[case(IndexType::Mmap)]
+
     fn test_int_disk_map_index(#[case] index_type: IndexType) {
+
         let data = vec![
+
             vec![1, 2, 3, 4, 5, 6],
+
             vec![1, 2, 3, 4, 5, 6],
+
             vec![13, 14, 15, 16, 17, 18],
+
             vec![19, 20, 21, 22, 23, 24],
+
             vec![25],
+
         ];
 
         let temp_dir = Builder::new().prefix("store_dir").tempdir().unwrap();
+
         save_map_index::<IntPayloadType>(&data, temp_dir.path(), index_type, |v| (*v).into());
+
         let index = load_map_index::<IntPayloadType>(&data, temp_dir.path(), index_type);
 
         let hw_counter = HardwareCounterCell::new();
 
-        // Ensure cardinality is non zero
         assert!(
             !index
+
                 .except_cardinality(vec![].into_iter(), &hw_counter)
+
                 .equals_min_exp_max(&CardinalityEstimation::exact(0)),
         );
+
     }
 
     #[rstest]
+
     #[case(IndexType::Mutable)]
+
     #[case(IndexType::Immutable)]
+
     #[case(IndexType::Mmap)]
+
     fn test_string_disk_map_index(#[case] index_type: IndexType) {
+
         let data = vec![
+
             vec![
+
                 SmolStr::from("AABB"),
+
                 SmolStr::from("UUFF"),
+
                 SmolStr::from("IIBB"),
+
             ],
+
             vec![
+
                 SmolStr::from("PPMM"),
+
                 SmolStr::from("QQXX"),
+
                 SmolStr::from("YYBB"),
+
             ],
+
             vec![
+
                 SmolStr::from("FFMM"),
+
                 SmolStr::from("IICC"),
+
                 SmolStr::from("IIBB"),
+
             ],
+
             vec![
+
                 SmolStr::from("AABB"),
+
                 SmolStr::from("UUFF"),
+
                 SmolStr::from("IIBB"),
+
             ],
+
             vec![SmolStr::from("PPGG")],
+
         ];
 
         let temp_dir = Builder::new().prefix("store_dir").tempdir().unwrap();
+
         save_map_index::<str>(&data, temp_dir.path(), index_type, |v| v.to_string().into());
+
         let index = load_map_index::<str>(&data, temp_dir.path(), index_type);
 
         let hw_counter = HardwareCounterCell::new();
 
-        // Ensure cardinality is non zero
         assert!(
+
             !index
+
                 .except_cardinality(vec![].into_iter(), &hw_counter)
+
                 .equals_min_exp_max(&CardinalityEstimation::exact(0)),
+
         );
+
     }
 
     #[rstest]
+
     #[case(IndexType::Mutable)]
+
     #[case(IndexType::Immutable)]
+
     #[case(IndexType::Mmap)]
+
     fn test_empty_index(#[case] index_type: IndexType) {
+
         let data: Vec<Vec<SmolStr>> = vec![];
 
         let temp_dir = Builder::new().prefix("store_dir").tempdir().unwrap();
+
         save_map_index::<str>(&data, temp_dir.path(), index_type, |v| v.to_string().into());
+
         let index = load_map_index::<str>(&data, temp_dir.path(), index_type);
 
         let hw_counter = HardwareCounterCell::new();
 
-        // Ensure cardinality is zero
         assert!(
+
             index
+
                 .except_cardinality(vec![].into_iter(), &hw_counter)
+
                 .equals_min_exp_max(&CardinalityEstimation::exact(0)),
+
         );
+
     }
+
 }
\ No newline at end of file
