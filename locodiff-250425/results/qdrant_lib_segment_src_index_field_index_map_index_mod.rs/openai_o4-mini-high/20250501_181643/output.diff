
index 0a4e2d76..c12a159c 100644
--- a/qdrant_lib_segment_src_index_field_index_map_index_mod.rs_expectedoutput.txt (expected):tmp/tmpbflfxwye_expected.txt	
+++ b/qdrant_lib_segment_src_index_field_index_map_index_mod.rs_extracted.txt (actual):tmp/tmpln0chxek_actual.txt	
@@ -1,3 +1,9 @@
+// @generated by cargo dev tools; do not edit by hand.
+
+pub mod immutable_map_index;
+pub mod mmap_map_index;
+pub mod mutable_map_index;
+
 use std::borrow::Borrow;
 use std::collections::hash_map::Entry;
 use std::fmt::{Debug, Display};
@@ -8,53 +14,52 @@ use std::str::FromStr;
 use std::sync::Arc;
 
 use ahash::HashMap;
-use common::counter::hardware_counter::HardwareCounterCell;
 use common::mmap_hashmap::Key;
 use common::types::PointOffsetType;
 use indexmap::IndexSet;
 use itertools::Itertools;
-use mmap_map_index::MmapMapIndex;
 use parking_lot::RwLock;
 use rocksdb::DB;
 use serde_json::Value;
 use smol_str::SmolStr;
 use uuid::Uuid;
 
-use self::immutable_map_index::ImmutableMapIndex;
-use self::mutable_map_index::MutableMapIndex;
-use super::FieldIndexBuilderTrait;
-use super::facet_index::FacetIndex;
-use super::mmap_point_to_values::MmapValue;
 use crate::common::Flusher;
 use crate::common::operation_error::{OperationError, OperationResult};
+use crate::counter::hardware_counter::HardwareCounterCell;
 use crate::data_types::facets::{FacetHit, FacetValueRef};
 use crate::index::field_index::stat_tools::number_of_selected_points;
 use crate::index::field_index::{
-    CardinalityEstimation, PayloadBlockCondition, PayloadFieldIndex, PrimaryCondition, ValueIndexer,
+    CardinalityEstimation, FieldCondition, PayloadBlockCondition, PayloadFieldIndex, PrimaryCondition,
+    ValueIndexer,
 };
-use crate::index::query_estimator::combine_should_estimations;
 use crate::telemetry::PayloadIndexTelemetry;
 use crate::types::{
-    AnyVariants, FieldCondition, IntPayloadType, Match, MatchAny, MatchExcept, MatchValue,
-    PayloadKeyType, UuidIntType, ValueVariants,
+    AnyVariants, IntPayloadType, Match, MatchAny, MatchExcept, MatchValue, PayloadKeyType, UuidIntType,
+    ValueVariants,
 };
 
-pub mod immutable_map_index;
-pub mod mmap_map_index;
-pub mod mutable_map_index;
+use self::immutable_map_index::ImmutableMapIndex;
+use self::mmap_map_index::MmapMapIndex;
+use self::mmap_point_to_values::MmapValue;
+use self::mutable_map_index::MutableMapIndex;
+use super::FieldIndexBuilderTrait;
 
+/// Iterator over point IDs by reference.
 pub type IdRefIter<'a> = Box<dyn Iterator<Item = &'a PointOffsetType> + 'a>;
+/// Iterator over point IDs by value.
 pub type IdIter<'a> = Box<dyn Iterator<Item = PointOffsetType> + 'a>;
 
+/// A key type usable in a MapIndex.
 pub trait MapIndexKey: Key + MmapValue + Eq + Display + Debug {
+    /// Owned form of the key.
     type Owned: Borrow<Self> + Hash + Eq + Clone + FromStr + Default;
-
+    /// Convert borrowed to owned.
     fn to_owned(&self) -> Self::Owned;
 }
 
 impl MapIndexKey for str {
     type Owned = SmolStr;
-
     fn to_owned(&self) -> Self::Owned {
         SmolStr::from(self)
     }
@@ -62,7 +67,6 @@ impl MapIndexKey for str {
 
 impl MapIndexKey for IntPayloadType {
     type Owned = IntPayloadType;
-
     fn to_owned(&self) -> Self::Owned {
         *self
     }
@@ -70,12 +74,15 @@ impl MapIndexKey for IntPayloadType {
 
 impl MapIndexKey for UuidIntType {
     type Owned = UuidIntType;
-
     fn to_owned(&self) -> Self::Owned {
         *self
     }
 }
 
+/// An index mapping payload field values to points.
+///
+/// Supports a mutable on-disk RocksDB-backed index, an immutable disk-loaded index,
+/// and an on-disk or in-ram memory-mapped index.
 pub enum MapIndex<N: MapIndexKey + ?Sized> {
     Mutable(MutableMapIndex<N>),
     Immutable(ImmutableMapIndex<N>),
@@ -83,6 +90,7 @@ pub enum MapIndex<N: MapIndexKey + ?Sized> {
 }
 
 impl<N: MapIndexKey + ?Sized> MapIndex<N> {
+    /// Create a new in-memory (RocksDB + appendable flag) index.
     pub fn new_memory(db: Arc<RwLock<DB>>, field_name: &str, is_appendable: bool) -> Self {
         if is_appendable {
             MapIndex::Mutable(MutableMapIndex::new(db, field_name))
@@ -91,16 +99,17 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         }
     }
 
+    /// Load an existing memory map (immutable) index.
     pub fn new_mmap(path: &Path, is_on_disk: bool) -> OperationResult<Self> {
-        Ok(MapIndex::Mmap(Box::new(MmapMapIndex::load(
-            path, is_on_disk,
-        )?)))
+        Ok(MapIndex::Mmap(Box::new(MmapMapIndex::load(path, is_on_disk)?)))
     }
 
+    /// Builder for a memory (RocksDB) index.
     pub fn builder(db: Arc<RwLock<DB>>, field_name: &str) -> MapIndexBuilder<N> {
         MapIndexBuilder(MapIndex::Mutable(MutableMapIndex::new(db, field_name)))
     }
 
+    /// Builder for a memory-map index.
     pub fn mmap_builder(path: &Path, is_on_disk: bool) -> MapIndexMmapBuilder<N> {
         MapIndexMmapBuilder {
             path: path.to_owned(),
@@ -110,28 +119,29 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         }
     }
 
-    fn load_from_db(&mut self) -> OperationResult<bool> {
+    /// Load or reload from underlying storage.
+    pub fn load_from_db(&mut self) -> OperationResult<bool> {
         match self {
             MapIndex::Mutable(index) => index.load_from_db(),
             MapIndex::Immutable(index) => index.load_from_db(),
-            // mmap index is always loaded
             MapIndex::Mmap(_) => Ok(true),
         }
     }
 
+    /// Check if any value at `idx` satisfies `check_fn`.
     pub fn check_values_any(
         &self,
         idx: PointOffsetType,
-        hw_counter: &HardwareCounterCell,
         check_fn: impl Fn(&N) -> bool,
     ) -> bool {
         match self {
             MapIndex::Mutable(index) => index.check_values_any(idx, check_fn),
             MapIndex::Immutable(index) => index.check_values_any(idx, check_fn),
-            MapIndex::Mmap(index) => index.check_values_any(idx, hw_counter, check_fn),
+            MapIndex::Mmap(index) => index.check_values_any(idx, check_fn),
         }
     }
 
+    /// Return stored values for a point.
     pub fn get_values(
         &self,
         idx: PointOffsetType,
@@ -147,6 +157,7 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         }
     }
 
+    /// Number of values for a point.
     pub fn values_count(&self, idx: PointOffsetType) -> usize {
         match self {
             MapIndex::Mutable(index) => index.values_count(idx).unwrap_or_default(),
@@ -155,7 +166,13 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         }
     }
 
-    fn get_indexed_points(&self) -> usize {
+    /// Is the values list empty?
+    pub fn values_is_empty(&self, idx: PointOffsetType) -> bool {
+        self.values_count(idx) == 0
+    }
+
+    /// Total indexed points.
+    pub fn get_indexed_points(&self) -> usize {
         match self {
             MapIndex::Mutable(index) => index.get_indexed_points(),
             MapIndex::Immutable(index) => index.get_indexed_points(),
@@ -163,7 +180,8 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         }
     }
 
-    fn get_values_count(&self) -> usize {
+    /// Total number of assigned values.
+    pub fn get_values_count(&self) -> usize {
         match self {
             MapIndex::Mutable(index) => index.get_values_count(),
             MapIndex::Immutable(index) => index.get_values_count(),
@@ -171,6 +189,7 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         }
     }
 
+    /// Unique distinct values count.
     pub fn get_unique_values_count(&self) -> usize {
         match self {
             MapIndex::Mutable(index) => index.get_unique_values_count(),
@@ -179,22 +198,31 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         }
     }
 
-    fn get_count_for_value(&self, value: &N, hw_counter: &HardwareCounterCell) -> Option<usize> {
-        match self {
+    /// Cardnarity for single value.
+    fn match_cardinality(
+        &self,
+        value: &N,
+        _hw_counter: &HardwareCounterCell,
+    ) -> CardinalityEstimation {
+        let values_count = match self {
             MapIndex::Mutable(index) => index.get_count_for_value(value),
             MapIndex::Immutable(index) => index.get_count_for_value(value),
-            MapIndex::Mmap(index) => index.get_count_for_value(value, hw_counter),
+            MapIndex::Mmap(index) => index.get_count_for_value(value),
         }
+        .unwrap_or(0);
+        CardinalityEstimation::exact(values_count)
     }
 
-    fn get_iterator(&self, value: &N, hw_counter: &HardwareCounterCell) -> IdRefIter<'_> {
+    /// Iterator of points having `value`.
+    fn get_iterator(&self, value: &N, _hw_counter: &HardwareCounterCell) -> IdRefIter<'_> {
         match self {
             MapIndex::Mutable(index) => index.get_iterator(value),
             MapIndex::Immutable(index) => index.get_iterator(value),
-            MapIndex::Mmap(index) => index.get_iterator(value, hw_counter),
+            MapIndex::Mmap(index) => index.get_iterator(value),
         }
     }
 
+    /// Iterator of all distinct values.
     pub fn iter_values(&self) -> Box<dyn Iterator<Item = &N> + '_> {
         match self {
             MapIndex::Mutable(index) => index.iter_values(),
@@ -203,6 +231,7 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         }
     }
 
+    /// Iterator over (value, count).
     pub fn iter_counts_per_value(&self) -> Box<dyn Iterator<Item = (&N, usize)> + '_> {
         match self {
             MapIndex::Mutable(index) => Box::new(index.iter_counts_per_value()),
@@ -211,6 +240,7 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         }
     }
 
+    /// Iterator over (value, point IDs).
     pub fn iter_values_map<'a>(
         &'a self,
         hw_cell: &'a HardwareCounterCell,
@@ -222,10 +252,16 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         }
     }
 
-    pub fn storage_cf_name(field: &str) -> String {
-        format!("{field}_map")
+    /// Return storage files for mmap variant.
+    fn files(&self) -> Vec<PathBuf> {
+        match self {
+            MapIndex::Mutable(_) => Vec::new(),
+            MapIndex::Immutable(_) => Vec::new(),
+            MapIndex::Mmap(index) => index.files(),
+        }
     }
 
+    /// Return database flusher.
     fn flusher(&self) -> Flusher {
         match self {
             MapIndex::Mutable(index) => index.get_db_wrapper().flusher(),
@@ -234,55 +270,7 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         }
     }
 
-    fn match_cardinality(
-        &self,
-        value: &N,
-        hw_counter: &HardwareCounterCell,
-    ) -> CardinalityEstimation {
-        let values_count = self.get_count_for_value(value, hw_counter).unwrap_or(0);
-
-        CardinalityEstimation::exact(values_count)
-    }
-
-    pub fn get_telemetry_data(&self) -> PayloadIndexTelemetry {
-        PayloadIndexTelemetry {
-            field_name: None,
-            points_count: self.get_indexed_points(),
-            points_values_count: self.get_values_count(),
-            histogram_bucket_size: None,
-            index_type: match self {
-                MapIndex::Mutable(_) => "mutable_map",
-                MapIndex::Immutable(_) => "immutable_map",
-                MapIndex::Mmap(_) => "mmap_map",
-            },
-        }
-    }
-
-    pub fn encode_db_record(value: &N, idx: PointOffsetType) -> String {
-        format!("{value}/{idx}")
-    }
-
-    pub fn decode_db_record(s: &str) -> OperationResult<(N::Owned, PointOffsetType)> {
-        const DECODE_ERR: &str = "Index db parsing error: wrong data format";
-        let separator_pos = s
-            .rfind('/')
-            .ok_or_else(|| OperationError::service_error(DECODE_ERR))?;
-        if separator_pos == s.len() - 1 {
-            return Err(OperationError::service_error(DECODE_ERR));
-        }
-        let value_str = &s[..separator_pos];
-        let value =
-            N::Owned::from_str(value_str).map_err(|_| OperationError::service_error(DECODE_ERR))?;
-        let idx_str = &s[separator_pos + 1..];
-        let idx = PointOffsetType::from_str(idx_str)
-            .map_err(|_| OperationError::service_error(DECODE_ERR))?;
-        Ok((value, idx))
-    }
-
-    pub fn values_is_empty(&self, idx: PointOffsetType) -> bool {
-        self.values_count(idx) == 0
-    }
-
+    /// Drop underlying column (RocksDB) or noop for mmap.
     fn clear(self) -> OperationResult<()> {
         match self {
             MapIndex::Mutable(index) => index.get_db_wrapper().recreate_column_family(),
@@ -291,6 +279,7 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         }
     }
 
+    /// Remove a point assignment.
     fn remove_point(&mut self, id: PointOffsetType) -> OperationResult<()> {
         match self {
             MapIndex::Mutable(index) => index.remove_point(id),
@@ -302,127 +291,40 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         }
     }
 
-    fn files(&self) -> Vec<PathBuf> {
-        match self {
-            MapIndex::Mutable(_) => Vec::new(),
-            MapIndex::Immutable(_) => Vec::new(),
-            MapIndex::Mmap(index) => index.files(),
-        }
-    }
-
-    /// Estimates cardinality for `except` clause
-    ///
-    /// # Arguments
-    ///
-    /// * 'excluded' - values, which are not considered as matching
-    ///
-    /// # Returns
-    ///
-    /// * `CardinalityEstimation` - estimation of cardinality
+    /// Cardinality estimation for Except.
     fn except_cardinality<'a>(
         &'a self,
         excluded: impl Iterator<Item = &'a N>,
         hw_counter: &HardwareCounterCell,
     ) -> CardinalityEstimation {
-        // Minimal case: we exclude as many points as possible.
-        // In this case, excluded points do not have any other values except excluded ones.
-        // So the first step - we estimate how many other points is needed to fit unused values.
-
-        // Example:
-        // Values: 20, 20
-        // Unique values: 5
-        // Total points: 100
-        // Total values: 110
-        // total_excluded_value_count = 40
-        // non_excluded_values_count = 110 - 40 = 70
-        // max_values_per_point = 5 - 2 = 3
-        // min_not_excluded_by_values = 70 / 3 = 24
-        // min = max(24, 100 - 40) = 60
-        // exp = ...
-        // max = min(20, 70) = 20
-
-        // Values: 60, 60
-        // Unique values: 5
-        // Total points: 100
-        // Total values: 200
-        // total_excluded_value_count = 120
-        // non_excluded_values_count = 200 - 120 = 80
-        // max_values_per_point = 5 - 2 = 3
-        // min_not_excluded_by_values = 80 / 3 = 27
-        // min = max(27, 100 - 120) = 27
-        // exp = ...
-        // max = min(60, 80) = 60
-
-        // Values: 60, 60, 60
-        // Unique values: 5
-        // Total points: 100
-        // Total values: 200
-        // total_excluded_value_count = 180
-        // non_excluded_values_count = 200 - 180 = 20
-        // max_values_per_point = 5 - 3 = 2
-        // min_not_excluded_by_values = 20 / 2 = 10
-        // min = max(10, 100 - 180) = 10
-        // exp = ...
-        // max = min(60, 20) = 20
-
-        let excluded_value_counts: Vec<_> = excluded
-            .map(|val| {
-                self.get_count_for_value(val.borrow(), hw_counter)
-                    .unwrap_or(0)
+        let total_values = self.get_values_count();
+        let total_points = self.get_indexed_points();
+        let excluded_counts: Vec<_> = excluded
+            .map(|val| match self {
+                MapIndex::Mutable(index) => index.get_count_for_value(val).unwrap_or(0),
+                MapIndex::Immutable(index) => index.get_count_for_value(val).unwrap_or(0),
+                MapIndex::Mmap(index) => index.get_count_for_value(val).unwrap_or(0),
             })
             .collect();
-        let total_excluded_value_count: usize = excluded_value_counts.iter().sum();
-
-        debug_assert!(total_excluded_value_count <= self.get_values_count());
+        let total_excluded: usize = excluded_counts.iter().sum();
 
-        let non_excluded_values_count = self
-            .get_values_count()
-            .saturating_sub(total_excluded_value_count);
-        let max_values_per_point = self
-            .get_unique_values_count()
-            .saturating_sub(excluded_value_counts.len());
+        let non_excluded_values = total_values.saturating_sub(total_excluded);
+        let max_vals_per_point = self.get_unique_values_count().saturating_sub(excluded_counts.len());
 
-        if max_values_per_point == 0 {
-            // All points are excluded, so we can't select any point
-            debug_assert_eq!(non_excluded_values_count, 0);
+        if max_vals_per_point == 0 {
             return CardinalityEstimation::exact(0);
         }
 
-        // Minimal amount of points, required to fit all unused values.
-        // Cardinality can't be less than this value.
-        let min_not_excluded_by_values = non_excluded_values_count.div_ceil(max_values_per_point);
-
-        let min = min_not_excluded_by_values.max(
-            self.get_indexed_points()
-                .saturating_sub(total_excluded_value_count),
-        );
-
-        // Maximum scenario: selected points overlap as much as possible.
-        // From one side, all excluded values should be assigned to the same point
-        // => we can take the value with the maximum amount of points.
-        // From another side, all other values should be enough to fill all other points.
-
-        let max_excluded_value_count = excluded_value_counts.iter().max().copied().unwrap_or(0);
-
-        let max = self
-            .get_indexed_points()
-            .saturating_sub(max_excluded_value_count)
-            .min(non_excluded_values_count);
-
-        // Expected case: we assume that all points are filled equally.
-        // So we can estimate the probability of the point to have non-excluded value.
-        let exp = number_of_selected_points(self.get_indexed_points(), non_excluded_values_count)
-            .max(min)
-            .min(max);
-
-        CardinalityEstimation {
-            primary_clauses: vec![],
-            min,
-            exp,
-            max,
-        }
+        let min_points_by_vals = non_excluded_values.div_ceil(max_vals_per_point);
+        let min = min_points_by_vals.max(total_points.saturating_sub(total_excluded));
+        let max_excl = excluded_counts.into_iter().max().unwrap_or(0);
+        let max = total_points.saturating_sub(max_excl).min(non_excluded_values);
+        let exp = number_of_selected_points(total_points, non_excluded_values).max(min).min(max);
+
+        CardinalityEstimation { primary_clauses: vec![], min, exp, max }
     }
 
+    /// Iterator of points not having any of the excluded values.
     fn except_set<'a, K, A>(
         &'a self,
         excluded: &'a IndexSet<K, A>,
@@ -435,41 +337,83 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         Box::new(
             self.iter_values()
                 .filter(|key| !excluded.contains((*key).borrow()))
-                .flat_map(move |key| self.get_iterator(key.borrow(), hw_counter).copied())
+                .flat_map(move |key| self.get_iterator(key, hw_counter).copied())
                 .unique(),
         )
     }
 
-    pub fn is_on_disk(&self) -> bool {
-        match self {
-            MapIndex::Mutable(_) => false,
-            MapIndex::Immutable(_) => false,
-            MapIndex::Mmap(index) => index.is_on_disk(),
+    /// Column family name.
+    pub fn storage_cf_name(field: &str) -> String {
+        format!("{}_map", field)
+    }
+
+    /// Encode record for RocksDB.
+    pub fn encode_db_record(value: &N, idx: PointOffsetType) -> String {
+        format!("{value}/{idx}")
+    }
+
+    /// Decode RocksDB record.
+    pub fn decode_db_record(s: &str) -> OperationResult<(N::Owned, PointOffsetType)> {
+        const DECODE_ERR: &str = "Index db parsing error: wrong data format";
+        let pos = s.rfind('/').ok_or_else(|| OperationError::service_error(DECODE_ERR))?;
+        if pos == s.len() - 1 {
+            return Err(OperationError::service_error(DECODE_ERR));
         }
+        let vs = &s[..pos];
+        let val = N::Owned::from_str(vs).map_err(|_| OperationError::service_error(DECODE_ERR))?;
+        let is = &s[pos + 1..];
+        let id = PointOffsetType::from_str(is).map_err(|_| OperationError::service_error(DECODE_ERR))?;
+        Ok((val, id))
     }
 
-    /// Populate all pages in the mmap.
-    /// Block until all pages are populated.
+    /// Populate mmap pages.
     pub fn populate(&self) -> OperationResult<()> {
-        match self {
-            MapIndex::Mutable(_) => {}   // Not a mmap
-            MapIndex::Immutable(_) => {} // Not a mmap
-            MapIndex::Mmap(index) => index.populate()?,
+        if let MapIndex::Mmap(idx) = self {
+            idx.populate()?;
         }
         Ok(())
     }
 
-    /// Drop disk cache.
+    /// Clear mmap cache.
     pub fn clear_cache(&self) -> OperationResult<()> {
-        match self {
-            MapIndex::Mutable(_) => {}   // Not a mmap
-            MapIndex::Immutable(_) => {} // Not a mmap
-            MapIndex::Mmap(index) => index.clear_cache()?,
+        if let MapIndex::Mmap(idx) = self {
+            idx.clear_cache()?;
         }
         Ok(())
     }
+
+    /// Is mmap on-disk?
+    pub fn is_on_disk(&self) -> bool {
+        matches!(self, MapIndex::Mmap(idx) if idx.is_on_disk())
+    }
+
+    /// Telemetry information.
+    pub fn get_telemetry_data(&self) -> PayloadIndexTelemetry {
+        PayloadIndexTelemetry {
+            field_name: None,
+            points_count: self.get_indexed_points(),
+            points_values_count: self.get_values_count(),
+            histogram_bucket_size: None,
+            index_type: match self {
+                MapIndex::Mutable(_) => "mutable_map",
+                MapIndex::Immutable(_) => "immutable_map",
+                MapIndex::Mmap(_) => "mmap_map",
+            },
+        }
+    }
+
+    /// Cardinality estimation for a single value.
+    pub fn match_cardinality(&self, value: &N) -> CardinalityEstimation {
+        let cnt = match self {
+            MapIndex::Mutable(index) => index.get_count_for_value(value).unwrap_or(0),
+            MapIndex::Immutable(index) => index.get_count_for_value(value).unwrap_or(0),
+            MapIndex::Mmap(index) => index.get_count_for_value(value).unwrap_or(0),
+        };
+        CardinalityEstimation::exact(cnt)
+    }
 }
 
+/// Builder for a RocksDB-based index.
 pub struct MapIndexBuilder<N: MapIndexKey + ?Sized>(MapIndex<N>);
 
 impl<N: MapIndexKey + ?Sized> FieldIndexBuilderTrait for MapIndexBuilder<N>
@@ -479,11 +423,7 @@ where
     type FieldIndexType = MapIndex<N>;
 
     fn init(&mut self) -> OperationResult<()> {
-        match &mut self.0 {
-            MapIndex::Mutable(index) => index.get_db_wrapper().recreate_column_family(),
-            MapIndex::Immutable(index) => index.get_db_wrapper().recreate_column_family(),
-            MapIndex::Mmap(_) => unreachable!(),
-        }
+        self.0.get_db_wrapper().recreate_column_family()
     }
 
     fn add_point(
@@ -500,6 +440,7 @@ where
     }
 }
 
+/// Builder for a memory-mapped index.
 pub struct MapIndexMmapBuilder<N: MapIndexKey + ?Sized> {
     path: PathBuf,
     point_to_values: Vec<Vec<N::Owned>>,
@@ -524,35 +465,26 @@ where
         payload: &[&Value],
         hw_counter: &HardwareCounterCell,
     ) -> OperationResult<()> {
-        let mut flatten_values: Vec<_> = vec![];
-        for value in payload.iter() {
-            let payload_values = <MapIndex<N> as ValueIndexer>::get_values(value);
-            flatten_values.extend(payload_values);
+        let mut flatten = Vec::new();
+        for v in payload.iter() {
+            flatten.extend(<MapIndex<N> as ValueIndexer>::get_values(v));
         }
-        let flatten_values: Vec<N::Owned> = flatten_values.into_iter().map(Into::into).collect();
-
+        let owned: Vec<_> = flatten.into_iter().map(Into::into).collect();
         if self.point_to_values.len() <= id as usize {
             self.point_to_values.resize_with(id as usize + 1, Vec::new);
         }
-
-        self.point_to_values[id as usize].extend(flatten_values.clone());
-
-        let mut hw_cell_wb = hw_counter
-            .payload_index_io_write_counter()
-            .write_back_counter();
-
-        for value in flatten_values {
-            let entry = self.values_to_points.entry(value);
-
-            if let Entry::Vacant(e) = &entry {
-                let size = N::mmapped_size(N::as_referenced(e.key().borrow()));
-                hw_cell_wb.incr_delta(size);
+        self.point_to_values[id as usize].extend(owned.clone());
+
+        let mut wb = hw_counter.payload_index_io_write_counter().write_back_counter();
+        for val in owned {
+            let ent = self.values_to_points.entry(val.clone());
+            if let Entry::Vacant(e) = &ent {
+                let sz = N::mmapped_size(N::as_referenced(e.key().borrow()));
+                wb.incr_delta(sz);
             }
-
-            hw_cell_wb.incr_delta(size_of_val(&id));
-            entry.or_default().push(id);
+            wb.incr_delta(std::mem::size_of_val(&id));
+            ent.or_default().push(id);
         }
-
         Ok(())
     }
 
@@ -570,42 +502,36 @@ impl PayloadFieldIndex for MapIndex<str> {
     fn count_indexed_points(&self) -> usize {
         self.get_indexed_points()
     }
-
     fn load(&mut self) -> OperationResult<bool> {
         self.load_from_db()
     }
-
     fn cleanup(self) -> OperationResult<()> {
         self.clear()
     }
-
     fn flusher(&self) -> Flusher {
         MapIndex::flusher(self)
     }
-
     fn files(&self) -> Vec<PathBuf> {
         self.files()
     }
-
     fn filter<'a>(
         &'a self,
         condition: &'a FieldCondition,
-        hw_counter: &'a HardwareCounterCell,
+        hw_counter: &HardwareCounterCell,
     ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + 'a>> {
         match &condition.r#match {
             Some(Match::Value(MatchValue { value })) => match value {
                 ValueVariants::String(keyword) => Some(Box::new(
                     self.get_iterator(keyword.as_str(), hw_counter).copied(),
                 )),
-                ValueVariants::Integer(_) => None,
-                ValueVariants::Bool(_) => None,
+                _ => None,
             },
             Some(Match::Any(MatchAny { any: any_variant })) => match any_variant {
                 AnyVariants::Strings(keywords) => Some(Box::new(
                     keywords
                         .iter()
-                        .flat_map(move |keyword| {
-                            self.get_iterator(keyword.as_str(), hw_counter).copied()
+                        .flat_map(move |kw| {
+                            self.get_iterator(kw.as_str(), hw_counter).copied()
                         })
                         .unique(),
                 )),
@@ -630,7 +556,6 @@ impl PayloadFieldIndex for MapIndex<str> {
             _ => None,
         }
     }
-
     fn estimate_cardinality(
         &self,
         condition: &FieldCondition,
@@ -639,37 +564,25 @@ impl PayloadFieldIndex for MapIndex<str> {
         match &condition.r#match {
             Some(Match::Value(MatchValue { value })) => match value {
                 ValueVariants::String(keyword) => {
-                    let mut estimation = self.match_cardinality(keyword.as_str(), hw_counter);
-                    estimation
-                        .primary_clauses
-                        .push(PrimaryCondition::Condition(Box::new(condition.clone())));
-                    Some(estimation)
+                    let mut est = self.match_cardinality(keyword.as_str(), hw_counter);
+                    est.primary_clauses.push(PrimaryCondition::Condition(Box::new(condition.clone())));
+                    Some(est)
                 }
-                ValueVariants::Integer(_) => None,
-                ValueVariants::Bool(_) => None,
+                _ => None,
             },
-            Some(Match::Any(MatchAny { any: any_variant })) => match any_variant {
+            Some(Match::Any(MatchAny { any })) => match any {
                 AnyVariants::Strings(keywords) => {
-                    let estimations = keywords
+                    let v: Vec<_> = keywords
                         .iter()
-                        .map(|keyword| self.match_cardinality(keyword.as_str(), hw_counter))
-                        .collect::<Vec<_>>();
-                    let estimation = if estimations.is_empty() {
-                        CardinalityEstimation::exact(0)
-                    } else {
-                        combine_should_estimations(&estimations, self.get_indexed_points())
-                    };
-                    Some(
-                        estimation.with_primary_clause(PrimaryCondition::Condition(Box::new(
-                            condition.clone(),
-                        ))),
-                    )
+                        .map(|kw| self.match_cardinality(kw.as_str(), hw_counter))
+                        .collect();
+                    let c = if v.is_empty() { CardinalityEstimation::exact(0) }
+                    else { crate::index::field_index::combine_should_estimations(&v, self.get_indexed_points()) };
+                    Some(c.with_primary_clause(PrimaryCondition::Condition(Box::new(condition.clone()))))
                 }
-                AnyVariants::Integers(integers) => {
-                    if integers.is_empty() {
-                        Some(CardinalityEstimation::exact(0).with_primary_clause(
-                            PrimaryCondition::Condition(Box::new(condition.clone())),
-                        ))
+                AnyVariants::Integers(ints) => {
+                    if ints.is_empty() {
+                        Some(CardinalityEstimation::exact(0).with_primary_clause(PrimaryCondition::Condition(Box::new(condition.clone()))))
                     } else {
                         None
                     }
@@ -681,9 +594,7 @@ impl PayloadFieldIndex for MapIndex<str> {
                 }
                 AnyVariants::Integers(others) => {
                     if others.is_empty() {
-                        Some(CardinalityEstimation::exact(0).with_primary_clause(
-                            PrimaryCondition::Condition(Box::new(condition.clone())),
-                        ))
+                        Some(CardinalityEstimation::exact(0).with_primary_clause(PrimaryCondition::Condition(Box::new(condition.clone()))))
                     } else {
                         None
                     }
@@ -692,7 +603,6 @@ impl PayloadFieldIndex for MapIndex<str> {
             _ => None,
         }
     }
-
     fn payload_blocks(
         &self,
         threshold: usize,
@@ -700,100 +610,60 @@ impl PayloadFieldIndex for MapIndex<str> {
     ) -> Box<dyn Iterator<Item = PayloadBlockCondition> + '_> {
         Box::new(
             self.iter_values()
-                .map(|value| {
+                .map(move |v| {
                     (
-                        value,
-                        self.get_count_for_value(value, &HardwareCounterCell::disposable()) // Payload_blocks only used in HNSW building, which is unmeasured.
-                            .unwrap_or(0),
+                        v,
+                        self.get_count_for_value(v, &HardwareCounterCell::disposable()).unwrap_or(0),
                     )
                 })
-                .filter(move |(_value, count)| *count > threshold)
-                .map(move |(value, count)| PayloadBlockCondition {
-                    condition: FieldCondition::new_match(key.clone(), value.to_string().into()),
-                    cardinality: count,
+                .filter(move |&(_v, cnt)| cnt > threshold)
+                .map(move |(v, cnt)| PayloadBlockCondition {
+                    condition: FieldCondition::new_match(key.clone(), v.to_string().into()),
+                    cardinality: cnt,
                 }),
         )
     }
 }
 
-impl PayloadFieldIndex for MapIndex<UuidIntType> {
+impl PayloadFieldIndex for MapIndex<IntPayloadType> {
     fn count_indexed_points(&self) -> usize {
         self.get_indexed_points()
     }
-
     fn load(&mut self) -> OperationResult<bool> {
         self.load_from_db()
     }
-
     fn cleanup(self) -> OperationResult<()> {
         self.clear()
     }
-
     fn flusher(&self) -> Flusher {
         MapIndex::flusher(self)
     }
-
     fn files(&self) -> Vec<PathBuf> {
         self.files()
     }
-
     fn filter<'a>(
         &'a self,
         condition: &'a FieldCondition,
-        hw_counter: &'a HardwareCounterCell,
+        hw_counter: &HardwareCounterCell,
     ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + 'a>> {
         match &condition.r#match {
             Some(Match::Value(MatchValue { value })) => match value {
-                ValueVariants::String(uuid_string) => {
-                    let uuid = Uuid::from_str(uuid_string).ok()?;
-                    Some(Box::new(
-                        self.get_iterator(&uuid.as_u128(), hw_counter).copied(),
-                    ))
-                }
-                ValueVariants::Integer(_) => None,
-                ValueVariants::Bool(_) => None,
+                ValueVariants::Integer(integer) => Some(Box::new(self.get_iterator(integer, hw_counter).copied())),
+                _ => None,
             },
-            Some(Match::Any(MatchAny { any: any_variant })) => match any_variant {
-                AnyVariants::Strings(uuids_string) => {
-                    let uuids: Result<IndexSet<u128>, _> = uuids_string
+            Some(Match::Any(MatchAny { any })) => match any {
+                AnyVariants::Integers(integers) => Some(Box::new(
+                    integers
                         .iter()
-                        .map(|uuid_string| Uuid::from_str(uuid_string).map(|x| x.as_u128()))
-                        .collect();
-
-                    let uuids = uuids.ok()?;
-
-                    Some(Box::new(
-                        uuids
-                            .into_iter()
-                            .flat_map(move |uuid| self.get_iterator(&uuid, hw_counter).copied())
-                            .unique(),
-                    ))
-                }
-                AnyVariants::Integers(integers) => {
-                    if integers.is_empty() {
-                        Some(Box::new(iter::empty()))
-                    } else {
-                        None
-                    }
-                }
+                        .flat_map(move |i| self.get_iterator(i, hw_counter).copied())
+                        .unique(),
+                )),
+                AnyVariants::Strings(_) => None,
             },
             Some(Match::Except(MatchExcept { except })) => match except {
-                AnyVariants::Strings(uuids_string) => {
-                    let uuids: Result<IndexSet<u128>, _> = uuids_string
-                        .iter()
-                        .map(|uuid_string| Uuid::from_str(uuid_string).map(|x| x.as_u128()))
-                        .collect();
-
-                    let excluded_uuids = uuids.ok()?;
-                    let exclude_iter = self
-                        .iter_values()
-                        .filter(move |key| !excluded_uuids.contains(*key))
-                        .flat_map(move |key| self.get_iterator(key, hw_counter).copied())
-                        .unique();
-                    Some(Box::new(exclude_iter))
-                }
-                AnyVariants::Integers(other) => {
-                    if other.is_empty() {
+                AnyVariants::Integers(integers) => Some(self.except_set(integers, hw_counter)),
+                AnyVariants::Strings(_) => {
+                    if except.is_empty() {
                         Some(Box::new(iter::empty()))
                     } else {
                         None
@@ -803,7 +673,6 @@ impl PayloadFieldIndex for MapIndex<UuidIntType> {
             _ => None,
         }
     }
-
     fn estimate_cardinality(
         &self,
         condition: &FieldCondition,
@@ -811,67 +680,30 @@ impl PayloadFieldIndex for MapIndex<UuidIntType> {
     ) -> Option<CardinalityEstimation> {
         match &condition.r#match {
             Some(Match::Value(MatchValue { value })) => match value {
-                ValueVariants::String(uuid_string) => {
-                    let uuid = Uuid::from_str(uuid_string).ok()?;
-                    let mut estimation = self.match_cardinality(&uuid.as_u128(), hw_counter);
-                    estimation
-                        .primary_clauses
-                        .push(PrimaryCondition::Condition(Box::new(condition.clone())));
-                    Some(estimation)
+                ValueVariants::Integer(integer) => {
+                    let mut est = self.match_cardinality(integer, hw_counter);
+                    est.primary_clauses.push(PrimaryCondition::Condition(Box::new(condition.clone())));
+                    Some(est)
                 }
-                ValueVariants::Integer(_) => None,
-                ValueVariants::Bool(_) => None,
+                _ => None,
             },
-            Some(Match::Any(MatchAny { any: any_variant })) => match any_variant {
-                AnyVariants::Strings(uuids_string) => {
-                    let uuids: Result<IndexSet<u128>, _> = uuids_string
+            Some(Match::Any(MatchAny { any })) => match any {
+                AnyVariants::Integers(integers) => {
+                    let v: Vec<_> = integers
                         .iter()
-                        .map(|uuid_string| Uuid::from_str(uuid_string).map(|x| x.as_u128()))
+                        .map(|i| self.match_cardinality(i, hw_counter))
                         .collect();
-
-                    let uuids = uuids.ok()?;
-
-                    let estimations = uuids
-                        .into_iter()
-                        .map(|uuid| self.match_cardinality(&uuid, hw_counter))
-                        .collect::<Vec<_>>();
-                    let estimation = if estimations.is_empty() {
-                        CardinalityEstimation::exact(0)
-                    } else {
-                        combine_should_estimations(&estimations, self.get_indexed_points())
-                    };
-                    Some(
-                        estimation.with_primary_clause(PrimaryCondition::Condition(Box::new(
-                            condition.clone(),
-                        ))),
-                    )
-                }
-                AnyVariants::Integers(integers) => {
-                    if integers.is_empty() {
-                        Some(CardinalityEstimation::exact(0).with_primary_clause(
-                            PrimaryCondition::Condition(Box::new(condition.clone())),
-                        ))
-                    } else {
-                        None
-                    }
+                    let c = if v.is_empty() { CardinalityEstimation::exact(0) }
+                    else { crate::index::field_index::combine_should_estimations(&v, self.get_indexed_points()) };
+                    Some(c.with_primary_clause(PrimaryCondition::Condition(Box::new(condition.clone()))))
                 }
+                AnyVariants::Strings(_) => None,
             },
             Some(Match::Except(MatchExcept { except })) => match except {
-                AnyVariants::Strings(uuids_string) => {
-                    let uuids: Result<IndexSet<u128>, _> = uuids_string
-                        .iter()
-                        .map(|uuid_string| Uuid::from_str(uuid_string).map(|x| x.as_u128()))
-                        .collect();
-
-                    let excluded_uuids = uuids.ok()?;
-
-                    Some(self.except_cardinality(excluded_uuids.iter(), hw_counter))
-                }
-                AnyVariants::Integers(other) => {
-                    if other.is_empty() {
-                        Some(CardinalityEstimation::exact(0).with_primary_clause(
-                            PrimaryCondition::Condition(Box::new(condition.clone())),
-                        ))
+                AnyVariants::Integers(integers) => Some(self.except_cardinality(integers.iter(), hw_counter)),
+                AnyVariants::Strings(_) => {
+                    if except.is_empty() {
+                        Some(CardinalityEstimation::exact(0).with_primary_clause(PrimaryCondition::Condition(Box::new(condition.clone()))))
                     } else {
                         None
                     }
@@ -880,7 +712,6 @@ impl PayloadFieldIndex for MapIndex<UuidIntType> {
             _ => None,
         }
     }
-
     fn payload_blocks(
         &self,
         threshold: usize,
@@ -888,88 +719,80 @@ impl PayloadFieldIndex for MapIndex<UuidIntType> {
     ) -> Box<dyn Iterator<Item = PayloadBlockCondition> + '_> {
         Box::new(
             self.iter_values()
-                .map(move |value| {
+                .map(move |v| {
                     (
-                        value,
-                        self.get_count_for_value(value, &HardwareCounterCell::disposable()) // payload_blocks only used in HNSW building, which is unmeasured.
-                            .unwrap_or(0),
+                        v,
+                        self.get_count_for_value(v, &HardwareCounterCell::disposable()).unwrap_or(0),
                     )
                 })
-                .filter(move |(_value, count)| *count >= threshold)
-                .map(move |(value, count)| PayloadBlockCondition {
-                    condition: FieldCondition::new_match(
-                        key.clone(),
-                        Uuid::from_u128(*value).to_string().into(),
-                    ),
-                    cardinality: count,
+                .filter(move |&(_v, cnt)| cnt >= threshold)
+                .map(move |(v, cnt)| PayloadBlockCondition {
+                    condition: FieldCondition::new_match(key.clone(), (*v).into()),
+                    cardinality: cnt,
                 }),
         )
     }
 }
 
-impl PayloadFieldIndex for MapIndex<IntPayloadType> {
+impl PayloadFieldIndex for MapIndex<UuidIntType> {
     fn count_indexed_points(&self) -> usize {
         self.get_indexed_points()
     }
-
     fn load(&mut self) -> OperationResult<bool> {
         self.load_from_db()
     }
-
     fn cleanup(self) -> OperationResult<()> {
         self.clear()
     }
-
     fn flusher(&self) -> Flusher {
         MapIndex::flusher(self)
     }
-
     fn files(&self) -> Vec<PathBuf> {
         self.files()
     }
-
     fn filter<'a>(
         &'a self,
         condition: &'a FieldCondition,
-        hw_counter: &'a HardwareCounterCell,
+        hw_counter: &HardwareCounterCell,
     ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + 'a>> {
         match &condition.r#match {
             Some(Match::Value(MatchValue { value })) => match value {
-                ValueVariants::String(_) => None,
-                ValueVariants::Integer(integer) => {
-                    Some(Box::new(self.get_iterator(integer, hw_counter).copied()))
+                ValueVariants::String(s) => {
+                    let uuid = Uuid::from_str(s).ok()?;
+                    Some(Box::new(self.get_iterator(&uuid.as_u128(), hw_counter).copied()))
                 }
-                ValueVariants::Bool(_) => None,
+                _ => None,
             },
-            Some(Match::Any(MatchAny { any: any_variant })) => match any_variant {
-                AnyVariants::Strings(keywords) => {
-                    if keywords.is_empty() {
-                        Some(Box::new(vec![].into_iter()))
-                    } else {
-                        None
-                    }
+            Some(Match::Any(MatchAny { any })) => match any {
+                AnyVariants::Strings(ss) => {
+                    let uuids: Result<IndexSet<u128>, _> =
+                        ss.iter().map(|s| Uuid::from_str(s).map(|u| u.as_u128())).collect();
+                    let uu = uuids.ok()?;
+                    Some(Box::new(
+                        uu.into_iter()
+                            .flat_map(move |u| self.get_iterator(&u, hw_counter).copied())
+                            .unique(),
+                    ))
                 }
-                AnyVariants::Integers(integers) => Some(Box::new(
-                    integers
-                        .iter()
-                        .flat_map(move |integer| self.get_iterator(integer, hw_counter).copied())
-                        .unique(),
-                )),
+                AnyVariants::Integers(_) => None,
             },
             Some(Match::Except(MatchExcept { except })) => match except {
-                AnyVariants::Strings(other) => {
-                    if other.is_empty() {
-                        Some(Box::new(iter::empty()))
-                    } else {
-                        None
-                    }
+                AnyVariants::Strings(ss) => {
+                    let uuids: Result<IndexSet<u128>, _> =
+                        ss.iter().map(|s| Uuid::from_str(s).map(|u| u.as_u128())).collect();
+                    let uu = uuids.ok()?;
+                    Some(Box::new(
+                        self.iter_values()
+                            .filter(move |key| !uu.contains(*key))
+                            .flat_map(move |key| self.get_iterator(key, hw_counter).copied())
+                            .unique(),
+                    ))
                 }
-                AnyVariants::Integers(integers) => Some(self.except_set(integers, hw_counter)),
+                AnyVariants::Integers(_) => None,
             },
             _ => None,
         }
     }
-
     fn estimate_cardinality(
         &self,
         condition: &FieldCondition,
@@ -977,61 +800,38 @@ impl PayloadFieldIndex for MapIndex<IntPayloadType> {
     ) -> Option<CardinalityEstimation> {
         match &condition.r#match {
             Some(Match::Value(MatchValue { value })) => match value {
-                ValueVariants::String(_) => None,
-                ValueVariants::Integer(integer) => {
-                    let mut estimation = self.match_cardinality(integer, hw_counter);
-                    estimation
-                        .primary_clauses
-                        .push(PrimaryCondition::Condition(Box::new(condition.clone())));
-                    Some(estimation)
+                ValueVariants::String(s) => {
+                    let uuid = Uuid::from_str(s).ok()?;
+                    let mut est = self.match_cardinality(&uuid.as_u128(), hw_counter);
+                    est.primary_clauses.push(PrimaryCondition::Condition(Box::new(condition.clone())));
+                    Some(est)
                 }
-                ValueVariants::Bool(_) => None,
+                _ => None,
             },
-            Some(Match::Any(MatchAny { any: any_variants })) => match any_variants {
-                AnyVariants::Strings(keywords) => {
-                    if keywords.is_empty() {
-                        Some(CardinalityEstimation::exact(0).with_primary_clause(
-                            PrimaryCondition::Condition(Box::new(condition.clone())),
-                        ))
-                    } else {
-                        None
-                    }
-                }
-                AnyVariants::Integers(integers) => {
-                    let estimations = integers
-                        .iter()
-                        .map(|integer| self.match_cardinality(integer, hw_counter))
-                        .collect::<Vec<_>>();
-                    let estimation = if estimations.is_empty() {
-                        CardinalityEstimation::exact(0)
-                    } else {
-                        combine_should_estimations(&estimations, self.get_indexed_points())
-                    };
-                    Some(
-                        estimation.with_primary_clause(PrimaryCondition::Condition(Box::new(
-                            condition.clone(),
-                        ))),
-                    )
+            Some(Match::Any(MatchAny { any })) => match any {
+                AnyVariants::Strings(ss) => {
+                    let uuids: Result<IndexSet<u128>, _> =
+                        ss.iter().map(|s| Uuid::from_str(s).map(|u| u.as_u128())).collect();
+                    let uu = uuids.ok()?;
+                    let v: Vec<_> = uu.into_iter().map(|u| self.match_cardinality(&u, hw_counter)).collect();
+                    let c = if v.is_empty() { CardinalityEstimation::exact(0) }
+                    else { crate::index::field_index::combine_should_estimations(&v, self.get_indexed_points()) };
+                    Some(c.with_primary_clause(PrimaryCondition::Condition(Box::new(condition.clone()))))
                 }
+                AnyVariants::Integers(_) => None,
             },
             Some(Match::Except(MatchExcept { except })) => match except {
-                AnyVariants::Strings(others) => {
-                    if others.is_empty() {
-                        Some(CardinalityEstimation::exact(0).with_primary_clause(
-                            PrimaryCondition::Condition(Box::new(condition.clone())),
-                        ))
-                    } else {
-                        None
-                    }
-                }
-                AnyVariants::Integers(integers) => {
-                    Some(self.except_cardinality(integers.iter(), hw_counter))
+                AnyVariants::Strings(ss) => {
+                    let uuids: Result<IndexSet<u128>, _> =
+                        ss.iter().map(|s| Uuid::from_str(s).map(|u| u.as_u128())).collect();
+                    let uu = uuids.ok()?;
+                    Some(self.except_cardinality(uu.iter(), hw_counter))
                 }
+                AnyVariants::Integers(_) => None,
             },
             _ => None,
         }
     }
-
     fn payload_blocks(
         &self,
         threshold: usize,
@@ -1039,61 +839,26 @@ impl PayloadFieldIndex for MapIndex<IntPayloadType> {
     ) -> Box<dyn Iterator<Item = PayloadBlockCondition> + '_> {
         Box::new(
             self.iter_values()
-                .map(move |value| {
+                .map(move |v| {
                     (
-                        value,
-                        self.get_count_for_value(value, &HardwareCounterCell::disposable()) // Only used in HNSW building so no measurement needed here.
-                            .unwrap_or(0),
+                        v,
+                        self.get_count_for_value(v, &HardwareCounterCell::disposable()).unwrap_or(0),
                     )
                 })
-                .filter(move |(_value, count)| *count >= threshold)
-                .map(move |(value, count)| PayloadBlockCondition {
-                    condition: FieldCondition::new_match(key.clone(), (*value).into()),
-                    cardinality: count,
+                .filter(move |&(_v, cnt)| cnt >= threshold)
+                .map(move |(v, cnt)| PayloadBlockCondition {
+                    condition: FieldCondition::new_match(
+                        key.clone(),
+                        Uuid::from_u128(*v).to_string().into(),
+                    ),
+                    cardinality: cnt,
                 }),
         )
     }
 }
 
-impl<N> FacetIndex for MapIndex<N>
-where
-    N: MapIndexKey + ?Sized,
-    for<'a> N::Referenced<'a>: Into<FacetValueRef<'a>>,
-    for<'a> &'a N: Into<FacetValueRef<'a>>,
-{
-    fn get_point_values(
-        &self,
-        point_id: PointOffsetType,
-    ) -> impl Iterator<Item = FacetValueRef> + '_ {
-        MapIndex::get_values(self, point_id)
-            .into_iter()
-            .flatten()
-            .map(Into::into)
-    }
-
-    fn iter_values(&self) -> impl Iterator<Item = FacetValueRef<'_>> + '_ {
-        self.iter_values().map(Into::into)
-    }
-
-    fn iter_values_map<'a>(
-        &'a self,
-        hw_counter: &'a HardwareCounterCell,
-    ) -> impl Iterator<Item = (FacetValueRef<'a>, IdIter<'a>)> + 'a {
-        self.iter_values_map(hw_counter)
-            .map(|(k, iter)| (k.into(), iter))
-    }
-
-    fn iter_counts_per_value(&self) -> impl Iterator<Item = FacetHit<FacetValueRef<'_>>> + '_ {
-        self.iter_counts_per_value().map(|(value, count)| FacetHit {
-            value: value.into(),
-            count,
-        })
-    }
-}
-
 impl ValueIndexer for MapIndex<str> {
     type ValueType = String;
-
     fn add_many(
         &mut self,
         id: PointOffsetType,
@@ -1102,22 +867,12 @@ impl ValueIndexer for MapIndex<str> {
     ) -> OperationResult<()> {
         match self {
             MapIndex::Mutable(index) => index.add_many_to_map(id, values, hw_counter),
-            MapIndex::Immutable(_) => Err(OperationError::service_error(
-                "Can't add values to immutable map index",
-            )),
-            MapIndex::Mmap(_) => Err(OperationError::service_error(
-                "Can't add values to mmap map index",
-            )),
+            _ => Err(OperationError::service_error("Can't add values to this index")),
         }
     }
-
     fn get_value(value: &Value) -> Option<String> {
-        if let Value::String(keyword) = value {
-            return Some(keyword.to_owned());
-        }
-        None
+        value.as_str().map(|s| s.to_owned())
     }
-
     fn remove_point(&mut self, id: PointOffsetType) -> OperationResult<()> {
         self.remove_point(id)
     }
@@ -1125,7 +880,6 @@ impl ValueIndexer for MapIndex<str> {
 
 impl ValueIndexer for MapIndex<IntPayloadType> {
     type ValueType = IntPayloadType;
-
     fn add_many(
         &mut self,
         id: PointOffsetType,
@@ -1134,22 +888,12 @@ impl ValueIndexer for MapIndex<IntPayloadType> {
     ) -> OperationResult<()> {
         match self {
             MapIndex::Mutable(index) => index.add_many_to_map(id, values, hw_counter),
-            MapIndex::Immutable(_) => Err(OperationError::service_error(
-                "Can't add values to immutable map index",
-            )),
-            MapIndex::Mmap(_) => Err(OperationError::service_error(
-                "Can't add values to mmap map index",
-            )),
+            _ => Err(OperationError::service_error("Can't add values to this index")),
         }
     }
-
     fn get_value(value: &Value) -> Option<IntPayloadType> {
-        if let Value::Number(num) = value {
-            return num.as_i64();
-        }
-        None
+        value.as_i64()
     }
-
     fn remove_point(&mut self, id: PointOffsetType) -> OperationResult<()> {
         self.remove_point(id)
     }
@@ -1157,46 +901,61 @@ impl ValueIndexer for MapIndex<IntPayloadType> {
 
 impl ValueIndexer for MapIndex<UuidIntType> {
     type ValueType = UuidIntType;
-
     fn add_many(
         &mut self,
         id: PointOffsetType,
-        values: Vec<Self::ValueType>,
+        values: Vec<UuidIntType>,
         hw_counter: &HardwareCounterCell,
     ) -> OperationResult<()> {
         match self {
             MapIndex::Mutable(index) => index.add_many_to_map(id, values, hw_counter),
-            MapIndex::Immutable(_) => Err(OperationError::service_error(
-                "Can't add values to immutable map index",
-            )),
-            MapIndex::Mmap(_) => Err(OperationError::service_error(
-                "Can't add values to mmap map index",
-            )),
+            _ => Err(OperationError::service_error("Can't add values to this index")),
         }
     }
-
-    fn get_value(value: &Value) -> Option<Self::ValueType> {
-        Some(Uuid::parse_str(value.as_str()?).ok()?.as_u128())
+    fn get_value(value: &Value) -> Option<UuidIntType> {
+        value.as_str().and_then(|s| Uuid::parse_str(s).ok().map(|u| u.as_u128()))
     }
-
     fn remove_point(&mut self, id: PointOffsetType) -> OperationResult<()> {
         self.remove_point(id)
     }
 }
 
+impl<N> FacetIndex for MapIndex<N>
+where
+    N: MapIndexKey + ?Sized,
+    for<'a> &'a N: Into<FacetValueRef<'a>>,
+    for<'a> N::Referenced<'a>: Into<FacetValueRef<'a>>,
+{
+    fn get_point_values(
+        &self,
+        point_id: PointOffsetType,
+    ) -> impl Iterator<Item = FacetValueRef<'_>> + '_ {
+        self.get_values(point_id).into_iter().flatten().map(Into::into)
+    }
+    fn iter_values(&self) -> impl Iterator<Item = FacetValueRef<'_>> + '_ {
+        self.iter_values().map(Into::into)
+    }
+    fn iter_values_map<'a>(
+        &'a self,
+        hw_counter: &'a HardwareCounterCell,
+    ) -> impl Iterator<Item = (FacetValueRef<'a>, IdIter<'a>)> + 'a {
+        self.iter_values_map(hw_counter).map(|(k, it)| (k.into(), it))
+    }
+    fn iter_counts_per_value(&self) -> impl Iterator<Item = FacetHit<FacetValueRef<'_>>> + '_ {
+        self.iter_counts_per_value()
+            .map(|(v, c)| FacetHit { value: v.into(), count: c })
+    }
+}
+
 #[cfg(test)]
 mod tests {
+    use super::*;
+    use crate::common::rocksdb_wrapper::open_db_with_existing_cf;
+    use rstest::rstest;
     use std::collections::HashSet;
     use std::path::Path;
-
-    use rstest::rstest;
     use tempfile::Builder;
 
-    use super::*;
-    use crate::common::rocksdb_wrapper::open_db_with_existing_cf;
-
-    const FIELD_NAME: &str = "test";
-
     #[derive(Clone, Copy)]
     enum IndexType {
         Mutable,
@@ -1207,109 +966,68 @@ mod tests {
     fn save_map_index<N>(
         data: &[Vec<N::Owned>],
         path: &Path,
-        index_type: IndexType,
+        idx_type: IndexType,
         into_value: impl Fn(&N::Owned) -> Value,
     ) where
         N: MapIndexKey + ?Sized,
         MapIndex<N>: PayloadFieldIndex + ValueIndexer,
         <MapIndex<N> as ValueIndexer>::ValueType: Into<N::Owned>,
     {
-        let hw_counter = HardwareCounterCell::new();
-
-        match index_type {
+        let hw = HardwareCounterCell::new();
+        match idx_type {
             IndexType::Mutable | IndexType::Immutable => {
-                let mut builder =
-                    MapIndex::<N>::builder(open_db_with_existing_cf(path).unwrap(), FIELD_NAME);
-                builder.init().unwrap();
-                for (idx, values) in data.iter().enumerate() {
-                    let values: Vec<Value> = values.iter().map(&into_value).collect();
-                    let values: Vec<_> = values.iter().collect();
-                    builder
-                        .add_point(idx as PointOffsetType, &values, &hw_counter)
-                        .unwrap();
+                let mut bldr = MapIndex::<N>::builder(open_db_with_existing_cf(path).unwrap(), "test");
+                bldr.init().unwrap();
+                for (i, vals) in data.iter().enumerate() {
+                    let vs: Vec<Value> = vals.iter().map(&into_value).collect();
+                    let refs: Vec<_> = vs.iter().collect();
+                    bldr.add_point(i as _, &refs, &hw).unwrap();
                 }
-                builder.finalize().unwrap();
+                bldr.finalize().unwrap();
             }
             IndexType::Mmap => {
-                let mut builder = MapIndex::<N>::mmap_builder(path, false);
-                builder.init().unwrap();
-                for (idx, values) in data.iter().enumerate() {
-                    let values: Vec<Value> = values.iter().map(&into_value).collect();
-                    let values: Vec<_> = values.iter().collect();
-                    builder
-                        .add_point(idx as PointOffsetType, &values, &hw_counter)
-                        .unwrap();
+                let mut bldr = MapIndex::<N>::mmap_builder(path, false);
+                bldr.init().unwrap();
+                for (i, vals) in data.iter().enumerate() {
+                    let vs: Vec<Value> = vals.iter().map(&into_value).collect();
+                    let refs: Vec<_> = vs.iter().collect();
+                    bldr.add_point(i as _, &refs, &hw).unwrap();
                 }
-                builder.finalize().unwrap();
+                bldr.finalize().unwrap();
             }
         }
     }
 
-    fn load_map_index<N: MapIndexKey + ?Sized>(
+    fn load_map_index<N>(
         data: &[Vec<N::Owned>],
         path: &Path,
-        index_type: IndexType,
-    ) -> MapIndex<N> {
-        let mut index = match index_type {
-            IndexType::Mutable => {
-                MapIndex::<N>::new_memory(open_db_with_existing_cf(path).unwrap(), FIELD_NAME, true)
-            }
-            IndexType::Immutable => MapIndex::<N>::new_memory(
-                open_db_with_existing_cf(path).unwrap(),
-                FIELD_NAME,
-                false,
-            ),
+        idx_type: IndexType,
+    ) -> MapIndex<N>
+    where
+        N: MapIndexKey + ?Sized,
+    {
+        let mut idx = match idx_type {
+            IndexType::Mutable => MapIndex::<N>::new_memory(open_db_with_existing_cf(path).unwrap(), "test", true),
+            IndexType::Immutable => MapIndex::<N>::new_memory(open_db_with_existing_cf(path).unwrap(), "test", false),
             IndexType::Mmap => MapIndex::<N>::new_mmap(path, false).unwrap(),
         };
-        index.load_from_db().unwrap();
-        for (idx, values) in data.iter().enumerate() {
-            let index_values: HashSet<N::Owned> = index
-                .get_values(idx as PointOffsetType)
-                .unwrap()
-                .map(|v| N::to_owned(N::from_referenced(&v)))
+        idx.load_from_db().unwrap();
+        for (i, vals) in data.iter().enumerate() {
+            let got: HashSet<N> = idx
+                .get_values(i as _).unwrap()
+                .map(|r| N::to_owned(N::as_referenced(&r)))
                 .collect();
-            let index_values: HashSet<&N> = index_values.iter().map(|v| v.borrow()).collect();
-            let check_values: HashSet<&N> = values.iter().map(|v| v.borrow()).collect();
-            assert_eq!(index_values, check_values);
-        }
-
-        index
-    }
-
-    #[test]
-    fn test_index_non_ascending_insertion() {
-        let temp_dir = Builder::new().prefix("store_dir").tempdir().unwrap();
-        let mut builder = MapIndex::<IntPayloadType>::mmap_builder(temp_dir.path(), false);
-        builder.init().unwrap();
-
-        let data = [vec![1, 2, 3, 4, 5, 6], vec![25], vec![10, 11]];
-
-        let hw_counter = HardwareCounterCell::new();
-
-        for (idx, values) in data.iter().enumerate().rev() {
-            let values: Vec<Value> = values.iter().map(|i| (*i).into()).collect();
-            let values: Vec<_> = values.iter().collect();
-            builder
-                .add_point(idx as PointOffsetType, &values, &hw_counter)
-                .unwrap();
-        }
-
-        let index = builder.finalize().unwrap();
-        for (idx, values) in data.iter().enumerate().rev() {
-            let res: Vec<_> = index
-                .get_values(idx as u32)
-                .unwrap()
-                .map(|i| *i as i32)
-                .collect();
-            assert_eq!(res, *values);
+            let want: HashSet<N> = vals.iter().cloned().collect();
+            assert_eq!(got, want);
         }
+        idx
     }
 
     #[rstest]
     #[case(IndexType::Mutable)]
     #[case(IndexType::Immutable)]
     #[case(IndexType::Mmap)]
-    fn test_int_disk_map_index(#[case] index_type: IndexType) {
+    fn test_int_disk_map_index(#[case] idx_type: IndexType) {
         let data = vec![
             vec![1, 2, 3, 4, 5, 6],
             vec![1, 2, 3, 4, 5, 6],
@@ -1317,82 +1035,61 @@ mod tests {
             vec![19, 20, 21, 22, 23, 24],
             vec![25],
         ];
-
-        let temp_dir = Builder::new().prefix("store_dir").tempdir().unwrap();
-        save_map_index::<IntPayloadType>(&data, temp_dir.path(), index_type, |v| (*v).into());
-        let index = load_map_index::<IntPayloadType>(&data, temp_dir.path(), index_type);
-
-        let hw_counter = HardwareCounterCell::new();
-
-        // Ensure cardinality is non zero
-        assert!(
-            !index
-                .except_cardinality(vec![].into_iter(), &hw_counter)
-                .equals_min_exp_max(&CardinalityEstimation::exact(0)),
-        );
+        let td = Builder::new().prefix("store_dir").tempdir().unwrap();
+        save_map_index::<IntPayloadType>(&data, td.path(), idx_type, |v| (*v).into());
+        let idx = load_map_index::<IntPayloadType>(&data, td.path(), idx_type);
+        let hw = HardwareCounterCell::new();
+        assert!(!idx.except_cardinality(vec![].into_iter(), &hw).equals_min_exp_max(&CardinalityEstimation::exact(0)));
     }
 
     #[rstest]
     #[case(IndexType::Mutable)]
     #[case(IndexType::Immutable)]
     #[case(IndexType::Mmap)]
-    fn test_string_disk_map_index(#[case] index_type: IndexType) {
+    fn test_string_disk_map_index(#[case] idx_type: IndexType) {
         let data = vec![
-            vec![
-                SmolStr::from("AABB"),
-                SmolStr::from("UUFF"),
-                SmolStr::from("IIBB"),
-            ],
-            vec![
-                SmolStr::from("PPMM"),
-                SmolStr::from("QQXX"),
-                SmolStr::from("YYBB"),
-            ],
-            vec![
-                SmolStr::from("FFMM"),
-                SmolStr::from("IICC"),
-                SmolStr::from("IIBB"),
-            ],
-            vec![
-                SmolStr::from("AABB"),
-                SmolStr::from("UUFF"),
-                SmolStr::from("IIBB"),
-            ],
+            vec![SmolStr::from("AABB"), SmolStr::from("UUFF"), SmolStr::from("IIBB")],
+            vec![SmolStr::from("PPMM"), SmolStr::from("QQXX"), SmolStr::from("YYBB")],
+            vec![SmolStr::from("FFMM"), SmolStr::from("IICC"), SmolStr::from("IIBB")],
+            vec![SmolStr::from("AABB"), SmolStr::from("UUFF"), SmolStr::from("IIBB")],
             vec![SmolStr::from("PPGG")],
         ];
-
-        let temp_dir = Builder::new().prefix("store_dir").tempdir().unwrap();
-        save_map_index::<str>(&data, temp_dir.path(), index_type, |v| v.to_string().into());
-        let index = load_map_index::<str>(&data, temp_dir.path(), index_type);
-
-        let hw_counter = HardwareCounterCell::new();
-
-        // Ensure cardinality is non zero
-        assert!(
-            !index
-                .except_cardinality(vec![].into_iter(), &hw_counter)
-                .equals_min_exp_max(&CardinalityEstimation::exact(0)),
-        );
+        let td = Builder::new().prefix("store_dir").tempdir().unwrap();
+        save_map_index::<str>(&data, td.path(), idx_type, |v| v.to_string().into());
+        let idx = load_map_index::<str>(&data, td.path(), idx_type);
+        let hw = HardwareCounterCell::new();
+        assert!(!idx.except_cardinality(vec![].into_iter(), &hw).equals_min_exp_max(&CardinalityEstimation::exact(0)));
     }
 
     #[rstest]
     #[case(IndexType::Mutable)]
     #[case(IndexType::Immutable)]
     #[case(IndexType::Mmap)]
-    fn test_empty_index(#[case] index_type: IndexType) {
+    fn test_empty_index(#[case] idx_type: IndexType) {
         let data: Vec<Vec<SmolStr>> = vec![];
+        let td = Builder::new().prefix("store_dir").tempdir().unwrap();
+        save_map_index::<str>(&data, td.path(), idx_type, |v| v.to_string().into());
+        let idx = load_map_index::<str>(&data, td.path(), idx_type);
+        let hw = HardwareCounterCell::new();
+        assert!(idx.except_cardinality(vec![].into_iter(), &hw).equals_min_exp_max(&CardinalityEstimation::exact(0)));
+    }
 
-        let temp_dir = Builder::new().prefix("store_dir").tempdir().unwrap();
-        save_map_index::<str>(&data, temp_dir.path(), index_type, |v| v.to_string().into());
-        let index = load_map_index::<str>(&data, temp_dir.path(), index_type);
-
-        let hw_counter = HardwareCounterCell::new();
-
-        // Ensure cardinality is zero
-        assert!(
-            index
-                .except_cardinality(vec![].into_iter(), &hw_counter)
-                .equals_min_exp_max(&CardinalityEstimation::exact(0)),
-        );
+    #[test]
+    fn test_index_non_ascending_insertion() {
+        let td = Builder::new().prefix("store_dir").tempdir().unwrap();
+        let mut bldr = MapIndex::<IntPayloadType>::mmap_builder(td.path(), false);
+        bldr.init().unwrap();
+        let data = [vec![1,2,3,4,5,6], vec![25], vec![10,11]];
+        let hw = HardwareCounterCell::new();
+        for (i, vals) in data.iter().enumerate().rev() {
+            let vs: Vec<Value> = vals.iter().map(|&x| x.into()).collect();
+            let refs: Vec<_> = vs.iter().collect();
+            bldr.add_point(i as _, &refs, &hw).unwrap();
+        }
+        let idx = bldr.finalize().unwrap();
+        for (i, vals) in data.iter().enumerate().rev() {
+            let got: Vec<_> = idx.get_values(i as _).unwrap().map(|&x| x as i32).collect();
+            assert_eq!(got, *vals);
+        }
     }
 }
\ No newline at end of file
