
index 419f10c61..7101f2140 100644
--- a/tldraw_packages_tldraw_src_lib_defaultExternalContentHandlers.ts_expectedoutput.txt (expected):tmp/tmpvwx8w9t1_expected.txt	
+++ b/tldraw_packages_tldraw_src_lib_defaultExternalContentHandlers.ts_extracted.txt (actual):tmp/tmpq6vwry9q_actual.txt	
@@ -20,12 +20,12 @@ import {
 	Vec,
 	VecLike,
 	assert,
-	createShapeId,
 	fetch,
 	getHashForBuffer,
 	getHashForString,
 	toRichText,
 } from '@tldraw/editor'
+
 import { EmbedDefinition } from './defaultEmbedDefinitions'
 import { EmbedShapeUtil } from './shapes/embed/EmbedShapeUtil'
 import { FONT_FAMILIES, FONT_SIZES, TEXT_PROPS } from './shapes/shared/default-shape-constants'
@@ -36,15 +36,7 @@ import { putExcalidrawContent } from './utils/excalidraw/putExcalidrawContent'
 import { renderRichTextFromHTML } from './utils/text/richText'
 import { cleanupText, isRightToLeftLanguage } from './utils/text/text'
 
-/**
- * 5000px
- * @public
- */
 export const DEFAULT_MAX_IMAGE_DIMENSION = 5000
-/**
- * 10mb
- * @public
- */
 export const DEFAULT_MAX_ASSET_SIZE = 10 * 1024 * 1024
 
 /** @public */
@@ -55,8 +47,7 @@ export interface TLExternalContentProps {
 	 */
 	maxImageDimension?: number
 	/**
-	 * The maximum size (in bytes) of an asset. Assets larger than this will be rejected. Defaults
-	 * to 10mb (10 * 1024 * 1024).
+	 * The maximum size (in bytes) of an asset. Assets larger than this will be rejected. Defaults to 10mb (10 * 1024 * 1024).
 	 */
 	maxAssetSize?: number
 	/**
@@ -203,7 +194,8 @@ export async function defaultHandleExternalUrlAsset(
 				'',
 			title: doc.head.querySelector('meta[property="og:title"]')?.getAttribute('content') ?? url,
 			description:
-				doc.head.querySelector('meta[property="og:description"]')?.getAttribute('content') ?? '',
+				doc.head.querySelector('meta[property="og:description"]')?.getAttribute('content') ??
+				'',
 		}
 		if (!meta.image.startsWith('http')) {
 			meta.image = new URL(meta.image, url).href
@@ -329,19 +321,18 @@ export async function defaultHandleExternalFileContent(
 			: editor.getViewportPageBounds().center)
 
 	const pagePoint = new Vec(position.x, position.y)
-	const assetPartials: TLAsset[] = []
 	const assetsToUpdate: {
 		asset: TLAsset
 		file: File
 		temporaryAssetPreview?: string
 	}[] = []
+
 	for (const file of files) {
 		if (file.size > maxAssetSize) {
 			toasts.addToast({
 				title: msg('assets.files.size-too-big'),
 				severity: 'error',
 			})
-
 			console.warn(
 				`File size too big: ${(file.size / 1024).toFixed()}kb > ${(
 					maxAssetSize / 1024
@@ -349,10 +340,6 @@ export async function defaultHandleExternalFileContent(
 			)
 			continue
 		}
-
-		// Use mime type instead of file ext, this is because
-		// window.navigator.clipboard does not preserve file names
-		// of copied files.
 		if (!file.type) {
 			toasts.addToast({
 				title: msg('assets.files.upload-failed'),
@@ -361,19 +348,15 @@ export async function defaultHandleExternalFileContent(
 			console.error('No mime type')
 			continue
 		}
-
-		// We can only accept certain extensions (either images or a videos)
 		const acceptedTypes = [...acceptedImageMimeTypes, ...acceptedVideoMimeTypes]
 		if (!acceptedTypes.includes(file.type)) {
 			toasts.addToast({
 				title: msg('assets.files.type-not-allowed'),
 				severity: 'error',
 			})
-
 			console.warn(`${file.name} not loaded - Mime type not allowed ${file.type}.`)
 			continue
 		}
-
 		const isImageType = acceptedImageMimeTypes.includes(file.type)
 		const isVideoType = acceptedVideoMimeTypes.includes(file.type)
 		const hash = getHashForBuffer(await file.arrayBuffer())
@@ -389,24 +372,24 @@ export async function defaultHandleExternalFileContent(
 		if (isImageType) {
 			temporaryAssetPreview = editor.createTemporaryAssetPreview(assetId, file)
 		}
-		assetPartials.push(assetInfo)
 		assetsToUpdate.push({ asset: assetInfo, file, temporaryAssetPreview })
 	}
 
-	Promise.allSettled(
+	const assets: TLAsset[] = []
+	await Promise.allSettled(
 		assetsToUpdate.map(async (assetAndFile) => {
 			try {
 				const newAsset = await editor.getAssetForExternalContent({
 					type: 'file',
 					file: assetAndFile.file,
 				})
-
 				if (!newAsset) {
 					throw Error('Could not create an asset')
 				}
-
+				const updated = { ...newAsset, id: assetAndFile.asset.id }
+				assets.push(updated)
 				// Save the new asset under the old asset's id
-				editor.updateAssets([{ ...newAsset, id: assetAndFile.asset.id }])
+				editor.updateAssets([updated])
 			} catch (error) {
 				toasts.addToast({
 					title: msg('assets.files.upload-failed'),
@@ -419,7 +402,7 @@ export async function defaultHandleExternalFileContent(
 		})
 	)
 
-	createShapesForAssets(editor, assetPartials, pagePoint)
+	createShapesForAssets(editor, assets, pagePoint)
 }
 
 /** @public */
@@ -440,47 +423,29 @@ export async function defaultHandleExternalTextContent(
 		? renderRichTextFromHTML(editor, html)
 		: toRichText(cleanedUpPlaintext)
 
-	// todo: discuss
-	// If we have one shape with rich text selected, update the shape's text.
-	// const onlySelectedShape = editor.getOnlySelectedShape()
-	// if (onlySelectedShape && 'richText' in onlySelectedShape.props) {
-	// 	editor.updateShapes([
-	// 		{
-	// 			id: onlySelectedShape.id,
-	// 			type: onlySelectedShape.type,
-	// 			props: {
-	// 				richText: richTextToPaste,
-	// 			},
-	// 		},
-	// 	])
-
-	// 	return
-	// }
-
 	// Measure the text with default values
 	let w: number
 	let h: number
 	let autoSize: boolean
 	let align = 'middle' as TLTextShapeProps['textAlign']
 
-	const htmlToMeasure = html ?? cleanedUpPlaintext.replace(/\n/g, '<br>')
-	const isMultiLine = html
-		? richTextToPaste.content.length > 1
-		: cleanedUpPlaintext.split('\n').length > 1
+	const isMultiLine = html ? richTextToPaste.content.length > 1 : cleanedUpPlaintext.split('\n').length > 1
 
-	// check whether the text contains the most common characters in RTL languages
 	const isRtl = isRightToLeftLanguage(cleanedUpPlaintext)
 
 	if (isMultiLine) {
 		align = isMultiLine ? (isRtl ? 'end' : 'start') : 'middle'
 	}
 
-	const rawSize = editor.textMeasure.measureHtml(htmlToMeasure, {
-		...TEXT_PROPS,
-		fontFamily: FONT_FAMILIES[defaultProps.font],
-		fontSize: FONT_SIZES[defaultProps.size],
-		maxWidth: null,
-	})
+	const rawSize = editor.textMeasure.measureHtml(
+		html ?? cleanedUpPlaintext.replace(/\n/g, '<br>'),
+		{
+			...TEXT_PROPS,
+			fontFamily: FONT_FAMILIES[defaultProps.font],
+			fontSize: FONT_SIZES[defaultProps.size],
+			maxWidth: null,
+		}
+	)
 
 	const minWidth = Math.min(
 		isMultiLine ? editor.getViewportPageBounds().width * 0.9 : 920,
@@ -488,18 +453,20 @@ export async function defaultHandleExternalTextContent(
 	)
 
 	if (rawSize.w > minWidth) {
-		const shrunkSize = editor.textMeasure.measureHtml(htmlToMeasure, {
-			...TEXT_PROPS,
-			fontFamily: FONT_FAMILIES[defaultProps.font],
-			fontSize: FONT_SIZES[defaultProps.size],
-			maxWidth: minWidth,
-		})
+		const shrunkSize = editor.textMeasure.measureHtml(
+			html ?? cleanedUpPlaintext.replace(/\n/g, '<br>'),
+			{
+				...TEXT_PROPS,
+				fontFamily: FONT_FAMILIES[defaultProps.font],
+				fontSize: FONT_SIZES[defaultProps.size],
+				maxWidth: minWidth,
+			}
+		)
 		w = shrunkSize.w
 		h = shrunkSize.h
 		autoSize = false
 		align = isRtl ? 'end' : 'start'
 	} else {
-		// autosize is fine
 		w = rawSize.w
 		h = rawSize.h
 		autoSize = true
@@ -517,7 +484,6 @@ export async function defaultHandleExternalTextContent(
 			y: p.y - h / 2,
 			props: {
 				richText: richTextToPaste,
-				// if the text has more than one line, align it to the left
 				textAlign: align,
 				autoSize,
 				w,
@@ -637,7 +603,6 @@ export async function getMediaAssetInfoPartial(
 	let fileType = file.type
 
 	if (file.type === 'video/quicktime') {
-		// hack to make .mov videos work
 		fileType = 'video/mp4'
 	}
 
@@ -664,9 +629,9 @@ export async function getMediaAssetInfoPartial(
 	} as TLImageAsset | TLVideoAsset
 
 	if (maxImageDimension && isFinite(maxImageDimension)) {
-		const size = { w: assetInfo.props.w, h: assetInfo.props.h }
-		const resizedSize = containBoxSize(size, { w: maxImageDimension, h: maxImageDimension })
-		if (size !== resizedSize && MediaHelpers.isStaticImageType(file.type)) {
+		const curSize = { w: assetInfo.props.w, h: assetInfo.props.h }
+		const resizedSize = containBoxSize(curSize, { w: maxImageDimension, h: maxImageDimension })
+		if (curSize !== resizedSize && MediaHelpers.isStaticImageType(file.type)) {
 			assetInfo.props.w = resizedSize.w
 			assetInfo.props.h = resizedSize.h
 		}
@@ -675,18 +640,7 @@ export async function getMediaAssetInfoPartial(
 	return assetInfo
 }
 
-/**
- * A helper function for an external content handler. It creates bookmarks,
- * images or video shapes corresponding to the type of assets provided.
- *
- * @param editor - The editor instance
- *
- * @param assets - An array of asset Ids
- *
- * @param position - the position at which to create the shapes
- *
- * @public
- */
+/** @public */
 export async function createShapesForAssets(
 	editor: Editor,
 	assets: TLAsset[],
@@ -713,7 +667,6 @@ export async function createShapesForAssets(
 						h: asset.props.h,
 					},
 				})
-
 				currentPoint.x += asset.props.w
 				break
 			}
@@ -730,8 +683,8 @@ export async function createShapesForAssets(
 						h: asset.props.h,
 					},
 				})
-
 				currentPoint.x += asset.props.w
+				break
 			}
 		}
 	}
@@ -739,7 +692,6 @@ export async function createShapesForAssets(
 	editor.run(() => {
 		// Create any assets
 		const assetsToCreate = assets.filter((asset) => !editor.getAsset(asset.id))
-
 		editor.store.atomic(() => {
 			if (assetsToCreate.length) {
 				editor.createAssets(assetsToCreate)
@@ -755,23 +707,14 @@ export async function createShapesForAssets(
 	return partials.map((p) => p.id)
 }
 
-/**
- * Repositions selected shapes do that the center of the group is
- * at the provided position
- *
- * @param editor - The editor instance
- *
- * @param position - the point to center the shapes around
- *
- * @public
- */
+/** @public */
 export function centerSelectionAroundPoint(editor: Editor, position: VecLike) {
 	// Re-position shapes so that the center of the group is at the provided point
 	const viewportPageBounds = editor.getViewportPageBounds()
 	let selectionPageBounds = editor.getSelectionPageBounds()
 
 	if (selectionPageBounds) {
-		const offset = selectionPageBounds!.center.sub(position)
+		const offset = selectionPageBounds.center.sub(position)
 
 		editor.updateShapes(
 			editor.getSelectedShapes().map((shape) => {
@@ -786,8 +729,9 @@ export function centerSelectionAroundPoint(editor: Editor, position: VecLike) {
 			})
 		)
 	}
-	selectionPageBounds = editor.getSelectionPageBounds()
+
 	// align selection with the grid if necessary
+	selectionPageBounds = editor.getSelectionPageBounds()
 	if (selectionPageBounds && editor.getInstanceState().isGridMode) {
 		const gridSize = editor.getDocumentSettings().gridSize
 		const topLeft = new Vec(selectionPageBounds.minX, selectionPageBounds.minY)
@@ -805,6 +749,7 @@ export function centerSelectionAroundPoint(editor: Editor, position: VecLike) {
 			})
 		)
 	}
+
 	// Zoom out to fit the shapes, if necessary
 	selectionPageBounds = editor.getSelectionPageBounds()
 	if (selectionPageBounds && !viewportPageBounds.contains(selectionPageBounds)) {
