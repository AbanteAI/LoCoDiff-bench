
index 6abe1ca7..ab3ddc50 100644
--- a/ghostty_src_terminal_kitty_graphics_image.zig_expectedoutput.txt (expected):tmp/tmp7y_o2xdg_expected.txt	
+++ b/ghostty_src_terminal_kitty_graphics_image.zig_extracted.txt (actual):tmp/tmpubbftujs_actual.txt	
@@ -194,7 +194,8 @@ pub const LoadingImage = struct {
     /// Reads the data from a temporary file and returns it. This allocates
     /// and does not free any of the data, so the caller must free it.
     ///
-    /// This will also delete the temporary file if it is in a safe location.
+    /// This will also delete the temporary file if it is successful and the temporary file is
+    /// in a safe, well-known location.
     fn readFile(
         self: *LoadingImage,
         comptime medium: command.Transmission.Medium,
@@ -342,487 +343,4 @@ pub const LoadingImage = struct {
         const actual_len = self.data.items.len;
         if (actual_len != expected_len) {
             std.log.warn(
-                "unexpected length image id={} width={} height={} bpp={} expected_len={} actual_len={}",
-                .{ img.id, img.width, img.height, bpp, expected_len, actual_len },
-            );
-            return error.InvalidData;
-        }
-
-        // Set our time
-        self.image.transmit_time = std.time.Instant.now() catch |err| {
-            log.warn("failed to get time: {}", .{err});
-            return error.InternalError;
-        };
-
-        // Everything looks good, copy the image data over.
-        var result = self.image;
-        result.data = try self.data.toOwnedSlice(alloc);
-        errdefer result.deinit(alloc);
-        self.image = .{};
-        return result;
-    }
-
-    /// Debug function to write the data to a file. This is useful for
-    /// capturing some test data for unit tests.
-    pub fn debugDump(self: LoadingImage) !void {
-        if (comptime builtin.mode != .Debug) @compileError("debugDump in non-debug");
-
-        var buf: [1024]u8 = undefined;
-        const filename = try std.fmt.bufPrint(
-            &buf,
-            "image-{s}-{s}-{d}x{d}-{}.data",
-            .{
-                @tagName(self.image.format),
-                @tagName(self.image.compression),
-                self.image.width,
-                self.image.height,
-                self.image.id,
-            },
-        );
-        const cwd = std.fs.cwd();
-        const f = try cwd.createFile(filename, .{});
-        defer f.close();
-
-        const writer = f.writer();
-        try writer.writeAll(self.data.items);
-    }
-
-    /// Decompress the data in-place.
-    fn decompress(self: *LoadingImage, alloc: Allocator) !void {
-        return switch (self.image.compression) {
-            .none => {},
-            .zlib_deflate => self.decompressZlib(alloc),
-        };
-    }
-
-    fn decompressZlib(self: *LoadingImage, alloc: Allocator) !void {
-        // Open our zlib stream
-        var fbs = std.io.fixedBufferStream(self.data.items);
-        var stream = std.compress.zlib.decompressor(fbs.reader());
-
-        // Write it to an array list
-        var list = std.ArrayList(u8).init(alloc);
-        errdefer list.deinit();
-        stream.reader().readAllArrayList(&list, max_size) catch |err| {
-            log.warn("failed to read decompressed data: {}", .{err});
-            return error.DecompressionFailed;
-        };
-
-        // Empty our current data list, take ownership over managed array list
-        self.data.deinit(alloc);
-        self.data = .{ .items = list.items, .capacity = list.capacity };
-
-        // Make sure we note that our image is no longer compressed
-        self.image.compression = .none;
-    }
-
-    /// Decode the data as PNG. This will also updated the image dimensions.
-    fn decodePng(self: *LoadingImage, alloc: Allocator) !void {
-        assert(self.image.format == .png);
-
-        const result = wuffs.png.decode(
-            alloc,
-            self.data.items,
-        ) catch |err| switch (err) {
-            error.WuffsError => return error.InvalidData,
-            error.OutOfMemory => return error.OutOfMemory,
-        };
-        defer alloc.free(result.data);
-
-        if (result.data.len > max_size) {
-            log.warn("png image too large size={} max_size={}", .{ result.data.len, max_size });
-            return error.InvalidData;
-        }
-
-        // Replace our data
-        self.data.deinit(alloc);
-        self.data = .{};
-        try self.data.ensureUnusedCapacity(alloc, result.data.len);
-        try self.data.appendSlice(alloc, result.data[0..result.data.len]);
-
-        // Store updated image dimensions
-        self.image.width = result.width;
-        self.image.height = result.height;
-        self.image.format = .rgba;
-    }
-};
-
-/// Image represents a single fully loaded image.
-pub const Image = struct {
-    id: u32 = 0,
-    number: u32 = 0,
-    width: u32 = 0,
-    height: u32 = 0,
-    format: command.Transmission.Format = .rgb,
-    compression: command.Transmission.Compression = .none,
-    data: []const u8 = "",
-    transmit_time: std.time.Instant = undefined,
-
-    /// Set this to true if this image was loaded by a command that
-    /// doesn't specify an ID or number, since such commands should
-    /// not be responded to, even though we do currently give them
-    /// IDs in the public range (which is bad!).
-    implicit_id: bool = false,
-
-    pub const Error = error{
-        InternalError,
-        InvalidData,
-        DecompressionFailed,
-        DimensionsRequired,
-        DimensionsTooLarge,
-        FilePathTooLong,
-        TemporaryFileNotInTempDir,
-        TemporaryFileNotNamedCorrectly,
-        UnsupportedFormat,
-        UnsupportedMedium,
-        UnsupportedDepth,
-    };
-
-    pub fn deinit(self: *Image, alloc: Allocator) void {
-        if (self.data.len > 0) alloc.free(self.data);
-    }
-
-    /// Mostly for logging
-    pub fn withoutData(self: *const Image) Image {
-        var copy = self.*;
-        copy.data = "";
-        return copy;
-    }
-};
-
-/// The rect taken up by some image placement, in grid cells. This will
-/// be rounded up to the nearest grid cell since we can't place images
-/// in partial grid cells.
-pub const Rect = struct {
-    top_left: PageList.Pin,
-    bottom_right: PageList.Pin,
-};
-
-// This specifically tests we ALLOW invalid RGB data because Kitty
-// documents that this should work.
-test "image load with invalid RGB data" {
-    const testing = std.testing;
-    const alloc = testing.allocator;
-
-    // <ESC>_Gi=31,s=1,v=1,a=q,t=d,f=24;AAAA<ESC>\
-    var cmd: command.Command = .{
-        .control = .{ .transmit = .{
-            .format = .rgb,
-            .width = 1,
-            .height = 1,
-            .image_id = 31,
-        } },
-        .data = try alloc.dupe(u8, "AAAA"),
-    };
-    defer cmd.deinit(alloc);
-    var loading = try LoadingImage.init(alloc, &cmd);
-    defer loading.deinit(alloc);
-}
-
-test "image load with image too wide" {
-    const testing = std.testing;
-    const alloc = testing.allocator;
-
-    var cmd: command.Command = .{
-        .control = .{ .transmit = .{
-            .format = .rgb,
-            .width = max_dimension + 1,
-            .height = 1,
-            .image_id = 31,
-        } },
-        .data = try alloc.dupe(u8, "AAAA"),
-    };
-    defer cmd.deinit(alloc);
-    var loading = try LoadingImage.init(alloc, &cmd);
-    defer loading.deinit(alloc);
-    try testing.expectError(error.DimensionsTooLarge, loading.complete(alloc));
-}
-
-test "image load with image too tall" {
-    const testing = std.testing;
-    const alloc = testing.allocator;
-
-    var cmd: command.Command = .{
-        .control = .{ .transmit = .{
-            .format = .rgb,
-            .height = max_dimension + 1,
-            .width = 1,
-            .image_id = 31,
-        } },
-        .data = try alloc.dupe(u8, "AAAA"),
-    };
-    defer cmd.deinit(alloc);
-    var loading = try LoadingImage.init(alloc, &cmd);
-    defer loading.deinit(alloc);
-    try testing.expectError(error.DimensionsTooLarge, loading.complete(alloc));
-}
-
-test "image load: rgb, zlib compressed, direct" {
-    const testing = std.testing;
-    const alloc = testing.allocator;
-
-    var cmd: command.Command = .{
-        .control = .{ .transmit = .{
-            .format = .rgb,
-            .medium = .direct,
-            .compression = .zlib_deflate,
-            .height = 96,
-            .width = 128,
-            .image_id = 31,
-        } },
-        .data = try alloc.dupe(
-            u8,
-            @embedFile("testdata/ghostty_src_terminal_kitty_graphics_image.zig_expectedoutput.txt (expected): rgb, not compressed, direct" {
-    const testing = std.testing;
-    const alloc = testing.allocator;
-
-    var cmd: command.Command = .{
-        .control = .{ .transmit = .{
-            .format = .rgb,
-            .medium = .direct,
-            .compression = .none,
-            .width = 20,
-            .height = 15,
-            .image_id = 31,
-        } },
-        .data = try alloc.dupe(
-            u8,
-            @embedFile("testdata/ghostty_src_terminal_kitty_graphics_image.zig_expectedoutput.txt (expected): rgb, zlib compressed, direct, chunked" {
-    const testing = std.testing;
-    const alloc = testing.allocator;
-
-    const data = @embedFile("testdata/ghostty_src_terminal_kitty_graphics_image.zig_expectedoutput.txt (expected): command.Command = .{
-        .control = .{ .transmit = .{
-            .format = .rgb,
-            .medium = .direct,
-            .compression = .zlib_deflate,
-            .height = 96,
-            .width = 128,
-            .image_id = 31,
-            .more_chunks = true,
-        } },
-        .data = try alloc.dupe(u8, data[0..1024]),
-    };
-    defer cmd.deinit(alloc);
-    var loading = try LoadingImage.init(alloc, &cmd);
-    defer loading.deinit(alloc);
-
-    // Read our remaining chunks
-    var fbs = std.io.fixedBufferStream(data[1024..]);
-    var buf: [1024]u8 = undefined;
-    while (fbs.reader().readAll(&buf)) |size| {
-        try loading.addData(alloc, buf[0..size]);
-        if (size < buf.len) break;
-    } else |err| return err;
-
-    // Complete
-    var img = try loading.complete(alloc);
-    defer img.deinit(alloc);
-    try testing.expect(img.compression == .none);
-}
-
-test "image load: rgb, zlib compressed, direct, chunked with zero initial chunk" {
-    const testing = std.testing;
-    const alloc = testing.allocator;
-
-    const data = @embedFile("testdata/ghostty_src_terminal_kitty_graphics_image.zig_expectedoutput.txt (expected): command.Command = .{
-        .control = .{ .transmit = .{
-            .format = .rgb,
-            .medium = .direct,
-            .compression = .zlib_deflate,
-            .height = 96,
-            .width = 128,
-            .image_id = 31,
-            .more_chunks = true,
-        } },
-    };
-    defer cmd.deinit(alloc);
-    var loading = try LoadingImage.init(alloc, &cmd);
-    defer loading.deinit(alloc);
-
-    // Read our remaining chunks
-    var fbs = std.io.fixedBufferStream(data);
-    var buf: [1024]u8 = undefined;
-    while (fbs.reader().readAll(&buf)) |size| {
-        try loading.addData(alloc, buf[0..size]);
-        if (size < buf.len) break;
-    } else |err| return err;
-
-    // Complete
-    var img = try loading.complete(alloc);
-    defer img.deinit(alloc);
-    try testing.expect(img.compression == .none);
-}
-
-test "image load: temporary file without correct path" {
-    const testing = std.testing;
-    const alloc = testing.allocator;
-
-    var tmp_dir = try internal_os.TempDir.init();
-    defer tmp_dir.deinit();
-    const data = @embedFile("testdata/ghostty_src_terminal_kitty_graphics_image.zig_expectedoutput.txt (expected): [std.fs.max_path_bytes]u8 = undefined;
-    const path = try tmp_dir.dir.realpath("image.data", &buf);
-
-    var cmd: command.Command = .{
-        .control = .{ .transmit = .{
-            .format = .rgb,
-            .medium = .temporary_file,
-            .compression = .none,
-            .width = 20,
-            .height = 15,
-            .image_id = 31,
-        } },
-        .data = try alloc.dupe(u8, path),
-    };
-    defer cmd.deinit(alloc);
-    try testing.expectError(error.TemporaryFileNotNamedCorrectly, LoadingImage.init(alloc, &cmd));
-
-    // Temporary file should still be there
-    try tmp_dir.dir.access(path, .{});
-}
-
-test "image load: rgb, not compressed, temporary file" {
-    const testing = std.testing;
-    const alloc = testing.allocator;
-
-    var tmp_dir = try internal_os.TempDir.init();
-    defer tmp_dir.deinit();
-    const data = @embedFile("testdata/ghostty_src_terminal_kitty_graphics_image.zig_expectedoutput.txt (expected): [std.fs.max_path_bytes]u8 = undefined;
-    const path = try tmp_dir.dir.realpath("tty-graphics-protocol-image.data", &buf);
-
-    var cmd: command.Command = .{
-        .control = .{ .transmit = .{
-            .format = .rgb,
-            .medium = .temporary_file,
-            .compression = .none,
-            .width = 20,
-            .height = 15,
-            .image_id = 31,
-        } },
-        .data = try alloc.dupe(u8, path),
-    };
-    defer cmd.deinit(alloc);
-    var loading = try LoadingImage.init(alloc, &cmd);
-    defer loading.deinit(alloc);
-    var img = try loading.complete(alloc);
-    defer img.deinit(alloc);
-    try testing.expect(img.compression == .none);
-
-    // Temporary file should be gone
-    try testing.expectError(error.FileNotFound, tmp_dir.dir.access(path, .{}));
-}
-
-test "image load: rgb, not compressed, regular file" {
-    const testing = std.testing;
-    const alloc = testing.allocator;
-
-    var tmp_dir = try internal_os.TempDir.init();
-    defer tmp_dir.deinit();
-    const data = @embedFile("testdata/ghostty_src_terminal_kitty_graphics_image.zig_expectedoutput.txt (expected): [std.fs.max_path_bytes]u8 = undefined;
-    const path = try tmp_dir.dir.realpath("image.data", &buf);
-
-    var cmd: command.Command = .{
-        .control = .{ .transmit = .{
-            .format = .rgb,
-            .medium = .file,
-            .compression = .none,
-            .width = 20,
-            .height = 15,
-            .image_id = 31,
-        } },
-        .data = try alloc.dupe(u8, path),
-    };
-    defer cmd.deinit(alloc);
-    var loading = try LoadingImage.init(alloc, &cmd);
-    defer loading.deinit(alloc);
-    var img = try loading.complete(alloc);
-    defer img.deinit(alloc);
-    try testing.expect(img.compression == .none);
-    try tmp_dir.dir.access(path, .{});
-}
-
-test "image load: png, not compressed, regular file" {
-    const testing = std.testing;
-    const alloc = testing.allocator;
-
-    var tmp_dir = try internal_os.TempDir.init();
-    defer tmp_dir.deinit();
-    const data = @embedFile("testdata/ghostty_src_terminal_kitty_graphics_image.zig_expectedoutput.txt (expected): [std.fs.max_path_bytes]u8 = undefined;
-    const path = try tmp_dir.dir.realpath("tty-graphics-protocol-image.data", &buf);
-
-    var cmd: command.Command = .{
-        .control = .{ .transmit = .{
-            .format = .png,
-            .medium = .file,
-            .compression = .none,
-            .width = 0,
-            .height = 0,
-            .image_id = 31,
-        } },
-        .data = try alloc.dupe(u8, path),
-    };
-    defer cmd.deinit(alloc);
-    var loading = try LoadingImage.init(alloc, &cmd);
-    defer loading.deinit(alloc);
-    var img = try loading.complete(alloc);
-    defer img.deinit(alloc);
-    try testing.expect(img.compression == .none);
-    try testing.expect(img.format == .rgba);
-    try tmp_dir.dir.access(path, .{});
-}
\ No newline at end of file
+                "unexpected length image id={} width
\ No newline at end of file
