--- ghostty_src_terminal_kitty_graphics_image.zig_expectedoutput.txt (expected)+++ ghostty_src_terminal_kitty_graphics_image.zig_extracted.txt (actual)@@ -30,11 +30,11 @@     image: Image,
 
     /// The data that is being built up.
-    data: std.ArrayListUnmanaged(u8) = .{},
+    data: std.ArrayListUnmanaged(u8),
 
     /// This is non-null when a transmit and display command is given
     /// so that we display the image after it is fully loaded.
-    display: ?command.Display = null,
+    display: ?command.Display,
 
     /// Quiet is the quiet settings for the initial load command. This is
     /// used if q isn't set on subsequent chunks.
@@ -58,6 +58,7 @@                 .format = t.format,
             },
 
+            .data = .{},
             .display = cmd.display(),
             .quiet = cmd.quiet,
         };
@@ -125,8 +126,7 @@         const fd = std.c.shm_open(pathz, @as(c_int, @bitCast(std.c.O{ .ACCMODE = .RDONLY })), 0);
         switch (std.posix.errno(fd)) {
             .SUCCESS => {},
-            else => |err| {
-                log.warn("unable to open shared memory {s}: {}", .{ path, err });
+            else => |_| {
                 return error.InvalidData;
             },
         }
@@ -136,8 +136,7 @@         // The size from stat on may be larger than our expected size because
         // shared memory has to be a multiple of the page size.
         const stat_size: usize = stat: {
-            const stat = std.posix.fstat(fd) catch |err| {
-                log.warn("unable to fstat shared memory {s}: {}", .{ path, err });
+            const stat = std.posix.fstat(fd) catch |_| {
                 return error.InvalidData;
             };
             if (stat.size <= 0) return error.InvalidData;
@@ -173,8 +172,7 @@             std.c.MAP{ .TYPE = .SHARED },
             fd,
             0,
-        ) catch |err| {
-            log.warn("unable to mmap shared memory {s}: {}", .{ path, err });
+        ) catch |_| {
             return error.InvalidData;
         };
         defer std.posix.munmap(map);
@@ -260,7 +258,7 @@         // Read the file
         var managed = std.ArrayList(u8).init(alloc);
         errdefer managed.deinit();
-        const size: usize = if (t.size > 0) @min(t.size, max_size) else max_size;
+        const size: usize = if (t.size > 0) @min(@intCast(t.size), max_size) else max_size;
         reader.readAllArrayList(&managed, size) catch |err| {
             log.warn("failed to read temporary file: {}", .{err});
             return error.InvalidData;
@@ -326,11 +324,11 @@     pub fn complete(self: *LoadingImage, alloc: Allocator) !Image {
         const img = &self.image;
 
+        // Decode the png if we have to
+        if (img.format == .png) try self.decodePng(alloc);
+
         // Decompress the data if it is compressed.
         try self.decompress(alloc);
-
-        // Decode the png if we have to
-        if (img.format == .png) try self.decodePng(alloc);
 
         // Validate our dimensions.
         if (img.width == 0 or img.height == 0) return error.DimensionsRequired;
@@ -341,7 +339,7 @@         const expected_len = img.width * img.height * bpp;
         const actual_len = self.data.items.len;
         if (actual_len != expected_len) {
-            std.log.warn(
+            log.warn(
                 "unexpected length image id={} width={} height={} bpp={} expected_len={} actual_len={}",
                 .{ img.id, img.width, img.height, bpp, expected_len, actual_len },
             );
@@ -358,7 +356,7 @@         var result = self.image;
         result.data = try self.data.toOwnedSlice(alloc);
         errdefer result.deinit(alloc);
-        self.image = .{};
+        self.image = undefined; // So deinit doesn't free the data
         return result;
     }
 
@@ -403,8 +401,7 @@         // Write it to an array list
         var list = std.ArrayList(u8).init(alloc);
         errdefer list.deinit();
-        stream.reader().readAllArrayList(&list, max_size) catch |err| {
-            log.warn("failed to read decompressed data: {}", .{err});
+        stream.reader().readAllArrayList(&list, max_size) catch |_| {
             return error.DecompressionFailed;
         };
 
@@ -449,20 +446,20 @@ 
 /// Image represents a single fully loaded image.
 pub const Image = struct {
-    id: u32 = 0,
-    number: u32 = 0,
-    width: u32 = 0,
-    height: u32 = 0,
-    format: command.Transmission.Format = .rgb,
-    compression: command.Transmission.Compression = .none,
-    data: []const u8 = "",
-    transmit_time: std.time.Instant = undefined,
+    id: u32,
+    number: u32,
+    width: u32,
+    height: u32,
+    format: command.Transmission.Format,
+    compression: command.Transmission.Compression,
+    data: []const u8,
+    transmit_time: std.time.Instant,
 
     /// Set this to true if this image was loaded by a command that
     /// doesn't specify an ID or number, since such commands should
     /// not be responded to, even though we do currently give them
     /// IDs in the public range (which is bad!).
-    implicit_id: bool = false,
+    implicit_id: bool,
 
     pub const Error = error{
         InternalError,
@@ -476,6 +473,7 @@         UnsupportedFormat,
         UnsupportedMedium,
         UnsupportedDepth,
+        OutOfMemory,
     };
 
     pub fn deinit(self: *Image, alloc: Allocator) void {
@@ -764,12 +762,12 @@     defer tmp_dir.deinit();
     const data = @embedFile("testdata/image-rgb-none-20x15-2147483647-raw.data");
     try tmp_dir.dir.writeFile(.{
-        .sub_path = "image.data",
+        .sub_path = "tty-graphics-protocol-image.data",
         .data = data,
     });
 
     var buf: [std.fs.max_path_bytes]u8 = undefined;
-    const path = try tmp_dir.dir.realpath("image.data", &buf);
+    const path = try tmp_dir.dir.realpath("tty-graphics-protocol-image.data", &buf);
 
     var cmd: command.Command = .{
         .control = .{ .transmit = .{
