
index 1a1fc9aef..0495982e0 100644
--- a/qdrant_lib_segment_src_entry_entry_point.rs_expectedoutput.txt (expected):tmp/tmptxo5mk6__expected.txt	
+++ b/qdrant_lib_segment_src_entry_entry_point.rs_extracted.txt (actual):tmp/tmpm0_dcj01_actual.txt	
@@ -47,8 +47,6 @@ pub trait SegmentEntry: SnapshotEntry {
     ) -> OperationResult<Vec<Vec<ScoredPoint>>>;
 
     /// Rescore results with a formula that can reference payload values.
-    ///
-    /// A deleted bitslice is passed to exclude points from a wrapped segment.
     fn rescore_with_formula(
         &self,
         formula_ctx: Arc<FormulaContext>,
@@ -239,28 +237,6 @@ pub trait SegmentEntry: SnapshotEntry {
     /// Get segment type
     fn segment_type(&self) -> SegmentType;
 
-    /// Get current stats of the segment
-    fn info(&self) -> SegmentInfo;
-
-    /// Get size related stats of the segment.
-    /// This returns `SegmentInfo` with some non size-related data (like `schema`) unset to improve performance.
-    fn size_info(&self) -> SegmentInfo;
-
-    /// Get segment configuration
-    fn config(&self) -> &SegmentConfig;
-
-    /// Get current stats of the segment
-    fn is_appendable(&self) -> bool;
-
-    /// Flushes current segment state into a persistent storage, if possible
-    /// if sync == true, block current thread while flushing
-    ///
-    /// Returns maximum version number which is guaranteed to be persisted.
-    fn flush(&self, sync: bool, force: bool) -> OperationResult<SeqNumberType>;
-
-    /// Removes all persisted data and forces to destroy segment
-    fn drop_data(self) -> OperationResult<()>;
-
     /// Path to data, owned by segment
     fn data_path(&self) -> PathBuf;
 
@@ -320,6 +296,28 @@ pub trait SegmentEntry: SnapshotEntry {
         hw_counter: &HardwareCounterCell,
     ) -> OperationResult<usize>;
 
+    /// Get current stats of the segment
+    fn info(&self) -> SegmentInfo;
+
+    /// Get size related stats of the segment.
+    /// This returns `SegmentInfo` with some non size-related data (like `schema`) unset to improve performance.
+    fn size_info(&self) -> SegmentInfo;
+
+    /// Get segment configuration
+    fn config(&self) -> &SegmentConfig;
+
+    /// Get current stats of the segment
+    fn is_appendable(&self) -> bool;
+
+    /// Flushes current segment state into a persistent storage, if possible
+    /// if sync == true, block current thread while flushing
+    ///
+    /// Returns maximum version number which is guaranteed to be persisted.
+    fn flush(&self, sync: bool, force: bool) -> OperationResult<SeqNumberType>;
+
+    /// Removes all persisted data and forces to destroy segment
+    fn drop_data(self) -> OperationResult<()>;
+
     // Get collected telemetry data of segment
     fn get_telemetry_data(&self, detail: TelemetryDetail) -> SegmentTelemetry;
 
