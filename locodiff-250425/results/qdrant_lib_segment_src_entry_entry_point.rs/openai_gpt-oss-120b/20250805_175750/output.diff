
index 1a1fc9aef..06eb5372c 100644
--- a/qdrant_lib_segment_src_entry_entry_point.rs_expectedoutput.txt (expected):tmp/tmphctzgr70_expected.txt	
+++ b/qdrant_lib_segment_src_entry_entry_point.rs_extracted.txt (actual):tmp/tmpj_enp4ge_actual.txt	
@@ -18,21 +18,22 @@ use crate::json_path::JsonPath;
 use crate::telemetry::SegmentTelemetry;
 use crate::types::{
     Filter, Payload, PayloadFieldSchema, PayloadKeyType, PayloadKeyTypeRef, PointIdType,
-    ScoredPoint, SearchParams, SegmentConfig, SegmentInfo, SegmentType, SeqNumberType, VectorName,
-    VectorNameBuf, WithPayload, WithVector,
+    ScoredPoint, SearchParams, SegmentConfig, SegmentInfo, SegmentType, SeqNumberType,
+    SnapshotFormat, VectorName, VectorNameBuf, WithPayload, WithVector,
 };
 
 /// Define all operations which can be performed with Segment or Segment-like entity.
 ///
-/// Assume all operations are idempotent - which means that no matter how many times an operation
-/// is executed - the storage state will be the same.
+/// Assume all operations are idempotent â€“ the storage state will be unchanged
+/// no matter how many times an operation is performed.
 pub trait SegmentEntry: SnapshotEntry {
-    /// Get current update version of the segment
+    /// Get current update version of the segment.
     fn version(&self) -> SeqNumberType;
 
-    /// Get version of specified point
+    /// Get version of a specified point.
     fn point_version(&self, point_id: PointIdType) -> Option<SeqNumberType>;
 
+    /// Batch search.
     #[allow(clippy::too_many_arguments)]
     fn search_batch(
         &self,
@@ -46,15 +47,6 @@ pub trait SegmentEntry: SnapshotEntry {
         query_context: &SegmentQueryContext,
     ) -> OperationResult<Vec<Vec<ScoredPoint>>>;
 
-    /// Rescore results with a formula that can reference payload values.
-    ///
-    /// A deleted bitslice is passed to exclude points from a wrapped segment.
-    fn rescore_with_formula(
-        &self,
-        formula_ctx: Arc<FormulaContext>,
-        hw_counter: &HardwareCounterCell,
-    ) -> OperationResult<Vec<ScoredPoint>>;
-
     fn upsert_point(
         &mut self,
         op_num: SeqNumberType,
@@ -83,6 +75,7 @@ pub trait SegmentEntry: SnapshotEntry {
         op_num: SeqNumberType,
         point_id: PointIdType,
         vector_name: &VectorName,
+        hw_counter: &HardwareCounterCell,
     ) -> OperationResult<bool>;
 
     fn set_payload(
@@ -98,7 +91,7 @@ pub trait SegmentEntry: SnapshotEntry {
         &mut self,
         op_num: SeqNumberType,
         point_id: PointIdType,
-        full_payload: &Payload,
+        payload: &Payload,
         hw_counter: &HardwareCounterCell,
     ) -> OperationResult<bool>;
 
@@ -117,6 +110,13 @@ pub trait SegmentEntry: SnapshotEntry {
         hw_counter: &HardwareCounterCell,
     ) -> OperationResult<bool>;
 
+    fn set_full_payload_with_json(
+        &mut self,
+        op_num: SeqNumberType,
+        point_id: PointIdType,
+        payload: &str,
+    ) -> OperationResult<bool>;
+
     fn vector(
         &self,
         vector_name: &VectorName,
@@ -125,20 +125,15 @@ pub trait SegmentEntry: SnapshotEntry {
 
     fn all_vectors(&self, point_id: PointIdType) -> OperationResult<NamedVectors>;
 
-    /// Retrieve payload for the point
-    /// If not found, return empty payload
     fn payload(
         &self,
         point_id: PointIdType,
         hw_counter: &HardwareCounterCell,
     ) -> OperationResult<Payload>;
 
-    /// Iterator over all points in segment in ascending order.
     fn iter_points(&self) -> Box<dyn Iterator<Item = PointIdType> + '_>;
 
-    /// Paginate over points which satisfies filtering condition starting with `offset` id including.
-    ///
-    /// Cancelled by `is_stopped` flag.
+    /// Paginate over points satisfying the filter.
     fn read_filtered<'a>(
         &'a self,
         offset: Option<PointIdType>,
@@ -148,11 +143,7 @@ pub trait SegmentEntry: SnapshotEntry {
         hw_counter: &HardwareCounterCell,
     ) -> Vec<PointIdType>;
 
-    /// Return points which satisfies filtering condition ordered by the `order_by.key` field,
-    /// starting with `order_by.start_from` value including.
-    ///
-    /// Will fail if there is no index for the order_by key.
-    /// Cancelled by `is_stopped` flag.
+    /// Ordered read.
     fn read_ordered_filtered<'a>(
         &'a self,
         limit: Option<usize>,
@@ -162,9 +153,7 @@ pub trait SegmentEntry: SnapshotEntry {
         hw_counter: &HardwareCounterCell,
     ) -> OperationResult<Vec<(OrderValue, PointIdType)>>;
 
-    /// Return random points which satisfies filtering condition.
-    ///
-    /// Cancelled by `is_stopped` flag.
+    /// Random read.
     fn read_random_filtered(
         &self,
         limit: usize,
@@ -173,7 +162,7 @@ pub trait SegmentEntry: SnapshotEntry {
         hw_counter: &HardwareCounterCell,
     ) -> Vec<PointIdType>;
 
-    /// Read points in [from; to) range
+    /// Read points in [from; to) range.
     fn read_range(&self, from: Option<PointIdType>, to: Option<PointIdType>) -> Vec<PointIdType>;
 
     /// Return all unique values for the given key.
@@ -193,103 +182,61 @@ pub trait SegmentEntry: SnapshotEntry {
         hw_counter: &HardwareCounterCell,
     ) -> OperationResult<HashMap<FacetValue, usize>>;
 
-    /// Check if there is point with `point_id` in this segment.
-    ///
-    /// Soft deleted points are excluded.
-    fn has_point(&self, point_id: PointIdType) -> bool;
-
-    /// Estimate available point count in this segment for given filter.
-    fn estimate_point_count<'a>(
-        &'a self,
-        filter: Option<&'a Filter>,
-        hw_counter: &HardwareCounterCell,
-    ) -> CardinalityEstimation;
-
-    fn vector_names(&self) -> HashSet<VectorNameBuf>;
-
-    /// Whether this segment is completely empty in terms of points
-    ///
-    /// The segment is considered to not be empty if it contains any points, even if deleted.
-    /// Deleted points still have a version which may be important at time of recovery. Deciding
-    /// this by just the reported point count is not reliable in case a proxy segment is used.
-    ///
-    /// Payload indices or type of storage are not considered here.
-    fn is_empty(&self) -> bool;
-
-    /// Number of available points
-    ///
-    /// - excludes soft deleted points
-    fn available_point_count(&self) -> usize;
-
-    /// Number of deleted points
-    fn deleted_point_count(&self) -> usize;
-
-    /// Size of all available vectors in storage
-    fn available_vectors_size_in_bytes(&self, vector_name: &VectorName) -> OperationResult<usize>;
-
-    /// Max value from all `available_vectors_size_in_bytes`
-    fn max_available_vectors_size_in_bytes(&self) -> OperationResult<usize> {
-        self.vector_names()
-            .into_iter()
-            .map(|vector_name| self.available_vectors_size_in_bytes(&vector_name))
-            .collect::<OperationResult<Vec<_>>>()
-            .map(|sizes| sizes.into_iter().max().unwrap_or_default())
-    }
-
-    /// Get segment type
-    fn segment_type(&self) -> SegmentType;
-
-    /// Get current stats of the segment
-    fn info(&self) -> SegmentInfo;
-
-    /// Get size related stats of the segment.
-    /// This returns `SegmentInfo` with some non size-related data (like `schema`) unset to improve performance.
-    fn size_info(&self) -> SegmentInfo;
-
-    /// Get segment configuration
-    fn config(&self) -> &SegmentConfig;
-
-    /// Get current stats of the segment
-    fn is_appendable(&self) -> bool;
-
-    /// Flushes current segment state into a persistent storage, if possible
-    /// if sync == true, block current thread while flushing
-    ///
-    /// Returns maximum version number which is guaranteed to be persisted.
-    fn flush(&self, sync: bool, force: bool) -> OperationResult<SeqNumberType>;
-
-    /// Removes all persisted data and forces to destroy segment
-    fn drop_data(self) -> OperationResult<()>;
-
-    /// Path to data, owned by segment
-    fn data_path(&self) -> PathBuf;
+    /// Get indexed fields.
+    fn get_indexed_fields(&self) -> HashMap<PayloadKeyType, PayloadFieldSchema>;
 
-    /// Delete field index, if exists
+    /// Delete field index, if exists.
     fn delete_field_index(
         &mut self,
         op_num: SeqNumberType,
         key: PayloadKeyTypeRef,
+        hw_counter: &HardwareCounterCell,
     ) -> OperationResult<bool>;
 
-    /// Build the field index for the key and schema, if not built before.
+    /// Build a field index (if missing), returning schema and built index.
     fn build_field_index(
         &self,
         op_num: SeqNumberType,
         key: PayloadKeyTypeRef,
-        field_type: Option<&PayloadFieldSchema>,
+        field_schema: Option<&PayloadFieldSchema>,
         hw_counter: &HardwareCounterCell,
     ) -> OperationResult<Option<(PayloadFieldSchema, Vec<FieldIndex>)>>;
 
-    /// Apply a built index. Returns whether it was actually applied or not.
+    /// Apply a built index.
     fn apply_field_index(
         &mut self,
         op_num: SeqNumberType,
         key: PayloadKeyType,
         field_schema: PayloadFieldSchema,
         field_index: Vec<FieldIndex>,
+    ) -> OperationResult<bool> {
+        let Some((schema, index)) = self
+            .build_field_index(op_num, key, Some(&field_schema), &HardwareCounterCell::dummy())?
+        else {
+            return Ok(false);
+        };
+
+        self.apply_field_index(op_num, key, schema, index)
+    }
+
+    /// Delete points by filter.
+    fn delete_filtered<'a>(
+        &'a mut self,
+        op_num: SeqNumberType,
+        filter: &'a Filter,
+        hw_counter: &HardwareCounterCell,
+    ) -> OperationResult<usize>;
+
+    /// Set the payload of a point.
+    fn set_full_payload(
+        &mut self,
+        op_num: SeqNumberType,
+        point_id: PointIdType,
+        payload: &Payload,
+        hw_counter: &HardwareCounterCell,
     ) -> OperationResult<bool>;
 
-    /// Create index for a payload field, if not exists
+    /// Create index for a payload field (if not existing).
     fn create_field_index(
         &mut self,
         op_num: SeqNumberType,
@@ -297,31 +244,53 @@ pub trait SegmentEntry: SnapshotEntry {
         field_schema: Option<&PayloadFieldSchema>,
         hw_counter: &HardwareCounterCell,
     ) -> OperationResult<bool> {
-        let Some((schema, index)) =
-            self.build_field_index(op_num, key, field_schema, hw_counter)?
+        let Some((schema, index)) = self
+            .build_field_index(op_num, key, field_schema, hw_counter)?
         else {
             return Ok(false);
         };
-
         self.apply_field_index(op_num, key.to_owned(), schema, index)
     }
 
-    /// Get indexed fields
-    fn get_indexed_fields(&self) -> HashMap<PayloadKeyType, PayloadFieldSchema>;
+    /// Compute the vector name set.
+    fn vector_names(&self) -> HashSet<VectorNameBuf>;
 
-    /// Checks if segment errored during last operations
-    fn check_error(&self) -> Option<SegmentFailedState>;
+    /// Whether the segment contains any points (including deleted).
+    fn is_empty(&self) -> bool;
 
-    /// Delete points by the given filter
-    fn delete_filtered<'a>(
-        &'a mut self,
-        op_num: SeqNumberType,
-        filter: &'a Filter,
-        hw_counter: &HardwareCounterCell,
-    ) -> OperationResult<usize>;
+    /// Number of available points (excludes deleted).
+    fn available_point_count(&self) -> usize;
+
+    /// Number of deleted points.
+    fn deleted_point_count(&self) -> usize;
+
+    /// Size of all available vectors in storage.
+    fn available_vectors_size_in_bytes(&self, vector_name: &VectorName) -> OperationResult<usize>;
+
+    /// Maximum of the above across all vectors.
+    fn max_available_vectors_size_in_bytes(&self) -> OperationResult<usize> {
+        self.vector_names()
+            .into_iter()
+            .map(|v| self.available_vectors_size_in_bytes(&v))
+            .collect::<OperationResult<Vec<_>>>()
+            .map(|sizes| sizes.into_iter().max().unwrap_or_default())
+    }
+
+    /// Get segment type.
+    fn segment_type(&self) -> SegmentType;
+
+    /// Get collection information.
+    fn info(&self) -> SegmentInfo;
+
+    /// Get sizeâ€‘related information (with some fields zeroed for performance).
+    fn size_info(&self) -> SegmentInfo;
+
+    /// Get configuration.
+    fn config(&self) -> &SegmentConfig;
 
-    // Get collected telemetry data of segment
+    /// Get telemetry data.
     fn get_telemetry_data(&self, detail: TelemetryDetail) -> SegmentTelemetry;
 
+    /// Fill queryâ€‘related data into a context.
     fn fill_query_context(&self, query_context: &mut QueryContext);
 }
\ No newline at end of file
