
index e41616d2b..3338b460b 100644
--- a/ghostty_src_font_shaper_run.zig_expectedoutput.txt (expected):tmp/tmp7s8jxdpo_expected.txt	
+++ b/ghostty_src_font_shaper_run.zig_extracted.txt (actual):tmp/tmp517y1wtg_actual.txt	
@@ -262,145 +262,4 @@ pub const RunIterator = struct {
 
             // If we're a Kitty unicode placeholder then we add a blank.
             if (cell.codepoint() == terminal.kitty.graphics.unicode.placeholder) {
-                try self.addCodepoint(&hasher, ' ', @intCast(cluster));
-                continue;
-            }
-
-            // Add all the codepoints for our grapheme
-            try self.addCodepoint(
-                &hasher,
-                if (cell.codepoint() == 0) ' ' else cell.codepoint(),
-                @intCast(cluster),
-            );
-            if (cell.hasGrapheme()) {
-                const cps = self.row.grapheme(cell).?;
-                for (cps) |cp| {
-                    // Do not send presentation modifiers
-                    if (cp == 0xFE0E or cp == 0xFE0F) continue;
-                    try self.addCodepoint(&hasher, cp, @intCast(cluster));
-                }
-            }
-        }
-
-        // Finalize our buffer
-        try self.hooks.finalize();
-
-        // Add our length to the hash as an additional mechanism to avoid collisions
-        autoHash(&hasher, j - self.i);
-
-        // Add our font index
-        autoHash(&hasher, current_font);
-
-        // Move our cursor. Must defer since we use self.i below.
-        defer self.i = j;
-
-        return TextRun{
-            .hash = hasher.final(),
-            .offset = @intCast(self.i),
-            .cells = @intCast(j - self.i),
-            .grid = self.grid,
-            .font_index = current_font,
-        };
-    }
-
-    fn addCodepoint(self: *RunIterator, hasher: anytype, cp: u32, cluster: u32) !void {
-        autoHash(hasher, cp);
-        autoHash(hasher, cluster);
-        try self.hooks.addCodepoint(cp, cluster);
-    }
-
-    /// Find a font index that supports the grapheme for the given cell,
-    /// or null if no such font exists.
-    ///
-    /// This is used to find a font that supports the entire grapheme.
-    /// We look for fonts that support each individual codepoint and then
-    /// find the common font amongst all candidates.
-    fn indexForCell(
-        self: *RunIterator,
-        alloc: Allocator,
-        cell: *terminal.Cell,
-        style: font.Style,
-        presentation: ?font.Presentation,
-    ) !?font.Collection.Index {
-        if (cell.isEmpty() or
-            cell.codepoint() == 0 or
-            cell.codepoint() == terminal.kitty.graphics.unicode.placeholder)
-        {
-            return try self.grid.getIndex(
-                alloc,
-                ' ',
-                style,
-                presentation,
-            );
-        }
-
-        // Get the font index for the primary codepoint.
-        const primary_cp: u32 = cell.codepoint();
-        const primary = try self.grid.getIndex(
-            alloc,
-            primary_cp,
-            style,
-            presentation,
-        ) orelse return null;
-
-        // Easy, and common: we aren't a multi-codepoint grapheme, so
-        // we just return whatever index for the cell codepoint.
-        if (!cell.hasGrapheme()) return primary;
-
-        // If this is a grapheme, we need to find a font that supports
-        // all of the codepoints in the grapheme.
-        const cps = self.row.grapheme(cell) orelse return primary;
-        var candidates = try std.ArrayList(font.Collection.Index).initCapacity(alloc, cps.len + 1);
-        defer candidates.deinit();
-        candidates.appendAssumeCapacity(primary);
-
-        for (cps) |cp| {
-            // Ignore Emoji ZWJs
-            if (cp == 0xFE0E or cp == 0xFE0F or cp == 0x200D) continue;
-
-            // Find a font that supports this codepoint. If none support this
-            // then the whole grapheme can't be rendered so we return null.
-            //
-            // We explicitly do not require the additional grapheme components
-            // to support the base presentation, since it is common for emoji
-            // fonts to support the base emoji with emoji presentation but not
-            // certain ZWJ-combined characters like the male and female signs.
-            const idx = try self.grid.getIndex(
-                alloc,
-                cp,
-                style,
-                null,
-            ) orelse return null;
-            candidates.appendAssumeCapacity(idx);
-        }
-
-        // We need to find a candidate that has ALL of our codepoints
-        for (candidates.items) |idx| {
-            if (!self.grid.hasCodepoint(idx, primary_cp, presentation)) continue;
-            for (cps) |cp| {
-                // Ignore Emoji ZWJs
-                if (cp == 0xFE0E or cp == 0xFE0F or cp == 0x200D) continue;
-                if (!self.grid.hasCodepoint(idx, cp, null)) break;
-            } else {
-                // If the while completed, then we have a candidate that
-                // supports all of our codepoints.
-                return idx;
-            }
-        }
-
-        return null;
-    }
-};
-
-/// Returns a style that when compared must be identical for a run to
-/// continue.
-fn comparableStyle(style: terminal.Style) terminal.Style {
-    var s = style;
-
-    // We allow background colors to differ because we'll just paint the
-    // cell background whatever the style is, and wherever the glyph
-    // lands on top of it will be the color of the glyph.
-    s.bg_color = .none;
-
-    return s;
-}
\ No newline at end of file
+                try self.add
\ No newline at end of file
