--- qdrant_lib_segment_tests_integration_payload_index_test.rs_expectedoutput.txt (expected)+++ qdrant_lib_segment_tests_integration_payload_index_test.rs_extracted.txt (actual)@@ -1,8 +1,8 @@ use std::collections::HashMap;
 use std::fs::create_dir;
 use std::path::Path;
+use std::sync::atomic::AtomicBool;
 use std::sync::Arc;
-use std::sync::atomic::AtomicBool;
 
 use anyhow::{Context, Result};
 use atomic_refcell::AtomicRefCell;
@@ -27,9 +27,9 @@     STR_PROJ_KEY, STR_ROOT_PROJ_KEY, TEXT_KEY, generate_diverse_nested_payload,
     generate_diverse_payload, random_filter, random_nested_filter, random_vector,
 };
-use segment::index::PayloadIndex;
 use segment::index::field_index::{FieldIndex, PrimaryCondition};
 use segment::index::struct_payload_index::StructPayloadIndex;
+use segment::index::PayloadIndex;
 use segment::json_path::JsonPath;
 use segment::payload_json;
 use segment::payload_storage::PayloadStorage;
@@ -469,16 +469,6 @@             .unwrap();
     }
 
-    for (_field, indexes) in struct_segment.payload_index.borrow().field_indexes.iter() {
-        for index in indexes {
-            assert!(index.count_indexed_points() < num_points as usize);
-            assert!(
-                index.count_indexed_points()
-                    > (num_points as usize - points_to_delete - points_to_clear)
-            );
-        }
-    }
-
     (struct_segment, plain_segment)
 }
 
@@ -750,8 +740,7 @@ 
     // rely on test data from `build_test_segments_nested_payload`
     let nested_key = "nested_1[].nested_2";
-    let nested_match =
-        FieldCondition::new_match(JsonPath::new(nested_key), "some value".to_owned().into());
+    let nested_match = FieldCondition::new_match(JsonPath::new(nested_key), "some value".to_owned().into());
     let filter = Filter::new_must(Condition::new_nested(
         JsonPath::new(STR_ROOT_PROJ_KEY),
         Filter::new_must(Condition::Field(nested_match)),
@@ -1141,18 +1130,13 @@             .for_each(|(r1, r2)| {
                 assert_eq!(
                     r1.id, r2.id,
-                    "got different ScoredPoint {r1:?} and {r2:?} for\n\
-                    query vector {query_vector:?}\n\
-                    query filter {query_filter:?}\n\
-                    plain result {plain_result:?}\n\
-                    struct result{struct_result:?}"
+                    "got different ScoredPoint {r1:?} and {r2:?} for\nquery vector {query_vector:?}\nquery filter {query_filter:?}\nplain result {plain_result:?}\nstruct result{struct_result:?}"
                 );
                 assert!((r1.score - r2.score) < 0.0001)
             });
     }
 }
 
-#[test]
 fn test_update_payload_index_type() {
     let dir = Builder::new().prefix("storage_dir").tempdir().unwrap();
     let mut payload_storage = InMemoryPayloadStorage::default();
