
index d46358c38..9e778b449 100644
--- a/qdrant_lib_segment_tests_integration_payload_index_test.rs_expectedoutput.txt (expected):tmp/tmpmpym7907_expected.txt	
+++ b/qdrant_lib_segment_tests_integration_payload_index_test.rs_extracted.txt (actual):tmp/tmp_w9xo7v1_actual.txt	
@@ -8,12 +8,11 @@ use anyhow::{Context, Result};
 use atomic_refcell::AtomicRefCell;
 use common::budget::ResourcePermit;
 use common::counter::hardware_counter::HardwareCounterCell;
-use common::types::PointOffsetType;
 use fnv::FnvBuildHasher;
 use indexmap::IndexSet;
 use itertools::Itertools;
-use rand::prelude::StdRng;
-use rand::{Rng, SeedableRng};
+use rand::SeedableRng;
+use rand::{Rng, rng};
 use segment::data_types::facets::{FacetParams, FacetValue};
 use segment::data_types::index::{
     FloatIndexParams, FloatIndexType, IntegerIndexParams, IntegerIndexType, KeywordIndexParams,
@@ -43,8 +42,8 @@ use segment::types::PayloadSchemaType::{Integer, Keyword};
 use segment::types::{
     AnyVariants, Condition, Distance, FieldCondition, Filter, GeoBoundingBox, GeoLineString,
     GeoPoint, GeoPolygon, GeoRadius, HnswConfig, Indexes, IsEmptyCondition, Match, Payload,
-    PayloadField, PayloadSchemaParams, PayloadSchemaType, Range, SegmentConfig, ValueVariants,
-    VectorDataConfig, VectorStorageType, WithPayload,
+    PayloadField, PayloadSchemaParams, PayloadSchemaType, Range, SegmentConfig, VectorDataConfig,
+    VectorStorageType, WithPayload,
 };
 use segment::utils::scored_point_ties::ScoredPointTies;
 use tempfile::{Builder, TempDir};
@@ -473,8 +472,7 @@ fn build_test_segments_nested_payload(path_struct: &Path, path_plain: &Path) ->
         for index in indexes {
             assert!(index.count_indexed_points() < num_points as usize);
             assert!(
-                index.count_indexed_points()
-                    > (num_points as usize - points_to_delete - points_to_clear)
+                index.count_indexed_points() > (num_points as usize - points_to_delete - points_to_clear)
             );
         }
     }
@@ -483,7 +481,8 @@ fn build_test_segments_nested_payload(path_struct: &Path, path_plain: &Path) ->
 }
 
 fn validate_geo_filter(test_segments: &TestSegments, query_filter: Filter) -> Result<()> {
-    let mut rnd = rand::rng();
+    let mut rnd = rng();
+    let query = random_vector(&mut rnd, DIM).into();
 
     for _i in 0..ATTEMPTS {
         let query = random_vector(&mut rnd, DIM).into();
@@ -497,6 +496,7 @@ fn validate_geo_filter(test_segments: &TestSegments, query_filter: Filter) -> Re
                 Some(&query_filter),
                 5,
                 None,
+                &false.into(),
             )
             .unwrap();
 
@@ -529,6 +529,7 @@ fn validate_geo_filter(test_segments: &TestSegments, query_filter: Filter) -> Re
                 Some(&query_filter),
                 5,
                 None,
+                &false.into(),
             )
             .unwrap();
 
@@ -750,8 +751,7 @@ fn test_root_nested_array_filter_cardinality_estimation() {
 
     // rely on test data from `build_test_segments_nested_payload`
     let nested_key = "nested_1[].nested_2";
-    let nested_match =
-        FieldCondition::new_match(JsonPath::new(nested_key), "some value".to_owned().into());
+    let nested_match = FieldCondition::new_match(JsonPath::new(nested_key), "some value".to_owned().into());
     let filter = Filter::new_must(Condition::new_nested(
         JsonPath::new(STR_ROOT_PROJ_KEY),
         Filter::new_must(Condition::Field(nested_match)),
@@ -770,7 +770,7 @@ fn test_root_nested_array_filter_cardinality_estimation() {
     let primary_clause = estimation.primary_clauses.first().unwrap();
 
     let expected_primary_clause = FieldCondition::new_match(
-        JsonPath::new(&format!("{STR_ROOT_PROJ_KEY}[].{nested_key}")), // full key expected
+        JsonPath::new(&format!("{}[].{}", STR_ROOT_PROJ_KEY, nested_key)), // full key expected
         "some value".to_owned().into(),
     );
 
@@ -781,8 +781,6 @@ fn test_root_nested_array_filter_cardinality_estimation() {
         o => panic!("unexpected primary clause: {o:?}"),
     }
 
-    let hw_counter = HardwareCounterCell::new();
-
     let payload_index = struct_segment.payload_index.borrow();
     let filter_context = payload_index.filter_context(&filter, &hw_counter);
     let exact = struct_segment
@@ -848,8 +846,6 @@ fn test_nesting_nested_array_filter_cardinality_estimation() {
         o => panic!("unexpected primary clause: {o:?}"),
     }
 
-    let hw_counter = HardwareCounterCell::new();
-
     let payload_index = struct_segment.payload_index.borrow();
     let filter_context = payload_index.filter_context(&filter, &hw_counter);
     let exact = struct_segment
@@ -869,7 +865,7 @@ fn test_nesting_nested_array_filter_cardinality_estimation() {
 
 /// Compare search with plain, struct, and mmap indices.
 fn test_struct_payload_index(test_segments: &TestSegments) -> Result<()> {
-    let mut rnd = rand::rng();
+    let mut rnd = rng();
 
     for _i in 0..ATTEMPTS {
         let query_vector = random_vector(&mut rnd, DIM).into();
@@ -885,6 +881,7 @@ fn test_struct_payload_index(test_segments: &TestSegments) -> Result<()> {
                 Some(&query_filter),
                 5,
                 None,
+                &false.into(),
             )
             .unwrap();
         let struct_result = test_segments
@@ -897,6 +894,7 @@ fn test_struct_payload_index(test_segments: &TestSegments) -> Result<()> {
                 Some(&query_filter),
                 5,
                 None,
+                &false.into(),
             )
             .unwrap();
         let mmap_result = test_segments
@@ -909,6 +907,7 @@ fn test_struct_payload_index(test_segments: &TestSegments) -> Result<()> {
                 Some(&query_filter),
                 5,
                 None,
+                &false.into(),
             )
             .unwrap();
 
@@ -932,7 +931,6 @@ fn test_struct_payload_index(test_segments: &TestSegments) -> Result<()> {
             "{estimation:#?}",
         );
 
-        // Perform additional sort to break ties by score
         let mut plain_result_sorted_ties: Vec<ScoredPointTies> =
             plain_result.iter().map(|x| x.into()).collect_vec();
         plain_result_sorted_ties.sort();
@@ -964,9 +962,7 @@ fn test_struct_payload_index(test_segments: &TestSegments) -> Result<()> {
             plain_result_sorted_ties,
             struct_result_sorted_ties,
             mmap_result_sorted_ties,
-        )
-        .map(|(r1, r2, r3)| (r1.0, r2.0, r3.0))
-        {
+        ) {
             ensure!(
                 r1.id == r2.id,
                 "got different ScoredPoint {r1:?} and {r2:?} for\n\
@@ -991,7 +987,7 @@ fn test_struct_payload_index(test_segments: &TestSegments) -> Result<()> {
 }
 
 fn test_struct_payload_geo_boundingbox_index(test_segments: &TestSegments) -> Result<()> {
-    let mut rnd = rand::rng();
+    let mut rnd = rng();
 
     let geo_bbox = GeoBoundingBox {
         top_left: GeoPoint {
@@ -1015,7 +1011,7 @@ fn test_struct_payload_geo_boundingbox_index(test_segments: &TestSegments) -> Re
 }
 
 fn test_struct_payload_geo_radius_index(test_segments: &TestSegments) -> Result<()> {
-    let mut rnd = rand::rng();
+    let mut rnd = rng();
 
     let r_meters = rnd.random_range(1.0..10000.0);
     let geo_radius = GeoRadius {
@@ -1041,7 +1037,7 @@ fn test_struct_payload_geo_polygon_index(test_segments: &TestSegments) -> Result
     let interiors_num = 3;
 
     fn generate_ring(polygon_edge: i32) -> GeoLineString {
-        let mut rnd = rand::rng();
+        let mut rnd = rng();
         let mut line = GeoLineString {
             points: (0..polygon_edge)
                 .map(|_| GeoPoint {
@@ -1082,14 +1078,16 @@ fn test_struct_payload_index_nested_fields() {
     let dir1 = Builder::new().prefix("segment1_dir").tempdir().unwrap();
     let dir2 = Builder::new().prefix("segment2_dir").tempdir().unwrap();
 
-    let mut rnd = rand::rng();
+    let dim = 5;
+
+    let mut rnd = rng();
 
     let (struct_segment, plain_segment) =
         build_test_segments_nested_payload(dir1.path(), dir2.path());
 
     let attempts = 100;
     for _i in 0..attempts {
-        let query_vector = random_vector(&mut rnd, DIM).into();
+        let query_vector = random_vector(&mut rnd, dim);
         let query_filter = random_nested_filter(&mut rnd);
         let plain_result = plain_segment
             .search(
@@ -1103,6 +1101,7 @@ fn test_struct_payload_index_nested_fields() {
                 Some(&query_filter),
                 5,
                 None,
+                &false.into(),
             )
             .unwrap();
         let struct_result = struct_segment
@@ -1117,6 +1116,7 @@ fn test_struct_payload_index_nested_fields() {
                 Some(&query_filter),
                 5,
                 None,
+                &false.into(),
             )
             .unwrap();
 
@@ -1145,245 +1145,4 @@ fn test_struct_payload_index_nested_fields() {
                     query vector {query_vector:?}\n\
                     query filter {query_filter:?}\n\
                     plain result {plain_result:?}\n\
-                    struct result{struct_result:?}"
-                );
-                assert!((r1.score - r2.score) < 0.0001)
-            });
-    }
-}
-
-#[test]
-fn test_update_payload_index_type() {
-    let dir = Builder::new().prefix("storage_dir").tempdir().unwrap();
-    let mut payload_storage = InMemoryPayloadStorage::default();
-
-    let point_num = 10;
-    let mut points = HashMap::new();
-
-    let mut payloads: Vec<Payload> = vec![];
-    for i in 0..point_num {
-        payloads.push(payload_json! {"field": i});
-    }
-
-    let hw_counter = HardwareCounterCell::new();
-
-    for (idx, payload) in payloads.into_iter().enumerate() {
-        points.insert(idx, payload.clone());
-        payload_storage
-            .set(idx as PointOffsetType, &payload, &hw_counter)
-            .unwrap();
-    }
-
-    let wrapped_payload_storage = Arc::new(AtomicRefCell::new(payload_storage.into()));
-    let id_tracker = Arc::new(AtomicRefCell::new(FixtureIdTracker::new(point_num)));
-
-    let mut index = StructPayloadIndex::open(
-        wrapped_payload_storage,
-        id_tracker,
-        HashMap::new(),
-        dir.path(),
-        true,
-    )
-    .unwrap();
-
-    let field = JsonPath::new("field");
-
-    // set field to Integer type
-    index.set_indexed(&field, Integer, &hw_counter).unwrap();
-    assert_eq!(
-        *index.indexed_fields().get(&field).unwrap(),
-        FieldType(Integer)
-    );
-    let field_index = index.field_indexes.get(&field).unwrap();
-    assert_eq!(field_index[0].count_indexed_points(), point_num);
-    assert_eq!(field_index[1].count_indexed_points(), point_num);
-
-    // update field to Keyword type
-    index.set_indexed(&field, Keyword, &hw_counter).unwrap();
-    assert_eq!(
-        *index.indexed_fields().get(&field).unwrap(),
-        FieldType(Keyword)
-    );
-    let field_index = index.field_indexes.get(&field).unwrap();
-    assert_eq!(field_index[0].count_indexed_points(), 0); // only one field index for Keyword
-
-    // set field to Integer type (again)
-    index.set_indexed(&field, Integer, &hw_counter).unwrap();
-    assert_eq!(
-        *index.indexed_fields().get(&field).unwrap(),
-        FieldType(Integer)
-    );
-    let field_index = index.field_indexes.get(&field).unwrap();
-    assert_eq!(field_index[0].count_indexed_points(), point_num);
-    assert_eq!(field_index[1].count_indexed_points(), point_num);
-}
-
-fn test_any_matcher_cardinality_estimation(test_segments: &TestSegments) -> Result<()> {
-    let keywords: IndexSet<String, FnvBuildHasher> = ["value1", "value2"]
-        .iter()
-        .map(|&i| i.to_string())
-        .collect();
-    let any_match = FieldCondition::new_match(
-        JsonPath::new(STR_KEY),
-        Match::new_any(AnyVariants::Strings(keywords)),
-    );
-
-    let filter = Filter::new_must(Condition::Field(any_match.clone()));
-
-    let hw_counter = HardwareCounterCell::new();
-
-    let estimation = test_segments
-        .struct_segment
-        .payload_index
-        .borrow()
-        .estimate_cardinality(&filter, &hw_counter);
-
-    ensure!(estimation.primary_clauses.len() == 1);
-    for clause in estimation.primary_clauses.iter() {
-        let expected_primary_clause = any_match.clone();
-
-        match clause {
-            PrimaryCondition::Condition(field_condition) => {
-                ensure!(*field_condition == Box::new(expected_primary_clause));
-            }
-            o => panic!("unexpected primary clause: {o:?}"),
-        }
-    }
-
-    let hw_counter = HardwareCounterCell::new();
-
-    let payload_index = test_segments.struct_segment.payload_index.borrow();
-    let filter_context = payload_index.filter_context(&filter, &hw_counter);
-    let exact = test_segments
-        .struct_segment
-        .id_tracker
-        .borrow()
-        .iter_ids()
-        .filter(|x| filter_context.check(*x))
-        .collect_vec()
-        .len();
-
-    eprintln!("exact = {exact:#?}");
-    eprintln!("estimation = {estimation:#?}");
-
-    ensure!(exact <= estimation.max);
-    ensure!(exact >= estimation.min);
-
-    Ok(())
-}
-
-/// FacetParams fixture without a filter
-fn keyword_facet_request() -> FacetParams {
-    let limit = 1000;
-    let key: JsonPath = STR_KEY.try_into().unwrap();
-    let exact = false; // This is only used at local shard level
-
-    // *** Without filter ***
-    FacetParams {
-        key: key.clone(),
-        limit,
-        filter: None,
-        exact,
-    }
-}
-
-/// Checks that the counts are the same as counting each value exactly.
-fn validate_facet_result(
-    segment: &Segment,
-    facet_hits: HashMap<FacetValue, usize>,
-    filter: Option<Filter>,
-) -> Result<()> {
-    let hw_counter = HardwareCounterCell::new();
-
-    for (value, count) in facet_hits.iter() {
-        // Compare against exact count
-        let value = ValueVariants::from(value.clone());
-
-        let count_filter = Filter::new_must(Condition::Field(FieldCondition::new_match(
-            JsonPath::new(STR_KEY),
-            Match::from(value.clone()),
-        )));
-        let count_filter = Filter::merge_opts(Some(count_filter), filter.clone());
-
-        let exact = segment
-            .read_filtered(
-                None,
-                None,
-                count_filter.as_ref(),
-                &Default::default(),
-                &hw_counter,
-            )
-            .len();
-
-        ensure!(*count == exact, "Facet value: {value:?}");
-    }
-
-    Ok(())
-}
-
-fn test_struct_keyword_facet(test_segments: &TestSegments) -> Result<()> {
-    let request = keyword_facet_request();
-
-    // Plain segment should fail, as it does not have a keyword index
-    assert!(
-        test_segments
-            .plain_segment
-            .facet(&request, &Default::default(), &Default::default())
-            .is_err(),
-    );
-
-    // Struct segment
-    let facet_hits = test_segments
-        .struct_segment
-        .facet(&request, &Default::default(), &Default::default())
-        .unwrap();
-
-    validate_facet_result(&test_segments.struct_segment, facet_hits, None).context(here!())
-}
-
-fn test_mmap_keyword_facet(test_segments: &TestSegments) -> Result<()> {
-    let request = keyword_facet_request();
-
-    let facet_hits = test_segments
-        .mmap_segment
-        .facet(&request, &Default::default(), &Default::default())
-        .unwrap();
-
-    validate_facet_result(&test_segments.mmap_segment, facet_hits, None).context(here!())
-}
-
-fn test_struct_keyword_facet_filtered(test_segments: &TestSegments) -> Result<()> {
-    let mut request = keyword_facet_request();
-
-    for _ in 0..ATTEMPTS {
-        let filter = random_filter(&mut rand::rng(), 3);
-        request.filter = Some(filter.clone());
-
-        let facet_hits = test_segments
-            .struct_segment
-            .facet(&request, &Default::default(), &Default::default())
-            .unwrap();
-
-        validate_facet_result(&test_segments.struct_segment, facet_hits, Some(filter))
-            .context(here!())?
-    }
-    Ok(())
-}
-
-fn test_mmap_keyword_facet_filtered(test_segments: &TestSegments) -> Result<()> {
-    let mut request = keyword_facet_request();
-
-    for _ in 0..ATTEMPTS {
-        let filter = random_filter(&mut rand::rng(), 3);
-        request.filter = Some(filter.clone());
-
-        let facet_hits = test_segments
-            .mmap_segment
-            .facet(&request, &Default::default(), &Default::default())
-            .unwrap();
-
-        validate_facet_result(&test_segments.mmap_segment, facet_hits, Some(filter))
-            .context(here!())?
-    }
-    Ok(())
-}
\ No newline at end of file
+                    struct result{struct_result
\ No newline at end of file
