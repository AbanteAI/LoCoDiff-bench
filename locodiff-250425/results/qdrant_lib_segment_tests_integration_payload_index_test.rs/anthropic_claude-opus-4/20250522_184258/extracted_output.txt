fn test_is_empty_conditions(test_segments: &TestSegments) -> Result<()> {
    let filter = Filter::new_must(Condition::IsEmpty(IsEmptyCondition {
        is_empty: PayloadField {
            key: JsonPath::new(FLICKING_KEY),
        },
    }));

    let hw_counter = HardwareCounterCell::new();

    let estimation_struct = test_segments
        .struct_segment
        .payload_index
        .borrow()
        .estimate_cardinality(&filter, &hw_counter);

    let estimation_plain = test_segments
        .plain_segment
        .payload_index
        .borrow()
        .estimate_cardinality(&filter, &hw_counter);

    let plain_result = test_segments
        .plain_segment
        .payload_index
        .borrow()
        .query_points(&filter, &hw_counter);

    let real_number = plain_result.len();

    let struct_result = test_segments
        .struct_segment
        .payload_index
        .borrow()
        .query_points(&filter, &hw_counter);

    ensure!(plain_result == struct_result);

    eprintln!("estimation_plain = {estimation_plain:#?}");
    eprintln!("estimation_struct = {estimation_struct:#?}");
    eprintln!("real_number = {real_number:#?}");

    ensure!(estimation_plain.max >= real_number);
    ensure!(estimation_plain.min <= real_number);

    ensure!(estimation_struct.max >= real_number);
    ensure!(estimation_struct.min <= real_number);

    ensure!(
        (estimation_struct.exp as f64 - real_number as f64).abs()
            <= (estimation_plain.exp as f64 - real_number as f64).abs()
    );

    Ok(())
}