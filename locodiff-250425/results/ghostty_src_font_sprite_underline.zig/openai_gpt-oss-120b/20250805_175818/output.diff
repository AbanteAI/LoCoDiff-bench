
index 38eca3025..f5e41ae2e 100644
--- a/ghostty_src_font_sprite_underline.zig_expectedoutput.txt (expected):tmp/tmpu1on87sm_expected.txt	
+++ b/ghostty_src_font_sprite_underline.zig_extracted.txt (actual):tmp/tmpld2siqeo_actual.txt	
@@ -16,8 +16,9 @@ const assert = std.debug.assert;
 const Allocator = std.mem.Allocator;
 const font = @import("../main.zig");
 const Sprite = font.sprite.Sprite;
+const z2d = @import("z2d");
 
-/// Draw an underline.
+// Draw an underline.
 pub fn renderGlyph(
     alloc: Allocator,
     atlas: *font.Atlas,
@@ -27,7 +28,6 @@ pub fn renderGlyph(
     line_pos: u32,
     line_thickness: u32,
 ) !font.Glyph {
-    // Draw the appropriate sprite
     var canvas: font.sprite.Canvas, const offset_y: i32 = switch (sprite) {
         .underline => try drawSingle(alloc, width, line_thickness),
         .underline_double => try drawDouble(alloc, width, line_thickness),
@@ -47,10 +47,6 @@ pub fn renderGlyph(
         .width = width,
         .height = @intCast(region.height),
         .offset_x = 0,
-        // Glyph.offset_y is the distance between the top of the glyph and the
-        // bottom of the cell. We want the top of the glyph to be at line_pos
-        // from the TOP of the cell, and then offset by the offset_y from the
-        // draw function.
         .offset_y = @as(i32, @intCast(height -| line_pos)) - offset_y,
         .atlas_x = region.x,
         .atlas_y = region.y,
@@ -76,7 +72,6 @@ fn drawSingle(alloc: Allocator, width: u32, thickness: u32) !CanvasAndOffset {
     }, .on);
 
     const offset_y: i32 = 0;
-
     return .{ canvas, offset_y };
 }
 
@@ -85,7 +80,6 @@ fn drawDouble(alloc: Allocator, width: u32, thickness: u32) !CanvasAndOffset {
     // Our gap between lines will be at least 2px.
     // (i.e. if our thickness is 1, we still have a gap of 2)
     const gap = @max(2, thickness);
-
     const height: u32 = thickness * 2 * gap;
     var canvas = try font.sprite.Canvas.init(alloc, width, height);
 
@@ -98,13 +92,12 @@ fn drawDouble(alloc: Allocator, width: u32, thickness: u32) !CanvasAndOffset {
 
     canvas.rect(.{
         .x = 0,
-        .y = thickness * 2,
+        .y = thickness + gap,
         .width = width,
         .height = thickness,
     }, .on);
 
     const offset_y: i32 = -@as(i32, @intCast(thickness));
-
     return .{ canvas, offset_y };
 }
 
@@ -118,11 +111,10 @@ fn drawDotted(alloc: Allocator, width: u32, thickness: u32) !CanvasAndOffset {
     const gap_width = try std.math.divCeil(u32, width -| (dot_count * dot_width), dot_count);
     var i: u32 = 0;
     while (i < dot_count) : (i += 1) {
-        // Ensure we never go out of bounds for the rect
         const x = @min(i * (dot_width + gap_width), width - 1);
         const rect_width = @min(width - x, dot_width);
         canvas.rect(.{
-            .x = @intCast(x),
+            .x = x,
             .y = 0,
             .width = rect_width,
             .height = thickness,
@@ -130,7 +122,6 @@ fn drawDotted(alloc: Allocator, width: u32, thickness: u32) !CanvasAndOffset {
     }
 
     const offset_y: i32 = 0;
-
     return .{ canvas, offset_y };
 }
 
@@ -143,11 +134,10 @@ fn drawDashed(alloc: Allocator, width: u32, thickness: u32) !CanvasAndOffset {
     const dash_count = (width / dash_width) + 1;
     var i: u32 = 0;
     while (i < dash_count) : (i += 2) {
-        // Ensure we never go out of bounds for the rect
         const x = @min(i * dash_width, width - 1);
         const rect_width = @min(width - x, dash_width);
         canvas.rect(.{
-            .x = @intCast(x),
+            .x = x,
             .y = 0,
             .width = rect_width,
             .height = thickness,
@@ -155,7 +145,6 @@ fn drawDashed(alloc: Allocator, width: u32, thickness: u32) !CanvasAndOffset {
     }
 
     const offset_y: i32 = 0;
-
     return .{ canvas, offset_y };
 }
 
@@ -192,8 +181,6 @@ fn drawCurly(alloc: Allocator, width: u32, thickness: u32) !CanvasAndOffset {
     // follow Xiaolin Wu's antialias algorithm to draw the curve
     var x: u32 = 0;
     while (x < width) : (x += 1) {
-        // We sample the wave function at the *middle* of each
-        // pixel column, to ensure that it renders symmetrically.
         const t: f64 = (@as(f64, @floatFromInt(x)) + 0.5) * wave_period;
         // Use the slope at this location to add thickness to
         // the line on this column, counteracting the thinning
@@ -211,7 +198,6 @@ fn drawCurly(alloc: Allocator, width: u32, thickness: u32) !CanvasAndOffset {
         const cosx: f64 = @cos(t);
         // This will be the center of our stroke.
         const y: f64 = y_mid + half_amplitude * cosx;
-
         // The upper pixel and lower pixel are
         // calculated relative to the center.
         const y_u: f64 = y - float_thick * 0.5 - slope_factor_u;
@@ -233,7 +219,6 @@ fn drawCurly(alloc: Allocator, width: u32, thickness: u32) !CanvasAndOffset {
     }
 
     const offset_y: i32 = @intFromFloat(-@round(half_amplitude));
-
     return .{ canvas, offset_y };
 }
 
@@ -309,4 +294,5 @@ test "curly" {
         9,
         2,
     );
-}
\ No newline at end of file
+}
+```
\ No newline at end of file
