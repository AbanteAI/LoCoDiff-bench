
index 94dc6911d..26e7f3d4d 100644
--- a/ghostty_src_font_face_freetype.zig_expectedoutput.txt (expected):tmp/tmpx8a14yta_expected.txt	
+++ b/ghostty_src_font_face_freetype.zig_extracted.txt (actual):tmp/tmp5uaourt6_actual.txt	
@@ -201,7 +201,7 @@ pub const Face = struct {
         var best_i: i32 = 0;
         var best_diff: i32 = 0;
         while (i < face.handle.*.num_fixed_sizes) : (i += 1) {
-            const width = face.handle.*.available_sizes[@intCast(i)].width;
+            const width = face.handle.*.available_sizes[@intCast(usize, i)].width;
             const diff = @as(i32, @intCast(size)) - @as(i32, @intCast(width));
             if (i == 0 or diff < best_diff) {
                 best_diff = diff;
@@ -337,9 +337,10 @@ pub const Face = struct {
             try self.face.renderGlyph(.normal);
         }
 
+        const bitmap_ft = glyph.*.bitmap;
+
         // This bitmap is blank. I've seen it happen in a font, I don't know why.
         // If it is empty, we just return a valid glyph struct that does nothing.
-        const bitmap_ft = glyph.*.bitmap;
         if (bitmap_ft.rows == 0) return .{
             .width = 0,
             .height = 0,
@@ -548,18 +549,18 @@ pub const Face = struct {
         };
 
         const offset_x: i32 = offset_x: {
-            var result: i32 = glyph_metrics.bitmap_left;
+            var result_: i32 = glyph_metrics.bitmap_left;
 
             // If our cell was resized to be wider then we center our
             // glyph in the cell.
             if (metrics.original_cell_width) |original_width| {
                 if (original_width < metrics.cell_width) {
                     const diff = (metrics.cell_width - original_width) / 2;
-                    result += @intCast(diff);
+                    result_ += @intCast(diff);
                 }
             }
 
-            break :offset_x result;
+            break :offset_x result_;
         };
 
         // log.warn("renderGlyph width={} height={} offset_x={} offset_y={} glyph_metrics={}", .{
