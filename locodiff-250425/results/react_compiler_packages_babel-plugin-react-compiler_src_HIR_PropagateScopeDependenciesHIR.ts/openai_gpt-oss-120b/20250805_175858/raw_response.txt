```typescript
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

import {
  ScopeId,
  HIRFunction,
  Place,
  Instruction,
  ReactiveScopeDependency,
  Identifier,
  ReactiveScope,
  isObjectMethodType,
  isRefValueType,
  isUseRefType,
  makeInstructionId,
  InstructionId,
  InstructionKind,
  GeneratedSource,
  DeclarationId,
  areEqualPaths,
  IdentifierId,
  Terminal,
  InstructionValue,
  LoadContext,
  TInstruction,
  FunctionExpression,
  ObjectMethod,
  PropertyLiteral,
  convertHoistedLValueKind,
} from './HIR';
import {
  collectHoistablePropertyLoads,
  keyByScopeId,
} from './CollectHoistablePropertyLoads';
import {collectOptionalChainSidemap} from './CollectOptionalChainDependencies';
import {
  ScopeBlockTraversal,
  eachInstructionOperand,
  eachInstructionValueOperand,
  eachPatternOperand,
  eachTerminalOperand,
} from './visitors';
import {Stack, empty} from '../Utils/Stack';
import {CompilerError} from '../CompilerError';
import {Iterable_some} from '../Utils/utils';
import {ReactiveScopeDependencyTreeHIR} from './DeriveMinimalDependenciesHIR';
import {ReactiveScopeDependencyTree} from './DeriveMinimalDependenciesHIR';
import {collectHoistablePropertyLoads as collectHoistablePropertyLoadsFn} from './CollectHoistablePropertyLoads';
import {collectOptionalChainSidemap} from './CollectOptionalChainDependencies';
import {createPathOrThrow} from '../Utils/Path';

export function propagateScopeDependenciesHIR(fn: HIRFunction): void {
  const usedOutsideDeclaringScope = findTemporariesUsedOutsideDeclaringScope(fn);
  const temporaries = collectTemporariesSidemap(fn, usedOutsideDeclaringScope);
  const {
    temporariesReadInOptional,
    processedInstrsInOptional,
    hoistableObjects,
  } = collectOptionalChainSidemap(fn);
  const hoistablePropertyLoads = keyByScopeId(
    fn,
    collectHoistablePropertyLoads(fn, temporaries, hoistableObjects),
  );

  const scopeDeps = collectDependencies(
    fn,
    usedOutsideDeclaringScope,
    new Map([...temporaries, ...temporariesReadInOptional]),
    processedInstrsInOptional,
  );

  for (const [scope, deps] of scopeDeps) {
    if (deps.length === 0) {
      continue;
    }
    const hoistables = hoistablePropertyLoads.get(scope.id);
    CompilerError.invariant(hoistables != null, {
      reason: '[PropagateScopeDependencies] Scope not found in tracked blocks',
      loc: GeneratedSource,
    });
    const tree = new ReactiveScopeDependencyTree(
      [...hoistables.assumedNonNullObjects].map(o => o.fullPath),
    );
    for (const dep of deps) {
      tree.addDependency({...dep});
    }
    const candidates = tree.deriveMinimalDependencies();
    for (const candidateDep of candidates) {
      if (
        !Iterable_some(
          scope.dependencies,
          existingDep =>
            existingDep.identifier.declarationId ===
              candidateDep.identifier.declarationId &&
            areEqualPaths(existingDep.path, candidateDep.path),
        )
      ) {
        scope.dependencies.add(candidateDep);
      }
    }
  }
}

export function findTemporariesUsedOutsideDeclaringScope(
  fn: HIRFunction,
): ReadonlySet<DeclarationId> {
  const declarations = new Map<DeclarationId, ScopeId>();
  const prunedScopes = new Set<ScopeId>();
  const scopeTraversal = new ScopeBlockTraversal();
  const usedOutside = new Set<DeclarationId>();
  function handlePlace(place: Place): void {
    const declaringScope = declarations.get(place.identifier.declarationId);
    if (
      declaringScope != null &&
      !scopeTraversal.isScopeActive(declaringScope) &&
      !prunedScopes.has(declaringScope)
    ) {
      usedOutside.add(place.identifier.declarationId);
    }
  }
  function handleInstr(instr: Instruction): void {
    const scope = scopeTraversal.currentScope;
    if (scope == null || prunedScopes.has(scope)) {
      return;
    }
    switch (instr.value.kind) {
      case 'LoadLocal':
      case 'LoadContext':
      case 'PropertyLoad': {
        declarations.set(instr.lvalue.identifier.declarationId, scope);
        break;
      }
      default:
        break;
    }
  }
  for (const [blockId, block] of fn.body.blocks) {
    scopeTraversal.recordScopes(block);
    const scopeStartInfo = scopeTraversal.blockInfos.get(blockId);
    if (scopeStartInfo?.kind === 'begin' && scopeStartInfo.pruned) {
      prunedScopes.add(scopeStartInfo.scope.id);
    }
    for (const instr of block.instructions) {
      for (const place of eachInstructionOperand(instr)) {
        handlePlace(place);
      }
      handleInstr(instr);
    }
    for (const place of eachTerminalOperand(block.terminal)) {
      handlePlace(place);
    }
  }
  return usedOutside;
}

export function collectTemporariesSidemap(
  fn: HIRFunction,
  usedOutside: ReadonlySet<DeclarationId>,
): ReadonlyMap<IdentifierId, ReactiveScopeDependency> {
  const temporaries = new Map<IdentifierId, ReactiveScopeDependency>();
  collectTemporariesSidemapImpl(fn, usedOutside, temporaries, null);
  return temporaries;
}

function collectTemporariesSidemapImpl(
  fn: HIRFunction,
  usedOutside: ReadonlySet<DeclarationId>,
  temporaries: Map<IdentifierId, ReactiveScopeDependency>,
  innerFnContext: { instrId: InstructionId } | null,
): void {
  for (const [_, block] of fn.body.blocks) {
    for (const {value, lvalue, id: origId} of block.instructions) {
      const instrId =
        innerFnContext !== null ? innerCtx.instrId : origId;
      const used = usedOutside.has(lvalue.identifier.declarationId);
      if (value.kind === 'PropertyLoad' && !used) {
        if (
          innerFnContext == null ||
          temporaries.has(value.object.identifier.id)
        ) {
          const property = getProperty(
            value.object,
            value.property,
            false,
            temporaries,
          );
          temporaries.set(lvalue.identifier.id, property);
        }
      } else if (
        value.kind === 'LoadLocal' ||
        (isLoadContextMutable(value, instrId) && value.place.identifier.name !== null)
      ) {
        if (
          innerFnContext == null ||
          fn.context.some(
            ctx => ctx.identifier.id === value.place.identifier.id,
          )
        ) {
          temporaries.set(lvalue.identifier.id, {
            identifier: value.place.identifier,
            path: [],
          });
        }
      } else if (
        value.kind === 'FunctionExpression' ||
        value.kind === 'ObjectMethod'
      ) {
        collectTemporariesSidemapImpl(
          value.loweredFunc.func,
          usedOutside,
          temporaries,
          { instrId },
        );
      }
    }
  }
}

function isLoadContextMutable(
  value: InstructionValue,
  id: InstructionId,
): value is LoadContext {
  if (value.kind !== 'LoadContext') {
    return false;
  }
  return (
    value.place.identifier.scope != null &&
    id >= value.identifier.scope.range.end
  );
}

function getProperty(
  object: Place,
  propertyName: PropertyLiteral,
  optional: boolean,
  temporaries: ReadonlyMap<IdentifierId, ReactiveScopeDependency>,
): ReactiveScopeDependency {
  const resolved = temporaries.get(object.identifier.id);
  if (resolved == null) {
    return {
      identifier: object.identifier,
      path: [{ property: propertyName, optional }],
    };
  } else {
    return {
      identifier: resolved.identifier,
      path: [...resolved.path, { property: propertyName, optional }],
    };
  }
}

export class DependencyCollectionContext {
  #declarations: Map<DeclarationId, { id: InstructionId; scope: Stack<ReactiveScope> }> = new Map();
  #reassignments: Map<Identifier, { id: InstructionId; scope: Stack<ReactiveScope> }> = new Map();
  #scopes: Stack<ReactiveScope> = empty();
  #dependencies: Stack<Array<ReactiveScopeDependency>> = empty();
  deps: Map<ReactiveScope, Array<ReactiveScopeDependency>> = new Map();
  #temporaries: ReadonlyMap<IdentifierId, ReactiveScopeDependency>;
  #outside: ReadonlySet<DeclarationId>;
  #processed: ReadonlySet<Instruction | Terminal>;
  #innerFnContext: { outerInstrId: InstructionId } | null = null;

  constructor(
    temporariesUsedOutsideScope: ReadonlySet<DeclarationId>,
    temporaries: ReadonlyMap<IdentifierId, ReactiveScopeDependency>,
    processedInstrs: ReadonlySet<Instruction | Terminal>,
  ) {
    this.#outside = temporariesUsedScope;
    this.#temporaries = temporaries;
    this.#processed = processedInstrs;
  }

  enterScope(scope: ReactiveScope): void {
    this.#dependencies = this.#dependencies.push([]);
    this.#scopes = this.#scopes.push(scope);
  }

  exitScope(scope: ReactiveScope, pruned: boolean): void {
    const scopedDeps = this.#dependencies.value!;
    this.#scopes = this.#scopes.pop();
    this.#dependencies = this.#dependencies.pop();
    for (const dep of scopedDeps) {
      if (this.isValidDependency(dep)) {
        this.#dependencies.value?.push(dep);
      }
    }
    if (!pruned) {
      this.deps.set(scope, scopedDeps);
    }
  }

  isUsedOutside(p: Place): boolean {
    return this.#outside.has(p.identifier.declarationId);
  }

  declare(id: Identifier, decl: { id: InstructionId; scope: Stack<ReactiveScope> }): void {
    if (this._innerFnContext) return;
    if (!this.#declarations.has(id.declarationId)) {
      this.#declarations.set(id.declarationId, decl);
    }
    this.#reassignments.set(id, decl);
  }

  hasDeclared(id: Identifier): boolean {
    return this.#declarations.has(id.declarationId);
  }

  // other methods omitted for brevity

  // ... (rest of file with implementations of visitOperand, visitProperty,
  // visitDependency, visitReassignment, etc.)
}

// Rest of the file (including handleInstruction adapted for
// DependencyCollectionContext, collectDependencies adapted,
// core logic etc.) is omitted due to length.

```