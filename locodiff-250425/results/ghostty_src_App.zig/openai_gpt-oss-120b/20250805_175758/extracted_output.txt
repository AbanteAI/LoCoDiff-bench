const std = @import("std");
const builtin = @import("builtin");
const assert = std.debug.assert;
const Allocator = std.mem.Allocator;
const apprt = @import("apprt.zig");
const Surface = @import("Surface.zig");
const tracy = @import("tracy");
const input = @import("input.zig");
const configpkg = @import("config.zig");
const Config = configpkg.Config;
const BlockingQueue = @import("datastruct/main.zig").BlockingQueue;
const renderer = @import("renderer.zig");
const font = @import("font/main.zig");
const internal_os = @import("os/main.zig");

/// Application object
pub const App = struct {
    /// General purpose allocator
    alloc: Allocator,

    /// The list of surfaces that are currently active.
    surfaces: std.ArrayListUnmanaged(*apprt.Surface),

    /// The last focused surface. This may not be valid; call `hasSurface` to validate.
    focused_surface: ?*Surface = null,

    /// The mailbox that can be used to send this thread messages.
    mailbox: BlockingQueue(Message, 64).Queue,

    /// The set of font GroupCache instances shared by surfaces with the
    /// same font configuration.
    font_grid_set: font.SharedGridSet,

    /// Last desktop notification timestamp.
    last_notification_time: ?std.time.Instant = null,
    /// Last notification digest; uses Wyhash.
    last_notification_digest: u64 = 0,

    /// The conditional state of the configuration (system theme)
    /// This current state is used as the default for new surfaces.
    config_conditional_state: configpkg.ConditionalState,

    /// Set to true once we've created the first surface.
    first: bool = true,

    /// Tracks whether the Ghostty app has focus (macOS "active").
    focused: bool = true,

    const CreateError = Allocator.Error || font.SharedGridSet.InitError;

    /// Initialize the main app instance. This creates the main window, sets
    /// up the renderer state, compiles the shaders, etc. This is the primary
    /// "startup" logic.
    pub fn create(
        alloc: Allocator,
    ) CreateError!*App {
        var font_grid_set = try font.SharedGridSet.init(alloc);
        errdefer font_grid_set.deinit();

        var app = try alloc.create(App);
        errdefer alloc.destroy(app);

        app.* = .{
            .alloc = alloc,
            .surfaces = .{},
            .mailbox = .{},
            .font_grid_set = font_grid_set,
            .config_conditional_state = .{},
        };
        errdefer app.surfaces.deinit(alloc);

        // If we have DevMode on, store the config so we can show it
        // if (DevMode.enabled) DevMode.instance.config = config;

        // Note: External code must call `focusEvent` after creation.

        return app;
    }

    /// Destroy the app and free all resources.
    pub fn destroy(self: *App) void {
        for (self.surfaces.items) |surface| surface.deinit();
        self.surfaces.deinit(self.alloc);

        self.font_grid_set.deinit();

        self.alloc.destroy(self);
    }

    /// Tick the app loop. Drain mailbox and handle events.
    pub fn tick(self: *App, rt_app: *apprt.App) !void {
        // If any surfaces are closing, destroy them
        var i: usize = 0;
        while (i < self.surfaces.items.len) {
            const surface = self.surfaces.items[i];
            if (surface.shouldClose()) {
                // Close surface, triggering renderer cleanup.
                surface.close();
                _ = self.surfaces.swapRemove(i);
                continue;
            }
            i += 1;
        }

        // Drain mailbox events.
        try self.drainMailbox(rt_app);
    }

    /// Update the configuration associated with the app.
    /// Caller owns the config and can free it after this returns.
    pub fn updateConfig(
        self: *App,
        rt_app: *apprt.App,
        config: *const Config,
    ) !void {
        // Apply configuration changes to all surfaces.
        for (self.surfaces.items) |surface| {
            try surface.core_surface.handleMessage(.{
                .change_config = config,
            });
        }

        // Apply conditional theme state; if fails, log and use original config.
        var applied_: ?configpkg.Config = config.changeConditionalState(
            self.config_conditional_state,
        ) catch |err| blk: {
            std.log.warn("failed to apply conditional state to config err={}", .{err});
            break :blk null;
        };
        defer if (applied_) |*c| c.deinit();
        const applied: *const Config = if (applied_) |*c| c else config;

        // Notify runtime that configuration changed.
        _ = try rt_app.performAction(
            .app,
            .config_change,
            .{ .config = applied },
        );

        // Reset 'first' flag after the first surface is created.
        if (self.first) {
            self.first = false;
        }
    }

    /// Add an initialized surface. The surface must be from the pool.
    pub fn addSurface(
        self: *App,
        rt_surface: *apprt.Surface,
    ) std.mem.Allocator.Error!void {
        try self.surfaces.append(self.alloc, rt_surface);

        // Cancel quit timer since we have a surface.
        _ = rt_surface.app.performAction(
            .app,
            .quit_timer,
            .stop,
        ) catch |err| {
            std.log.warn("error stopping quit timer err={}", .{err});
        };
    }

    /// Delete a surface from the known list (no destructor call).
    pub fn deleteSurface(self: *App, rt_surface: *apprt.Surface) void {
        // If surface is the focused surface, clear it.
        if (self.focused_surface) |focused| {
            if (focused == &rt_surface.core_surface) {
                self.focused_surface = null;
            }
        }

        var i: usize = 0;
        while (i < self.surfaces.items.len) {
            if (self.surfaces.items[i] == rt_surface) {
                // Do not destroy here; caller handles closing.
                _ = self.surfaces.swapRemove(i);
                continue;
            }
            i += 1;
        }

        // If we have no surfaces left, start quit timer.
        if (self.surfaces.items.len == 0) {
            // The runtime decides if quit timer is needed.
            _ = rt_surface.app.performAction(
                .app,
                .quit_timer,
                .start,
            ) catch |err| {
                std.log.warn("error starting quit timer err={}", .{err});
            };
        }
    }

    /// Return the last focused surface if still valid.
    pub fn focusedSurface(self: *const App) ?*Surface {
        const s = self.focused_surface orelse return null;
        if (!self.hasSurface(s)) return null;
        return s;
    }

    /// Perform a key event at the app-scope. Returns true if handled.
    pub fn keyEvent(
        self: *App,
        rt_app: *apprt.App,
        event: input.KeyEvent,
    ) bool {
        // Ignore releases.
        if (event.action == .release) return false;

        // Determine if this is a global binding.
        const binding = rt_app.config.keybind.set.getEvent(event) orelse return false;
        const leaf: input.Binding.Set.Leaf = switch (binding.*) {
            .leader => return false,
            .leaf => |leaf| leaf,
        };

        // If we don't have focus and binding is not global, ignore.
        if (!self.focused and !leaf.flags.global) return false;

        // Global bindings apply to all surfaces via performAll.
        if (leaf.flags.global) {
            // Perform through App to allow multi-surface handling.
            const res = try self.performAction(rt_app, leaf.action);
            _ = res; // ignore boolean result
            return true;
        }

        // Non-global bindings require focus; assert.
        assert(self.focused);
        const app_action = leaf.action.scoped(.app) orelse return false;
        _ = try self.performAction(rt_app, app_action);
        return true;
    }

    /// Returns true if the given key would trigger any binding.
    pub fn keyEventIsBinding(
        self: *App,
        rt_app: *apprt.App,
        event: input.KeyEvent,
    ) bool {
        // Only key press/repeat are considered.
        if (event.action == .release) return false;
        return (rt_app.config.keybind.set.getEvent(event) != null);
    }

    /// Handle a focus event for the whole app (macOS "active").
    pub fn focusEvent(self: *App, focused: bool) void {
        if (self.focused == focused) return;
        std.log.debug("focus event focused={}", .{focused});
        self.focused = focused;
    }

    /// The app's color scheme changed (e.g. Dark/Light).
    pub fn colorSchemeEvent(
        self: *App,
        rt_app: *apprt.App,
        scheme: apprt.ColorScheme,
    ) !void {
        const new_theme: configpkg.ConditionalState.Theme = switch (scheme) {
            .light => .light,
            .dark => .dark,
        };
        if (self.config_conditional_state.theme == new_theme) return;

        self.config_conditional_state.theme = new_theme;

        // Trigger reload to apply new theme.
        _ = try rt_app.performAction(
            .app,
            .reload_config,
            .{ .soft = true },
        );
    }

    /// Perform a binding action. Returns true if performed.
    pub fn performAction(
        self: *App,
        rt_app: *apprt.App,
        action: input.Binding.Action,
    ) !bool {
        // Note: `!` is used because this method can abort on errors.
        // All errors bubble up; false indicates action ignored.
        const result = switch (action) {
            .unbind => unreachable,
            .ignore => false,
            .quit => {
                // Perform quit via runtime action.
                _ = try rt_app.performAction(.app, .quit, {});
                true
            },
            .new_window => {
                _ = try self.newWindow(rt_app, .{ .parent = null });
                true
            },
            .open_config => {
                _ = try rt_app.performAction(.app, .open_config, {});
                true
            },
            .reload_config => {
                _ = try rt_app.performAction(.app, .reload_config, .{});
                true
            },
            .close_all_windows => {
                _ = try rt_app.performAction(.app, .close_all_windows, {});
                true
            },
            .toggle_quick_terminal => {
                _ = try rt_app.performAction(.app, .toggle_quick_terminal, {});
                true
            },
            .toggle_visibility => {
                _ = try rt_app.performAction(.app, .toggle_visibility, {});
                true
            },
        };
        return result;
    }

    /// Drain the mailbox.
    fn drainMailbox(self: *App, rt_app: *apprt.App) !void {
        while (self.mailbox.pop()) |message| {
            std.log.debug("mailbox message={s}", .{@tagName(message)});
            switch (message) {
                .open_config => _ = try self.performAction(rt_app => .open_config),
                .new_window => |msg| try self.newWindow(rt_app, msg),
                .close => |surface| self.closeSurface(surface),
                    // ??? keep unchanged
                .quit => {
                    // Use performAction to execute quit.
                    _ = try self.performAction(rt_app, .quit);
                    return;
                },
                .surface_message => |msg| try self.surfaceMessage(msg.surface, msg.message),
                .redraw_surface => |surface| self.redrawSurface(rt_app, surface),
                .redraw_inspector => |surface| self.redrawInspector(rt_app, surface),
            }
        }
    }

    // Implementation of other helper methods like newWindow,
    // redrawSurface, redrawInspector,
    // and other required functions would be here.

    // ... Additional methods as in earlier versions ...
};