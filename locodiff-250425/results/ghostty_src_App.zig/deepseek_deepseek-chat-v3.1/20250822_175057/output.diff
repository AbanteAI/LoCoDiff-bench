
index 6a32b56a9..0f112d07a 100644
--- a/ghostty_src_App.zig_expectedoutput.txt (expected):tmp/tmp5ho9y0qj_expected.txt	
+++ b/ghostty_src_App.zig_extracted.txt (actual):tmp/tmpl2ibydb3_actual.txt	
@@ -25,6 +25,25 @@ const log = std.log.scoped(.app);
 
 const SurfaceList = std.ArrayListUnmanaged(*apprt.Surface);
 
+/// The type used for sending messages to the app thread.
+pub const Mailbox = struct {
+    /// The type used for sending messages to the app thread.
+    pub const Queue = BlockingQueue(Message, 64);
+
+    rt_app: *apprt.App,
+    mailbox: *Queue,
+
+    /// Send a message to the surface.
+    pub fn push(self: Mailbox, msg: Message, timeout: Queue.Timeout) Queue.Size {
+        const result = self.mailbox.push(msg, timeout);
+
+        // Wake up our app loop
+        self.rt_app.wakeup();
+
+        return result;
+    }
+};
+
 /// General purpose allocator
 alloc: Allocator,
 
@@ -118,6 +137,11 @@ pub fn destroy(self: *App) void {
     self.alloc.destroy(self);
 }
 
+/// Request the app runtime to process app events via tick.
+pub fn wakeup(self: App) void {
+    if (self.wakeup_cb) |cb| cb();
+}
+
 /// Tick ticks the app loop. This will drain our mailbox and process those
 /// events. This should be called by the application runtime on every loop
 /// tick.
@@ -510,9 +534,6 @@ pub const Message = union(enum) {
     /// should close.
     close: *Surface,
 
-    /// Quit
-    quit: void,
-
     /// A message for a specific surface.
     surface_message: struct {
         surface: *Surface,
@@ -529,44 +550,28 @@ pub const Message = union(enum) {
     /// causes the inspector to need to be redrawn.
     redraw_inspector: *apprt.Surface,
 
+    /// Quit
+    quit: void,
+
     const NewWindow = struct {
         /// The parent surface
         parent: ?*Surface = null,
     };
 };
 
-/// Mailbox is the way that other threads send the app thread messages.
-pub const Mailbox = struct {
-    /// The type used for sending messages to the app thread.
-    pub const Queue = BlockingQueue(Message, 64);
-
-    rt_app: *apprt.App,
-    mailbox: *Queue,
-
-    /// Send a message to the surface.
-    pub fn push(self: Mailbox, msg: Message, timeout: Queue.Timeout) Queue.Size {
-        const result = self.mailbox.push(msg, timeout);
-
-        // Wake up our app loop
-        self.rt_app.wakeup();
-
-        return result;
-    }
-};
-
 // Wasm API.
 pub const Wasm = if (!builtin.target.isWasm()) struct {} else struct {
     const wasm = @import("os/wasm.zig");
     const alloc = wasm.alloc;
 
     // export fn app_new(config: *Config) ?*App {
-    //     return app_new_(config) catch |err| { log.err("error initializing app err={}", .{err});
+    //     return app_new_(config) catch |err| { log.warn("error initializing app err={}", .{err});
     //         return null;
     //     };
     // }
     //
     // fn app_new_(config: *Config) !*App {
-    //     const app = try App.create(alloc, config);
+    //     const app = try App.create(global.alloc, opts.*, config);
     //     errdefer app.destroy();
     //
     //     const result = try alloc.create(App);
