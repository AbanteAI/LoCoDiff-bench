--- qdrant_lib_segment_src_index_field_index_numeric_index_mutable_numeric_index.rs_expectedoutput.txt (expected)+++ qdrant_lib_segment_src_index_field_index_numeric_index_mutable_numeric_index.rs_extracted.txt (actual)@@ -4,17 +4,19 @@ use std::sync::Arc;
 
 use common::counter::hardware_counter::HardwareCounterCell;
+use common::counter::write_back_counter::WritebackCounterCell;
 use common::types::PointOffsetType;
 use parking_lot::RwLock;
 use rocksdb::DB;
 
 use super::{
-    Encodable, HISTOGRAM_MAX_BUCKET_SIZE, HISTOGRAM_PRECISION, numeric_index_storage_cf_name,
+    numeric_index_storage_cf_name, Encodable, HISTOGRAM_MAX_BUCKET_SIZE, HISTOGRAM_PRECISION,
 };
 use crate::common::operation_error::{OperationError, OperationResult};
 use crate::common::rocksdb_buffered_delete_wrapper::DatabaseColumnScheduledDeleteWrapper;
 use crate::common::rocksdb_wrapper::DatabaseColumnWrapper;
 use crate::index::field_index::histogram::{Histogram, Numericable, Point};
+use std::mem::size_of_val;
 
 pub struct MutableNumericIndex<T: Encodable + Numericable> {
     db_wrapper: DatabaseColumnScheduledDeleteWrapper,
@@ -59,7 +61,7 @@             index.point_to_values[idx as usize].push(value);
 
             let key = Point::new(value, idx);
-            InMemoryNumericIndex::add_to_map(&mut index.map, &mut index.histogram, key);
+            InMemoryNumericIndex::<T>::add_to_map(&mut index.map, &mut index.histogram, key);
         }
         for values in &index.point_to_values {
             if !values.is_empty() {
