--- qdrant_lib_segment_src_index_field_index_numeric_index_mutable_numeric_index.rs_expectedoutput.txt (expected)+++ qdrant_lib_segment_src_index_field_index_numeric_index_mutable_numeric_index.rs_extracted.txt (actual)@@ -21,7 +21,6 @@     in_memory_index: InMemoryNumericIndex<T>,
 }
 
-// Numeric Index with insertions and deletions without persistence
 pub struct InMemoryNumericIndex<T: Encodable + Numericable> {
     pub map: BTreeSet<Point<T>>,
     pub histogram: Histogram<T>,
@@ -42,7 +41,7 @@     }
 }
 
-impl<T: Encodable + Numericable + Default> FromIterator<(PointOffsetType, T)>
+impl<T: Encodable + Numericable + Default> FromIterator<(PointOffsetType, T)> 
     for InMemoryNumericIndex<T>
 {
     fn from_iter<I: IntoIterator<Item = (PointOffsetType, T)>>(iter: I) -> Self {
@@ -145,9 +144,6 @@ 
     fn add_to_map(map: &mut BTreeSet<Point<T>>, histogram: &mut Histogram<T>, key: Point<T>) {
         let was_added = map.insert(key.clone());
-        // Histogram works with unique values (idx + value) only, so we need to
-        // make sure that we don't add the same value twice.
-        // key is a combination of value + idx, so we can use it to ensure than the pair is unique
         if was_added {
             histogram.insert(
                 key,
