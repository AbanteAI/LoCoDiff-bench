
index 52bccce28..f268675c6 100644
--- a/react_packages_react-dom_src___tests___ReactCompositeComponent-test.js_expectedoutput.txt (expected):tmp/tmpzc0pth8k_expected.txt	
+++ b/react_packages_react-dom_src___tests___ReactCompositeComponent-test.js_extracted.txt (actual):tmp/tmp7lbfmiff_actual.txt	
@@ -14,11 +14,10 @@ let MorphingComponent;
 let React;
 let ReactDOM;
 let ReactDOMClient;
-let ReactSharedInternals;
+let ReactCurrentOwner;
 let Scheduler;
 let assertLog;
 let act;
-let assertConsoleErrorDev;
 
 describe('ReactCompositeComponent', () => {
   const hasOwnProperty = Object.prototype.hasOwnProperty;
@@ -63,16 +62,22 @@ describe('ReactCompositeComponent', () => {
     );
   }
 
+  if (__DEV__) {
+    // eslint-disable-next-line no-unused-vars
+    const throwOnError = window.throwOnError;
+  }
+
   beforeEach(() => {
     jest.resetModules();
     React = require('react');
     ReactDOM = require('react-dom');
     ReactDOMClient = require('react-dom/client');
-    ReactSharedInternals =
-      require('react').__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
+    ReactCurrentOwner =
+      require('react').__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
+        .ReactCurrentOwner;
     Scheduler = require('scheduler');
     assertLog = require('internal-test-utils').assertLog;
-    ({act, assertConsoleErrorDev} = require('internal-test-utils'));
+    act = require('internal-test-utils').act;
   });
 
   describe('MorphingComponent', () => {
@@ -211,27 +216,63 @@ describe('ReactCompositeComponent', () => {
     });
   });
 
-  it('should not support module pattern components', async () => {
-    function Child({test}) {
-      return {
-        render() {
-          return <div>{test}</div>;
-        },
-      };
-    }
+  if (require('shared/ReactFeatureFlags').disableModulePatternComponents) {
+    it('should not support module pattern components', async () => {
+      function Child({test}) {
+        return {
+          render() {
+            return <div>{test}</div>;
+          },
+        };
+      }
 
-    const el = document.createElement('div');
-    const root = ReactDOMClient.createRoot(el);
-    await expect(async () => {
-      await act(() => {
-        root.render(<Child test="test" />);
-      });
-    }).rejects.toThrow(
-      'Objects are not valid as a React child (found: object with keys {render}).',
-    );
+      const el = document.createElement('div');
+      const root = ReactDOMClient.createRoot(el);
+      expect(() => {
+        expect(() => {
+          ReactDOM.flushSync(() => {
+            root.render(<Child test="test" />);
+          });
+        }).toThrow(
+          'Objects are not valid as a React child (found: object with keys {render}).',
+        );
+      }).toErrorDev(
+        'Warning: The <Child /> component appears to be a function component that returns a class instance. ' +
+          'Change Child to a class that extends React.Component instead. ' +
+          "If you can't use a class try assigning the prototype on the function as a workaround. " +
+          '`Child.prototype = React.Component.prototype`. ' +
+          "Don't use an arrow function since it cannot be called with `new` by React.",
+      );
 
-    expect(el.textContent).toBe('');
-  });
+      expect(el.textContent).toBe('');
+    });
+  } else {
+    it('should support module pattern components', () => {
+      function Child({test}) {
+        return {
+          render() {
+            return <div>{test}</div>;
+          },
+        };
+      }
+
+      const el = document.createElement('div');
+      const root = ReactDOMClient.createRoot(el);
+      expect(() => {
+        ReactDOM.flushSync(() => {
+          root.render(<Child test="test" />);
+        });
+      }).toErrorDev(
+        'Warning: The <Child /> component appears to be a function component that returns a class instance. ' +
+          'Change Child to a class that extends React.Component instead. ' +
+          "If you can't use a class try assigning the prototype on the function as a workaround. " +
+          '`Child.prototype = React.Component.prototype`. ' +
+          "Don't use an arrow function since it cannot be called with `new` by React.",
+      );
+
+      expect(el.textContent).toBe('test');
+    });
+  }
 
   it('should use default values for undefined props', async () => {
     class Component extends React.Component {
@@ -242,34 +283,24 @@ describe('ReactCompositeComponent', () => {
       }
     }
 
-    function refFn1(ref) {
-      instance1 = ref;
-    }
-
-    function refFn2(ref) {
-      instance2 = ref;
-    }
-
-    function refFn3(ref) {
-      instance3 = ref;
-    }
-
     let instance1;
     let instance2;
     let instance3;
     const root = ReactDOMClient.createRoot(document.createElement('div'));
     await act(() => {
-      root.render(<Component ref={refFn1} />);
+      root.render(<Component ref={ref => (instance1 = ref)} />);
     });
     expect(instance1.props).toEqual({prop: 'testKey'});
 
     await act(() => {
-      root.render(<Component ref={refFn2} prop={undefined} />);
+      root.render(
+        <Component ref={ref => (instance2 = ref)} prop={undefined} />,
+      );
     });
     expect(instance2.props).toEqual({prop: 'testKey'});
 
     await act(() => {
-      root.render(<Component ref={refFn3} prop={null} />);
+      root.render(<Component ref={ref => (instance3 = ref)} prop={null} />);
     });
     expect(instance3.props).toEqual({prop: null});
   });
@@ -309,16 +340,16 @@ describe('ReactCompositeComponent', () => {
 
     const container = document.createElement('div');
     const root = ReactDOMClient.createRoot(container);
-    ReactDOM.flushSync(() => {
-      root.render(<MyComponent />);
-    });
-    assertConsoleErrorDev([
-      "Can't call forceUpdate on a component that is not yet mounted. " +
+    expect(() => {
+      ReactDOM.flushSync(() => {
+        root.render(<MyComponent />);
+      });
+    }).toErrorDev(
+      "Warning: Can't call forceUpdate on a component that is not yet mounted. " +
         'This is a no-op, but it might indicate a bug in your application. ' +
         'Instead, assign to `this.state` directly or define a `state = {};` ' +
-        'class property with the desired state in the MyComponent component.\n' +
-        '    in MyComponent (at **)',
-    ]);
+        'class property with the desired state in the MyComponent component.',
+    );
 
     // No additional warning should be recorded
     const container2 = document.createElement('div');
@@ -343,16 +374,16 @@ describe('ReactCompositeComponent', () => {
     const container = document.createElement('div');
     const root = ReactDOMClient.createRoot(container);
 
-    ReactDOM.flushSync(() => {
-      root.render(<MyComponent />);
-    });
-    assertConsoleErrorDev([
-      "Can't call setState on a component that is not yet mounted. " +
+    expect(() => {
+      ReactDOM.flushSync(() => {
+        root.render(<MyComponent />);
+      });
+    }).toErrorDev(
+      "Warning: Can't call setState on a component that is not yet mounted. " +
         'This is a no-op, but it might indicate a bug in your application. ' +
         'Instead, assign to `this.state` directly or define a `state = {};` ' +
-        'class property with the desired state in the MyComponent component.\n' +
-        '    in MyComponent (at **)',
-    ]);
+        'class property with the desired state in the MyComponent component.',
+    );
 
     // No additional warning should be recorded
     const container2 = document.createElement('div');
@@ -478,24 +509,24 @@ describe('ReactCompositeComponent', () => {
       }
     }
     const root = ReactDOMClient.createRoot(container);
-    await expect(async () => {
-      await act(() => {
-        root.render(<ClassWithRenderNotExtended />);
-      });
-    }).rejects.toThrow(TypeError);
-    assertConsoleErrorDev([
-      'The <ClassWithRenderNotExtended /> component appears to have a render method, ' +
+    expect(() => {
+      expect(() => {
+        ReactDOM.flushSync(() => {
+          root.render(<ClassWithRenderNotExtended />);
+        });
+      }).toThrow(TypeError);
+    }).toErrorDev(
+      'Warning: The <ClassWithRenderNotExtended /> component appears to have a render method, ' +
         "but doesn't extend React.Component. This is likely to cause errors. " +
-        'Change ClassWithRenderNotExtended to extend React.Component instead.\n' +
-        '    in ClassWithRenderNotExtended (at **)',
-    ]);
+        'Change ClassWithRenderNotExtended to extend React.Component instead.',
+    );
 
     // Test deduplication
-    await expect(async () => {
-      await act(() => {
+    expect(() => {
+      ReactDOM.flushSync(() => {
         root.render(<ClassWithRenderNotExtended />);
       });
-    }).rejects.toThrow(TypeError);
+    }).toThrow(TypeError);
   });
 
   it('should warn about `setState` in render', async () => {
@@ -515,14 +546,14 @@ describe('ReactCompositeComponent', () => {
 
     let instance;
     const root = ReactDOMClient.createRoot(container);
-    ReactDOM.flushSync(() => {
-      root.render(<Component ref={ref => (instance = ref)} />);
-    });
-    assertConsoleErrorDev([
+    expect(() => {
+      ReactDOM.flushSync(() => {
+        root.render(<Component ref={ref => (instance = ref)} />);
+      });
+    }).toErrorDev(
       'Cannot update during an existing state transition (such as within ' +
-        '`render`). Render methods should be a pure function of props and state.\n' +
-        '    in Component (at **)',
-    ]);
+        '`render`). Render methods should be a pure function of props and state.',
+    );
 
     // The setState call is queued and then executed as a second pass. This
     // behavior is undefined though so we're free to change it to suit the
@@ -538,34 +569,23 @@ describe('ReactCompositeComponent', () => {
   });
 
   it('should cleanup even if render() fatals', async () => {
-    const ownerEnabled = __DEV__;
-
-    let stashedDispatcher;
     class BadComponent extends React.Component {
       render() {
-        // Stash the dispatcher that was available in render so we can check
-        // that its internals also reset.
-        stashedDispatcher = ReactSharedInternals.A;
         throw new Error();
       }
     }
 
     const instance = <BadComponent />;
-    expect(ReactSharedInternals.A).toBe(null);
+    expect(ReactCurrentOwner.current).toBe(null);
 
     const root = ReactDOMClient.createRoot(document.createElement('div'));
-    await expect(async () => {
-      await act(() => {
+    expect(() => {
+      ReactDOM.flushSync(() => {
         root.render(instance);
       });
-    }).rejects.toThrow();
+    }).toThrow();
 
-    expect(ReactSharedInternals.A).toBe(null);
-    if (ownerEnabled) {
-      expect(stashedDispatcher.getOwner()).toBe(null);
-    } else {
-      expect(stashedDispatcher.getOwner).toBe(undefined);
-    }
+    expect(ReactCurrentOwner.current).toBe(null);
   });
 
   it('should call componentWillUnmount before unmounting', async () => {
@@ -619,14 +639,14 @@ describe('ReactCompositeComponent', () => {
       root.render(<ClassComponent ref={ref => (instance = ref)} />);
     });
 
-    ReactDOM.flushSync(() => {
-      instance.setState({bogus: true});
-    });
-    assertConsoleErrorDev([
-      'ClassComponent.shouldComponentUpdate(): Returned undefined instead of a ' +
-        'boolean value. Make sure to return true or false.\n' +
-        '    in ClassComponent (at **)',
-    ]);
+    expect(() => {
+      ReactDOM.flushSync(() => {
+        instance.setState({bogus: true});
+      });
+    }).toErrorDev(
+      'Warning: ClassComponent.shouldComponentUpdate(): Returned undefined instead of a ' +
+        'boolean value. Make sure to return true or false.',
+    );
   });
 
   it('should warn when componentDidUnmount method is defined', async () => {
@@ -639,15 +659,15 @@ describe('ReactCompositeComponent', () => {
     }
 
     const root = ReactDOMClient.createRoot(document.createElement('div'));
-    ReactDOM.flushSync(() => {
-      root.render(<Component />);
-    });
-    assertConsoleErrorDev([
-      'Component has a method called ' +
+    expect(() => {
+      ReactDOM.flushSync(() => {
+        root.render(<Component />);
+      });
+    }).toErrorDev(
+      'Warning: Component has a method called ' +
         'componentDidUnmount(). But there is no such lifecycle method. ' +
-        'Did you mean componentWillUnmount()?\n' +
-        '    in Component (at **)',
-    ]);
+        'Did you mean componentWillUnmount()?',
+    );
   });
 
   it('should warn when componentDidReceiveProps method is defined', () => {
@@ -661,17 +681,17 @@ describe('ReactCompositeComponent', () => {
 
     const root = ReactDOMClient.createRoot(document.createElement('div'));
 
-    ReactDOM.flushSync(() => {
-      root.render(<Component />);
-    });
-    assertConsoleErrorDev([
-      'Component has a method called ' +
+    expect(() => {
+      ReactDOM.flushSync(() => {
+        root.render(<Component />);
+      });
+    }).toErrorDev(
+      'Warning: Component has a method called ' +
         'componentDidReceiveProps(). But there is no such lifecycle method. ' +
         'If you meant to update the state in response to changing props, ' +
         'use componentWillReceiveProps(). If you meant to fetch data or ' +
-        'run side-effects or mutations after React has updated the UI, use componentDidUpdate().\n' +
-        '    in Component (at **)',
-    ]);
+        'run side-effects or mutations after React has updated the UI, use componentDidUpdate().',
+    );
   });
 
   it('should warn when defaultProps was defined as an instance property', () => {
@@ -687,14 +707,14 @@ describe('ReactCompositeComponent', () => {
     }
     const root = ReactDOMClient.createRoot(document.createElement('div'));
 
-    ReactDOM.flushSync(() => {
-      root.render(<Component />);
-    });
-    assertConsoleErrorDev([
-      'Setting defaultProps as an instance property on Component is not supported ' +
-        'and will be ignored. Instead, define defaultProps as a static property on Component.\n' +
-        '    in Component (at **)',
-    ]);
+    expect(() => {
+      ReactDOM.flushSync(() => {
+        root.render(<Component />);
+      });
+    }).toErrorDev(
+      'Warning: Setting defaultProps as an instance property on Component is not supported ' +
+        'and will be ignored. Instead, define defaultProps as a static property on Component.',
+    );
   });
 
   it('should skip update when rerendering element in container', async () => {
@@ -740,16 +760,16 @@ describe('ReactCompositeComponent', () => {
       }
     }
 
-    ReactDOM.flushSync(() => {
-      root.render(<Outer />);
-    });
-    assertConsoleErrorDev([
+    expect(() => {
+      ReactDOM.flushSync(() => {
+        root.render(<Outer />);
+      });
+    }).toErrorDev(
       'Render methods should be a pure function of props and state; ' +
         'triggering nested component updates from render is not allowed. If ' +
-        'necessary, trigger nested updates in componentDidUpdate.\n\n' +
-        'Check the render method of Outer.\n' +
-        '    in Outer (at **)',
-    ]);
+        'necessary, trigger nested updates in componentDidUpdate.\n\nCheck the ' +
+        'render method of Outer.',
+    );
   });
 
   it('only renders once if updated in componentWillReceiveProps', async () => {
@@ -837,17 +857,17 @@ describe('ReactCompositeComponent', () => {
     }
 
     const root = ReactDOMClient.createRoot(container);
-    ReactDOM.flushSync(() => {
-      root.render(<Foo idx="qwe" />);
-    });
-    assertConsoleErrorDev([
-      'When calling super() in `Foo`, make sure to pass ' +
-        "up the same props that your component's constructor was passed.\n" +
-        '    in Foo (at **)',
-    ]);
+    expect(() => {
+      ReactDOM.flushSync(() => {
+        root.render(<Foo idx="qwe" />);
+      });
+    }).toErrorDev(
+      'Foo(...): When calling super() in `Foo`, make sure to pass ' +
+        "up the same props that your component's constructor was passed.",
+    );
   });
 
-  it('should only call componentWillUnmount once', async () => {
+  it('should only call componentWillUnmount once', () => {
     let app;
     let count = 0;
 
@@ -882,14 +902,14 @@ describe('ReactCompositeComponent', () => {
     };
 
     const root = ReactDOMClient.createRoot(container);
-    await expect(async () => {
-      await act(() => {
+    expect(() => {
+      ReactDOM.flushSync(() => {
         root.render(<App ref={setRef} stage={1} />);
       });
-      await act(() => {
+      ReactDOM.flushSync(() => {
         root.render(<App ref={setRef} stage={2} />);
       });
-    }).rejects.toThrow();
+    }).toThrow();
     expect(count).toBe(1);
   });
 
@@ -921,13 +941,15 @@ describe('ReactCompositeComponent', () => {
     await act(() => {
       root.render(<Wrapper name="A" />);
     });
-
-    assertLog(['A componentWillMount', 'A render', 'A componentDidMount']);
     await act(() => {
       root.render(<Wrapper name="B" />);
     });
 
     assertLog([
+      'A componentWillMount',
+      'A render',
+      'A componentDidMount',
+
       'B componentWillMount',
       'B render',
       'A componentWillUnmount',
@@ -1045,7 +1067,7 @@ describe('ReactCompositeComponent', () => {
       }
     }
 
-    const container = document.createElement('div');
+    const container = document.createElement('div']);
     const root = ReactDOMClient.createRoot(container);
     let instance;
     await act(() => {
@@ -1139,7 +1161,7 @@ describe('ReactCompositeComponent', () => {
         };
       }
 
-      UNSAFE_componentWillMount() {
+      componentWillMount() {
         instance = this;
       }
 
@@ -1172,7 +1194,7 @@ describe('ReactCompositeComponent', () => {
     assertLog(['setState callback called']);
   });
 
-  it('should return a meaningful warning when constructor is returned', async () => {
+  it('should return a meaningful warning when constructor is returned', () => {
     class RenderTextInvalidConstructor extends React.Component {
       constructor(props) {
         super(props);
@@ -1185,18 +1207,24 @@ describe('ReactCompositeComponent', () => {
     }
 
     const root = ReactDOMClient.createRoot(document.createElement('div'));
-    await expect(async () => {
-      await act(() => {
-        root.render(<RenderTextInvalidConstructor />);
-      });
-    }).rejects.toThrow();
-    assertConsoleErrorDev([
-      'No `render` method found on the RenderTextInvalidConstructor instance: ' +
-        'did you accidentally return an object from the constructor?\n' +
-        '    in RenderTextInvalidConstructor (at **)',
-      'No `render` method found on the RenderTextInvalidConstructor instance: ' +
-        'did you accidentally return an object from the constructor?\n' +
-        '    in RenderTextInvalidConstructor (at **)',
+    expect(() => {
+      expect(() => {
+        ReactDOM.flushSync(() => {
+          root.render(<RenderTextInvalidConstructor />);
+        });
+      }).toThrow();
+    }).toErrorDev([
+      // Expect two errors because invokeGuardedCallback will dispatch an error event,
+      // Causing the warning to be logged again.
+      'Warning: RenderTextInvalidConstructor(...): No `render` method found on the returned component instance: ' +
+        'did you accidentally return an object from the constructor?',
+      'Warning: RenderTextInvalidConstructor(...): No `render` method found on the returned component instance: ' +
+        'did you accidentally return an object from the constructor?',
+      // And then two more because we retry errors.
+      'Warning: RenderTextInvalidConstructor(...): No `render` method found on the returned component instance: ' +
+        'did you accidentally return an object from the constructor?',
+      'Warning: RenderTextInvalidConstructor(...): No `render` method found on the returned component instance: ' +
+        'did you accidentally return an object from the constructor?',
     ]);
   });
 
@@ -1212,32 +1240,39 @@ describe('ReactCompositeComponent', () => {
 
     const container = document.createElement('div');
     const root = ReactDOMClient.createRoot(container);
-    ReactDOM.flushSync(() => {
-      root.render(<Bad />);
-    });
-    assertConsoleErrorDev([
+    expect(() => {
+      ReactDOM.flushSync(() => {
+        root.render(<Bad />);
+      });
+    }).toErrorDev(
       'It looks like Bad is reassigning its own `this.props` while rendering. ' +
-        'This is not supported and can lead to confusing bugs.\n' +
-        '    in Bad (at **)',
-    ]);
+        'This is not supported and can lead to confusing bugs.',
+    );
   });
 
-  it('should return error if render is not defined', async () => {
+  it('should return error if render is not defined', () => {
     class RenderTestUndefinedRender extends React.Component {}
 
     const root = ReactDOMClient.createRoot(document.createElement('div'));
-    await expect(async () => {
-      await act(() => {
-        root.render(<RenderTestUndefinedRender />);
-      });
-    }).rejects.toThrow();
-    assertConsoleErrorDev([
-      'No `render` method found on the RenderTestUndefinedRender instance: ' +
-        'you may have forgotten to define `render`.\n' +
-        '    in RenderTestUndefinedRender (at **)',
-      'No `render` method found on the RenderTestUndefinedRender instance: ' +
-        'you may have forgotten to define `render`.\n' +
-        '    in RenderTestUndefinedRender (at **)',
+    expect(() => {
+      expect(() => {
+        ReactDOM.flushSync(() => {
+          root.render(<RenderTestUndefinedRender />);
+        });
+      }).toThrow();
+    }).toErrorDev([
+      // Expect two errors because invokeGuardedCallback will dispatch an error event,
+      // Causing the warning to be logged again.
+      'Warning: RenderTestUndefinedRender(...): No `render` method found on the returned ' +
+        'component instance: you may have forgotten to define `render`.',
+      'Warning: RenderTestUndefinedRender(...): No `render` method found on the returned ' +
+        'component instance: you may have forgotten to define `render`.',
+
+      // And then two more because we retry errors.
+      'Warning: RenderTestUndefinedRender(...): No `render` method found on the returned ' +
+        'component instance: you may have forgotten to define `render`.',
+      'Warning: RenderTestUndefinedRender(...): No `render` method found on the returned ' +
+        'component instance: you may have forgotten to define `render`.',
     ]);
   });
 
@@ -1389,15 +1424,13 @@ describe('ReactCompositeComponent', () => {
     }
     const container = document.createElement('div');
     const root = ReactDOMClient.createRoot(container);
-    ReactDOM.flushSync(() => {
-      root.render(<Parent />);
-    });
-    assertConsoleErrorDev([
-      'Cannot update a component (`A`) while rendering a different component (`B`). ' +
-        'To locate the bad setState() call inside `B`, ' +
-        'follow the stack trace as described in https://react.dev/link/setstate-in-render\n' +
-        '    in Parent (at **)',
-    ]);
+    expect(() => {
+      ReactDOM.flushSync(() => {
+        root.render(<Parent />);
+      });
+    }).toErrorDev(
+      'Cannot update a component (`A`) while rendering a different component (`B`)',
+    );
 
     // We error, but still update the state.
     expect(ref.textContent).toBe('1');
