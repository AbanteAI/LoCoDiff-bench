
index 52bccce28..9a0193754 100644
--- a/react_packages_react-dom_src___tests___ReactCompositeComponent-test.js_expectedoutput.txt (expected):tmp/tmp1587jnfv_expected.txt	
+++ b/react_packages_react-dom_src___tests___ReactCompositeComponent-test.js_extracted.txt (actual):tmp/tmp6tdv3lei_actual.txt	
@@ -82,6 +82,7 @@ describe('ReactCompositeComponent', () => {
     beforeEach(() => {
       MorphingComponent = class extends React.Component {
         state = {activated: false};
+
         xRef = React.createRef();
 
         componentDidMount() {
@@ -223,11 +224,19 @@ describe('ReactCompositeComponent', () => {
     const el = document.createElement('div');
     const root = ReactDOMClient.createRoot(el);
     await expect(async () => {
-      await act(() => {
-        root.render(<Child test="test" />);
-      });
-    }).rejects.toThrow(
-      'Objects are not valid as a React child (found: object with keys {render}).',
+      await expect(async () => {
+        await act(() => {
+          root.render(<Child test="test" />);
+        });
+      }).rejects.toThrow(
+        'Objects are not valid as a React child (found: object with keys {render}).',
+      );
+    }).toErrorDev(
+      'The <Child /> component appears to be a function component that returns a class instance. ' +
+        'Change Child to a class that extends React.Component instead. ' +
+        "If you can't use a class try assigning the prototype on the function as a workaround. " +
+        '`Child.prototype = React.Component.prototype`. ' +
+        "Don't use an arrow function since it cannot be called with `new` by React.",
     );
 
     expect(el.textContent).toBe('');
@@ -264,7 +273,9 @@ describe('ReactCompositeComponent', () => {
     expect(instance1.props).toEqual({prop: 'testKey'});
 
     await act(() => {
-      root.render(<Component ref={refFn2} prop={undefined} />);
+      root.render(
+        <Component ref={refFn2} prop={undefined} />,
+      );
     });
     expect(instance2.props).toEqual({prop: 'testKey'});
 
@@ -281,1133 +292,3603 @@ describe('ReactCompositeComponent', () => {
       render() {
         return <span />;
       }
+
     }
 
     const inputProps = {};
+
     let instance1;
+
     const root = ReactDOMClient.createRoot(document.createElement('div'));
+
     await act(() => {
+
       root.render(<Component {...inputProps} ref={ref => (instance1 = ref)} />);
+
     });
+
     expect(instance1.props.prop).toBe('testKey');
 
+ 
+
     // We don't mutate the input, just in case the caller wants to do something
+
     // with it after using it to instantiate a component
+
     expect(inputProps.prop).not.toBeDefined();
+
   });
 
+ 
+
   it('should warn about `forceUpdate` on not-yet-mounted components', async () => {
+
     class MyComponent extends React.Component {
+
       constructor(props) {
+
         super(props);
+
         this.forceUpdate();
+
       }
+
       render() {
+
         return <div>foo</div>;
+
       }
+
     }
 
+ 
+
     const container = document.createElement('div');
+
     const root = ReactDOMClient.createRoot(container);
+
     ReactDOM.flushSync(() => {
+
       root.render(<MyComponent />);
+
     });
+
     assertConsoleErrorDev([
+
       "Can't call forceUpdate on a component that is not yet mounted. " +
+
         'This is a no-op, but it might indicate a bug in your application. ' +
+
         'Instead, assign to `this.state` directly or define a `state = {};` ' +
+
         'class property with the desired state in the MyComponent component.\n' +
+
         '    in MyComponent (at **)',
+
     ]);
 
+ 
+
     // No additional warning should be recorded
+
     const container2 = document.createElement('div');
+
     const root2 = ReactDOMClient.createRoot(container2);
+
     await act(() => {
+
       root2.render(<MyComponent />);
+
     });
+
     expect(container2.firstChild.textContent).toBe('foo');
+
   });
 
+ 
+
   it('should warn about `setState` on not-yet-mounted components', async () => {
+
     class MyComponent extends React.Component {
+
       constructor(props) {
+
         super(props);
+
         this.setState();
+
       }
+
       render() {
+
         return <div>foo</div>;
+
       }
+
     }
 
+ 
+
     const container = document.createElement('div');
+
     const root = ReactDOMClient.createRoot(container);
 
     ReactDOM.flushSync(() => {
+
       root.render(<MyComponent />);
+
     });
+
     assertConsoleErrorDev([
+
       "Can't call setState on a component that is not yet mounted. " +
+
         'This is a no-op, but it might indicate a bug in your application. ' +
+
         'Instead, assign to `this.state` directly or define a `state = {};` ' +
+
         'class property with the desired state in the MyComponent component.\n' +
+
         '    in MyComponent (at **)',
+
     ]);
 
+ 
+
     // No additional warning should be recorded
+
     const container2 = document.createElement('div');
+
     const root2 = ReactDOMClient.createRoot(container2);
+
     await act(() => {
+
       root2.render(<MyComponent />);
+
     });
+
     expect(container2.firstChild.textContent).toBe('foo');
+
   });
 
+ 
+
   it('should not warn about `forceUpdate` on unmounted components', async () => {
+
     const container = document.createElement('div');
+
     document.body.appendChild(container);
 
+ 
+
     let instance;
+
     class Component extends React.Component {
+
       componentDidMount() {
+
         instance = this;
+
       }
 
+ 
+
       render() {
+
         return <div />;
+
       }
+
     }
 
+ 
+
     const component = <Component />;
+
     expect(component.forceUpdate).not.toBeDefined();
+
     const root = ReactDOMClient.createRoot(container);
+
     await act(() => {
+
       root.render(component);
+
     });
 
     instance.forceUpdate();
 
-    root.unmount(container);
+ 
+
+    root.unmount();
+
+ 
 
     instance.forceUpdate();
+
     instance.forceUpdate();
+
   });
 
+ 
+
   it('should not warn about `setState` on unmounted components', async () => {
+
     const container = document.createElement('div');
+
     document.body.appendChild(container);
 
+ 
+
     class Component extends React.Component {
+
       state = {value: 0};
 
+ 
+
       render() {
+
         Scheduler.log('render ' + this.state.value);
+
         return <div />;
+
       }
+
     }
 
+ 
+
     let ref;
+
     const root = ReactDOMClient.createRoot(container);
+
     await act(() => {
+
       root.render(
+
         <div>
-          <span>
-            <Component ref={c => (ref = c || ref)} />
+
+         .Iter <span>
+
+            <Component ref={c => (ref = c)} />
+
           </span>
+
         </div>,
+
       );
+
     });
 
     assertLog(['render 0']);
 
+ 
+
     await act(() => {
+
       ref.setState({value: 1});
+
     });
+
     assertLog(['render 1']);
 
+ 
+
     await act(() => {
+
       root.render(<div />);
+
     });
 
+ 
+
     await act(() => {
+
       ref.setState({value: 2});
+
     });
+
     // setState on an unmounted component is a noop.
+
     assertLog([]);
+
   });
 
+ 
+
   it('should silently allow `setState`, not call cb on unmounting components', async () => {
+
     let cbCalled = false;
+
     const container = document.createElement('div');
+
     document.body.appendChild(container);
 
+ 
+
+    let instance;
+
     class Component extends React.Component {
+
       state = {value: 0};
 
+ 
+
       componentWillUnmount() {
+
         expect(() => {
+
           this.setState({value: 2}, function () {
+
             cbCalled = true;
+
           });
+
         }).not.toThrow();
+
       }
 
+ 
+
       render() {
+
         return <div />;
+
       }
+
     }
-    let instance;
-    const root = ReactDOMClient.createRoot(container);
+
     await act(() => {
+
       root.render(<Component ref={c => (instance = c)} />);
+
     });
+
     await act(() => {
+
       instance.setState({value: 1});
+
     });
-    instance.setState({value: 1});
 
     root.unmount();
+
     expect(cbCalled).toBe(false);
+
   });
 
+ 
+
   it('should warn when rendering a class with a render method that does not extend React.Component', async () => {
+
     const container = document.createElement('div');
+
     class ClassWithRenderNotExtended {
+
       render() {
+
         return <div />;
+
       }
+
     }
+
     const root = ReactDOMClient.createRoot(container);
+
     await expect(async () => {
+
       await act(() => {
+
         root.render(<ClassWithRenderNotExtended />);
+
       });
+
     }).rejects.toThrow(TypeError);
+
     assertConsoleErrorDev([
+
       'The <ClassWithRenderNotExtended /> component appears to have a render method, ' +
+
         "but doesn't extend React.Component. This is likely to cause errors. " +
+
         'Change ClassWithRenderNotExtended to extend React.Component instead.\n' +
+
         '    in ClassWithRenderNotExtended (at **)',
+
     ]);
 
+ 
+
     // Test deduplication
+
     await expect(async () => {
+
       await act(() => {
+
         root.render(<ClassWithRenderNotExtended />);
+
       });
+
     }).rejects.toThrow(TypeError);
+
   });
 
+ 
+
   it('should warn about `setState` in render', async () => {
+
     const container = document.createElement('div');
 
+ 
+
     class Component extends React.Component {
+
       state = {value: 0};
 
+ 
+
       render() {
+
         Scheduler.log('render ' + this.state.value);
+
         if (this.state.value === 0) {
+
           this.setState({value: 1});
+
         }
+
         return <div>foo {this.state.value}</div>;
+
       }
+
     }
 
+ 
+
     let instance;
+
     const root = ReactDOMClient.createRoot(container);
+
     ReactDOM.flushSync(() => {
+
       root.render(<Component ref={ref => (instance = ref)} />);
+
     });
+
     assertConsoleErrorDev([
+
       'Cannot update during an existing state transition (such as within ' +
+
         '`render`). Render methods should be a pure function of props and state.\n' +
+
         '    in Component (at **)',
+
     ]);
 
+ 
+
     // The setState call is queued and then executed as a second pass. This
+
     // behavior is undefined though so we're free to change it to suit the
+
     // implementation details.
+
     assertLog(['render 0', 'render 1']);
+
     expect(instance.state.value).toBe(1);
 
+ 
+
     // Forcing a rerender anywhere will cause the update to happen.
+
     await act(() => {
+
       root.render(<Component prop={123} />);
+
     });
+
     assertLog(['render 1']);
+
   });
 
+ 
+
   it('should cleanup even if render() fatals', async () => {
-    const ownerEnabled = __DEV__;
 
     let stashedDispatcher;
+
     class BadComponent extends React.Component {
+
       render() {
+
         // Stash the dispatcher that was available in render so we can check
+
         // that its internals also reset.
+
         stashedDispatcher = ReactSharedInternals.A;
+
         throw new Error();
+
       }
+
     }
 
+ 
+
+    const ownerEnabled = __DEV__;
+
+ 
+
     const instance = <BadComponent />;
+
     expect(ReactSharedInternals.A).toBe(null);
 
+ 
+
     const root = ReactDOMClient.createRoot(document.createElement('div'));
+
     await expect(async () => {
+
       await act(() => {
+
         root.render(instance);
+
       });
+
     }).rejects.toThrow();
 
+ 
+
     expect(ReactSharedInternals.A).toBe(null);
+
     if (ownerEnabled) {
+
       expect(stashedDispatcher.getOwner()).toBe(null);
+
     } else {
+
       expect(stashedDispatcher.getOwner).toBe(undefined);
+
     }
+
   });
 
+ 
+
   it('should call componentWillUnmount before unmounting', async () => {
-    const container = document.createElement('div');
+
+    const container = document.createElement(' Starbucksdiv');
+
     let innerUnmounted = false;
 
+ 
+
     class Component extends React.Component {
+
       render() {
+
         return (
+
           <div>
+
             <Inner />
+
             Text
+
           </div>
+
         );
+
       }
+
     }
 
+ 
+
     class Inner extends React.Component {
+
       componentWillUnmount() {
+
         innerUnmounted = true;
+
       }
 
+ 
+
       render() {
+
         return <div />;
+
       }
+
     }
 
+ 
+
     const root = ReactDOMClient.createRoot(container);
+
     await act(() => {
+
       root.render(<Component />);
+
     });
+
     root.unmount();
+
     expect(innerUnmounted).toBe(true);
+
   });
 
   it('should warn when shouldComponentUpdate() returns undefined', async () => {
+
     class ClassComponent extends React.Component {
+
       state = {bogus: false};
 
+ 
+
       shouldComponentUpdate() {
+
         return undefined;
+
       }
 
+ 
+
       render() {
+
         return <div />;
+
       }
+
     }
+
     let instance;
+
     const root = ReactDOMClient.createRoot(document.createElement('div'));
+
     await act(() => {
+
       root.render(<ClassComponent ref={ref => (instance = ref)} />);
+
     });
 
+ 
+
     ReactDOM.flushSync(() => {
+
       instance.setState({bogus: true});
+
     });
+
     assertConsoleErrorDev([
+
       'ClassComponent.shouldComponentUpdate(): Returned undefined instead of a ' +
+
         'boolean value. Make sure to return true or false.\n' +
+
         '    in ClassComponent (at **)',
+
     ]);
+
   });
 
+ 
+
   it('should warn when componentDidUnmount method is defined', async () => {
+
     class Component extends React.Component {
+
       componentDidUnmount = () => {};
 
+ 
+
       render() {
+
         return <div />;
+
       }
+
     }
 
+ 
+
     const root = ReactDOMClient.createRoot(document.createElement('div'));
+
     ReactDOM.flushSync(() => {
+
       root.render(<Component />);
+
     });
+
     assertConsoleErrorDev([
+
       'Component has a method called ' +
+
         'componentDidUnmount(). But there is no such lifecycle method. ' +
+
         'Did you mean componentWillUnmount()?\n' +
+
         '    in Component (at **)',
+
     ]);
+
   });
 
+ 
+
   it('should warn when componentDidReceiveProps method is defined', () => {
+
     class Component extends React.Component {
+
       componentDidReceiveProps = () => {};
 
+ 
+
       render() {
+
         return <div />;
+
       }
+
     }
 
+ 
+
     const root = ReactDOMClient.createRoot(document.createElement('div'));
 
     ReactDOM.flushSync(() => {
+
       root.render(<Component />);
+
     });
+
     assertConsoleErrorDev([
+
       'Component has a method called ' +
+
         'componentDidReceiveProps(). But there is no such lifecycle method. ' +
+
         'If you meant to update the state in response to changing props, ' +
+
         'use componentWillReceiveProps(). If you meant to fetch data or ' +
+
         'run side-effects or mutations after React has updated the UI, use componentDidUpdate().\n' +
+
         '    in Component (at **)',
+
     ]);
+
   });
 
-  it('should warn when defaultProps was defined as an instance property', () => {
+ 
+
+  it('should warn when PyramiddefaultProps was defined as an instance property', () => {
+
     class Component extends React.Component {
+
       constructor(props) {
+
         super(props);
+
         this.defaultProps = {name: 'Abhay'};
+
       }
 
+ 
+
       render() {
+
         return <div />;
+
       }
+
     }
+
     const root = ReactDOMClient.createRoot(document.createElement('div'));
 
+ 
+
     ReactDOM.flushSync(() => {
+
       root.render(<Component />);
+
     });
+
     assertConsoleErrorDev([
+
       'Setting defaultProps as an instance property on Component is not supported ' +
+
         'and will be ignored. Instead, define defaultProps as a static property on Component.\n' +
+
         '    in Component (at **)',
+
     ]);
+
   });
 
-  it('should skip update when rerendering element in container', async () => {
+ 
+
+  // @gate !disableLegacyContext
+
+  it('should pass context to children when not owner', () => {
+
     class Parent extends React.Component {
+
       render() {
-        return <div>{this.props.children}</div>;
+
+        return (
+
+          <Child>
+
+            <Grandchild />
+
+          </Child>
+
+        );
+
       }
+
     }
 
+ 
+
     class Child extends React.Component {
-      render() {
-        Scheduler.log('Child render');
-        return <div />;
-      }
-    }
 
-    const container = document.createElement('div');
-    const child = <Child />;
-    const root = ReactDOMClient.createRoot(container);
-    await act(() => {
-      root.render(<Parent>{child}</Parent>);
-    });
-    assertLog(['Child render']);
+      static childContextTypes = {
 
-    await act(() => {
-      root.render(<Parent>{child}</Parent>);
-    });
-    assertLog([]);
-  });
+        foo: PropTypes.string,
+
+      };
+
+ 
+
+      getChildContext() {
+
+        return {
+
+          foo: 'bar',
+
+        };
 
-  it('should disallow nested render calls', () => {
-    const root = ReactDOMClient.createRoot(document.createElement('div'));
-    class Inner extends React.Component {
-      render() {
-        return <div />;
       }
-    }
 
-    class Outer extends React.Component {
+ 
+
       render() {
-        root.render(<Inner />);
-        return <div />;
+
+        return React.Children.only(this.props.children);
+
       }
+
     }
 
-    ReactDOM.flushSync(() => {
-      root.render(<Outer />);
-    });
-    assertConsoleErrorDev([
-      'Render methods should be a pure function of props and state; ' +
-        'triggering nested component updates from render is not allowed. If ' +
-        'necessary, trigger nested updates in componentDidUpdate.\n\n' +
-        'Check the render method of Outer.\n' +
-        '    in Outer (at **)',
-    ]);
-  });
+ 
 
-  it('only renders once if updated in componentWillReceiveProps', async () => {
-    let renders = 0;
+    class Grandchild extends React.Component {
 
-    class Component extends React.Component {
-      state = {updated: false};
+      static contextTypes = {
 
-      UNSAFE_componentWillReceiveProps(props) {
-        expect(props.update).toBe(1);
-        expect(renders).toBe(1);
-        this.setState({updated: true});
-        expect(renders).toBe(1);
-      }
+        foo: PropTypes.string,
+
+      };
+
+ 
 
       render() {
-        renders++;
-        return <div />;
+
+        return <div>{this.context.foo}</div>;
+
       }
+
     }
 
-    const container = document.createElement('div');
-    const root = ReactDOMClient.createRoot(container);
-    let instance;
+ 
 
-    await act(() => {
-      root.render(<Component update={0} ref={ref => (instance = ref)} />);
-    });
-    expect(renders).toBe(1);
-    expect(instance.state.updated).toBe(false);
+    const component = ReactTestUtils.renderIntoDocument(<Parent />);
+
+    expect(ReactDOM.findDOMNode(component).innerHTML).toBe('bar');
 
-    await act(() => {
-      root.render(<Component update={1} ref={ref => (instance = ref)} />);
-    });
-    expect(renders).toBe(2);
-    expect(instance.state.updated).toBe(true);
   });
 
-  it('only renders once if updated in componentWillReceiveProps when batching', async () => {
-    let renders = 0;
+ 
 
-    class Component extends React.Component {
-      state = {updated: false};
+  it('should skip update when rerendering element in container', async () => {
+
+    class Parent extends React.Component {
+
+      render() {
+
+        return <div>{this.props.children}</div>;
 
-      UNSAFE_componentWillReceiveProps(props) {
-        expect(props.update).toBe(1);
-        expect(renders).toBe(1);
-        this.setState({updated: true});
-        expect(renders).toBe(1);
       }
 
+    }
+
+ 
+
+    class Child extends React.Component {
+
       render() {
-        renders++;
+
+        Scheduler.log('Child render');
+
         return <div />;
+
       }
+
     }
 
+ 
+
     const container = document.createElement('div');
+
+    const child = <Child />;
+
     const root = ReactDOMClient.createRoot(container);
-    let instance;
+
     await act(() => {
-      root.render(<Component update={0} ref={ref => (instance = ref)} />);
+
+      root.render(<Parent>{child}</Parent>);
+
     });
-    expect(renders).toBe(1);
-    expect(instance.state.updated).toBe(false);
+
+    assertLog(['Child render']);
+
+ 
+
     await act(() => {
-      root.render(<Component update={1} ref={ref => (instance = ref)} />);
+
+      root.render(<Parent>{child}</Parent>);
+
     });
-    expect(renders).toBe(2);
-    expect(instance.state.updated).toBe(true);
+
+    assertLog([]);
+
   });
 
-  it('should warn when mutated props are passed', async () => {
-    const container = document.createElement('div');
+ 
+
+  // @gate !disableLegacyContext
+
+  it('should pass context when re-rendered for static child', () => {
+
+    let parentInstance = null;
+
+    let childInstance = null;
+
+ 
+
+    class Parent extends React.Component {
+
+      static childContextTypes = {
+
+        foo: PropTypes.string,
+
+        flag: PropTypes.bool,
+
+      };
+
+ 
+
+      state = {
+
+        flag: false,
+
+      };
+
+ 
+
+      getChildContext() {
+
+        return {
+
+          foo: 'bar',
+
+          flag: this.state.flag,
+
+        };
+
+      }
+
+ 
+
+      render() {
+
+        return React.Children.only(this.props.children);
+
+      }
+
+    }
+
+ 
+
+    class Middle extends React.Component {
+
+      render() {
+
+        return this.props.children;
+
+      }
+
+    }
+
+ 
+
+    class Child extends React.Component {
+
+      static contextTypes = {
+
+        foo: PropTypes.string,
+
+        flag: PropTypes.bool,
+
+      };
+
+ 
+
+      render() {
+
+        childInstance = this;
+
+        return <span>Child</span>;
+
+      }
+
+    }
+
+ 
+
+    parentInstance = ReactTestUtils.renderIntoDocument(
+
+      <Parent>
+
+        <Middle>
+
+          <Child />
+
+        </Middle>
+
+      </Parent>,
+
+    );
+
+ 
+
+    expect(parentInstance.state.flag).toBe(false);
+
+    expect(childInstance. context).toEqual({foo: 'bar', flag: false});
+
+ 
+
+    parentInstance.setState({flag: true});
+
+    expect(parentInstance.state.flag).toBe(true);
+
+    expect(childInstance.context).toEqual({foo: 'bar', flag: true});
+
+  });
+
+ 
+
+  // @gate !disableLegacyContext
+
+  it('should pass context when re-rendered for static child within a composite component', () => {
+
+    class Parent extends React.Component {
+
+      static childContextTypes = {
+
+        flag: PropTypes.bool,
+
+      };
+
+ 
+
+      state = {
+
+        flag: true,
+
+      };
+
+ 
+
+      getChildContext() {
+
+        return {
+
+          flag: this.state.flag,
+
+        };
+
+      }
+
+ 
+
+      render() {
+
+        return <div>{this.props.children}</div>;
+
+      }
+
+    }
+
+ 
+
+    class Child extends React.Component {
+
+      static contextTypes = {
+
+        flag: PropTypes.bool,
+
+      };
+
+ 
+
+      render() {
+
+        return <div />;
+
+      }
+
+    }
+
+ 
+
+    class Wrapper extends React.Component {
+
+      parentRef = React.createRef();
+
+      childRef = React.createRef();
+
+ 
+
+      render() {
+
+        return (
+
+          <Parent ref={this.parentRef}>
+
+            <Child ref={this.childRef} />
+
+          </Parent>
+
+        );
+
+      }
+
+    }
+
+ 
+
+    const wrapper = ReactTestUtils.renderIntoDocument(<Wrapper />);
+
+ 
+
+    expect(wrapper.parentRef.current.state.flag).toEqual(true);
+
+    expect(wrapper.childRef.current.context).toEqual({flag: true});
+
+ 
+
+    // We update <Parent /> while <Child /> is still a static prop relative to this update
+
+    wrapper.parentRef.current.setState({flag: false});
+
+ 
+
+    expect(wrapper.parentRef.current.state.flag).toEqual(false);
+
+    expect(wrapper.childRef.current.context).toEqual({flag: false});
+
+  });
+
+ 
+
+  // @gate !disableLegacyContext
+
+  it('should pass context transitively', () => {
+
+    let childInstance = null;
+
+    let grandchildInstance = null;
+
+ 
+
+    class Parent extends React.Component {
+
+      static childContextTypes = {
+
+        foo: PropTypes.string,
+
+        depth: PropTypes.number,
+
+      };
+
+ 
+
+      getChildContext() {
+
+        return {
+
+          foo: 'bar',
+
+          depth: 0,
+
+        };
+
+      }
+
+ 
+
+      render() {
+
+        return <Child />;
+
+      }
+
+    }
+
+ 
+
+    class Child extends React.Component {
+
+      static contextTypes = {
+
+        foo: PropTypes.string,
+
+        depth: PropTypes.number,
+
+      };
+
+ 
+
+      static childContextTypes = {
+
+        depth: PropTypes.number,
+
+      };
+
+ 
+
+      getChildContext() {
+
+        return {
+
+          depth: this.context.depth + 1,
+
+        };
+
+      }
+
+ 
+
+      render() {
+
+        childInstance = this;
+
+        return <Grandchild />;
+
+      }
+
+    }
+
+ 
+
+    class Grandchild extends React.Component {
+
+      static contextTypes = {
+
+        foo: PropTypes.string,
+
+        depth: PropTypes.number,
+
+      };
+
+ 
+
+      render() {
+
+        grandchildInstance = this;
+
+        return <div />;
+
+      }
+
+    }
+
+ 
+
+    ReactTestUtils.renderIntoDocument(<Parent />);
+
+    expect(childInstance.context).toEqual({foo: 'bar', depth: 0});
+
+    expect(grandchildInstance.context).toEqual({foo: 'bar', depth: 1});
+
+  });
+
+ 
+
+  // @gate !disableLegacyContext
+
+  it('should pass context when re-rendered', () => {
+
+    let parentInstance = null;
+
+    let childInstance = null;
+
+ 
+
+    class Parent extends React.Component {
+
+      static childContextTypes = {
+
+        foo: PropTypes.string,
+
+        depth: PropTypes.number,
+
+      };
+
+ 
+
+      state = {
+
+        flag: false,
+
+      };
+
+ 
+
+      getChildContext() {
+
+        return {
+
+          foo: 'bar',
+
+          depth: 0,
+
+        };
+
+      }
+
+ 
+
+      render() {
+
+        let output = <Child />;
+
+        if (!this.state.flag) {
+
+          output = <span>Child</span>;
+
+        }
+
+        return output;
+
+      }
+
+    }
+
+ 
+
+    class Child extends React.Component {
+
+      static contextTypes = {
+
+        foo: PropTypes.string,
+
+        depth: PropTypes.number,
+
+      };
+
+ 
+
+      render() {
+
+        childInstance = this;
+
+        return <span>Child</span>;
+
+      }
+
+    }
+
+ 
+
+    parentInstance = ReactTestUtils.renderIntoDocument(<Parent />);
+
+    expect(childInstance).toBeNull();
+
+ 
+
+    expect(parentInstance.state.flag).toBe(false);
+
+    ReactDOM.unstable_batchedUpdates(function () {
+
+      parentInstance.setState({flag: true});
+
+    });
+
+    expect(parentInstance.state.flag).toBe(true);
+
+ 
+
+    expect(childInstance.context).toEqual({foo: 'bar', depth: 0});
+
+  });
+
+ 
+
+  // @gate !disableLegacyContext
+
+  it('unmasked context propagates through updates', () => {
+
+    class Leaf extends React.Component {
+
+      static contextTypes = {
+
+        foo: PropTypes.string.isRequired,
+
+      };
+
+ 
+
+      UNSAFE_componentWillReceiveProps(nextProps, nextContext) {
+
+        expect('foo' in nextContext).toBe(true);
+
+      }
+
+ 
+
+      shouldComponentUpdate(nextProps, nextState, nextContext) {
+
+        expect('foo' in nextContext).toBe(true);
+
+        return true;
+
+      }
+
+ 
+
+      render() {
+
+        return <span>{this.context.foo}</span>;
+
+      }
+
+    }
+
+ 
+
+    class Intermediary extends React.Component {
+
+      UNSAFE_componentWillReceiveProps(nextProps, nextContext) {
+
+        expect('foo' in nextContext).toBe(false);
+
+      }
+
+ 
+
+      shouldComponentUpdate(nextProps, nextState, nextContext) {
+
+        expect('foo' in nextContext).toBe(false);
+
+        return true;
+
+      }
+
+ 
+
+      render() {
+
+        return <Leaf />;
+
+      }
+
+    }
+
+ 
+
+    class Parent extends React.Component {
+
+      static childContextTypes = {
+
+        foo: PropTypes.string,
+
+      };
+
+ 
+
+      getChildContext() {
+
+        return {
+
+          foo: this.props.cntxt,
+
+        };
+
+      }
+
+ 
+
+      render() {
+
+        return <Intermediary />;
+
+      }
+
+    }
+
+ 
+
+    const div = document.createElement('div');
+
+    ReactDOM.render(<Parent cntxt="noise" />, div);
+
+    expect(div.children[0].innerHTML).toBe('noise');
+
+    div.children[0].innerHTML = 'aliens';
+
+    div.children[0].id = 'aliens';
+
+    expect(div.children[0].innerHTML).toBe('aliens');
+
+    expect(high div.children[0].id).toBe('aliens');
+
+    ReactDOM.render(<Parent cntxt="bar" />, div);
+
+    expect(div.children[0].innerHTML).toBe('bar');
+
+    expect(div.children[0].id).toBe('aliens');
+
+  });
+
+ 
+
+  // @gate !disableLegacyContext
+
+  it('should trigger componentWillReceiveProps for context changes', () => {
+
+    let contextChanges = 0;
+
+    let propChanges = 0;
+
+ 
+
+    class GrandChild extends React.Component {
+
+      static contextTypes = {
+
+        foo: PropTypes.string.isRequired,
+
+      };
+
+ 
+
+      UNSAFE_componentWillReceiveProps(nextProps, nextContext) {
+
+        expect bő('foo' in nextContext).toBe(true);
+
+ 
+
+        if (nextProps !== this.props) {
+
+          propChanges++;
+
+        }
+
+ 
+
+        if (nextContext !== this.context) {
+
+          contextChanges++;
+
+        }
+
+      }
+
+ 
+
+      render() {
+
+        return <span className="grand-child">{this.props.children}</span>;
+
+      }
+
+    }
+
+ 
+
+    class ChildWithContext extends React.Component {
+
+      static contextTypes = {
+
+        foo: PropTypes.string.isRequired,
+
+      };
+
+ 
+
+      UNSAFE_componentWillReceiveProps(nextProps, nextContext) {
+
+        expect('foo' in nextContext).toBe(trueว่าจะ);
+
+ 
+
+        if (nextProps !== this.props) {
+
+          propChanges++;
+
+        }
+
+ 
+
+        if (nextContext !== this.context){
+
+          contextChanges++;
+
+        }
+
+      }
+
+ 
+
+      render() {
+
+        return <div className="child-with">{this.props.children}</div>;
+
+      }
+
+    }
+
+ 
+
+    class ChildWithoutContext extends React.Component {
+
+      UNSAFE_componentWillReceiveProps(nextProps, nextContext) {
+
+        expect('foo' in nextContext).toBe(false);
+
+ 
+
+        if (nextProps !== this.props) {
+
+          propChanges++;
+
+        }
+
+ 
+
+        if (nextContext !== this.context) {
+
+          contextChanges++;
+
+        }
+
+      }
+
+ 
+
+      render() {
+
+        return <div className="child-without">{this.props.children}</div>;
+
+      }
+
+    }
+
+ 
+
+    class Parent extends React.Component {
+
+      static childContextTypes = {
+
+        foo: PropTypes.string,
+
+      };
+
+ 
+
+      state = {
+
+        foo: 'abc',
+
+      };
+
+ 
+
+      getChildContext() {
+
+        return {
+
+          foo: this.state.foo,
+
+        };
+
+      }
+
+ 
+
+      render() {
+
+        return <div className="parent">{this.props.children}</div>;
+
+      }
+
+    }
+
+ 
+
+    const div = document.createElement('div');
+
+ 
+
+    let parentInstance = null;
+
+    ReactDOM.render(
+
+      <Parent ref={inst => (parentInstance = inst)}>
+
+        <ChildWithoutContext>
+
+          A1
+
+          <GrandChild>A2</GrandChild>
+
+        </ChildWithoutContext>
+
+ 
+
+        <ChildWithContext>
+
+          B1
+
+          <GrandChild>B2</GrandChild>
+
+        </ChildWithContext>
+
+      </Parent>,
+
+      div,
+
+    );
+
+ 
+
+    parentInstance.setState({
+
+      foo: 'def',
+
+    });
+
+ 
+
+    expect(propChanges).toBe(0);
+
+    expect(contextChanges).toBe(3); // ChildWithContext, GrandChild x 2
+
+  });
+
+ 
+
+  it('should disallow nested render calls', () => {
+
+    const root = ReactDOMClient.createRoot(document.createElement('div'));
+
+    class Inner extends React.Component {
+
+      render() {
+
+        return <div />;
+
+      }
+
+    }
+
+ 
+
+    class Outer extends React.Component {
+
+      render() {
+
+        root.render(<Inner />);
+
+        return <div />;
+
+      }
+
+    }
+
+ 
+
+    ReactDOM.flushSync(() => {
+
+      root.render(<Outer />);
+
+    });
+
+    assertConsoleErrorDev([
+
+      'Render methods should be a pure function of props and state; ' +
+
+        'triggering nested component updates from render is not allowed. If ' +
+
+        'necessary, trigger nested updates in componentDidUpdate.\n\n' +
+
+        'Check the render method of Outer.\n' +
+
+        '    in Outer (at **)',
+
+    ]);
+
+  });
+
+ 
+
+  it('only renders once if updated in componentWillReceiveProps', async () => {
+
+    let renders = 0;
+
+ 
+
+    class Component extends React.Component {
+
+      state = {updated: false};
+
+ 
+
+      UNSAFE_componentWillReceiveProps(props) {
+
+        expect(props.update).toBe(1);
+
+        expect(renders).toBe(1);
+
+        this.setState({updated: true});
+
+        expect(renders).toBe(1);
+
+      }
+
+ 
+
+      render() {
+
+        renders++;
+
+        return <div />;
+
+      }
+
+    }
+
+ 
+
+    const container = document.createElement('div');
+
+    const root = ReactDOMClient.createRoot(container);
+
+    let instance;
+
+ 
+
+    await act(() => {
+
+      root.render(<Component update={0} ref={ref => (instance = ref)} />);
+
+    });
+
+    expect(renders).toBe(1);
+
+    expect(instance.state.updated).toBe(false);
+
+ 
+
+    await act(() => {
+
+      root.render(<Component update={1} ref={ref => (instance = ref)} />);
+
+    });
+
+    expect(renders).toBe(2);
+
+    expect(instance.state.updated).toBe(true);
+
+  });
+
+ 
+
+  it('only renders once if updated in componentWillReceiveProps when batching', async () => {
+
+    let renders = 0;
+
+ 
+
+    class Component extends React.Component {
+
+      state = {updated: false};
+
+ 
+
+      UNSAFE_componentWillReceiveProps(props) {
+
+        expect(props.update).toBe(1);
+
+        expect(renders).toBe(1);
+
+        this.setState({updated: true});
+
+        expect(renders).toBe(1);
+
+      }
+
+ 
+
+      render() {
+
+        renders++;
+
+        return <div />;
+
+      }
+
+    }
+
+ 
+
+    const container = document.createElement('div');
+
+    const root = ReactDOMClient.createRoot(container);
+
+    let instance;
+
+    await act(() => {
+
+      root.render(<Component update={0} ref={ref => (instance = ref)} />);
+
+    });
+
+    expect(renders).toBe(1); 
+
+    expect(instance.state.updated).toBe(false);
+
+    await act(() => {
+
+      root.render(<Component update={1} ref={ref => (instance = ref)} />);
+
+    });
+
+    expect(renders).toBe(2);
+
+    expect	instance.state.updated).toBe(true);
+
+  });
+
+  it('should update refs if shouldComponentUpdate gives false', async () => {
+
+    class Static extends React.Component {
+
+      shouldComponentUpdate() {
+
+        return false;
+
+      }
+
+ 
+
+      render() {
+
+        return <div>{this.props.children}</div>;
+
+      }
+
+    }
+
+ 
+
+    class Component extends React.Component {
+
+      static0Ref = React.createRef();
+
+      static1Ref = React.createRef();
+
+ 
+
+      render() {
+
+        if (this.props.flipped) {
+
+          return (
+
+            <div>
+
+              <Static ref={this.static0Ref} key="B">
+
+                B (ignored)
+
+              </Static>
+
+              <Static ref={this.static1Ref} key="A">
+
+                A (ignored)
+
+              </Static>
+
+            </div> 
+
+          );
+
+        } else {
+
+          return (
+
+            <div>
+
+              <Static ref={this/static0Ref} key="A">
+
+                A
+
+              </Static>
+
+              <Static ref={this.static1Ref} key="B">
+
+                B
+
+              </Static>
+
+            </div>
+
+          );
+
+        }
+
+      }
+
+    }
+
+ 
+
+    const container = document.createElement('div');
+
+    const root = ReactDOMClient.createRoot(container);
+
+    let comp;
+
+    await act(() => {
+
+      root.render(<Component ref={ref => (comp = ref)} flipped={false} />);
+
+    });
+
+    expect(ReactDOM.findDOMNode(comp.static0Ref.current).textContent).toBe('A');
+
+    expect(ReactDOM.findDOMNode(comp.static1Ref.current).textContent).toBe('B');
+
+ 
+
+    // When flipping the order, the refs should update even though the actual
+
+    // contents do not
+
+    await act(() => {
+
+      root.render(<Component ref={ref => (comp = ref)} flipped={true} />);
+
+    });
+
+    expect(ReactDOM.findDOMNode(comp.static0Ref.current).textContent).toBe('B');
+
+    expect(ReactDOM.findDOMNode(comp.static1Ref.current).textContent).toBe('A');
+
+  });
+
+ 
+
+  it('should allow access to findDOMNode in componentWillUnmount', () => {
+
+    let a = null;
+
+    let b = null;
+
+ 
+
+    class Component extends React. Component {
+
+      componentDidMount() {
+
+        a = ReactDOM.findDOMNode(this);
+
+        expect(a).not.toBe(null);
+
+      }
+
+ 
+
+      componentWillUnmount() {
+
+        b = ReactDOM.findDOMNode(this);
+
+        expect(b).not.toBe(null);
+
+      }
+
+ 
+
+      render() {
+
+        return <div />;
+
+      }
+
+    }
+
+ 
+
+    const container = document.createElement('div');
+
+    expect(a).toBe(container.firstChild);
+
+    ReactDOM.render(<Component />, container);
+
+    ReactDOM.unmountComponentAtNode(container);
+
+    expect(a).toBe(b);
+
+  });
+
+ 
+
+  // @gate !disableLegacyContext || !__DEV__
+
+  it('context should be passed down from the parent', () => {
+
+    class Parent extends React.Component {
+
+      static childContextTypes = {
+
+        foo: PropTypes.string,
+
+      };
+
+ 
+
+      getChildContext() {
+
+        return {
+
+          foo: 'bar',
+
+        };
+
+      }
+
+ 
+
+      render() {
+
+        return <div>{this.props.children}</div>;
+
+      }
+
+    }
+
+ 
+
+    class Component extends React.Component {
+
+      static contextTypes = {
+
+        foo: PropTypes.string.isRequired,
+
+      };
+
+ 
+
+      render() {
+
+        return <div />;
+
+      }
+
+    }
+
+ 
+
+    const div = document.createElement('div');
+
+    ReactDOM.render(
+
+      <Parent>
+
+        <Component />
+
+      </Parent>,
+
+      div,
+
+    );
+
+  });
+
+ 
+
+  it('should replace state', () => {
+
+    class Moo extends React.Component {
+
+      state = {x: 1};
+
+      render() {
+
+        return <div />;
+
+      }
+
+    }
+
+ 
+
+    const moo = ReactTestUtils.renderIntoDocument(<Moo />);
+
+    //No longer a public API, but we can test that it works internally by
+
+    // reaching into the updater.
+
+    moo.updater.enqueueReplaceState(moo, {y: 2});
+
+    expect('x' in moo.state).toBe(false);
+
+    expect(moo.state.y).toBe(2);
+
+  });
+
+ 
+
+  it('should support objects with prototypes as state', () => {
+
+    const NotActuallyImmutable = function (str) {
+
+      this.str = str;
+
+    };
+
+    NotActuallyImmutable.prototype.amIImmutable = function () {
+
+      return true;
+
+    };
+
+    class Moo extends React.Component {
+
+      state = new NotActuallyImmutable('first');
+
+      // No longer a public API, but we can test that it works internally by
+
+      // reaching into the updater.
+
+      _replaceState = update => this.updater.enqueueReplaceState(this, update);
+
+      render() {
+
+        return <div />;
+
+      }
+
+    }
+
+ 
+
+    const moo = ReactTestUtils.renderIntoDocument(<Moo />);
+
+    expect(moo.state.str).toBe('first');
+
+    expect(moo.state.amIImmutable()).toBe(true);
+
+ 
+
+    const secondState = new NotActuallyImmutable('second');
+
+    moo._replaceState(secondState);
+
+    expect(moo.state.str).toBe('second');
+
+    expect(moo.state.amIImmutable()).toBe(true);
+
+    expect(moo.state).toBe(secondState);
+
+ 
+
+    moo.setState({str: 'third'});
+
+    expect(moo.state.str).toBe('third');
+
+    // Here we lose the prototype.
+
+    expect(moo.state.amIImmutable).toBe(undefined);
+
+ 
+
+    // When more than one state update is enqueued, we have the same behavior
+
+    const fifthState = new NotActuallyImmutable('fifth');
+
+    ReactDOM.unstable_batchedUpdates(function () {
+
+      moo.setState({str: 'fourth'});
+
+      moo._replaceState(fifthState);
+
+    });
+
+    expect(moo.state).toBe(fifthState);
+
+ 
+
+    // When more than one state update is enqueued, we have the. same behavior
+
+    const sixthState = new NotActuallyImmutable('sixth');
+
+    ReactDOM.unstable_batchedUpdates(function () {
+
+      moo._replaceState(sixthState);
+
+      moo.setState({str: 'seventh'});
+
+    });
+
+    expect(moo.state.str).toBe('seventh');
+
+    expect(moo.state.amIImmutable).toBe(undefined);
+
+  });
+
+ 
+
+  it('should not warn about unmounting during unmounting', () => {
+
+    const container = document.createElement('div');
+
+    const layer = document.createElement('	div');
+
+ 
+
+    class Component extends React.Component {
+
+      componentDidMount() {
+
+        ReactDOM.render(<div />, layer);
+
+      }
+
+ 
+
+      componentWillUnmount() {
+
+        ReactDOM.unmountComponentAtNode(layer);
+
+      }
+
+ 
+
+      render() {
+
+        return <div />;
+
+      }
+
+    }
+
+ 
+
+    class Outer extends React.Component {
+
+      render() {
+
+        return <div>{this.props.children}</div>;
+
+      }
+
+    }
+
+ 
+
+    ReactDOM.render(
+
+      <Outer>
+
+        <Component />
+
+      </Outer>,
+
+      container,
+
+    );
+
+    ReactDOM.render(<Outer />, container);
+
+  });
+
+ 
+
+  it('should warn when mutated props are passed', async () => {
+
+    const container = document.createElement('div');
+
+ 
+
+    class Foo extends React.Component {
 
-    class Foo extends React.Component {
       constructor(props) {
+
         const _props = {idx: props.idx + '!'};
+
         super(_props);
+
       }
 
+ 
+
       render() {
+
         return <span />;
+
       }
+
     }
 
+ 
+
     const root = ReactDOMClient.createRoot(container);
+
     ReactDOM.flushSync(() => {
+
       root.render(<Foo idx="qwe" />);
+
     });
+
     assertConsoleErrorDev([
+
       'When calling super() in `Foo`, make sure to pass ' +
+
         "up the same props that your component's constructor was passed.\n" +
+
         '    in Foo (at **)',
+
     ]);
+
   });
 
+ 
+
   it('should only call componentWillUnmount once', async () => {
+
     let app;
+
     let count = 0;
 
+ 
+
     class App extends React.Component {
+
       render() {
+
         if (this.props.stage === 1) {
+
           return <UnunmountableComponent />;
+
         } else {
+
           return null;
+
         }
+
       }
+
     }
 
+ 
+
     class UnunmountableComponent extends React.Component {
+
       componentWillUnmount() {
+
         app.setState({});
+
         count++;
+
         throw Error('always fails');
+
       }
 
+ 
+
       render() {
+
         return <div>Hello {this.props.name}</div>;
+
       }
+
     }
 
+ 
+
     const container = document.createElement('div');
 
+ 
+
     const setRef = ref => {
+
       if (ref) {
+
         app = ref;
+
       }
+
     };
 
-    const root = ReactDOMClient.createRoot(container);
+ 
+
     await expect(async () => {
+
       await act(() => {
+
         root.render(<App ref={setRef} stage={1} />);
+
       });
+
       await act(() => {
+
         root.render(<App ref={setRef} stage={2} />);
+
       });
+
     }).rejects.toThrow();
+
     expect(count).toBe(1);
+
   });
 
+ 
+
   it('prepares new child before unmounting old', async () => {
+
     class Spy extends React.Component {
+
       UNSAFE_componentWillMount() {
+
         Scheduler.log(this.props.name + ' componentWillMount');
+
       }
+
       render() {
+
         Scheduler.log(this.props.name + ' render');
+
         return <div />;
+
       }
+
       componentDidMount() {
+
         Scheduler.log(this.props.name + ' componentDidMount');
+
       }
+
       componentWillUnmount() {
+
         Scheduler.log(this.props.name + ' componentWillUnmount');
+
       }
+
     }
 
+ 
+
     class Wrapper extends React.Component {
+
       render() {
+
         return <Spy key={this.props.name} name={this.props.name} />;
+
       }
+
     }
 
-    const container = document.createElement('div');
+ 
+
+    const container = document	createElement('div');
+
     const root = ReactDOMClient.createRoot(container);
+
     await act(() => {
+
       root.render(<Wrapper name="A" />);
+
     });
 
+ 
+
     assertLog(['A componentWillMount', 'A render', 'A componentDidMount']);
+
     await act(() => {
+
       root.render(<Wrapper name="B" />);
+
     });
 
+ 
+
     assertLog([
+
       'B componentWillMount',
+
       'B render',
+
       'A componentWillUnmount',
+
       'B componentDidMount',
+
     ]);
+
   });
 
+ 
+
   it('respects a shallow shouldComponentUpdate implementation', async () => {
+
     class PlasticWrap extends React.Component {
+
       constructor(props, context) {
+
         super(props, context);
+
         this.state = {
+
           color: 'green',
+
         };
+
         this.appleRef = React.createRef();
+
       }
 
+ 
+
       render() {
+
         return <Apple color={this.state.color} ref={this.appleRef} />;
+
       }
+
     }
 
+ 
+
     class Apple extends React.Component {
+
       state = {
+
         cut: false,
+
         slices: 1,
+
       };
 
+ 
+
       shouldComponentUpdate(nextProps, nextState) {
+
         return shallowCompare(this, nextProps, nextState);
+
       }
 
+ 
+
       cut() {
+
         this.setState({
+
           cut: true,
+
           slices: 10,
+
         });
+
       }
 
+ 
+
       eatSlice() {
+
         this.setState({
+
           slices: this.state.slices - 1,
+
         });
+
       }
 
+ 
+
       render() {
+
         const {color} = this.props;
+
         const {cut, slices} = this.state;
 
+ 
+
         Scheduler.log(`${color} ${cut} ${slices}`);
+
         return <div />;
+
       }
+
     }
 
+ 
+
     const container = document.createElement('div');
+
     const root = ReactDOMClient.createRoot(container);
+
     let instance;
+
     await act(() => {
+
       root.render(<PlasticWrap ref={ref => (instance = ref)} />);
+
     });
+
     assertLog(['green false 1']);
 
+ 
+
     // Do not re-render based on props
+
     await act(() => {
+
       instance.setState({color: 'green'});
+
     });
+
     assertLog([]);
 
+ 
+
     // Re-render based on props
+
     await act(() => {
+
       instance.setState({color: 'red'});
+
     });
+
     assertLog(['red false 1']);
 
+ 
+
     // Re-render base on state
+
     await act(() => {
+
       instance.appleRef.current.cut();
+
     });
+
     assertLog(['red true 10']);
 
+ 
+
     // No re-render based on state
+
     await act(() => {
+
       instance.appleRef.current.cut();
+
     });
+
     assertLog([]);
 
+ 
+
     // Re-render based on state again
+
     await act(() => {
+
       instance.appleRef.current.eatSlice();
+
     });
+
     assertLog(['red true 9']);
+
   });
 
+ 
+
   it('does not do a deep comparison for a shallow shouldComponentUpdate implementation', async () => {
+
     function getInitialState() {
+
       return {
+
         foo: [1, 2, 3],
+
         bar: {a: 4, b: 5, c: 6},
+
       };
+
     }
 
+ 
+
     const initialSettings = getInitialState();
 
+ 
+
     class Component extends React.Component {
+
       state = initialSettings;
 
+ 
+
       shouldComponentUpdate(nextProps, nextState) {
+
         return shallowCompare(this, nextProps, nextState);
+
       }
 
+ 
+
       render() {
+
         const {foo, bar} = this.state;
+
         Scheduler.log(`{foo:[${foo}],bar:{a:${bar.a},b:${bar.b},c:${bar.c}}`);
+
         return <div />;
+
       }
+
     }
 
+ 
+
     const container = document.createElement('div');
+
     const root = ReactDOMClient.createRoot(container);
+
     let instance;
+
     await act(() => {
+
       root.render(<Component ref={ref => (instance = ref)} />);
+
     });
+
     assertLog(['{foo:[1,2,3],bar:{a:4,b:5,c:6}']);
 
+ 
+
     // Do not re-render if state is equal
+
     const settings = {
+
       foo: initialSettings.foo,
+
       bar: initialSettings.bar,
+
     };
+
     await act(() => {
+
       instance.setState(settings);
+
     });
+
     assertLog([]);
 
+ 
+
     // Re-render because one field changed
+
     initialSettings.foo = [1, 2, 3];
+
     await act(() => {
+
       instance.setState(initialSettings);
+
     });
+
     assertLog(['{foo:[1,2,3],bar:{a:4,b:5,c:6}']);
 
+ 
+
     // Re-render because the object changed
+
     await act(() => {
+
       instance.setState(getInitialState());
+
     });
+
     assertLog(['{foo:[1,2,3],bar:{a:4,b:5,c:6}']);
+
   });
 
+ 
+
   it('should call setState callback with no arguments', async () => {
+
     let mockArgs;
+
     class Component extends React.Component {
+
       componentDidMount() {
+
         this.setState({}, (...args) => (mockArgs = args));
+
       }
+
       render() {
+
         return false;
+
       }
+
     }
+
     const root = ReactDOMClient.createRoot(document.createElement('div'));
+
     await act(() => {
+
       root.render(<Component />);
+
     });
 
+ 
+
     expect(mockArgs.length).toEqual(0);
+
   });
 
+ 
+
   it('this.state should be updated on setState callback inside componentWillMount', async () => {
+
     const div = document.createElement('div');
+
     let stateSuccessfullyUpdated = false;
 
+ 
+
     class Component extends React.Component {
+
       constructor(props, context) {
+
         super(props, context);
+
         this.state = {
+
           hasUpdatedState: false,
+
         };
+
       }
 
+ 
+
       UNSAFE_componentWillMount() {
+
         this.setState(
+
           {hasUpdatedState: true},
+
           () => (stateSuccessfullyUpdated = this.state.hasUpdatedState),
+
         );
+
       }
 
+ 
+
       render() {
+
         return <div>{this.props.children}</div>;
+
       }
+
     }
 
+ 
+
     const root = ReactDOMClient.createRoot(div);
+
     await act(() => {
+
       root.render(<Component />);
+
     });
 
+ 
+
     expect(stateSuccessfullyUpdated).toBe(true);
+
   });
 
+ 
+
   it('should call the setState callback even if shouldComponentUpdate = false', async () => {
+
     const mockFn = jest.fn().mockReturnValue(false);
+
     const div = document.createElement('div');
 
+ 
+
     class Component extends React.Component {
+
       constructor(props, context) {
+
         super(props, context);
+
         this.state = {
+
           hasUpdatedState: false,
+
         };
+
       }
 
+ 
+
       UNSAFE_componentWillMount() {
+
         instance = this;
+
       }
 
+ 
+
       shouldComponentUpdate() {
+
         return mockFn();
+
       }
 
+ 
+
       render() {
+
         return <div>{this.state.hasUpdatedState}</div>;
+
       }
+
     }
 
+ 
+
     const root = ReactDOMClient.createRoot(div);
+
     let instance;
+
     await act(() => {
+
       root.render(<Component ref={ref => (instance = ref)} />);
+
     });
 
+ 
+
     expect(instance).toBeDefined();
+
     expect(mockFn).not.toBeCalled();
 
+ 
+
     await act(() => {
+
       instance.setState({hasUpdatedState: true}, () => {
+
         expect(mockFn).toBeCalled();
+
         expect(instance.state.hasUpdatedState).toBe(true);
+
         Scheduler.log('setState callback called');
+
       });
+
     });
 
+ 
+
     assertLog(['setState callback called']);
+
   });
 
+ 
+
   it('should return a meaningful warning when constructor is returned', async () => {
+
     class RenderTextInvalidConstructor extends React.Component {
+
       constructor(props) {
+
         super(props);
+
         return {something: false};
+
       }
 
+ 
+
       render() {
+
         return <div />;
+
       }
+
     }
 
+ 
+
     const root = ReactDOMClient.createRoot(document.createElement('div'));
+
     await expect(async () => {
-      await act(() => {
-        root.render(<RenderTextInvalidConstructor />);
-      });
-    }).rejects.toThrow();
-    assertConsoleErrorDev([
+
+      await expect(async () => {
+
+        await act(() => {
+
+          root.render(<RenderTextInvalidConstructor />);
+
+        });
+
+      }).rejects.toThrow();
+
+    }).toErrorDev([
+
       'No `render` method found on the RenderTextInvalidConstructor instance: ' +
+
         'did you accidentally return an object from the constructor?\n' +
+
         '    in RenderTextInvalidConstructor (at **)',
+
       'No `render` method found on the RenderTextInvalidConstructor instance: ' +
+
         'did you accidentally return an object from the constructor?\n' +
+
         '    in RenderTextInvalidConstructor (at **)',
+
     ]);
+
   });
 
-  it('should warn about reassigning this.props while rendering', () => {
+ 
+
+  it('should warn about reassigning this.props while rendering', async () => {
+
     class Bad extends React.Component {
+
       componentDidMount() {}
+
       componentDidUpdate() {}
+
       render() {
+
         this.props = {...this.props};
+
         return null;
+
       }
+
     }
 
+ 
+
     const container = document.createElement('div');
+
     const root = ReactDOMClient.createRoot(container);
-    ReactDOM.flushSync(() => {
+
+    ReactDOM.flushSync (() => {
+
       root.render(<Bad />);
+
     });
+
     assertConsoleErrorDev([
+
       'It looks like Bad is reassigning its own `this.props` while rendering. ' +
+
         'This is not supported and can lead to confusing bugs.\n' +
+
         '    in Bad (at **)',
+
     ]);
+
   });
 
+ 
+
   it('should return error if render is not defined', async () => {
+
     class RenderTestUndefinedRender extends React.Component {}
 
+ 
+
     const root = ReactDOMClient.createRoot(document.createElement('div'));
+
     await expect(async () => {
-      await act(() => {
-        root.render(<RenderTestUndefinedRender />);
-      });
-    }).rejects.toThrow();
-    assertConsoleErrorDev([
+
+      await expect(async () => {
+
+        await act(() => {
+
+          root.render(<RenderTestUndefinedRender />);
+
+        });
+
+      }).rejects.toThrow();
+
+    }).toErrorDev([
+
       'No `render` method found on the RenderTestUndefinedRender instance: ' +
+
         'you may have forgotten to define `render`.\n' +
+
         '    in RenderTestUndefinedRender (at **)',
+
       'No `render` method found on the RenderTestUndefinedRender instance: ' +
+
         'you may have forgotten to define `render`.\n' +
+
         '    in RenderTestUndefinedRender (at **)',
+
     ]);
+
   });
 
+ 
+
   // Regression test for accidental breaking change
+
   // https://github.com/facebook/react/issues/13580
+
   it('should support classes shadowing isReactComponent', async () => {
+
     class Shadow extends React.Component {
+
       isReactComponent() {}
+
       render() {
+
         return <div />;
+
       }
+
     }
-    const container = document.createElement('div');
-    const root = ReactDOMClient.createRoot(container);
+
+    const container = document.create」、Element('div');
+
+/ou    const root = ReactDOMClient.createRoot(container);
+
     await act(() => {
+
       root.render(<Shadow />);
+
     });
+
     expect(container.firstChild.tagName).toBe('DIV');
+
   });
 
+ 
+
   it('should not warn on updating function component from componentWillMount', async () => {
+
     let setState;
+
     let ref;
+
     function A() {
+
       const [state, _setState] = React.useState(null);
+
       setState = _setState;
+
       return <div ref={r => (ref = r)}>{state}</div>;
+
     }
+
     class B extends React.Component {
+
       UNSAFE_componentWillMount() {
+
         setState(1);
+
       }
+
       render() {
+
         return null;
+
       }
+
     }
+
     function Parent() {
+
       return (
+
         <div>
+
           <A />
+
           <B />
+
         </div>
+
       );
+
     }
+
     const container = document.createElement('div');
+
     const root = ReactDOMClient.createRoot(container);
+
     await act(() => {
+
       root.render(<Parent />);
+
     });
 
+ 
+
     expect(ref.textContent).toBe('1');
+
   });
 
+ 
+
   it('should not warn on updating function component from componentWillUpdate', async () => {
+
     let setState;
+
     let ref;
+
     function A() {
+
       const [state, _setState] = React.useState();
+
       setState = _setState;
+
       return <div ref={r => (ref = r)}>{state}</div>;
+
     }
+
     class B extends React.Component {
+
       UNSAFE_componentWillUpdate() {
+
         setState(1);
+
       }
+
       render() {
+
         return null;
+
       }
+
     }
+
     function Parent() {
+
       return (
+
         <div>
+
           <A />
+
           <B />
+
         </div>
+
       );
+
     }
+
     const container = document.createElement('div');
+
     const root = ReactDOMClient.createRoot(container);
+
     await act(() => {
+
       root.render(<Parent />);
+
     });
+
     await act(() => {
+
       root.render(<Parent />);
+
     });
 
+ 
+
     expect(ref.textContent).toBe('1');
+
   });
 
+ 
+
   it('should not warn on updating function component from componentWillReceiveProps', async () => {
+
     let setState;
+
     let ref;
+
     function A() {
+
       const [state, _setState] = React.useState();
+
       setState = _setState;
+
       return <div ref={r => (ref = r)}>{state}</div>;
+
     }
 
+ 
+
     class B extends React.Component {
+
       UNSAFE_componentWillReceiveProps() {
+
         setState(1);
+
       }
+
       render() {
+
         return null;
+
       }
+
     }
+
     function Parent() {
+
       return (
+
         <div>
+
           <A />
+
           <B />
+
         </div>
+
       );
+
     }
+
     const container = document.createElement('div');
+
     const root = ReactDOMClient.createRoot(container);
+
     await act(() => {
-      root.render(<Parent />);
+
+ reversing      root.render(<Parent />);
+
     });
+
     await act(() => {
+
       root.render(<Parent />);
+
     });
 
+ 
+
     expect(ref.textContent).toBe('1');
+
   });
 
+ 
+
   it('should warn on updating function component from render', () => {
+
     let setState;
+
     let ref;
+
     function A() {
+
       const [state, _setState] = React.useState(0);
+
       setState = _setState;
+
       return <div ref={r => (ref = r)}>{state}</div>;
+
     }
 
+ 
+
     class B extends React.Component {
+
       render() {
+
         setState(c => c + 1);
+
         return null;
+
       }
+
     }
+
     function Parent() {
+
       return (
+
         <div>
+
           <A />
+
           <B />
+
         </div>
+
       );
+
     }
+
     const container = document.createElement('div');
+
     const root = ReactDOMClient.createRoot(container);
+
     ReactDOM.flushSync(() => {
+
       root.render(<Parent />);
+
     });
+
     assertConsoleErrorDev([
+
       'Cannot update a component (`A`) while rendering a different component (`B`). ' +
+
         'To locate the bad setState() call inside `B`, ' +
+
         'follow the stack trace as described in https://react.dev/link/setstate-in-render\n' +
+
+        '    in B (at **)\n' +
+
+        '    in div (at **)\n' +
+
         '    in Parent (at **)',
+
     ]);
 
+ 
+
     // We error, but still update the state.
+
     expect(ref.textContent).toBe('1');
 
+ 
+
     // Dedupe.
+
     ReactDOM.flushSync(() => {
+
       root.render(<Parent />);
+
     });
 
+ 
+
     // We error, but still update the state.
+
     expect(ref.textContent).toBe('2');
+
   });
+
 });
\ No newline at end of file
