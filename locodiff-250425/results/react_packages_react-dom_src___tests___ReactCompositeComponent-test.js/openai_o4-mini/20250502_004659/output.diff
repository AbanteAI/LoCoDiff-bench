--- react_packages_react-dom_src___tests___ReactCompositeComponent-test.js_expectedoutput.txt (expected)+++ react_packages_react-dom_src___tests___ReactCompositeComponent-test.js_extracted.txt (actual)@@ -3,11 +3,7 @@  *
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
- *
- * @emails react-core
  */
-
-'use strict';
 
 let ChildUpdates;
 let MorphingComponent;
@@ -23,56 +19,17 @@ describe('ReactCompositeComponent', () => {
   const hasOwnProperty = Object.prototype.hasOwnProperty;
 
-  /**
-   * Performs equality by iterating through keys on an object and returning false
-   * when any key has values which are not strictly equal between the arguments.
-   * Returns true when the values of all keys are strictly equal.
-   */
-  function shallowEqual(objA: mixed, objB: mixed): boolean {
-    if (Object.is(objA, objB)) {
-      return true;
-    }
-    if (
-      typeof objA !== 'object' ||
-      objA === null ||
-      typeof objB !== 'object' ||
-      objB === null
-    ) {
-      return false;
-    }
-    const keysA = Object.keys(objA);
-    const keysB = Object.keys(objB);
-    if (keysA.length !== keysB.length) {
-      return false;
-    }
-    for (let i = 0; i < keysA.length; i++) {
-      if (
-        !hasOwnProperty.call(objB, keysA[i]) ||
-        !Object.is(objA[keysA[i]], objB[keysA[i]])
-      ) {
-        return false;
-      }
-    }
-    return true;
-  }
-
-  function shallowCompare(instance, nextProps, nextState) {
-    return (
-      !shallowEqual(instance.props, nextProps) ||
-      !shallowEqual(instance.state, nextState)
-    );
-  }
-
   beforeEach(() => {
     jest.resetModules();
     React = require('react');
     ReactDOM = require('react-dom');
     ReactDOMClient = require('react-dom/client');
     ReactSharedInternals =
-      require('react').__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
+      require('react')
+        .__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
     Scheduler = require('scheduler');
+    ({act, assertConsoleErrorDev} = require('internal-test-utils'));
     assertLog = require('internal-test-utils').assertLog;
-    ({act, assertConsoleErrorDev} = require('internal-test-utils'));
   });
 
   describe('MorphingComponent', () => {
@@ -102,10 +59,6 @@         }
       };
 
-      /**
-       * We'll use this to ensure that an old version is not cached when it is
-       * reallocated again.
-       */
       ChildUpdates = class extends React.Component {
         anchorRef = React.createRef();
 
@@ -127,6 +80,7 @@         }
       };
     });
+
     it('should support rendering to different child types over time', async () => {
       const root = ReactDOMClient.createRoot(document.createElement('div'));
       await act(() => {
@@ -191,19 +145,16 @@       });
       await act(() => {
         root.render(
-          // Warm any cache
           <ChildUpdates renderAnchor={true} anchorClassOn={true} />,
         );
       });
       await act(() => {
         root.render(
-          // Clear out the anchor
           <ChildUpdates renderAnchor={false} anchorClassOn={true} />,
         );
       });
       await act(() => {
         root.render(
-          // rerender
           <ChildUpdates renderAnchor={true} anchorClassOn={false} />,
         );
       });
@@ -229,7 +180,6 @@     }).rejects.toThrow(
       'Objects are not valid as a React child (found: object with keys {render}).',
     );
-
     expect(el.textContent).toBe('');
   });
 
@@ -242,34 +192,22 @@       }
     }
 
-    function refFn1(ref) {
-      instance1 = ref;
-    }
-
-    function refFn2(ref) {
-      instance2 = ref;
-    }
-
-    function refFn3(ref) {
-      instance3 = ref;
-    }
-
-    let instance1;
-    let instance2;
-    let instance3;
-    const root = ReactDOMClient.createRoot(document.createElement('div'));
-    await act(() => {
-      root.render(<Component ref={refFn1} />);
+    let instance1, instance2, instance3;
+    const root = ReactDOMClient.createRoot(document.createElement('div'));
+    await act(() => {
+      root.render(<Component ref={ref => (instance1 = ref)} />);
     });
     expect(instance1.props).toEqual({prop: 'testKey'});
 
     await act(() => {
-      root.render(<Component ref={refFn2} prop={undefined} />);
+      root.render(
+        <Component ref={ref => (instance2 = ref)} prop={undefined} />,
+      );
     });
     expect(instance2.props).toEqual({prop: 'testKey'});
 
     await act(() => {
-      root.render(<Component ref={refFn3} prop={null} />);
+      root.render(<Component ref={ref => (instance3 = ref)} prop={null} />);
     });
     expect(instance3.props).toEqual({prop: null});
   });
@@ -290,9 +228,6 @@       root.render(<Component {...inputProps} ref={ref => (instance1 = ref)} />);
     });
     expect(instance1.props.prop).toBe('testKey');
-
-    // We don't mutate the input, just in case the caller wants to do something
-    // with it after using it to instantiate a component
     expect(inputProps.prop).not.toBeDefined();
   });
 
@@ -303,7 +238,7 @@         this.forceUpdate();
       }
       render() {
-        return <div>foo</div>;
+        return <div />;
       }
     }
 
@@ -320,13 +255,10 @@         '    in MyComponent (at **)',
     ]);
 
-    // No additional warning should be recorded
     const container2 = document.createElement('div');
-    const root2 = ReactDOMClient.createRoot(container2);
-    await act(() => {
-      root2.render(<MyComponent />);
-    });
-    expect(container2.firstChild.textContent).toBe('foo');
+    await act(() => {
+      ReactDOMClient.createRoot(container2).render(<MyComponent />);
+    });
   });
 
   it('should warn about `setState` on not-yet-mounted components', async () => {
@@ -336,13 +268,12 @@         this.setState();
       }
       render() {
-        return <div>foo</div>;
-      }
-    }
-
-    const container = document.createElement('div');
-    const root = ReactDOMClient.createRoot(container);
-
+        return <div />;
+      }
+    }
+
+    const container = document.createElement('div');
+    const root = ReactDOMClient.createRoot(container);
     ReactDOM.flushSync(() => {
       root.render(<MyComponent />);
     });
@@ -354,43 +285,34 @@         '    in MyComponent (at **)',
     ]);
 
-    // No additional warning should be recorded
     const container2 = document.createElement('div');
-    const root2 = ReactDOMClient.createRoot(container2);
-    await act(() => {
-      root2.render(<MyComponent />);
-    });
-    expect(container2.firstChild.textContent).toBe('foo');
+    await act(() => {
+      ReactDOMClient.createRoot(container2).render(<MyComponent />);
+    });
   });
 
   it('should not warn about `forceUpdate` on unmounted components', async () => {
     const container = document.createElement('div');
     document.body.appendChild(container);
 
+    class Component extends React.Component {
+      componentDidMount() {
+        // nothing
+      }
+      render() {
+        return <div />;
+      }
+    }
+
     let instance;
-    class Component extends React.Component {
-      componentDidMount() {
-        instance = this;
-      }
-
-      render() {
-        return <div />;
-      }
-    }
-
-    const component = <Component />;
-    expect(component.forceUpdate).not.toBeDefined();
-    const root = ReactDOMClient.createRoot(container);
-    await act(() => {
-      root.render(component);
+    const root = ReactDOMClient.createRoot(container);
+    await act(() => {
+      root.render(<Component ref={c => (instance = c)} />);
     });
 
     instance.forceUpdate();
-
-    root.unmount(container);
-
+    root.unmount();
     instance.forceUpdate();
-    instance.forceUpdate();
   });
 
   it('should not warn about `setState` on unmounted components', async () => {
@@ -399,7 +321,6 @@ 
     class Component extends React.Component {
       state = {value: 0};
-
       render() {
         Scheduler.log('render ' + this.state.value);
         return <div />;
@@ -417,7 +338,6 @@         </div>,
       );
     });
-
     assertLog(['render 0']);
 
     await act(() => {
@@ -428,11 +348,9 @@     await act(() => {
       root.render(<div />);
     });
-
     await act(() => {
       ref.setState({value: 2});
     });
-    // setState on an unmounted component is a noop.
     assertLog([]);
   });
 
@@ -442,20 +360,18 @@     document.body.appendChild(container);
 
     class Component extends React.Component {
-      state = {value: 0};
-
       componentWillUnmount() {
         expect(() => {
-          this.setState({value: 2}, function () {
+          this.setState({value: 2}, () => {
             cbCalled = true;
           });
         }).not.toThrow();
       }
-
-      render() {
-        return <div />;
-      }
-    }
+      render() {
+        return <div />;
+      }
+    }
+
     let instance;
     const root = ReactDOMClient.createRoot(container);
     await act(() => {
@@ -464,8 +380,6 @@     await act(() => {
       instance.setState({value: 1});
     });
-    instance.setState({value: 1});
-
     root.unmount();
     expect(cbCalled).toBe(false);
   });
@@ -479,7 +393,7 @@     }
     const root = ReactDOMClient.createRoot(container);
     await expect(async () => {
-      await act(() => {
+      ReactDOM.flushSync(() => {
         root.render(<ClassWithRenderNotExtended />);
       });
     }).rejects.toThrow(TypeError);
@@ -492,7 +406,7 @@ 
     // Test deduplication
     await expect(async () => {
-      await act(() => {
+      ReactDOM.flushSync(() => {
         root.render(<ClassWithRenderNotExtended />);
       });
     }).rejects.toThrow(TypeError);
@@ -503,48 +417,40 @@ 
     class Component extends React.Component {
       state = {value: 0};
-
       render() {
         Scheduler.log('render ' + this.state.value);
         if (this.state.value === 0) {
           this.setState({value: 1});
         }
-        return <div>foo {this.state.value}</div>;
+        return <div>Child</div>;
       }
     }
 
     let instance;
     const root = ReactDOMClient.createRoot(container);
-    ReactDOM.flushSync(() => {
-      root.render(<Component ref={ref => (instance = ref)} />);
-    });
-    assertConsoleErrorDev([
+    await expect(async () => {
+      ReactDOM.flushSync(() => {
+        root.render(<Component ref={ref => (instance = ref)} />);
+      });
+    }).toErrorDev([
       'Cannot update during an existing state transition (such as within ' +
         '`render`). Render methods should be a pure function of props and state.\n' +
         '    in Component (at **)',
     ]);
 
-    // The setState call is queued and then executed as a second pass. This
-    // behavior is undefined though so we're free to change it to suit the
-    // implementation details.
     assertLog(['render 0', 'render 1']);
-    expect(instance.state.value).toBe(1);
 
     // Forcing a rerender anywhere will cause the update to happen.
     await act(() => {
-      root.render(<Component prop={123} />);
+      root.render(<Component />);
     });
     assertLog(['render 1']);
   });
 
   it('should cleanup even if render() fatals', async () => {
-    const ownerEnabled = __DEV__;
-
     let stashedDispatcher;
     class BadComponent extends React.Component {
       render() {
-        // Stash the dispatcher that was available in render so we can check
-        // that its internals also reset.
         stashedDispatcher = ReactSharedInternals.A;
         throw new Error();
       }
@@ -561,11 +467,7 @@     }).rejects.toThrow();
 
     expect(ReactSharedInternals.A).toBe(null);
-    if (ownerEnabled) {
-      expect(stashedDispatcher.getOwner()).toBe(null);
-    } else {
-      expect(stashedDispatcher.getOwner).toBe(undefined);
-    }
+    expect(stashedDispatcher.getOwner()).toBe(null);
   });
 
   it('should call componentWillUnmount before unmounting', async () => {
@@ -573,21 +475,9 @@     let innerUnmounted = false;
 
     class Component extends React.Component {
-      render() {
-        return (
-          <div>
-            <Inner />
-            Text
-          </div>
-        );
-      }
-    }
-
-    class Inner extends React.Component {
       componentWillUnmount() {
         innerUnmounted = true;
       }
-
       render() {
         return <div />;
       }
@@ -604,11 +494,9 @@   it('should warn when shouldComponentUpdate() returns undefined', async () => {
     class ClassComponent extends React.Component {
       state = {bogus: false};
-
       shouldComponentUpdate() {
         return undefined;
       }
-
       render() {
         return <div />;
       }
@@ -618,7 +506,6 @@     await act(() => {
       root.render(<ClassComponent ref={ref => (instance = ref)} />);
     });
-
     ReactDOM.flushSync(() => {
       instance.setState({bogus: true});
     });
@@ -630,39 +517,34 @@   });
 
   it('should warn when componentDidUnmount method is defined', async () => {
-    class Component extends React.Component {
+    class C extends React.Component {
       componentDidUnmount = () => {};
-
-      render() {
-        return <div />;
-      }
-    }
-
+      render() {
+        return <div />;
+      }
+    }
     const root = ReactDOMClient.createRoot(document.createElement('div'));
     ReactDOM.flushSync(() => {
-      root.render(<Component />);
+      root.render(<C />);
     });
     assertConsoleErrorDev([
       'Component has a method called ' +
         'componentDidUnmount(). But there is no such lifecycle method. ' +
         'Did you mean componentWillUnmount()?\n' +
-        '    in Component (at **)',
-    ]);
-  });
-
-  it('should warn when componentDidReceiveProps method is defined', () => {
-    class Component extends React.Component {
+        '    in C (at **)',
+    ]);
+  });
+
+  it('should warn when componentDidReceiveProps method is defined', async () => {
+    class C extends React.Component {
       componentDidReceiveProps = () => {};
-
-      render() {
-        return <div />;
-      }
-    }
-
-    const root = ReactDOMClient.createRoot(document.createElement('div'));
-
+      render() {
+        return <div />;
+      }
+    }
+    const root = ReactDOMClient.createRoot(document.createElement('div'));
     ReactDOM.flushSync(() => {
-      root.render(<Component />);
+      root.render(<C />);
     });
     assertConsoleErrorDev([
       'Component has a method called ' +
@@ -670,30 +552,28 @@         'If you meant to update the state in response to changing props, ' +
         'use componentWillReceiveProps(). If you meant to fetch data or ' +
         'run side-effects or mutations after React has updated the UI, use componentDidUpdate().\n' +
-        '    in Component (at **)',
-    ]);
-  });
-
-  it('should warn when defaultProps was defined as an instance property', () => {
-    class Component extends React.Component {
+        '    in C (at **)',
+    ]);
+  });
+
+  it('should warn when defaultProps was defined as an instance property', async () => {
+    class C extends React.Component {
       constructor(props) {
         super(props);
-        this.defaultProps = {name: 'Abhay'};
-      }
-
-      render() {
-        return <div />;
-      }
-    }
-    const root = ReactDOMClient.createRoot(document.createElement('div'));
-
+        this.defaultProps = {foo: 'bar'};
+      }
+      render() {
+        return <div />;
+      }
+    }
+    const root = ReactDOMClient.createRoot(document.createElement('div'));
     ReactDOM.flushSync(() => {
-      root.render(<Component />);
-    });
-    assertConsoleErrorDev([
-      'Setting defaultProps as an instance property on Component is not supported ' +
-        'and will be ignored. Instead, define defaultProps as a static property on Component.\n' +
-        '    in Component (at **)',
+      root.render(<C />);
+    });
+    assertConsoleErrorDev([
+      'Setting defaultProps as an instance property on C is not supported ' +
+        'and will be ignored. Instead, define defaultProps as a static property on C.\n' +
+        '    in C (at **)',
     ]);
   });
 
@@ -703,22 +583,19 @@         return <div>{this.props.children}</div>;
       }
     }
-
     class Child extends React.Component {
       render() {
         Scheduler.log('Child render');
         return <div />;
       }
     }
-
-    const container = document.createElement('div');
     const child = <Child />;
+    const container = document.createElement('div');
     const root = ReactDOMClient.createRoot(container);
     await act(() => {
       root.render(<Parent>{child}</Parent>);
     });
     assertLog(['Child render']);
-
     await act(() => {
       root.render(<Parent>{child}</Parent>);
     });
@@ -726,27 +603,30 @@   });
 
   it('should disallow nested render calls', () => {
-    const root = ReactDOMClient.createRoot(document.createElement('div'));
     class Inner extends React.Component {
       render() {
         return <div />;
       }
     }
-
     class Outer extends React.Component {
       render() {
-        root.render(<Inner />);
-        return <div />;
-      }
-    }
-
-    ReactDOM.flushSync(() => {
-      root.render(<Outer />);
-    });
-    assertConsoleErrorDev([
+        ReactDOM.flushSync(() => {
+          ReactDOMClient.createRoot(document.createElement('div')).render(
+            <Inner />,
+          );
+        });
+        return <div />;
+      }
+    }
+    const root = ReactDOMClient.createRoot(document.createElement('div'));
+    expect(() => {
+      ReactDOM.flushSync(() => {
+        root.render(<Outer />);
+      });
+    }).toErrorDev([
       'Render methods should be a pure function of props and state; ' +
         'triggering nested component updates from render is not allowed. If ' +
-        'necessary, trigger nested updates in componentDidUpdate.\n\n' +
+        'necessary, trigger nested updates in componentDidUpdate.\n' +
         'Check the render method of Outer.\n' +
         '    in Outer (at **)',
     ]);
@@ -754,90 +634,49 @@ 
   it('only renders once if updated in componentWillReceiveProps', async () => {
     let renders = 0;
-
     class Component extends React.Component {
       state = {updated: false};
-
       UNSAFE_componentWillReceiveProps(props) {
-        expect(props.update).toBe(1);
-        expect(renders).toBe(1);
-        this.setState({updated: true});
-        expect(renders).toBe(1);
-      }
-
+        if (props.update === 1) {
+          this.setState({updated: true});
+        }
+      }
       render() {
         renders++;
         return <div />;
       }
     }
-
     const container = document.createElement('div');
     const root = ReactDOMClient.createRoot(container);
     let instance;
-
-    await act(() => {
-      root.render(<Component update={0} ref={ref => (instance = ref)} />);
+    await act(() => {
+      root.render(
+        <Component ref={ref => (instance = ref)} update={0} />,
+      );
     });
     expect(renders).toBe(1);
-    expect(instance.state.updated).toBe(false);
-
-    await act(() => {
-      root.render(<Component update={1} ref={ref => (instance = ref)} />);
+    await act(() => {
+      root.render(
+        <Component ref={ref => (instance = ref)} update={1} />,
+      );
     });
     expect(renders).toBe(2);
     expect(instance.state.updated).toBe(true);
   });
 
-  it('only renders once if updated in componentWillReceiveProps when batching', async () => {
-    let renders = 0;
-
-    class Component extends React.Component {
-      state = {updated: false};
-
-      UNSAFE_componentWillReceiveProps(props) {
-        expect(props.update).toBe(1);
-        expect(renders).toBe(1);
-        this.setState({updated: true});
-        expect(renders).toBe(1);
-      }
-
-      render() {
-        renders++;
-        return <div />;
-      }
-    }
-
-    const container = document.createElement('div');
-    const root = ReactDOMClient.createRoot(container);
-    let instance;
-    await act(() => {
-      root.render(<Component update={0} ref={ref => (instance = ref)} />);
-    });
-    expect(renders).toBe(1);
-    expect(instance.state.updated).toBe(false);
-    await act(() => {
-      root.render(<Component update={1} ref={ref => (instance = ref)} />);
-    });
-    expect(renders).toBe(2);
-    expect(instance.state.updated).toBe(true);
-  });
-
   it('should warn when mutated props are passed', async () => {
-    const container = document.createElement('div');
-
     class Foo extends React.Component {
       constructor(props) {
-        const _props = {idx: props.idx + '!'};
-        super(_props);
-      }
-
+        const p = {idx: props.idx + '!'};
+        super(p);
+      }
       render() {
         return <span />;
       }
     }
-
-    const root = ReactDOMClient.createRoot(container);
-    ReactDOM.flushSync(() => {
+    const container = document.createElement('div');
+    const root = ReactDOMClient.createRoot(container);
+    await act(() => {
       root.render(<Foo idx="qwe" />);
     });
     assertConsoleErrorDev([
@@ -850,37 +689,30 @@   it('should only call componentWillUnmount once', async () => {
     let app;
     let count = 0;
-
     class App extends React.Component {
       render() {
         if (this.props.stage === 1) {
           return <UnunmountableComponent />;
-        } else {
-          return null;
         }
-      }
-    }
-
+        return null;
+      }
+    }
     class UnunmountableComponent extends React.Component {
       componentWillUnmount() {
         app.setState({});
         count++;
         throw Error('always fails');
       }
-
-      render() {
-        return <div>Hello {this.props.name}</div>;
-      }
-    }
-
-    const container = document.createElement('div');
-
+      render() {
+        return <div>Hello</div>;
+      }
+    }
+    const container = document.createElement('div');
     const setRef = ref => {
       if (ref) {
         app = ref;
       }
     };
-
     const root = ReactDOMClient.createRoot(container);
     await expect(async () => {
       await act(() => {
@@ -909,25 +741,23 @@         Scheduler.log(this.props.name + ' componentWillUnmount');
       }
     }
-
     class Wrapper extends React.Component {
       render() {
         return <Spy key={this.props.name} name={this.props.name} />;
       }
     }
-
     const container = document.createElement('div');
     const root = ReactDOMClient.createRoot(container);
     await act(() => {
       root.render(<Wrapper name="A" />);
     });
-
-    assertLog(['A componentWillMount', 'A render', 'A componentDidMount']);
     await act(() => {
       root.render(<Wrapper name="B" />);
     });
-
     assertLog([
+      'A componentWillMount',
+      'A render',
+      'A componentDidMount',
       'B componentWillMount',
       'B render',
       'A componentWillUnmount',
@@ -937,144 +767,102 @@ 
   it('respects a shallow shouldComponentUpdate implementation', async () => {
     class PlasticWrap extends React.Component {
-      constructor(props, context) {
-        super(props, context);
-        this.state = {
-          color: 'green',
-        };
-        this.appleRef = React.createRef();
-      }
-
-      render() {
+      state = {color: 'green'};
+      render() {
+        Scheduler.log(`render ${this.state.color}`);
         return <Apple color={this.state.color} ref={this.appleRef} />;
       }
     }
-
     class Apple extends React.Component {
-      state = {
-        cut: false,
-        slices: 1,
-      };
-
+      state = {cut: false, slices: 1};
       shouldComponentUpdate(nextProps, nextState) {
-        return shallowCompare(this, nextProps, nextState);
-      }
-
+        return (
+          nextProps.color !== this.props.color ||
+          nextState.cut !== this.state.cut ||
+          nextState.slices !== this.state.slices
+        );
+      }
       cut() {
-        this.setState({
-          cut: true,
-          slices: 10,
-        });
-      }
-
+        this.setState({cut: true, slices: 10});
+      }
       eatSlice() {
-        this.setState({
-          slices: this.state.slices - 1,
-        });
-      }
-
-      render() {
-        const {color} = this.props;
-        const {cut, slices} = this.state;
-
-        Scheduler.log(`${color} ${cut} ${slices}`);
-        return <div />;
-      }
-    }
-
-    const container = document.createElement('div');
-    const root = ReactDOMClient.createRoot(container);
-    let instance;
-    await act(() => {
-      root.render(<PlasticWrap ref={ref => (instance = ref)} />);
-    });
-    assertLog(['green false 1']);
-
-    // Do not re-render based on props
-    await act(() => {
-      instance.setState({color: 'green'});
-    });
-    assertLog([]);
-
-    // Re-render based on props
-    await act(() => {
-      instance.setState({color: 'red'});
-    });
-    assertLog(['red false 1']);
-
-    // Re-render base on state
-    await act(() => {
-      instance.appleRef.current.cut();
-    });
-    assertLog(['red true 10']);
-
-    // No re-render based on state
-    await act(() => {
-      instance.appleRef.current.cut();
-    });
-    assertLog([]);
-
-    // Re-render based on state again
-    await act(() => {
-      instance.appleRef.current.eatSlice();
-    });
-    assertLog(['red true 9']);
+        this.setState({slices: this.state.slices - 1});
+      }
+      render() {
+        Scheduler.log(
+          `render ${this.props.color} ${this.state.cut} ${this.state.slices}`,
+        );
+        return <div />;
+      }
+    }
+
+    const container = document.createElement('div');
+    const root = ReactDOMClient.createRoot(container);
+    let wrapInstance;
+    await act(() => {
+      root.render(<PlasticWrap ref={ref => (wrapInstance = ref)} />);
+    });
+    // Do not re-render green -> green
+    await act(() => {
+      wrapInstance.setState({color: 'green'});
+    });
+    // Re-render green -> red
+    await act(() => {
+      wrapInstance.setState({color: 'red'});
+    });
+    // cut -> re-render
+    await act(() => {
+      wrapInstance.appleRef.current.cut();
+    });
+    // cut again -> no re-render
+    await act(() => {
+      wrapInstance.appleRef.current.cut();
+    });
+    // eatSlice -> re-render
+    await act(() => {
+      wrapInstance.appleRef.current.eatSlice();
+    });
   });
 
   it('does not do a deep comparison for a shallow shouldComponentUpdate implementation', async () => {
     function getInitialState() {
-      return {
-        foo: [1, 2, 3],
-        bar: {a: 4, b: 5, c: 6},
-      };
-    }
-
-    const initialSettings = getInitialState();
-
-    class Component extends React.Component {
-      state = initialSettings;
-
+      return {foo: [1, 2, 3], bar: {a: 4, b: 5, c: 6}};
+    }
+    class Component extends React.Component {
+      state = getInitialState();
       shouldComponentUpdate(nextProps, nextState) {
-        return shallowCompare(this, nextProps, nextState);
-      }
-
-      render() {
-        const {foo, bar} = this.state;
-        Scheduler.log(`{foo:[${foo}],bar:{a:${bar.a},b:${bar.b},c:${bar.c}}`);
-        return <div />;
-      }
-    }
-
-    const container = document.createElement('div');
-    const root = ReactDOMClient.createRoot(container);
-    let instance;
-    await act(() => {
-      root.render(<Component ref={ref => (instance = ref)} />);
-    });
-    assertLog(['{foo:[1,2,3],bar:{a:4,b:5,c:6}']);
-
-    // Do not re-render if state is equal
-    const settings = {
-      foo: initialSettings.foo,
-      bar: initialSettings.bar,
-    };
-    await act(() => {
-      instance.setState(settings);
-    });
-    assertLog([]);
-
-    // Re-render because one field changed
-    initialSettings.foo = [1, 2, 3];
-    await act(() => {
-      instance.setState(initialSettings);
-    });
-    assertLog(['{foo:[1,2,3],bar:{a:4,b:5,c:6}']);
-
-    // Re-render because the object changed
-    await act(() => {
-      instance.setState(getInitialState());
-    });
-    assertLog(['{foo:[1,2,3],bar:{a:4,b:5,c:6}']);
+        return (
+          nextState.foo !== this.state.foo || nextState.bar !== this.state.bar
+        );
+      }
+      render() {
+        Scheduler.log(
+          `{foo:[${this.state.foo}],bar:{a:${this.state.bar.a},b:${this.state.bar.b},c:${this.state.bar.c}}}`,
+        );
+        return <div />;
+      }
+    }
+
+    const container = document.createElement('div');
+    const root = ReactDOMClient.createRoot(container);
+    let inst;
+    await act(() => {
+      root.render(<Component ref={ref => (inst = ref)} />);
+    });
+    initial = getInitialState();
+    // same references -> no re-render
+    await act(() => {
+      inst.setState(initial);
+    });
+    // new foo instance -> re-render
+    initial.foo = [1, 2, 3];
+    await act(() => {
+      inst.setState(initial);
+    });
+    // new object -> re-render
+    await act(() => {
+      inst.setState(getInitialState());
+    });
   });
 
   it('should call setState callback with no arguments', async () => {
@@ -1087,89 +875,67 @@         return false;
       }
     }
-    const root = ReactDOMClient.createRoot(document.createElement('div'));
-    await act(() => {
-      root.render(<Component />);
-    });
-
-    expect(mockArgs.length).toEqual(0);
+    await act(() => {
+      ReactDOMClient.createRoot(document.createElement('div')).render(
+        <Component />,
+      );
+    });
+    expect(mockArgs.length).toBe(0);
   });
 
   it('this.state should be updated on setState callback inside componentWillMount', async () => {
     const div = document.createElement('div');
     let stateSuccessfullyUpdated = false;
-
-    class Component extends React.Component {
-      constructor(props, context) {
-        super(props, context);
-        this.state = {
-          hasUpdatedState: false,
-        };
-      }
-
+    class Component extends React.Component {
+      constructor(props) {
+        super(props);
+        this.state = {hasUpdatedState: false};
+      }
       UNSAFE_componentWillMount() {
         this.setState(
           {hasUpdatedState: true},
           () => (stateSuccessfullyUpdated = this.state.hasUpdatedState),
         );
       }
-
-      render() {
-        return <div>{this.props.children}</div>;
-      }
-    }
-
-    const root = ReactDOMClient.createRoot(div);
-    await act(() => {
-      root.render(<Component />);
-    });
-
+      render() {
+        return <div />;
+      }
+    }
+    await act(() => {
+      ReactDOMClient.createRoot(div).render(<Component />);
+    });
     expect(stateSuccessfullyUpdated).toBe(true);
   });
 
   it('should call the setState callback even if shouldComponentUpdate = false', async () => {
     const mockFn = jest.fn().mockReturnValue(false);
     const div = document.createElement('div');
-
-    class Component extends React.Component {
-      constructor(props, context) {
-        super(props, context);
-        this.state = {
-          hasUpdatedState: false,
-        };
-      }
-
+    class Component extends React.Component {
+      constructor(props) {
+        super(props);
+        this.state = {hasUpdatedState: false};
+      }
       UNSAFE_componentWillMount() {
-        instance = this;
-      }
-
+        // avoid calling setState in render warning
+      }
       shouldComponentUpdate() {
         return mockFn();
       }
-
-      render() {
-        return <div>{this.state.hasUpdatedState}</div>;
-      }
-    }
-
+      render() {
+        return <div />;
+      }
+    }
+    let instance;
     const root = ReactDOMClient.createRoot(div);
-    let instance;
     await act(() => {
       root.render(<Component ref={ref => (instance = ref)} />);
     });
-
-    expect(instance).toBeDefined();
-    expect(mockFn).not.toBeCalled();
-
     await act(() => {
       instance.setState({hasUpdatedState: true}, () => {
         expect(mockFn).toBeCalled();
         expect(instance.state.hasUpdatedState).toBe(true);
-        Scheduler.log('setState callback called');
-      });
-    });
-
-    assertLog(['setState callback called']);
+      });
+    });
   });
 
   it('should return a meaningful warning when constructor is returned', async () => {
@@ -1178,12 +944,10 @@         super(props);
         return {something: false};
       }
-
-      render() {
-        return <div />;
-      }
-    }
-
+      render() {
+        return <div />;
+      }
+    }
     const root = ReactDOMClient.createRoot(document.createElement('div'));
     await expect(async () => {
       await act(() => {
@@ -1194,55 +958,32 @@       'No `render` method found on the RenderTextInvalidConstructor instance: ' +
         'did you accidentally return an object from the constructor?\n' +
         '    in RenderTextInvalidConstructor (at **)',
-      'No `render` method found on the RenderTextInvalidConstructor instance: ' +
-        'did you accidentally return an object from the constructor?\n' +
-        '    in RenderTextInvalidConstructor (at **)',
-    ]);
-  });
-
-  it('should warn about reassigning this.props while rendering', () => {
-    class Bad extends React.Component {
-      componentDidMount() {}
-      componentDidUpdate() {}
-      render() {
-        this.props = {...this.props};
-        return null;
-      }
-    }
-
-    const container = document.createElement('div');
-    const root = ReactDOMClient.createRoot(container);
-    ReactDOM.flushSync(() => {
-      root.render(<Bad />);
-    });
-    assertConsoleErrorDev([
-      'It looks like Bad is reassigning its own `this.props` while rendering. ' +
-        'This is not supported and can lead to confusing bugs.\n' +
-        '    in Bad (at **)',
-    ]);
-  });
-
-  it('should return error if render is not defined', async () => {
-    class RenderTestUndefinedRender extends React.Component {}
-
-    const root = ReactDOMClient.createRoot(document.createElement('div'));
-    await expect(async () => {
-      await act(() => {
-        root.render(<RenderTestUndefinedRender />);
-      });
-    }).rejects.toThrow();
-    assertConsoleErrorDev([
-      'No `render` method found on the RenderTestUndefinedRender instance: ' +
-        'you may have forgotten to define `render`.\n' +
-        '    in RenderTestUndefinedRender (at **)',
-      'No `render` method found on the RenderTestUndefinedRender instance: ' +
-        'you may have forgotten to define `render`.\n' +
-        '    in RenderTestUndefinedRender (at **)',
-    ]);
-  });
-
-  // Regression test for accidental breaking change
-  // https://github.com/facebook/react/issues/13580
+    ]);
+  });
+
+  it('should warn for Hook set-state on unmounted component', async () => {
+    let instance;
+    const container = document.createElement('div');
+    document.body.appendChild(container);
+    function A() {
+      const [_, set] = React.useState(0);
+      instance = set;
+      return null;
+    }
+    const root = ReactDOMClient.createRoot(container);
+    await act(() => {
+      root.render(<A />);
+    });
+    root.unmount();
+    assertConsoleErrorDev([
+      "Can't perform a React state update on an unmounted component. This is a no-op, " +
+        'but it indicates a memory leak in your application. To fix, ' +
+        'cancel all subscriptions and asynchronous tasks in the ' +
+        'componentWillUnmount method.\n' +
+        '    in A (at **)',
+    ]);
+  });
+
   it('should support classes shadowing isReactComponent', async () => {
     class Shadow extends React.Component {
       isReactComponent() {}
@@ -1250,27 +991,23 @@         return <div />;
       }
     }
-    const container = document.createElement('div');
-    const root = ReactDOMClient.createRoot(container);
+    const root = ReactDOMClient.createRoot(document.createElement('div'));
     await act(() => {
       root.render(<Shadow />);
     });
-    expect(container.firstChild.tagName).toBe('DIV');
-  });
-
-  it('should not warn on updating function component from componentWillMount', async () => {
-    let setState;
+    expect(document.body.firstChild.tagName).toBe('DIV');
+  });
+
+  it('should warn on updating function component from render', () => {
     let ref;
     function A() {
-      const [state, _setState] = React.useState(null);
-      setState = _setState;
-      return <div ref={r => (ref = r)}>{state}</div>;
+      const [count, setCount] = React.useState(0);
+      ref = setCount;
+      return null;
     }
     class B extends React.Component {
-      UNSAFE_componentWillMount() {
-        setState(1);
-      }
-      render() {
+      render() {
+        ref(c => c + 1);
         return null;
       }
     }
@@ -1282,132 +1019,58 @@         </div>
       );
     }
-    const container = document.createElement('div');
-    const root = ReactDOMClient.createRoot(container);
-    await act(() => {
-      root.render(<Parent />);
-    });
-
-    expect(ref.textContent).toBe('1');
-  });
-
-  it('should not warn on updating function component from componentWillUpdate', async () => {
-    let setState;
-    let ref;
-    function A() {
-      const [state, _setState] = React.useState();
-      setState = _setState;
-      return <div ref={r => (ref = r)}>{state}</div>;
-    }
-    class B extends React.Component {
-      UNSAFE_componentWillUpdate() {
-        setState(1);
-      }
-      render() {
-        return null;
-      }
-    }
-    function Parent() {
-      return (
-        <div>
-          <A />
-          <B />
-        </div>
-      );
-    }
-    const container = document.createElement('div');
-    const root = ReactDOMClient.createRoot(container);
-    await act(() => {
-      root.render(<Parent />);
-    });
-    await act(() => {
-      root.render(<Parent />);
-    });
-
-    expect(ref.textContent).toBe('1');
-  });
-
-  it('should not warn on updating function component from componentWillReceiveProps', async () => {
-    let setState;
-    let ref;
-    function A() {
-      const [state, _setState] = React.useState();
-      setState = _setState;
-      return <div ref={r => (ref = r)}>{state}</div>;
-    }
-
-    class B extends React.Component {
-      UNSAFE_componentWillReceiveProps() {
-        setState(1);
-      }
-      render() {
-        return null;
-      }
-    }
-    function Parent() {
-      return (
-        <div>
-          <A />
-          <B />
-        </div>
-      );
-    }
-    const container = document.createElement('div');
-    const root = ReactDOMClient.createRoot(container);
-    await act(() => {
-      root.render(<Parent />);
-    });
-    await act(() => {
-      root.render(<Parent />);
-    });
-
-    expect(ref.textContent).toBe('1');
-  });
-
-  it('should warn on updating function component from render', () => {
-    let setState;
-    let ref;
-    function A() {
-      const [state, _setState] = React.useState(0);
-      setState = _setState;
-      return <div ref={r => (ref = r)}>{state}</div>;
-    }
-
-    class B extends React.Component {
-      render() {
-        setState(c => c + 1);
-        return null;
-      }
-    }
-    function Parent() {
-      return (
-        <div>
-          <A />
-          <B />
-        </div>
-      );
-    }
-    const container = document.createElement('div');
-    const root = ReactDOMClient.createRoot(container);
+    const root = ReactDOMClient.createRoot(document.createElement('div'));
     ReactDOM.flushSync(() => {
       root.render(<Parent />);
     });
     assertConsoleErrorDev([
       'Cannot update a component (`A`) while rendering a different component (`B`). ' +
-        'To locate the bad setState() call inside `B`, ' +
-        'follow the stack trace as described in https://react.dev/link/setstate-in-render\n' +
+        'To locate the bad setState() call inside `B`, follow the stack trace as described in ' +
+        'https://react.dev/link/setstate-in-render\n' +
         '    in Parent (at **)',
     ]);
-
-    // We error, but still update the state.
-    expect(ref.textContent).toBe('1');
-
     // Dedupe.
     ReactDOM.flushSync(() => {
       root.render(<Parent />);
     });
-
-    // We error, but still update the state.
-    expect(ref.textContent).toBe('2');
+  });
+
+  it('should warn about reassigning this.props while rendering', async () => {
+    class Bad extends React.Component {
+      render() {
+        this.props = {...this.props};
+        return null;
+      }
+    }
+    const root = ReactDOMClient.createRoot(document.createElement('div'));
+    await act(() => {
+      root.render(<Bad foo="bar" />);
+    });
+    assertConsoleErrorDev([
+      'It looks like Bad is reassigning its own `this.props` while rendering. ' +
+        'This is not supported and can lead to confusing bugs.\n' +
+        '    in Bad (at **)',
+    ]);
+  });
+
+  it('should warn about reassigning this.props in constructor', async () => {
+    class Bad extends React.Component {
+      constructor(props) {
+        super(props);
+        this.props = {foo: 'baz'};
+      }
+      render() {
+        return null;
+      }
+    }
+    const root = ReactDOMClient.createRoot(document.createElement('div'));
+    await act(() => {
+      root.render(<Bad foo="bar" />);
+    });
+    assertConsoleErrorDev([
+      'It looks like Bad is reassigning its own `this.props` in the constructor. ' +
+        'This is not supported and can lead to confusing bugs.\n' +
+        '    in Bad (at **)',
+    ]);
   });
 });