
index a7fabdd89..1b4eafab0 100644
--- a/tldraw_packages_editor_src_lib_editor_shapes_ShapeUtil.ts_expectedoutput.txt (expected):tmp/tmp7nbjkjzs_expected.txt	
+++ b/tldraw_packages_editor_src_lib_editor_shapes_ShapeUtil.ts_extracted.txt (actual):tmp/tmp4u5f95wn_actual.txt	
@@ -32,12 +32,7 @@ export interface TLShapeUtilConstructor<
 	migrations?: LegacyMigrations | TLPropsMigrations | MigrationSequence
 }
 
-/**
- * Options passed to {@link ShapeUtil.canBind}. A binding that could be made. At least one of
- * `fromShapeType` or `toShapeType` will belong to this shape util.
- *
- * @public
- */
+/** @public */
 export interface TLShapeUtilCanBindOpts<Shape extends TLUnknownShape = TLUnknownShape> {
 	/** The type of shape referenced by the `fromId` of the binding. */
 	fromShapeType: string
@@ -59,7 +54,8 @@ export interface TLShapeUtilCanBeLaidOutOpts {
 	shapes?: TLShape[]
 }
 
-/** Additional options for the {@link ShapeUtil.getGeometry} method.
+/**
+ * Additional options for the {@link ShapeUtil.getGeometry} method.
  *
  * @public
  */
@@ -79,7 +75,9 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	/** Configure this shape utils {@link ShapeUtil.options | `options`}. */
 	static configure<T extends TLShapeUtilConstructor<any, any>>(
 		this: T,
-		options: T extends new (...args: any[]) => { options: infer Options } ? Partial<Options> : never
+		options: T extends new (...args: any[]) => { options: infer Options }
+			? Partial<Options>
+			: never
 	): T {
 		// @ts-expect-error -- typescript has no idea what's going on here but it's fine
 		return class extends this {
@@ -173,373 +171,384 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	abstract indicator(shape: Shape): any
 
 	/**
-	 * Get the font faces that should be rendered in the document in order for this shape to render
-	 * correctly.
+	 * Get a JSX element for the shape (as an HTML element) to be rendered as part of the canvas background - behind any other shape content.
 	 *
 	 * @param shape - The shape.
-	 * @public
+	 * @internal
 	 */
-	getFontFaces(shape: Shape): TLFontFace[] {
-		return EMPTY_ARRAY
-	}
+	backgroundComponent?(shape: Shape): any
 
 	/**
-	 * Whether the shape can be snapped to by another shape.
+	 * Get the shape's background layer as an SVG object.
 	 *
 	 * @param shape - The shape.
+	 * @param ctx - The export context for the SVG - used for adding e.g. <def>s
+	 * @returns An SVG element.
 	 * @public
 	 */
-	canSnap(_shape: Shape): boolean {
-		return true
-	}
+	toBackgroundSvg?(
+		shape: Shape,
+		ctx: SvgExportContext
+	): ReactElement | null | Promise<ReactElement | null>
 
 	/**
-	 * Whether the shape can be tabbed to.
+	 * Get the shape as an SVG object.
 	 *
 	 * @param shape - The shape.
+	 * @param ctx - The export context for the SVG - used for adding e.g. <def>s
+	 * @returns An SVG element.
 	 * @public
 	 */
-	canTabTo(_shape: Shape): boolean {
-		return true
-	}
+	toSvg?(
+		shape: Shape,
+		ctx: SvgExportContext
+	): ReactElement | null | Promise<ReactElement | null>
 
 	/**
-	 * Whether the shape can be scrolled while editing.
+	 * Return elements to be added to the <defs> section of the canvases SVG context. This can be
+	 * used to define SVG content (e.g. patterns & masks) that can be referred to by ID from svg
+	 * elements returned by `component`.
 	 *
-	 * @public
+	 * Each def should have a unique `key`. If multiple defs from different shapes all have the same
+	 * key, only one will be used.
 	 */
-	canScroll(_shape: Shape): boolean {
-		return false
+	getCanvasSvgDefs(): TLShapeUtilCanvasSvgDef[] {
+		return []
 	}
 
 	/**
-	 * Whether the shape can be bound to. See {@link TLShapeUtilCanBindOpts} for details.
+	 * Get the interpolated props for an animating shape. This is an optional method.
+	 *
+	 * @example
+	 *
+	 * ```ts
+	 * util.getInterpolatedProps?.(startShape, endShape, t)
+	 * ```
 	 *
+	 * @param startShape - The initial shape.
+	 * @param endShape - The initial shape.
+	 * @param progress - The normalized progress between zero (start) and 1 (end).
 	 * @public
 	 */
-	canBind(_opts: TLShapeUtilCanBindOpts): boolean {
-		return true
-	}
+	getInterpolatedProps?(
+		startShape: Shape,
+		endShape: Shape,
+		progress: number
+	): Shape['props']
 
 	/**
-	 * Whether the shape can be double clicked to edit.
+	 * Get an array of handle models for the shape. This is an optional method.
+	 *
+	 * @example
+	 *
+	 * ```ts
+	 * util.getHandles?.(myShape)
+	 * ```
 	 *
+	 * @param shape - The shape.
 	 * @public
 	 */
-	canEdit(_shape: Shape): boolean {
-		return false
-	}
+	getHandles?(shape: Shape): TLHandle[]
 
 	/**
-	 * Whether the shape can be resized.
+	 * Get an array of outline segments for the shape. For most shapes,
+	 * this will be a single segment that includes the entire outline.
+	 * For shapes with handles, this might be segments of the outline
+	 * between each handle.
 	 *
+	 * @example
+	 *
+	 * ```ts
+	 * util.getOutlineSegments(myShape)
+	 * ```
+	 *
+	 * @param shape - The shape.
 	 * @public
 	 */
-	canResize(_shape: Shape): boolean {
-		return true
+	getOutlineSegments(shape: Shape): Vec[][] {
+		return [this.editor.getShapeGeometry(shape).vertices]
 	}
 
 	/**
-	 * Whether the shape can be edited in read-only mode.
+	 * Get the shape's (not cached) outline.
 	 *
+	 * @param shape - The shape.
 	 * @public
 	 */
-	canEditInReadOnly(_shape: Shape): boolean {
-		return false
+	getOutline(shape: Shape): Vec[] {
+		return this.editor.getBounds(shape).corners
 	}
 
 	/**
-	 * Whether the shape can be cropped.
+	 * Get the shape's snap points.
 	 *
+	 * @param shape - The shape.
 	 * @public
 	 */
-	canCrop(_shape: Shape): boolean {
-		return false
+	snapPoints(shape: Shape) {
+		return this.editor.getBounds(shape).snapPoints
 	}
 
 	/**
-	 * Whether the shape can participate in layout functions such as alignment or distribution.
+	 * Get the shape's cached center.
 	 *
 	 * @param shape - The shape.
-	 * @param info - Additional context information: the type of action causing the layout and the
-	 * @public
-	 *
 	 * @public
 	 */
-	canBeLaidOut(_shape: Shape, _info: TLShapeUtilCanBeLaidOutOpts): boolean {
-		return true
+	center(shape: Shape): Vec {
+		return this.getCenter(shape)
 	}
 
 	/**
-	 * Does this shape provide a background for its children? If this is true,
-	 * then any children with a `renderBackground` method will have their
-	 * backgrounds rendered _above_ this shape. Otherwise, the children's
-	 * backgrounds will be rendered above either the next ancestor that provides
-	 * a background, or the canvas background.
+	 * Get the shape's (not cached) center.
 	 *
-	 * @internal
+	 * @param shape - The shape.
+	 * @public
 	 */
-	providesBackgroundForChildren(_shape: Shape): boolean {
-		return false
+	getCenter(shape: Shape): Vec {
+		return this.editor.getBounds(shape).center
 	}
 
 	/**
-	 * Whether the shape should hide its resize handles when selected.
+	 * Get whether the shape can receive children of a given type.
 	 *
+	 * @param shape - The shape.
+	 * @param type - The shape type.
 	 * @public
 	 */
-	hideResizeHandles(_shape: Shape): boolean {
+	canReceiveNewChildrenOfType(_shape: Shape, _type: TLShape['type']) {
 		return false
 	}
 
 	/**
-	 * Whether the shape should hide its rotation handles when selected.
+	 * Get whether the shape can receive children of a given type.
 	 *
+	 * @param shape - The shape type.
+	 * @param shapes - The shapes that are being dropped.
 	 * @public
 	 */
-	hideRotateHandle(_shape: Shape): boolean {
+	canDropShapes(_shape: Shape, _shapes: TLShape[]) {
 		return false
 	}
 
 	/**
-	 * Whether the shape should hide its selection bounds background when selected.
+	 * Get the geometry to use when snapping to this this shape in translate/resize operations. See
+	 * {@link BoundsSnapGeometry} for details.
+	 */
+	getBoundsSnapGeometry(_shape: Shape): BoundsSnapGeometry {
+		return {}
+	}
+
+	/**
+	 * Get the geometry to use when snapping handles to this shape. See {@link HandleSnapGeometry}
+	 * for details.
+	 */
+	getHandleSnapGeometry(_shape: Shape): HandleSnapGeometry {
+		return {}
+	}
+
+	/**
+	 * Whether the shape can be snapped to by another shape.
 	 *
+	 * @param shape - The shape.
 	 * @public
 	 */
-	hideSelectionBoundsBg(_shape: Shape): boolean {
-		return false
+	canSnap(_shape: Shape): boolean {
+		return true
 	}
 
 	/**
-	 * Whether the shape should hide its selection bounds foreground when selected.
+	 * Whether the shape can be bound to. See {@link TLShapeUtilCanBindOpts} for details.
 	 *
 	 * @public
 	 */
-	hideSelectionBoundsFg(_shape: Shape): boolean {
-		return false
+	canBind(_opts: TLShapeUtilCanBindOpts): boolean {
+		return true
 	}
 
 	/**
-	 * Whether the shape's aspect ratio is locked.
+	 * Whether the shape can be edited in read-only mode.
 	 *
 	 * @public
 	 */
-	isAspectRatioLocked(_shape: Shape): boolean {
+	canEditInReadOnly(_shape: Shape): boolean {
 		return false
 	}
 
 	/**
-	 * Get a JSX element for the shape (as an HTML element) to be rendered as part of the canvas background - behind any other shape content.
+	 * Whether the shape can be edited.
 	 *
-	 * @param shape - The shape.
-	 * @internal
+	 * @public
 	 */
-	backgroundComponent?(shape: Shape): any
+	canEdit(_shape: Shape): boolean {
+		return false
+	}
 
 	/**
-	 * Get the interpolated props for an animating shape. This is an optional method.
-	 *
-	 * @example
-	 *
-	 * ```ts
-	 * util.getInterpolatedProps?.(startShape, endShape, t)
-	 * ```
+	 * Whether the shape can be resized.
 	 *
-	 * @param startShape - The initial shape.
-	 * @param endShape - The initial shape.
-	 * @param progress - The normalized progress between zero (start) and 1 (end).
 	 * @public
 	 */
-	getInterpolatedProps?(startShape: Shape, endShape: Shape, progress: number): Shape['props']
+	canResize(_shape: Shape): boolean {
+		return true
+	}
 
 	/**
-	 * Get an array of handle models for the shape. This is an optional method.
-	 *
-	 * @example
-	 *
-	 * ```ts
-	 * util.getHandles?.(myShape)
-	 * ```
+	 * Whether the shape can be cropped.
 	 *
-	 * @param shape - The shape.
 	 * @public
 	 */
-	getHandles?(shape: Shape): TLHandle[]
+	canCrop(_shape: Shape): boolean {
+		return false
+	}
 
 	/**
-	 * Get whether the shape can receive children of a given type.
+	 * Whether the shape can be tabbed to.
 	 *
 	 * @param shape - The shape.
-	 * @param type - The shape type.
 	 * @public
 	 */
-	canReceiveNewChildrenOfType(_shape: Shape, _type: TLShape['type']) {
-		return false
+	canTabTo(_shape: Shape): boolean {
+		return true
 	}
 
 	/**
-	 * Get whether the shape can receive children of a given type.
+	 * Whether the shape can be scrolled while editing.
 	 *
-	 * @param shape - The shape type.
-	 * @param shapes - The shapes that are being dropped.
 	 * @public
 	 */
-	canDropShapes(_shape: Shape, _shapes: TLShape[]) {
+	canScroll(_shape: Shape): boolean {
 		return false
 	}
 
 	/**
-	 * Get the shape as an SVG object.
+	 * Whether the shape can be unmounted when not visible in the editor. Consider keeping this to false if the shape's `component` has local state.
 	 *
-	 * @param shape - The shape.
-	 * @param ctx - The export context for the SVG - used for adding e.g. \<def\>s
-	 * @returns An SVG element.
 	 * @public
 	 */
-	toSvg?(shape: Shape, ctx: SvgExportContext): ReactElement | null | Promise<ReactElement | null>
+	canUnmount(_shape: Shape): boolean {
+		return true
+	}
 
 	/**
-	 * Get the shape's background layer as an SVG object.
+	 * Whether the shape can be laid out (align, distribute, etc.).
 	 *
 	 * @param shape - The shape.
-	 * @param ctx - ctx - The export context for the SVG - used for adding e.g. \<def\>s
-	 * @returns An SVG element.
+	 * @param info - Additional context information: the type of action causing the layout and the
 	 * @public
 	 */
-	toBackgroundSvg?(
-		shape: Shape,
-		ctx: SvgExportContext
-	): ReactElement | null | Promise<ReactElement | null>
-
-	/** @internal */
-	expandSelectionOutlinePx(shape: Shape): number | Box {
-		return 0
+	canBeLaidOut(_shape: Shape, _info: TLShapeUtilCanBeLaidOutOpts): boolean {
+		return true
 	}
 
 	/**
-	 * Return elements to be added to the \<defs\> section of the canvases SVG context. This can be
-	 * used to define SVG content (e.g. patterns & masks) that can be referred to by ID from svg
-	 * elements returned by `component`.
+	 * Whether the shape provides a background for its children. If this is true,
+	 * then any children with a `renderBackground` method will have their
+	 * backgrounds rendered _above_ this shape. Otherwise, the children's
+	 * backgrounds will be rendered above either the next ancestor that provides
+	 * a background, or the canvas background.
 	 *
-	 * Each def should have a unique `key`. If multiple defs from different shapes all have the same
-	 * key, only one will be used.
+	 * @internal
 	 */
-	getCanvasSvgDefs(): TLShapeUtilCanvasSvgDef[] {
-		return []
+	providesBackgroundForChildren(_shape: Shape): boolean {
+		return false
 	}
 
 	/**
-	 * Get the geometry to use when snapping to this this shape in translate/resize operations. See
-	 * {@link BoundsSnapGeometry} for details.
+	 * Whether the shape should hide its resize handles when selected.
+	 *
+	 * @public
 	 */
-	getBoundsSnapGeometry(_shape: Shape): BoundsSnapGeometry {
-		return {}
+	hideResizeHandles(_shape: Shape): boolean {
+		return false
 	}
 
 	/**
-	 * Get the geometry to use when snapping handles to this shape. See {@link HandleSnapGeometry}
-	 * for details.
+	 * Whether the shape should hide its rotation handles when selected.
+	 *
+	 * @public
 	 */
-	getHandleSnapGeometry(_shape: Shape): HandleSnapGeometry {
-		return {}
+	hideRotateHandle(_shape: Shape): boolean {
+		return false
 	}
 
-	getText(_shape: Shape): string | undefined {
-		return undefined
+	/**
+	 * Whether the shape should hide its selection bounds background when selected.
+	 *
+	 * @public
+	 */
+	hideSelectionBoundsBg(_shape: Shape): boolean {
+		return false
 	}
 
-	getAriaDescriptor(_shape: Shape): string | undefined {
-		return undefined
+	/**
+	 * Whether the shape should hide its selection bounds foreground when selected.
+	 *
+	 * @public
+	 */
+	hideSelectionBoundsFg(_shape: Shape): boolean {
+		return false
 	}
 
-	//  Events
-
 	/**
-	 * A callback called just before a shape is created. This method provides a last chance to modify
-	 * the created shape.
-	 *
-	 * @example
-	 *
-	 * ```ts
-	 * onBeforeCreate = (next) => {
-	 * 	return { ...next, x: next.x + 1 }
-	 * }
-	 * ```
+	 * Whether the shape's aspect ratio is locked.
 	 *
-	 * @param next - The next shape.
-	 * @returns The next shape or void.
 	 * @public
 	 */
-	onBeforeCreate?(next: Shape): Shape | void
+	isAspectRatioLocked(_shape: Shape): boolean {
+		return false
+	}
 
 	/**
-	 * A callback called just before a shape is updated. This method provides a last chance to modify
-	 * the updated shape.
-	 *
-	 * @example
-	 *
-	 * ```ts
-	 * onBeforeUpdate = (prev, next) => {
-	 * 	if (prev.x === next.x) {
-	 * 		return { ...next, x: next.x + 1 }
-	 * 	}
-	 * }
-	 * ```
+	 * Get the font faces that should be rendered in the document in order for this shape to render correctly.
 	 *
-	 * @param prev - The previous shape.
-	 * @param next - The next shape.
-	 * @returns The next shape or void.
+	 * @param shape - The shape.
 	 * @public
 	 */
-	onBeforeUpdate?(prev: Shape, next: Shape): Shape | void
+	getFontFaces(_shape: Shape): TLFontFace[] {
+		return EMPTY_ARRAY
+	}
 
 	/**
-	 * A callback called when a shape changes from a crop.
+	 * Return the text for ARIA live region.
 	 *
-	 * @param shape - The shape at the start of the crop.
-	 * @param info - Info about the crop.
-	 * @returns A change to apply to the shape, or void.
+	 * @param shape - The shape.
 	 * @public
 	 */
-	onCrop?(
-		shape: Shape,
-		info: TLCropInfo<Shape>
-	): Omit<TLShapePartial<Shape>, 'id' | 'type'> | undefined | void
+	getAriaDescriptor(_shape: Shape): string | undefined {
+		return undefined
+	}
 
 	/**
-	 * A callback called when some other shapes are dragged over this one.
-	 *
-	 * @example
-	 *
-	 * ```ts
-	 * onDragShapesOver = (shape, shapes) => {
-	 * 	this.editor.reparentShapes(shapes, shape.id)
-	 * }
-	 * ```
+	 * Get text for searching.
 	 *
 	 * @param shape - The shape.
-	 * @param shapes - The shapes that are being dragged over this one.
 	 * @public
 	 */
-	onDragShapesOver?(shape: Shape, shapes: TLShape[]): void
+	getText(_shape: Shape): string | undefined {
+		return undefined
+	}
 
 	/**
-	 * A callback called when some other shapes are dragged out of this one.
+	 * Get the shape's bounding box. If the shape defines a custom geometry that
+	 * includes padding (such as arrow shapes), use that geometry here.
 	 *
 	 * @param shape - The shape.
-	 * @param shapes - The shapes that are being dragged out.
 	 * @public
 	 */
-	onDragShapesOut?(shape: Shape, shapes: TLShape[]): void
+	getBounds(shape: Shape): Box {
+		return this.editor.getBounds(shape)
+	}
 
 	/**
-	 * A callback called when some other shapes are dropped over this one.
+	 * Expand the selection outline by a number of pixels or a Box.
 	 *
 	 * @param shape - The shape.
-	 * @param shapes - The shapes that are being dropped over this one.
 	 * @public
 	 */
-	onDropShapesOver?(shape: Shape, shapes: TLShape[]): void
+	expandSelectionOutlinePx(shape: Shape): number | Box {
+		return 0
+	}
 
 	/**
 	 * A callback called when a shape starts being resized.
@@ -553,7 +562,7 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	/**
 	 * A callback called when a shape changes from a resize.
 	 *
-	 * @param shape - The shape at the start of the resize.
+	 * @param shape - The shape.
 	 * @param info - Info about the resize.
 	 * @returns A change to apply to the shape, or void.
 	 * @public
@@ -602,16 +611,6 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 */
 	onTranslateEnd?(initial: Shape, current: Shape): TLShapePartial<Shape> | void
 
-	/**
-	 * A callback called when a shape's handle changes.
-	 *
-	 * @param shape - The current shape.
-	 * @param info - An object containing the handle and whether the handle is 'precise' or not.
-	 * @returns A change to apply to the shape, or void.
-	 * @public
-	 */
-	onHandleDrag?(shape: Shape, info: TLHandleDragInfo<Shape>): TLShapePartial<Shape> | void
-
 	/**
 	 * A callback called when a shape starts being rotated.
 	 *
@@ -642,11 +641,14 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	onRotateEnd?(initial: Shape, current: Shape): TLShapePartial<Shape> | void
 
 	/**
-	 * Not currently used.
+	 * A callback called when a shape's handle changes.
 	 *
-	 * @internal
+	 * @param shape - The shape.
+	 * @param info - An object containing the handle and whether the handle is 'precise' or not.
+	 * @returns A change to apply to the shape, or void.
+	 * @public
 	 */
-	onBindingChange?(shape: Shape): TLShapePartial<Shape> | void
+	onHandleDrag?(shape: Shape, info: TLHandleDragInfo<Shape>): TLShapePartial<Shape> | void
 
 	/**
 	 * A callback called when a shape's children change.
@@ -701,47 +703,90 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 * @public
 	 */
 	onEditEnd?(shape: Shape): void
-}
 
-/**
- * Info about a crop.
- * @param handle - The handle being dragged.
- * @param change - The distance the handle is moved.
- * @param initialShape - The shape at the start of the resize.
- * @public
- */
-export interface TLCropInfo<T extends TLShape> {
-	handle: SelectionHandle
-	change: Vec
-	crop: TLShapeCrop
-	uncroppedSize: { w: number; h: number }
-	initialShape: T
-}
+	/**
+	 * A callback called just before a shape is created. This method provides a last chance to modify
+	 * the created shape.
+	 *
+	 * @example
+	 *
+	 * ```ts
+	 * onBeforeCreate = (next) => {
+	 *     return { ...next, x: next.x + 1 }
+	 * }
+	 * ```
+	 *
+	 * @param next - The next shape.
+	 * @returns The next shape or void.
+	 * @public
+	 */
+	onBeforeCreate?(next: Shape): Shape | void
 
-/**
- * The type of resize.
- *
- * 'scale_shape' - The shape is being scaled, usually as part of a larger selection.
- *
- * 'resize_bounds' - The user is directly manipulating an individual shape's bounds using a resize
- * handle. It is up to shape util implementers to decide how they want to handle the two
- * situations.
- *
- * @public
- */
-export type TLResizeMode = 'scale_shape' | 'resize_bounds'
+	/**
+	 * A callback called just before a shape is updated. This method provides a last chance to modify
+	 * the updated shape.
+	 *
+	 * @example
+	 *
+	 * ```ts
+	 * onBeforeUpdate = (prev, next) => {
+	 *     if (prev.x === next.x) {
+	 *         return { ...next, x: next.x + 1 }
+	 *     }
+	 * }
+	 * ```
+	 *
+	 * @param prev - The previous shape.
+	 * @param next - The next shape.
+	 * @returns The next shape or void.
+	 * @public
+	 */
+	onBeforeUpdate?(prev: Shape, next: Shape): Shape | void
 
-/**
- * Info about a resize.
- * @param newPoint - The new local position of the shape.
- * @param handle - The handle being dragged.
- * @param mode - The type of resize.
- * @param scaleX - The scale in the x-axis.
- * @param scaleY - The scale in the y-axis.
- * @param initialBounds - The bounds of the shape at the start of the resize.
- * @param initialShape - The shape at the start of the resize.
- * @public
- */
+	/**
+	 * A callback called when some other shapes are dragged over this one.
+	 *
+	 * @example
+	 *
+	 * ```ts
+	 * onDragShapesOver = (shape, shapes) => {
+	 *     this.editor.reparentShapes(shapes, shape.id)
+	 * }
+	 * ```
+	 *
+	 * @param shape - The shape.
+	 * @param shapes - The shapes that are being dragged over this one.
+	 * @public
+	 */
+	onDragShapesOver?(shape: Shape, shapes: TLShape[]): void
+
+	/**
+	 * A callback called when some other shapes are dragged out of this one.
+	 *
+	 * @param shape - The shape.
+	 * @param shapes - The shapes that are being dragged out.
+	 * @public
+	 */
+	onDragShapesOut?(shape: Shape, shapes: TLShape[]): void
+
+	/**
+	 * A callback called when some other shapes are dropped over this one.
+	 *
+	 * @param shape - The shape.
+	 * @param shapes - The shapes that are being dropped over this one.
+	 * @public
+	 */
+	onDropShapesOver?(shape: Shape, shapes: TLShape[]): void
+
+	/**
+	 * Not currently used.
+	 *
+	 * @internal
+	 */
+	onBindingChange?(shape: Shape): TLShapePartial<Shape> | void
+}
+
+/** @public */
 export interface TLResizeInfo<T extends TLShape> {
 	newPoint: Vec
 	handle: TLResizeHandle
@@ -752,7 +797,8 @@ export interface TLResizeInfo<T extends TLShape> {
 	initialShape: T
 }
 
-/* -------------------- Dragging -------------------- */
+/** @public */
+export type TLResizeMode = 'scale_shape' | 'resize_bounds'
 
 /** @public */
 export interface TLHandleDragInfo<T extends TLShape> {
