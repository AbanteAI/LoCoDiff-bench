
index a2b4b4303..cfe4e359a 100644
--- a/qdrant_lib_segment_src_index_field_index_full_text_index_inverted_index.rs_expectedoutput.txt (expected):tmp/tmpbp3yp1q9_expected.txt	
+++ b/qdrant_lib_segment_src_index_field_index_full_text_index_inverted_index.rs_extracted.txt (actual):tmp/tmpa8tsj5jd_actual.txt	
@@ -1,6 +1,5 @@
 use std::collections::{BTreeSet, HashMap};
 
-use common::counter::hardware_counter::HardwareCounterCell;
 use common::types::PointOffsetType;
 use serde::{Deserialize, Serialize};
 
@@ -83,7 +82,6 @@ pub trait InvertedIndex {
         &mut self,
         idx: PointOffsetType,
         document: Document,
-        hw_counter: &HardwareCounterCell,
     ) -> OperationResult<()>;
 
     fn remove_document(&mut self, idx: PointOffsetType) -> bool;
@@ -91,17 +89,17 @@ pub trait InvertedIndex {
     fn filter<'a>(
         &'a self,
         query: ParsedQuery,
-        hw_counter: &'a HardwareCounterCell,
+        hw_counter: &'a common::counter::hardware_counter::HardwareCounterCell,
     ) -> Box<dyn Iterator<Item = PointOffsetType> + 'a>;
 
-    fn get_posting_len(&self, token_id: TokenId, hw_counter: &HardwareCounterCell)
+    fn get_posting_len(&self, token_id: TokenId, hw_counter: &common::counter::hardware_counter::HardwareCounterCell)
     -> Option<usize>;
 
     fn estimate_cardinality(
         &self,
         query: &ParsedQuery,
         condition: &FieldCondition,
-        hw_counter: &HardwareCounterCell,
+        hw_counter: &common::counter::hardware_counter::HardwareCounterCell,
     ) -> CardinalityEstimation {
         let points_count = self.points_count();
 
@@ -185,7 +183,7 @@ pub trait InvertedIndex {
         &self,
         parsed_query: &ParsedQuery,
         point_id: PointOffsetType,
-        hw_counter: &HardwareCounterCell,
+        hw_counter: &common::counter::hardware_counter::HardwareCounterCell,
     ) -> bool;
 
     fn values_is_empty(&self, point_id: PointOffsetType) -> bool;
@@ -194,7 +192,7 @@ pub trait InvertedIndex {
 
     fn points_count(&self) -> usize;
 
-    fn get_token_id(&self, token: &str, hw_counter: &HardwareCounterCell) -> Option<TokenId>;
+    fn get_token_id(&self, token: &str, hw_counter: &common::counter::hardware_counter::HardwareCounterCell) -> Option<TokenId>;
 }
 
 #[cfg(test)]
@@ -350,77 +348,4 @@ mod tests {
         }
 
         // Check same points count
-        assert_eq!(mmap.active_points_count, immutable.points_count);
-    }
-
-    #[test]
-    fn test_mmap_index_congruence() {
-        let indexed_count = 10000;
-        let deleted_count = 500;
-
-        let mut mutable = mutable_inverted_index(indexed_count, deleted_count);
-        let immutable = ImmutableInvertedIndex::from(mutable.clone());
-
-        let path = tempfile::tempdir().unwrap().into_path();
-
-        MmapInvertedIndex::create(path.clone(), immutable).unwrap();
-
-        let mut mmap_index = MmapInvertedIndex::open(path, false).unwrap();
-
-        let queries: Vec<_> = (0..100).map(|_| generate_query()).collect();
-
-        let mut_parsed_queries: Vec<_> = queries
-            .clone()
-            .into_iter()
-            .map(|query| to_parsed_query(query, |token| mutable.vocab.get(&token).copied()))
-            .collect();
-
-        let hw_counter = HardwareCounterCell::new();
-
-        let imm_parsed_queries: Vec<_> = queries
-            .into_iter()
-            .map(|query| {
-                to_parsed_query(query, |token| mmap_index.get_token_id(&token, &hw_counter))
-            })
-            .collect();
-
-        for (mut_query, imm_query) in mut_parsed_queries
-            .iter()
-            .cloned()
-            .zip(imm_parsed_queries.iter().cloned())
-        {
-            let mut_filtered = mutable.filter(mut_query, &hw_counter).collect::<Vec<_>>();
-            let imm_filtered = mmap_index
-                .filter(imm_query, &hw_counter)
-                .collect::<Vec<_>>();
-
-            assert_eq!(mut_filtered, imm_filtered);
-        }
-
-        // Delete random documents from both indexes
-
-        let points_to_delete: Vec<_> = (0..deleted_count)
-            .map(|_| rand::rng().random_range(0..indexed_count))
-            .collect();
-
-        for point_id in &points_to_delete {
-            mutable.remove_document(*point_id);
-            mmap_index.remove_document(*point_id);
-        }
-
-        // Check congruence after deletion
-
-        for (mut_query, imm_query) in mut_parsed_queries
-            .iter()
-            .cloned()
-            .zip(imm_parsed_queries.iter().cloned())
-        {
-            let mut_filtered = mutable.filter(mut_query, &hw_counter).collect::<Vec<_>>();
-            let imm_filtered = mmap_index
-                .filter(imm_query, &hw_counter)
-                .collect::<Vec<_>>();
-
-            assert_eq!(mut_filtered, imm_filtered);
-        }
-    }
-}
\ No newline at end of file
+        assert_eq!(mmap.active_points_count,
\ No newline at end of file
