--- qdrant_lib_segment_src_index_field_index_full_text_index_inverted_index.rs_expectedoutput.txt (expected)+++ qdrant_lib_segment_src_index_field_index_full_text_index_inverted_index.rs_extracted.txt (actual)@@ -195,232 +195,4 @@     fn points_count(&self) -> usize;
 
     fn get_token_id(&self, token: &str, hw_counter: &HardwareCounterCell) -> Option<TokenId>;
-}
-
-#[cfg(test)]
-mod tests {
-    use std::collections::BTreeSet;
-
-    use common::counter::hardware_counter::HardwareCounterCell;
-    use rand::Rng;
-    use rand::seq::SliceRandom;
-    use rstest::rstest;
-
-    use super::{InvertedIndex, ParsedQuery, TokenId};
-    use crate::index::field_index::full_text_index::immutable_inverted_index::ImmutableInvertedIndex;
-    use crate::index::field_index::full_text_index::mmap_inverted_index::MmapInvertedIndex;
-    use crate::index::field_index::full_text_index::mutable_inverted_index::MutableInvertedIndex;
-
-    fn generate_word() -> String {
-        let mut rng = rand::rng();
-
-        // Each word is 1 to 3 characters long
-        let len = rng.random_range(1..=3);
-        rng.sample_iter(rand::distr::Alphanumeric)
-            .take(len)
-            .map(char::from)
-            .collect()
-    }
-
-    fn generate_query() -> Vec<String> {
-        let mut rng = rand::rng();
-        let len = rng.random_range(1..=2);
-        (0..len).map(|_| generate_word()).collect()
-    }
-
-    fn to_parsed_query(
-        query: Vec<String>,
-        token_to_id: impl Fn(String) -> Option<TokenId>,
-    ) -> ParsedQuery {
-        let tokens: Vec<_> = query.into_iter().map(token_to_id).collect();
-        ParsedQuery { tokens }
-    }
-
-    fn mutable_inverted_index(indexed_count: u32, deleted_count: u32) -> MutableInvertedIndex {
-        let mut index = MutableInvertedIndex::default();
-
-        let hw_counter = HardwareCounterCell::new();
-
-        for idx in 0..indexed_count {
-            // Generate 10 tot 30-word documents
-            let doc_len = rand::rng().random_range(10..=30);
-            let tokens: BTreeSet<String> = (0..doc_len).map(|_| generate_word()).collect();
-            let document = index.document_from_tokens(&tokens);
-            index.index_document(idx, document, &hw_counter).unwrap();
-        }
-
-        // Remove some points
-        let mut points_to_delete = (0..indexed_count).collect::<Vec<_>>();
-        points_to_delete.shuffle(&mut rand::rng());
-        for idx in &points_to_delete[..deleted_count as usize] {
-            index.remove_document(*idx);
-        }
-
-        index
-    }
-
-    #[test]
-    fn test_mutable_to_immutable() {
-        let mutable = mutable_inverted_index(2000, 400);
-
-        let immutable = ImmutableInvertedIndex::from(mutable.clone());
-
-        assert!(immutable.vocab.len() < mutable.vocab.len());
-        assert!(immutable.postings.len() < mutable.postings.len());
-        assert!(!immutable.vocab.is_empty());
-
-        // Check that new vocabulary token ids leads to the same posting lists
-        assert!({
-            immutable.vocab.iter().all(|(key, new_token)| {
-                let new_posting = immutable
-                    .postings
-                    .get(*new_token as usize)
-                    .cloned()
-                    .unwrap();
-
-                let orig_token = mutable.vocab.get(key).unwrap();
-
-                let orig_posting = mutable
-                    .postings
-                    .get(*orig_token as usize)
-                    .cloned()
-                    .unwrap()
-                    .unwrap();
-
-                let new_contains_orig = orig_posting
-                    .iter()
-                    .all(|point_id| new_posting.reader().contains(point_id));
-
-                let orig_contains_new = new_posting
-                    .iter()
-                    .all(|point_id| orig_posting.contains(point_id));
-
-                new_contains_orig && orig_contains_new
-            })
-        });
-    }
-
-    #[rstest]
-    #[case(2000, 400)]
-    #[case(2000, 2000)]
-    #[case(1111, 1110)]
-    #[case(1111, 0)]
-    #[case(10, 2)]
-    #[case(0, 0)]
-    #[test]
-    fn test_immutable_to_mmap(#[case] indexed_count: u32, #[case] deleted_count: u32) {
-        let mutable = mutable_inverted_index(indexed_count, deleted_count);
-        let immutable = ImmutableInvertedIndex::from(mutable);
-
-        let path = tempfile::tempdir().unwrap().into_path();
-
-        MmapInvertedIndex::create(path.clone(), immutable.clone()).unwrap();
-
-        let hw_counter = HardwareCounterCell::new();
-
-        let mmap = MmapInvertedIndex::open(path, false).unwrap();
-
-        // Check same vocabulary
-        for (token, token_id) in immutable.vocab.iter() {
-            assert_eq!(mmap.get_token_id(token, &hw_counter), Some(*token_id));
-        }
-
-        // Check same postings
-        for (token_id, posting) in immutable.postings.iter().enumerate() {
-            let chunk_reader = mmap.postings.get(token_id as u32, &hw_counter).unwrap();
-
-            for point_id in posting.iter() {
-                assert!(chunk_reader.contains(point_id));
-            }
-        }
-
-        for (point_id, count) in immutable.point_to_tokens_count.iter().enumerate() {
-            // Check same deleted points
-            assert_eq!(
-                mmap.deleted_points.get(point_id).unwrap(),
-                count.is_none(),
-                "point_id: {point_id}"
-            );
-
-            // Check same count
-            assert_eq!(
-                *mmap.point_to_tokens_count.get(point_id).unwrap(),
-                count.unwrap_or(0)
-            );
-        }
-
-        // Check same points count
-        assert_eq!(mmap.active_points_count, immutable.points_count);
-    }
-
-    #[test]
-    fn test_mmap_index_congruence() {
-        let indexed_count = 10000;
-        let deleted_count = 500;
-
-        let mut mutable = mutable_inverted_index(indexed_count, deleted_count);
-        let immutable = ImmutableInvertedIndex::from(mutable.clone());
-
-        let path = tempfile::tempdir().unwrap().into_path();
-
-        MmapInvertedIndex::create(path.clone(), immutable).unwrap();
-
-        let mut mmap_index = MmapInvertedIndex::open(path, false).unwrap();
-
-        let queries: Vec<_> = (0..100).map(|_| generate_query()).collect();
-
-        let mut_parsed_queries: Vec<_> = queries
-            .clone()
-            .into_iter()
-            .map(|query| to_parsed_query(query, |token| mutable.vocab.get(&token).copied()))
-            .collect();
-
-        let hw_counter = HardwareCounterCell::new();
-
-        let imm_parsed_queries: Vec<_> = queries
-            .into_iter()
-            .map(|query| {
-                to_parsed_query(query, |token| mmap_index.get_token_id(&token, &hw_counter))
-            })
-            .collect();
-
-        for (mut_query, imm_query) in mut_parsed_queries
-            .iter()
-            .cloned()
-            .zip(imm_parsed_queries.iter().cloned())
-        {
-            let mut_filtered = mutable.filter(mut_query, &hw_counter).collect::<Vec<_>>();
-            let imm_filtered = mmap_index
-                .filter(imm_query, &hw_counter)
-                .collect::<Vec<_>>();
-
-            assert_eq!(mut_filtered, imm_filtered);
-        }
-
-        // Delete random documents from both indexes
-
-        let points_to_delete: Vec<_> = (0..deleted_count)
-            .map(|_| rand::rng().random_range(0..indexed_count))
-            .collect();
-
-        for point_id in &points_to_delete {
-            mutable.remove_document(*point_id);
-            mmap_index.remove_document(*point_id);
-        }
-
-        // Check congruence after deletion
-
-        for (mut_query, imm_query) in mut_parsed_queries
-            .iter()
-            .cloned()
-            .zip(imm_parsed_queries.iter().cloned())
-        {
-            let mut_filtered = mutable.filter(mut_query, &hw_counter).collect::<Vec<_>>();
-            let imm_filtered = mmap_index
-                .filter(imm_query, &hw_counter)
-                .collect::<Vec<_>>();
-
-            assert_eq!(mut_filtered, imm_filtered);
-        }
-    }
 }