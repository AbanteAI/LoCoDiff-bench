
index e8150f404..8ef861697 100644
--- a/react_packages_react-server_src_ReactServerStreamConfigBun.js_expectedoutput.txt (expected):tmp/tmpyaaws_5q_expected.txt	
+++ b/react_packages_react-server_src_ReactServerStreamConfigBun.js_extracted.txt (actual):tmp/tmphs617wdi_actual.txt	
@@ -21,6 +21,10 @@ export type PrecomputedChunk = string;
 export opaque type Chunk = string;
 export type BinaryChunk = $ArrayBufferView;
 
+// AsyncLocalStorage is not available in bun
+export const supportsRequestStorage = false;
+export const requestStorage = (null: any);
+
 export function scheduleWork(callback: () => void) {
   setTimeout(callback, 0);
 }
@@ -42,10 +46,10 @@ export function writeChunk(
   destination: Destination,
   chunk: PrecomputedChunk | Chunk | BinaryChunk,
 ): void {
-  if (chunk.length === 0) {
+  // $FlowFixMe[invalid-argument] - `length` is valid for strings, not binary chunks.
+  if (typeof chunk === 'string' && chunk.length === 0) {
     return;
   }
-
   destination.write(chunk);
 }
 
@@ -73,7 +77,7 @@ export function stringToPrecomputedChunk(content: string): PrecomputedChunk {
 export function typedArrayToBinaryChunk(
   content: $ArrayBufferView,
 ): BinaryChunk {
-  // TODO: Does this needs to be cloned if it's transferred in enqueue()?
+  // TODO: Does this need to be cloned if it's transferred in enqueue()?
   return content;
 }
 
@@ -85,18 +89,20 @@ export function byteLengthOfBinaryChunk(chunk: BinaryChunk): number {
   return chunk.byteLength;
 }
 
-export function closeWithError(destination: Destination, error: mixed): void {
+export function closeWithError(
+  destination: Destination,
+  error: mixed,
+): void {
   if (typeof destination.error === 'function') {
     // $FlowFixMe[incompatible-call]: This is an Error object or the destination accepts other types.
     destination.error(error);
   } else {
-    // Earlier implementations doesn't support this method. In that environment you're
-    // supposed to throw from a promise returned but we don't return a promise in our
-    // approach. We could fork this implementation but this is environment is an edge
-    // case to begin with. It's even less common to run this in an older environment.
-    // Even then, this is not where errors are supposed to happen and they get reported
-    // to a global callback in addition to this anyway. So it's fine just to close this.
-    destination.close();
+    // Earlier implementations didn't support this method.
+    // For edge cases we simply close the stream.
+    // $FlowFixMe[method-unbinding]
+    if (typeof destination.close === 'function') {
+      destination.close();
+    }
   }
 }
 
