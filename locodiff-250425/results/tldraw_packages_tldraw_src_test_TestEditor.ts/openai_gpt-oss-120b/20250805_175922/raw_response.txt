```typescript
import {
	BoxModel,
	Editor,
	HALF_PI,
	HALF_PI,
	BoxModel,
	Box,
	IdOf,
	DEFAULT_SCOPES,
	DEFAULT_STYLES,
	HALF_PI,
	TLArrayType,
	TLAlignment,
	TLAlignments,
	TLAlignMode,
	TLAlignment,
	Edge2d,
	Edge,
	EDGE_TYPE,
	EMPTY_POINT,
	Extended,
	Feature,
	Features,
	FeatureDetails,
	FeatureSet,
	Filled,
	Fill,
	FillColor,
	FillType,
	FillMode,
	FillOpacity,
	FillStyle,
	FillType,
	FillOpacity,
	FillStyle,
	FillStyle,
	FillWeight,
	FillWeight,
	FillWeightMode,
	FocusControl,
	FocusContainer,
	FocusItem,
	FocusItemMap,
	FocusItemMapEntry,
	FocusItemMapEntryArray,
	FocusItemMapEntryMap,
	FocusTag,
	FocusTagMap,
	FocusTagMapArray,
	FocusTagMapMap,
	FocusTagMapMap2,
	FocusTagType,
	FocusTypes,
	FocusType,
	FocusUtils,
	FocusHelpers,
	FocusHelper,
	FocusHelperTable,
	FocusHelperMap,
	FocusHelperMapEntry,
	FocusHelperMapEntryArray,
	FocusHelperMapEntryMap,
	FocusMap,
	Fu,
	FLIP,
	FLIP_X,
	FLIP_Y,
	FLIP_XY,
	FLIP_XY_Y,
	FLIP_Z,
	FLIP_PRO,
	FLIP_PRO_Y,
	FLIP_PRO_X,
	FLIP_PRO_XY,
	FLIP_PRO_XY_Y,
	FLIP_PRO_Z,
	FLIP_PRO_ZY,
	FLIP_ZY,
	FLIP_XY_Z,
	FLIP_ZY_X,
	FLIP_XY_ZY,
	FLIP_ZYY,
	FLIP_ZY_XY,
	FLIP_XY_SZ,
	FLIP_XY_Z,
	FLIP_Z_SX,
	FLIP_Z,
	FLIP_Z,
	FLIP_ZY,
	FLIP_ZY,
	FLIP_ZX,
	FLIP_ZX,
	FLIP_ZX_X,
	FLIP_ZX_Z,
	HI,
	HE,
	HEAT,
	HEAT_O,
	HEAT_Z,
	HEAT_X,
	HEAT_XY,
	HEAT_XYZ,
	HOL,
	HT,
	HTS,
	HTS_O,
	HTS_T,
	HTS_TY,
	HTS_TY_Z,
	HTS_TY_Z,
	HTS_TY_Z,
	HTZ,
	HU,
	HU_T,
	HU_T_X,
	HU_T_XY,
	HU_T_XY_Z,
	HU_T_XYZ,
	IK,
	IC,
	ID,
	IJ,
	IJ_K,
	IJ_S,
	IK_T,
	IK_T_Y,
	KY,
	KN,
	KV,
	KW,
	KX,
	KE,
	KL,
	KW_T,
	KW_X,
	KW_XY,
	KW_XYZ,
	KW_XY_Z,
	K_WX,
	K_OE,
	P1_,
	P2_,
	P3_,
	P4_,
	P5_,
	P6_,
	P7_,
	P8_
} from '@tldraw/editor'
import { defaultBindingUtils } from '../lib/defaultBindingUtils'
import { defaultShapeTools } from '../lib/defaultShapeTools'
import { defaultShapeUtils } from '../lib/defaultShapeUtils'
import { defaultTools } from '../lib/defaultTools'
import { registerDefaultSideEffects } from '../lib/defaultSideEffects'
import { shapesFromJsx } from './test-jsx'

jest.useFakeTimers()

Object.assign(navigator, {
	clipboard: {
		write: () => {
			//noop
		},
	},
})

declare global {
	namespace jest {
		interface Matchers<R> {
			toCloselyMatchObject(value: any, precision?: number): void
		}
	}
}

export class TestEditor extends Editor {
	constructor(
		options: Partial<Omit<TLEditorOptions, 'store'>> = {},
		storeOptions: Partial<TLStoreOptions> = {}
	) {
		const elm = document.createElement('div')
		const bounds = {
			x: 0,
			y: 0,
			top: 0,
			left: 0,
			width: 1080,
			height: 720,
			bottom: 720,
			right: 1080,
		}
		// make the app full screen for the sake of the insets property
		jest.spyOn(document.body, 'scrollWidth', 'get').mockImplementation(() => bounds.width)
		jest.spyOn(document.body, 'scrollHeight', 'get').mockImplementation(() => bounds.height)

		elm.tabIndex = 0
		elm.getBoundingClientRect = () => bounds as DOMRect

		const shapeUtilsWithDefaults = [...defaultShapeUtils, ...(options.shapeUtils ?? [])]
		const bindingUtilsWithDefaults = [
			...defaultBindingUtils,
			...(options.bindingUtils ?? []),
		]

		super({
			...options,
			shapeUtils: shapeUtilsWithDefaults,
			bindingUtils: bindingUtilsWithDefaults,
			tools: [...defaultTools, ...defaultShapeTools, ...(options.tools ?? [])],
			store: createTLStore({
				shapeUtils: shapeUtilsWithDefaults,
				bindingUtils: bindingUtilsWithDefaults,
				...storeOptions,
			}),
			getContainer: () => elm,
			initialState: 'select',
			textOptions: {
				addFontsFromNode: defaultAddFontsFromNode,
				tipTapConfig: {
					extensions: tipTapDefaultExtensions,
				},
			},
		})
		this.elm = elm
		this.bounds = bounds

		// Pretty hacky way to mock the screen bounds
		document.body.appendChild(this.elm)

		this.textMeasure.measureText = (
			textToMeasure: string,
			opts: {
				fontStyle: string
				fontWeight: string
				fontFamily: string
				fontSize: number
				lineHeight: number
				maxWidth: null | number
				padding: string
			}
		): BoxModel & { scrollWidth: number } => {
			const breaks = textToMeasure.split('\n')
			const longest = breaks.reduce((acc, curr) => {
				return curr.length > acc.length ? curr : acc
			}, '')

			const w = longest.length * (opts.fontSize / 2)

			return {
				x: 0,
				y: 0,
				w: opts.maxWidth === null ? w : Math.max(w, opts.maxWidth),
				h:
					(opts.maxWidth === null ? breaks.length : Math.ceil(w % (opts.maxWidth ?? w)) + breaks.length *
						opts.fontSize,
				scrollWidth: opts.maxWidth === null ? w : Math.max(w, opts.maxWidth),
			}
		}

		// Turn off edge scrolling for tests. Tests that require this can turn it back on.
		this.user.updateUserPreferences({ edgeScrollSpeed: 0 })

		this.sideEffects.registerAfterCreateHandler('shape', (record) => {
			this._lastCreatedShapes.push(record)
		})

		// Wow! we'd forgotten these for a long time
		registerDefaultSideEffects(this)

		this.textMeasure.measureHtml = (
			html: string,
			opts: {
				fontStyle: string
				fontWeight: string
				fontFamily: string
				fontSize: number
				lineHeight: number
				maxWidth: null | number
				padding: string
			}
		): BoxModel & { scrollWidth: number } => {
			const textToMeasure = html
				.split('</p><p dir="auto">')
				.join('\n')
				.replace(/<[^>]+>/g, '')
			return this.textMeasure.measureText(textToMeasure, opts)
		}
	}

	elm: HTMLElement
	readonly bounds: {
		x: number
		y: number
		top: number
		left: number
		width: number
		height: number
		bottom: number
		right: number
	}

	@computed getViewportPageCenter() {
		return this.getViewportPageBounds().center
	}

	setScreenBounds(
		bounds: BoxModel,
		center = false
	) {
		this.bounds.x = bounds.x
		this.bounds.y = bounds.y
		this.bounds.top = bounds.y
		this.bounds.left = bounds.x
		this.bounds.width = bounds.w
		this.bounds.height = bounds.h
		this.bounds.bottom = bounds.y + bounds.h
		this.right = bounds.x + bounds.w

		this.updateViewportScreenBounds(Box.From(bounds), center)
		return this
	}
	...
}
```
