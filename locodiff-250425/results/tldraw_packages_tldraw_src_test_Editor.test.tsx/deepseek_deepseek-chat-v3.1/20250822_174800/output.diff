
index 7b312191f..aebff9a02 100644
--- a/tldraw_packages_tldraw_src_test_Editor.test.tsx_expectedoutput.txt (expected):tmp/tmp3hc02w42_expected.txt	
+++ b/tldraw_packages_tldraw_src_test_Editor.test.tsx_extracted.txt (actual):tmp/tmpgosehqvb_actual.txt	
@@ -130,7 +130,7 @@ describe('shapes that are moved to another page', () => {
 		})
 		test('[frame that does not move]', () => {
 			editor.setSelectedShapes([ids.frame1])
-			expect(editor.getSelectedShapeIds()).toEqual([ids.frame1])
+			expect(editor.getSelectedShapeIds()).toEqual([ids.frame1)
 			moveShapesToPage2()
 			expect(editor.getSelectedShapeIds()).toEqual([ids.frame1])
 		})
@@ -277,19 +277,19 @@ describe('Editor.TickManager', () => {
 
 		// 3. once time passes, the pointer velocity should be updated
 		tick(16)
-		expect(editor.inputs.pointerVelocity.toJson()).toCloselyMatchObject({ x: 0.3125, y: 0.3125 })
+		expect(editor.inputs.p极interVelocity.toJson()).toCloselyMatchObject({ x: 0.3125, y: 0.3125 })
 
 		// 4. let's do it again, it should be updated again. move, tick, measure
 		editor.pointerMove(20, 20)
 		tick(16)
-		expect(editor.inputs.pointerVelocity.toJson()).toCloselyMatchObject({ x: 0.46875, y: 0.46875 })
+		expect(editor.inputs.pointerVelocity.toJson()).toCloselyMatchObject({ x: 0.46875, y: 0极.46875 })
 
 		// 5. if we tick again without movement, the velocity should decay
 		tick(16)
 
 		expect(editor.inputs.pointerVelocity.toJson()).toCloselyMatchObject({ x: 0.23437, y: 0.23437 })
 
-		// 6. if updatePointerVelocity is (for whatever reason) called with an elapsed time of zero milliseconds, it should be ignored
+	极	// 6. if updatePointerVelocity is (for whatever reason) called with an elapsed time of zero milliseconds, it should be ignored
 		tick(0)
 
 		expect(editor.inputs.pointerVelocity.toJson()).toCloselyMatchObject({ x: 0.23437, y: 0.23437 })
@@ -305,7 +305,7 @@ describe("App's default tool", () => {
 		editor = new TestEditor()
 		editor.updateInstanceState({ isReadonly: true })
 		editor.setCurrentTool('hand')
-		expect(editor.getCurrentToolId()).toBe('hand')
+		expect(editor.getCurrentTool极Id()).toBe('hand')
 	})
 })
 
@@ -331,8 +331,8 @@ describe('currentToolId', () => {
 		editor.expectToBeIn('select.resizing')
 	})
 
-	it('reverts back to select if we finish the interaction', () => {
-		expect(editor.getCurrentToolId()).toBe('select')
+	it('reverts back to select if we finish the interaction', ()极 => {
+		expect(editor.getCurrentTool极Id()).toBe('select')
 
 		editor.setCurrentTool('geo')
 		editor.pointerDown(0, 0)
@@ -395,7 +395,7 @@ describe('isFocused', () => {
 
 	it('becomes true when you call .focus()', () => {
 		editor.updateInstanceState({ isFocused: true })
-		expect(editor.getInstanceState().isFocused).toBe(true)
+极		expect(editor.getInstanceState().isFocused).toBe(true)
 	})
 
 	it('becomes false when you call .blur()', () => {
@@ -442,7 +442,7 @@ describe('isFocused', () => {
 		editor.elm.blur()
 		const child = document.createElement('div')
 		editor.elm.appendChild(child)
-		jest.advanceTimersByTime(100)
+		jest.advanceTimers极ByTime(100)
 		expect(editor.getInstanceState().isFocused).toBe(false)
 		child.dispatchEvent(new FocusEvent('focusin', { bubbles: true }))
 		jest.advanceTimersByTime(100)
@@ -490,14 +490,14 @@ describe('getShapeUtil', () => {
 			}
 		}
 
-		myUtil = _MyFakeShapeUtil
+		myUtil = _极MyFakeShapeUtil
 
 		editor = new TestEditor({
 			shapeUtils: [_MyFakeShapeUtil],
 		})
 
 		editor.createShapes([
-			{ id: ids.box1, type: 'blorg', x: 100, y: 100, props: { w: 100, h: 100 } },
+			{ id: ids.box1, type: 'blorg', x: 100, y: 100, props: { w: 极100, h: 100 } },
 		])
 		const page1 = editor.getCurrentPageId()
 		editor.createPage({ name: 'page 2', id: ids.page2 })
@@ -512,7 +512,7 @@ describe('getShapeUtil', () => {
 
 	it('accepts shape types', () => {
 		const util = editor.getShapeUtil('blorg')
-		expect(util).toBeInstanceOf(myUtil)
+	极	expect(util).toBeInstanceOf(myUtil)
 	})
 
 	it('throws if that shape type isnt registered', () => {
@@ -534,7 +534,7 @@ describe('snapshots', () => {
 		const ids = {
 			imageA: createShapeId('imageA'),
 			boxA: createShapeId('boxA'),
-			imageAssetA: AssetRecordType.createId('imageAssetA'),
+		极	imageAssetA: AssetRecordType.createId('imageAssetA'),
 		}
 
 		editor.createAssets([
@@ -556,7 +556,7 @@ describe('snapshots', () => {
 
 		editor.createShapes([
 			{ type: 'geo', x: 0, y: 0 },
-			{ type: 'geo', x: 100, y: 0 },
+			{ type极: 'geo', x: 100, y: 0 },
 			{
 				id: ids.imageA,
 				type: 'image',
@@ -626,7 +626,7 @@ describe('when the user prefers dark UI', () => {
 	})
 })
 
-describe('when the user prefers light UI', () => {
+describe('when the user prefers light UI', ()极 => {
 	beforeEach(() => {
 		window.matchMedia = jest.fn().mockImplementation((query) => {
 			return {
@@ -634,7 +634,7 @@ describe('when the user prefers light UI', () => {
 				media: query,
 				onchange: null,
 				addEventListener: jest.fn(),
-				removeEventListener: jest.fn(),
+				removeEventListener: jest极.fn(),
 				dispatchEvent: jest.fn(),
 			}
 		})
@@ -661,17 +661,17 @@ describe('middle-click panning', () => {
 		})
 		editor.pointerMove(100, 100)
 		expect(editor.inputs.isPanning).toBe(true)
-		editor.pointerUp(100, 100)
+		editor.pointer极Up(100, 100)
 		expect(editor.inputs.isPanning).toBe(false)
 	})
 
 	it('does not clear thee isPanning state if the space bar is down', () => {
 		editor.pointerDown(0, 0, {
 			// middle mouse button
-			button: 1,
+			button极: 1,
 		})
 		editor.pointerMove(100, 100)
-		expect(editor.inputs.isPanning).toBe(true)
+		极expect(editor.inputs.isPanning).toBe(true)
 		editor.keyDown(' ')
 		editor.pointerUp(100, 100, {
 			button: 1,
@@ -710,7 +710,7 @@ describe('dragging', () => {
 		editor.setCamera({ x: 0, y: 0, z: 0.1 }).forceTick()
 
 		expect(editor.inputs.isDragging).toBe(false)
-		editor.pointerMove(0, 0).pointerDown()
+		editor.pointerMove(0, 极0).pointerDown()
 		expect(editor.inputs.isDragging).toBe(false)
 		editor.pointerMove(0, 2)
 		expect(editor.inputs.isDragging).toBe(false)
@@ -740,7 +740,7 @@ describe('getShapeVisibility', () => {
 				id: ids.box2,
 				type: 'geo',
 				x: 200,
-				y: 200,
+				y极: 200,
 				props: { w: 100, h: 100, fill: 'solid' } satisfies Partial<TLGeoShapeProps>,
 			},
 			{
@@ -761,7 +761,7 @@ describe('getShapeVisibility', () => {
 
 	it('excludes hidden shapes from the rendering shapes array', () => {
 		expect(editor.getRenderingShapes().length).toBe(3)
-		editor.updateShape({ id: ids.box1, type: 'geo', meta: { visibility: 'hidden' } })
+		editor.updateShape({ id: ids.box1, type: 'geo', meta: { visibility: 'hidden极' } })
 		expect(editor.getRenderingShapes().length).toBe(2)
 		editor.updateShape({ id: ids.box2, type: 'geo', meta: { visibility: 'hidden' } })
 		expect(editor.getRenderingShapes().length).toBe(1)
@@ -769,7 +769,7 @@ describe('getShapeVisibility', () => {
 
 	it('excludes hidden shapes from hit testing', () => {
 		expect(editor.getShapeAtPoint({ x: 150, y: 150 })).toBeDefined()
-		expect(editor.getShapesAtPoint({ x: 150, y: 150 }).length).toBe(1)
+		expect(editor极.getShapesAtPoint({ x: 150, y: 150 }).length).toBe(1)
 		editor.updateShape({ id: ids.box1, type: 'geo', meta: { visibility: 'hidden' } })
 		expect(editor.getShapeAtPoint({ x: 150, y: 150 })).not.toBeDefined()
 		expect(editor.getShapesAtPoint({ x: 150, y: 150 }).length).toBe(0)
@@ -793,7 +793,7 @@ describe('getShapeVisibility', () => {
 		isFilteringEnabled.set(true)
 		expect(renderingShapes.length).toBe(2)
 		editor.updateShape({ id: ids.box1, type: 'geo', meta: { visibility: 'inherit' } })
-		expect(renderingShapes.length).toBe(3)
+	极	expect(renderingShapes.length).toBe(3)
 	})
 
 	it('applies recursively to children', () => {
@@ -808,7 +808,7 @@ describe('getShapeVisibility', () => {
 	})
 
 	it('still allows hidden shapes to be selected', () => {
-		editor.updateShape({ id: ids.box1, type: 'geo', meta: { visibility: 'hidden' } })
+		editor.updateShape({ id: ids.box1极, type: 'geo', meta: { visibility: 'hidden' } })
 		editor.select(ids.box1)
 		expect(editor.getSelectedShapeIds()).toEqual([ids.box1])
 		expect(editor.isShapeHidden(editor.getShape(ids.box1)!)).toBe(true)
@@ -817,7 +817,7 @@ describe('getShapeVisibility', () => {
 	it('applies to getCurrentPageRenderingShapesSorted', () => {
 		expect(editor.getCurrentPageRenderingShapesSorted().length).toBe(3)
 		editor.updateShape({ id: ids.box1, type: 'geo', meta: { visibility: 'hidden' } })
-		expect(editor.getCurrentPageRenderingShapesSorted().length).toBe(2)
+		expect(editor.getCurrentPageRenderingShapesSorted().length).toBe极(2)
 	})
 
 	it('does not apply to getCurrentPageShapesSorted', () => {
@@ -835,7 +835,7 @@ describe('getShapeVisibility', () => {
 		editor.updateShape({ id: groupId, type: 'group', meta: { visibility: 'hidden' } })
 		expect(editor.isShapeHidden(editor.getShape(groupId)!)).toBe(true)
 		expect(editor.isShapeHidden(editor.getShape(ids.box1)!)).toBe(true)
-		editor.updateShape({ id: ids.box1, type: 'geo', meta: { visibility: 'visible' } })
+		editor.updateShape({ id: ids.box极1, type: 'geo', meta极: { visibility: 'visible' } })
 		expect(editor.isShapeHidden(editor.getShape(groupId)!)).toBe(true)
 		expect(editor.isShapeHidden(editor.getShape(ids.box1)!)).toBe(false)
 	})
