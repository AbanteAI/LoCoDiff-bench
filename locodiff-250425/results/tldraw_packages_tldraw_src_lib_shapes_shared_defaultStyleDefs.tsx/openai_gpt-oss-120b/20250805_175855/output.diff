
index beaf60808..7cf0539ad 100644
--- a/tldraw_packages_tldraw_src_lib_shapes_shared_defaultStyleDefs.tsx_expectedoutput.txt (expected):tmp/tmpi4m5rgz2_expected.txt	
+++ b/tldraw_packages_tldraw_src_lib_shapes_shared_defaultStyleDefs.tsx_extracted.txt (actual):tmp/tmpghzfp8x9_actual.txt	
@@ -10,14 +10,11 @@ import {
 	suffixSafeId,
 	tlenv,
 	useEditor,
-	useSharedSafeId,
-	useUniqueSafeId,
 	useValue,
 } from '@tldraw/editor'
 import { useCallback, useEffect, useRef, useState } from 'react'
 import { useDefaultColorTheme } from './useDefaultColorTheme'
 
-/** @public */
 export function getFillDefForExport(fill: TLDefaultFillStyle): SvgExportDef {
 	return {
 		key: `${DefaultFontStyle.id}:${fill}`,
@@ -64,25 +61,47 @@ export function getFillDefForCanvas(): TLShapeUtilCanvasSvgDef {
 }
 const TILE_PATTERN_SIZE = 8
 
-const generateImage = (dpr: number, currentZoom: number, darkMode: boolean) => {
+export function getFillDefForExport(fill: TLDefaultFillStyle): SvgExportDef {
+	return {
+		key: `${DefaultFontStyle.id}:${fill}`,
+		async getElement() {
+			if (fill !== 'pattern') return null
+			return <HashPatternForExport />
+		},
+	}
+}
+
+export function getFillDefForCanvas(): TLShapeUtilCanvasSvgDef {
+	return {
+		key: `${DefaultFontStyle.id}:pattern`,
+		component: PatternFillDefForCanvas,
+	}
+}
+interface PatternDef {
+	zoom: number
+	url: string
+	theme: 'light' | 'dark'
+}
+function generateImage(dpr: number, currentZoom: number, darkMode: boolean) {
 	return new Promise<Blob>((resolve, reject) => {
 		const size = TILE_PATTERN_SIZE * currentZoom * dpr
 
-		const canvasEl = document.createElement('canvas')
-		canvasEl.width = size
-		canvasEl.height = size
+		const canvas = document.createElement('canvas')
+		canvas.width = size
+		canvas.height = size
 
-		const ctx = canvasEl.getContext('2d')
-		if (!ctx) return
+		const ctx = canvas.getContext('2d')
+		if (!ctx) {
+			reject()
+			return
+		}
 
 		ctx.fillStyle = darkMode
 			? DefaultColorThemePalette.darkMode.solid
 			: DefaultColorThemePalette.lightMode.solid
 		ctx.fillRect(0, 0, size, size)
 
-		// This essentially generates an inverse of the pattern we're drawing.
 		ctx.globalCompositeOperation = 'destination-out'
-
 		ctx.lineCap = 'round'
 		ctx.lineWidth = 1.25 * currentZoom * dpr
 
@@ -92,15 +111,13 @@ const generateImage = (dpr: number, currentZoom: number, darkMode: boolean) => {
 		ctx.beginPath()
 		ctx.moveTo(s(t * 1), s(t * 3))
 		ctx.lineTo(s(t * 3), s(t * 1))
-
-		ctx.moveTo(s(t * 5), s(t * 7))
+		ctx.moveTo(s(t * 5), t(t * 7))
 		ctx.lineTo(s(t * 7), s(t * 5))
-
 		ctx.moveTo(s(t * 9), s(t * 11))
 		ctx.lineTo(s(t * 11), s(t * 9))
 		ctx.stroke()
 
-		canvasEl.toBlob((blob) => {
+		canvas.toBlob((blob) => {
 			if (!blob || debugFlags.throwToBlob.get()) {
 				reject()
 			} else {
@@ -109,7 +126,6 @@ const generateImage = (dpr: number, currentZoom: number, darkMode: boolean) => {
 		})
 	})
 }
-
 const canvasBlob = (size: [number, number], fn: (ctx: CanvasRenderingContext2D) => void) => {
 	const canvas = document.createElement('canvas')
 	canvas.width = size[0]
@@ -119,13 +135,16 @@ const canvasBlob = (size: [number, number], fn: (ctx: CanvasRenderingContext2D)
 	fn(ctx)
 	return canvas.toDataURL()
 }
-interface PatternDef {
-	zoom: number
-	url: string
-	theme: 'light' | 'dark'
+function getPatternLodForZoomLevel(zoom: number) {
+	return Math.ceil(Math.log2(Math.max(1, zoom)))
+}
+export function useGetHashPatternZoomName() {
+	const id = useSharedSafeId('hash_pattern')
+	return useCallback((zoom: number, theme: TLDefaultColorTheme['id']) => {
+		const lod = getPatternLodForZoomLevel(zoom)
+		return suffixSafeId(id, `${theme}_${lod}`)
+	}, [id])
 }
-
-let defaultPixels: { white: string; black: string } | null = null
 function getDefaultPixels() {
 	if (!defaultPixels) {
 		defaultPixels = {
@@ -135,28 +154,21 @@ function getDefaultPixels() {
 			}),
 			black: canvasBlob([1, 1], (ctx) => {
 				ctx.fillStyle = '#212529'
-				ctx.fillRect(0, 0, 1, 1)
+				.fillRect(0, 0, 1, 1)
 			}),
 		}
 	}
 	return defaultPixels
 }
+let defaultPixels: { white: string; black: string } | null = null
 
-function getPatternLodForZoomLevel(zoom: number) {
-	return Math.ceil(Math.log2(Math.max(1, zoom)))
-}
-
-export function useGetHashPatternZoomName() {
-	const id = useSharedSafeId('hash_pattern')
-	return useCallback(
-		(zoom: number, theme: TLDefaultColorTheme['id']) => {
-			const lod = getPatternLodForZoomLevel(zoom)
-			return suffixSafeId(id, `${theme}_${lod}`)
-		},
-		[id]
-	)
+function getDefaultPatterns(maxZoom: number): PatternDef[] {
+	const defaultPixels = getDefaultPixels()
+	return getPatternLodsToGenerate(maxZoom).flatMap((zoom) => [
+		{ zoom, url: defaultPixels.white, theme: 'light' },
+		{ zoom, url: defaultPixels.black, theme: 'dark' },
+	])
 }
-
 function getPatternLodsToGenerate(maxZoom: number) {
 	const levels = []
 	const minLod = 0
@@ -166,27 +178,14 @@ function getPatternLodsToGenerate(maxZoom: number) {
 	}
 	return levels
 }
-
-function getDefaultPatterns(maxZoom: number): PatternDef[] {
-	const defaultPixels = getDefaultPixels()
-	return getPatternLodsToGenerate(maxZoom).flatMap((zoom) => [
-		{ zoom, url: defaultPixels.white, theme: 'light' },
-		{ zoom, url: defaultPixels.black, theme: 'dark' },
-	])
-}
-
 function usePattern() {
 	const editor = useEditor()
 	const dpr = useValue('devicePixelRatio', () => editor.getInstanceState().devicePixelRatio, [
 		editor,
 	])
-	const maxZoom = useValue('maxZoom', () => Math.ceil(last(editor.getCameraOptions().zoomSteps)!), [
-		editor,
-	])
+	const maxZoom = useValue('maxZoom', () => Math.ceil(last(editor.getCameraOptions().zoomSteps)!), [editor])
 	const [isReady, setIsReady] = useState(false)
-	const [backgroundUrls, setBackgroundUrls] = useState<PatternDef[]>(() =>
-		getDefaultPatterns(maxZoom)
-	)
+	const [backgroundUrls, setBackgroundUrls] = useState<PatternDef[]>(() => getDefaultPatterns(maxZoom))
 	const getHashPatternZoomName = useGetHashPatternZoomName()
 
 	useEffect(() => {
@@ -194,32 +193,20 @@ function usePattern() {
 			setIsReady(true)
 			return
 		}
-
-		const promise = Promise.all(
-			getPatternLodsToGenerate(maxZoom).flatMap<Promise<PatternDef>>((zoom) => [
-				generateImage(dpr, zoom, false).then((blob) => ({
-					zoom,
-					theme: 'light',
-					url: URL.createObjectURL(blob),
-				})),
-				generateImage(dpr, zoom, true).then((blob) => ({
-					zoom,
-					theme: 'dark',
-					url: URL.createObjectURL(blob),
-				})),
-			])
-		)
-
-		let isCancelled = false
-		promise.then((urls) => {
-			if (isCancelled) return
+		const promises = getPatternLodsToGenerate(maxZoom).flatMap<Promise<PatternDef>>((zoom) => [
+			generateImage(dpr, zoom, false).then((blob) => ({ zoom, theme: 'light' as const, url: URL.createObjectURL(blob) })),
+			generateImage(dpr, zoom, true).then((blob) => ({ zoom, theme: 'dark' as const, url: URL.createObjectURL(blob) })),
+		])
+		let cancelled = false
+		Promise.all(promises).then((urls) => {
+			if (cancelled) return
 			setBackgroundUrls(urls)
 			setIsReady(true)
 		})
 		return () => {
-			isCancelled = true
+			cancelled = true
 			setIsReady(false)
-			promise.then((patterns) => {
+			Promise.all(promises).then((patterns) => {
 				for (const { url } of patterns) {
 					URL.revokeObjectURL(url)
 				}
@@ -248,7 +235,6 @@ function usePattern() {
 
 	return { defs, isReady }
 }
-
 function PatternFillDefForCanvas() {
 	const editor = useEditor()
 	const containerRef = useRef<SVGGElement>(null)
@@ -258,28 +244,19 @@ function PatternFillDefForCanvas() {
 		if (isReady && tlenv.isSafari) {
 			const htmlLayer = findHtmlLayerParent(containerRef.current!)
 			if (htmlLayer) {
-				// Wait for `patternContext` to be picked up
 				editor.timers.requestAnimationFrame(() => {
 					htmlLayer.style.display = 'none'
-
-					// Wait for 'display = "none"' to take effect
 					editor.timers.requestAnimationFrame(() => {
 						htmlLayer.style.display = ''
 					})
 				})
 			}
 		}
-	}, [editor, isReady])
+	}, [isReady])
 
-	return (
-		<g ref={containerRef} data-testid={isReady ? 'ready-pattern-fill-defs' : undefined}>
-			{defs}
-		</g>
-	)
+	return <g ref={containerRef}>{defs}</g>
 }
-
 function findHtmlLayerParent(element: Element): HTMLElement | null {
 	if (element.classList.contains('tl-html-layer')) return element as HTMLElement
 	if (element.parentElement) return findHtmlLayerParent(element.parentElement)
-	return null
-}
\ No newline at end of file
+	return null
\ No newline at end of file
