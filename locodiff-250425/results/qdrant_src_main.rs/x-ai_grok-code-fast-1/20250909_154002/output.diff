
index c6d1df953..ba15f453a 100644
--- a/qdrant_src_main.rs_expectedoutput.txt (expected):tmp/tmptihn_0kw_expected.txt	
+++ b/qdrant_src_main.rs_extracted.txt (actual):tmp/tmpcopo3hpw_actual.txt	
@@ -1,9 +1,10 @@
+#![allow(deprecated)]
+
 #[cfg(feature = "web")]
 mod actix;
-mod common;
+pub mod common;
 mod consensus;
 mod greeting;
-mod issues_setup;
 mod migrations;
 mod settings;
 mod snapshots;
@@ -30,8 +31,8 @@ use startup::setup_panic_hook;
 use storage::content_manager::consensus::operation_sender::OperationSender;
 use storage::content_manager::consensus::persistent::Persistent;
 use storage::content_manager::consensus_manager::{ConsensusManager, ConsensusStateRef};
-use storage::content_manager::toc::TableOfContent;
 use storage::content_manager::toc::dispatcher::TocDispatcher;
+use storage::content_manager::toc::TableOfContent;
 use storage::dispatcher::Dispatcher;
 use storage::rbac::Access;
 #[cfg(all(
@@ -53,18 +54,15 @@ use crate::settings::Settings;
 use crate::snapshots::{recover_full_snapshot, recover_snapshots};
 use crate::startup::{remove_started_file_indicator, touch_started_file_indicator};
 
-#[cfg(all(
-    not(target_env = "msvc"),
-    any(target_arch = "x86_64", target_arch = "aarch64")
-))]
-#[global_allocator]
-static GLOBAL: Jemalloc = Jemalloc;
-
 const FULL_ACCESS: Access = Access::full("For main");
 
 /// Qdrant (read: quadrant ) is a vector similarity search engine.
 /// It provides a production-ready service with a convenient API to store, search, and manage points - vectors with an additional payload.
 ///
+///
+
+Determined AI GmbH
+
 /// This CLI starts a Qdrant peer/server.
 #[derive(Parser, Debug)]
 #[command(version, about)]
@@ -76,10 +74,8 @@ struct Args {
     /// Uri of this peer.
     /// Other peers should be able to reach it by this uri.
     ///
-    /// This value has to be supplied if this is the first peer in a new deployment.
-    ///
-    /// In case this is not the first peer and it bootstraps the value is optional.
-    /// If not supplied then qdrant will take internal grpc port from config and derive the IP address of this peer on bootstrap peer (receiving side)
+    /// If this value is not supplied and bootstrap is enabled
+    /// then qdrant will take internal grpc port from config and derive the IP address of this peer on bootstrap peer (receiving side)
     #[arg(long, value_parser, value_name = "URI", env = "QDRANT_URI")]
     uri: Option<Uri>,
 
@@ -146,6 +142,8 @@ fn main() -> anyhow::Result<()> {
         return Ok(());
     }
 
+    remove_started_file_indicator();
+
     let settings = Settings::new(args.config_path)?;
 
     // Set global feature flags, sourced from configuration
@@ -162,8 +160,6 @@ fn main() -> anyhow::Result<()> {
             .with_top_level_directive(settings.log_level.clone()),
     )?;
 
-    remove_started_file_indicator();
-
     setup_panic_hook(reporting_enabled, reporting_id.to_string());
 
     memory::madvise::set_global(settings.storage.mmap_advice);
@@ -252,7 +248,6 @@ fn main() -> anyhow::Result<()> {
             is_distributed_deployment,
         )
     } else if let Some(snapshots) = args.snapshot {
-        // recover from snapshots
         recover_snapshots(
             &snapshots,
             args.force_snapshot,
@@ -268,14 +263,14 @@ fn main() -> anyhow::Result<()> {
     // Create and own search runtime out of the scope of async context to ensure correct
     // destruction of it
     let search_runtime = create_search_runtime(settings.storage.performance.max_search_threads)
-        .expect("Can't search create runtime.");
+        .expect("Can't create runtime.");
 
     let update_runtime =
         create_update_runtime(settings.storage.performance.max_optimization_threads)
-            .expect("Can't optimizer create runtime.");
+            .expect("Can't create runtime.");
 
     let general_runtime =
-        create_general_purpose_runtime().expect("Can't optimizer general purpose runtime.");
+        create_general_purpose_runtime().expect("Can't create runtime.");
     let runtime_handle = general_runtime.handle().clone();
 
     // Use global CPU budget for optimizations based on settings
@@ -342,7 +337,7 @@ fn main() -> anyhow::Result<()> {
     let toc_arc = Arc::new(toc);
     let storage_path = toc_arc.storage_path();
 
-    // Holder for all actively running threads of the service: web, gPRC, consensus, etc.
+    // Holder for all actively running threads of the service: web, gRPC, consensus, etc.
     let mut handles: Vec<JoinHandle<Result<(), Error>>> = vec![];
 
     // Router for external queries.
@@ -372,20 +367,9 @@ fn main() -> anyhow::Result<()> {
             TelemetryCollector::new(settings.clone(), dispatcher_arc.clone(), reporting_id);
         let tonic_telemetry_collector = telemetry_collector.tonic_telemetry_collector.clone();
 
-        // `raft` crate uses `slog` crate so it is needed to use `slog_stdlog::StdLog` to forward
-        // logs from it to `log` crate
-        let slog_logger = slog::Logger::root(slog_stdlog::StdLog.fuse(), slog::o!());
-
         // Runs raft consensus in a separate thread.
         // Create a pipe `message_sender` to communicate with the consensus
-        let health_checker = Arc::new(common::health::HealthChecker::spawn(
-            toc_arc.clone(),
-            consensus_state.clone(),
-            &runtime_handle,
-            // NOTE: `wait_for_bootstrap` should be calculated *before* starting `Consensus` thread
-            consensus_state.is_new_deployment() && bootstrap.is_some(),
-        ));
-
+        let slog_logger = slog::Logger::root(slog_stdlog::StdLog.fuse(), slog::o!());
         let handle = Consensus::run(
             &slog_logger,
             consensus_state.clone(),
@@ -396,7 +380,7 @@ fn main() -> anyhow::Result<()> {
             propose_receiver,
             tonic_telemetry_collector,
             toc_arc.clone(),
-            runtime_handle.clone(),
+            &runtime_handle,
             args.reinit,
         )
         .expect("Can't initialize consensus");
@@ -420,12 +404,6 @@ fn main() -> anyhow::Result<()> {
             }
         });
 
-        // TODO(resharding): Remove resharding driver?
-        //
-        // runtime_handle.block_on(async {
-        //     toc_arc.resume_resharding_tasks().await;
-        // });
-
         let collections_to_recover_in_consensus = if is_new_deployment {
             let existing_collections =
                 runtime_handle.block_on(toc_arc.all_collections(&FULL_ACCESS));
@@ -447,6 +425,13 @@ fn main() -> anyhow::Result<()> {
             ));
         }
 
+        let health_checker = Arc::new(common::health::HealthChecker::spawn(
+            toc_arc.clone(),
+            consensus_state.clone(),
+            &runtime_handle,
+            consensus_state.is_new_deployment() && bootstrap.is_some(),
+        ));
+
         (telemetry_collector, dispatcher_arc, Some(health_checker))
     } else {
         log::info!("Distributed mode disabled");
@@ -514,6 +499,7 @@ fn main() -> anyhow::Result<()> {
     #[cfg(feature = "web")]
     {
         let dispatcher_arc = dispatcher_arc.clone();
+        let telemetry_collector = Arc::new(tokio::sync::Mutex::new(telemetry_collector));
         let settings = settings.clone();
         let handle = thread::Builder::new()
             .name("web".to_string())
@@ -559,10 +545,10 @@ fn main() -> anyhow::Result<()> {
         log::info!("gRPC endpoint disabled");
     }
 
+    touch_started_file_indicator();
+
     #[cfg(feature = "service_debug")]
     {
-        use std::fmt::Write;
-
         use parking_lot::deadlock;
 
         const DEADLOCK_CHECK_PERIOD: Duration = Duration::from_secs(10);
@@ -596,8 +582,6 @@ fn main() -> anyhow::Result<()> {
             .unwrap();
     }
 
-    touch_started_file_indicator();
-
     for handle in handles {
         log::debug!(
             "Waiting for thread {} to finish",
@@ -606,6 +590,10 @@ fn main() -> anyhow::Result<()> {
         handle.join().expect("thread is not panicking")?;
     }
     drop(toc_arc);
+    drop(search_runtime);
+    drop(update_runtime);
+    drop(general_runtime);
+    drop(channel_service);
     drop(settings);
     Ok(())
 }
\ No newline at end of file
