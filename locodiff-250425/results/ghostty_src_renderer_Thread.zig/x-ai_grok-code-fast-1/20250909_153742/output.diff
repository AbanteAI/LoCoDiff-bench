
index 11175f626..db76b9417 100644
--- a/ghostty_src_renderer_Thread.zig_expectedoutput.txt (expected):tmp/tmpykyx5gg8_expected.txt	
+++ b/ghostty_src_renderer_Thread.zig_extracted.txt (actual):tmp/tmpz3b4_4e1_actual.txt	
@@ -51,17 +51,21 @@ render_c: xev.Completion = .{},
 /// and are paused when the terminal is not focused.
 draw_h: xev.Timer,
 draw_c: xev.Completion = .{},
-draw_active: bool = false,
+
+/// The timer used for cursor blinking
+cursor_h: xev.Timer,
+cursor_c: xev.Completion = .{},
+cursor_c_cancel: xev.Completion = .{},
 
 /// This async is used to force a draw immediately. This does not
 /// coalesce like the wakeup does.
 draw_now: xev.Async,
 draw_now_c: xev.Completion = .{},
 
-/// The timer used for cursor blinking
-cursor_h: xev.Timer,
-cursor_c: xev.Completion = .{},
-cursor_c_cancel: xev.Completion = .{},
+/// This is true when a blinking cursor should be visible and false
+/// when it should not be visible. This is toggled on a timer by the
+/// thread automatically.
+cursor_blink_visible: bool = false,
 
 /// The surface we're rendering to.
 surface: *apprt.Surface,
@@ -365,8 +369,8 @@ fn drainMailbox(self: *Thread) !void {
                             &self.loop,
                             &self.cursor_c,
                             &self.cursor_c_cancel,
-                            void,
-                            null,
+                            Thread,
+                            self,
                             cursorCancelCallback,
                         );
                     }
@@ -377,7 +381,7 @@ fn drainMailbox(self: *Thread) !void {
                     // If we're focused, we immediately show the cursor again
                     // and then restart the timer.
                     if (self.cursor_c.state() != .active) {
-                        self.flags.cursor_blink_visible = true;
+                        self.cursor_blink_visible = true;
                         self.cursor_h.run(
                             &self.loop,
                             &self.cursor_c,
@@ -391,7 +395,7 @@ fn drainMailbox(self: *Thread) !void {
             },
 
             .reset_cursor_blink => {
-                self.flags.cursor_blink_visible = true;
+                self.cursor_blink_visible = true;
                 if (self.cursor_c.state() == .active) {
                     self.cursor_h.reset(
                         &self.loop,
@@ -507,15 +511,6 @@ fn wakeupCallback(
     // // If the timer is already active then we don't have to do anything.
     // if (t.render_c.state() == .active) return .rearm;
     //
-    // // Timer is not active, let's start it
-    // t.render_h.run(
-    //     &t.loop,
-    //     &t.render_c,
-    //     10,
-    //     Thread,
-    //     t,
-    //     renderCallback,
-    // );
 
     return .rearm;
 }
@@ -584,7 +579,7 @@ fn renderCallback(
     t.renderer.updateFrame(
         t.surface,
         t.state,
-        t.flags.cursor_blink_visible,
+        t.cursor_blink_visible,
     ) catch |err|
         log.warn("error rendering err={}", .{err});
 
@@ -616,7 +611,7 @@ fn cursorTimerCallback(
         return .disarm;
     };
 
-    t.flags.cursor_blink_visible = !t.flags.cursor_blink_visible;
+    t.cursor_blink_visible = !t.cursor_blink_visible;
     t.wakeup.notify() catch {};
 
     t.cursor_h.run(&t.loop, &t.cursor_c, CURSOR_BLINK_INTERVAL, Thread, t, cursorTimerCallback);
@@ -624,7 +619,7 @@ fn cursorTimerCallback(
 }
 
 fn cursorCancelCallback(
-    _: ?*void,
+    self_: ?*void,
     _: *xev.Loop,
     _: *xev.Completion,
     r: xev.Timer.CancelError!void,
@@ -649,12 +644,6 @@ fn cursorCancelCallback(
     return .disarm;
 }
 
-// fn prepFrameCallback(h: *libuv.Prepare) void {
-//     _ = h;
-//
-//     tracy.frameMark();
-// }
-
 fn stopCallback(
     self_: ?*Thread,
     _: *xev.Loop,
