
index 11175f626..c9f115728 100644
--- a/ghostty_src_renderer_Thread.zig_expectedoutput.txt (expected):tmp/tmpndrc08vh_expected.txt	
+++ b/ghostty_src_renderer_Thread.zig_extracted.txt (actual):tmp/tmp2s9_ngij_actual.txt	
@@ -16,9 +16,8 @@ const App = @import("../App.zig");
 
 const Allocator = std.mem.Allocator;
 const log = std.log.scoped(.renderer_thread);
-
-const DRAW_INTERVAL = 8; // 120 FPS
 const CURSOR_BLINK_INTERVAL = 600;
+const DRAW_INTERVAL = 8; // 120 FPS
 
 /// The type used for sending messages to the IO thread. For now this is
 /// hardcoded with a capacity. We can make this a comptime parameter in
@@ -28,6 +27,9 @@ pub const Mailbox = BlockingQueue(rendererpkg.Message, 64);
 /// Allocator used for some state
 alloc: std.mem.Allocator,
 
+/// Configuration we need derived from the main config.
+config: DerivedConfig,
+
 /// The main event loop for the application. The user data of this loop
 /// is always the allocator used to create the loop. This is a convenience
 /// so that users of the loop always have an allocator.
@@ -79,9 +81,6 @@ mailbox: *Mailbox,
 /// Mailbox to send messages to the app thread
 app_mailbox: App.Mailbox,
 
-/// Configuration we need derived from the main config.
-config: DerivedConfig,
-
 flags: packed struct {
     /// This is true when a blinking cursor should be visible and false
     /// when it should not be visible. This is toggled on a timer by the
@@ -137,23 +136,23 @@ pub fn init(
     var render_h = try xev.Timer.init();
     errdefer render_h.deinit();
 
-    // Draw timer, see comments.
+    // Draw timer.
     var draw_h = try xev.Timer.init();
     errdefer draw_h.deinit();
 
-    // Draw now async, see comments.
+    // Draw now async.
     var draw_now = try xev.Async.init();
     errdefer draw_now.deinit();
 
-    // Setup a timer for blinking the cursor
+    // Setup a timer for blinking the cursor.
     var cursor_timer = try xev.Timer.init();
     errdefer cursor_timer.deinit();
 
-    // The mailbox for messaging this thread
+    // The mailbox for messaging this thread.
     var mailbox = try Mailbox.create(alloc);
     errdefer mailbox.destroy(alloc);
 
-    return .{
+    return Thread{
         .alloc = alloc,
         .config = DerivedConfig.init(config),
         .loop = loop,
@@ -197,7 +196,6 @@ pub fn threadMain(self: *Thread) void {
 
 fn threadMain_(self: *Thread) !void {
     defer log.debug("renderer thread exited", .{});
-
     // Setup our crash metadata
     crash.sentry.thread_state = .{
         .type = .renderer,
@@ -205,7 +203,7 @@ fn threadMain_(self: *Thread) !void {
     };
     defer crash.sentry.thread_state = null;
 
-    // Setup our thread QoS
+    // Set our thread QoS
     self.setQosClass();
 
     // Run our loop start/end callbacks if the renderer cares.
@@ -213,12 +211,6 @@ fn threadMain_(self: *Thread) !void {
     if (has_loop) try self.renderer.loopEnter(self);
     defer if (has_loop) self.renderer.loopExit();
 
-    // Run our thread start/end callbacks. This is important because some
-    // renderers have to do per-thread setup. For example, OpenGL has to set
-    // some thread-local state since that is how it works.
-    try self.renderer.threadEnter(self.surface);
-    defer self.renderer.threadExit();
-
     // Start the async handlers
     self.wakeup.wait(&self.loop, &self.wakeup_c, Thread, self, wakeupCallback);
     self.stop.wait(&self.loop, &self.stop_c, Thread, self, stopCallback);
@@ -227,7 +219,10 @@ fn threadMain_(self: *Thread) !void {
     // Send an initial wakeup message so that we render right away.
     try self.wakeup.notify();
 
-    // Start blinking the cursor.
+    // Start the draw timer if needed.
+    self.startDrawTimer();
+
+    // Setup a timer for blinking the cursor.
     self.cursor_h.run(
         &self.loop,
         &self.cursor_c,
@@ -237,12 +232,9 @@ fn threadMain_(self: *Thread) !void {
         cursorTimerCallback,
     );
 
-    // Start the draw timer
-    self.startDrawTimer();
-
     // Run
     log.debug("starting renderer thread", .{});
-    defer log.debug("starting renderer thread shutdown", .{});
+    defer log.debug("exiting renderer thread", .{});
     _ = try self.loop.run(.until_done);
 }
 
@@ -254,10 +246,6 @@ fn setQosClass(self: *const Thread) void {
         // If we aren't visible (our view is fully occluded) then we
         // always drop our rendering priority down because it's just
         // mostly wasted work.
-        //
-        // The renderer itself should be doing this as well (for example
-        // Metal will stop our DisplayLink) but this also helps with
-        // general forced updates and CPU usage i.e. a rebuild cells call.
         if (!self.flags.visible) break :class .utility;
 
         // If we're not focused, but we're visible, then we set a higher
@@ -286,10 +274,10 @@ fn startDrawTimer(self: *Thread) void {
     // even checking the active state in case we have a pending shutdown.
     self.draw_active = true;
 
-    // If our draw timer is already active, then we don't have to do anything.
+    // If our draw timer is already active then we don't have to do anything.
     if (self.draw_c.state() == .active) return;
 
-    // Start the timer which loops
+    // Start the timer which loops.
     self.draw_h.run(
         &self.loop,
         &self.draw_c,
@@ -316,10 +304,10 @@ fn drainMailbox(self: *Thread) !void {
                 // If our state didn't change we do nothing.
                 if (self.flags.visible == v) break :visible;
 
-                // Set our visible state
+                // Set our visible state.
                 self.flags.visible = v;
 
-                // Visibility affects our QoS class
+                // Visibility affects our QoS class.
                 self.setQosClass();
 
                 // If we became visible then we immediately trigger a draw.
@@ -327,87 +315,22 @@ fn drainMailbox(self: *Thread) !void {
                 // still be happening.
                 if (v) self.drawFrame(false);
 
-                // Notify the renderer so it can update any state.
-                self.renderer.setVisible(v);
-
-                // Note that we're explicitly today not stopping any
-                // cursor timers, draw timers, etc. These things have very
-                // little resource cost and properly maintaining their active
-                // state across different transitions is going to be bug-prone,
-                // so its easier to just let them keep firing and have them
-                // check the visible state themselves to control their behavior.
+                // Notify the renderer.
+                try self.renderer.setVisible(v);
             },
 
             .focus => |v| focus: {
                 // If our state didn't change we do nothing.
                 if (self.flags.focused == v) break :focus;
 
-                // Set our state
+                // Set our state.
                 self.flags.focused = v;
 
-                // Focus affects our QoS class
+                // Focus affects our QoS class.
                 self.setQosClass();
 
-                // Set it on the renderer
+                // Set it on the renderer.
                 try self.renderer.setFocus(v);
-
-                if (!v) {
-                    if (self.config.custom_shader_animation != .always) {
-                        // Stop the draw timer
-                        self.stopDrawTimer();
-                    }
-
-                    // If we're not focused, then we stop the cursor blink
-                    if (self.cursor_c.state() == .active and
-                        self.cursor_c_cancel.state() == .dead)
-                    {
-                        self.cursor_h.cancel(
-                            &self.loop,
-                            &self.cursor_c,
-                            &self.cursor_c_cancel,
-                            void,
-                            null,
-                            cursorCancelCallback,
-                        );
-                    }
-                } else {
-                    // Start the draw timer
-                    self.startDrawTimer();
-
-                    // If we're focused, we immediately show the cursor again
-                    // and then restart the timer.
-                    if (self.cursor_c.state() != .active) {
-                        self.flags.cursor_blink_visible = true;
-                        self.cursor_h.run(
-                            &self.loop,
-                            &self.cursor_c,
-                            CURSOR_BLINK_INTERVAL,
-                            Thread,
-                            self,
-                            cursorTimerCallback,
-                        );
-                    }
-                }
-            },
-
-            .reset_cursor_blink => {
-                self.flags.cursor_blink_visible = true;
-                if (self.cursor_c.state() == .active) {
-                    self.cursor_h.reset(
-                        &self.loop,
-                        &self.cursor_c,
-                        &self.cursor_c_cancel,
-                        CURSOR_BLINK_INTERVAL,
-                        Thread,
-                        self,
-                        cursorTimerCallback,
-                    );
-                }
-            },
-
-            .font_grid => |grid| {
-                self.renderer.setFontGrid(grid.grid);
-                grid.set.deref(grid.old_key);
             },
 
             .foreground_color => |color| {
@@ -446,6 +369,21 @@ fn drainMailbox(self: *Thread) !void {
                     try self.renderer.setMacOSDisplayID(v);
                 }
             },
+
+            .reset_cursor_blink => {
+                self.flags.cursor_blink_visible = true;
+                if (self.cursor_c.state() == .active) {
+                    self.cursor_h.reset(
+                        &self.loop,
+                        &self.cursor_c,
+                        &self.cursor_c_cancel,
+                        CURSOR_BLINK_INTERVAL,
+                        Thread,
+                        self,
+                        cursorTimerCallback,
+                    );
+                }
+            },
         }
     }
 }
@@ -466,9 +404,7 @@ fn drawFrame(self: *Thread, now: bool) void {
 
     // If we're doing single-threaded GPU calls then we just wake up the
     // app thread to redraw at this point.
-    if (rendererpkg.Renderer == rendererpkg.OpenGL and
-        rendererpkg.OpenGL.single_threaded_draw)
-    {
+    if (rendererpkg.Renderer == rendererpkg.OpenGL and rendererpkg.OpenGL.single_threaded_draw) {
         _ = self.app_mailbox.push(
             .{ .redraw_surface = self.surface },
             .{ .instant = {} },
@@ -489,7 +425,6 @@ fn wakeupCallback(
         log.err("error in wakeup err={}", .{err});
         return .rearm;
     };
-
     const t = self_.?;
 
     // When we wake up, we check the mailbox. Mailbox producers should
@@ -500,23 +435,6 @@ fn wakeupCallback(
     // Render immediately
     _ = renderCallback(t, undefined, undefined, {});
 
-    // The below is not used anymore but if we ever want to introduce
-    // a configuration to introduce a delay to coalesce renders, we can
-    // use this.
-    //
-    // // If the timer is already active then we don't have to do anything.
-    // if (t.render_c.state() == .active) return .rearm;
-    //
-    // // Timer is not active, let's start it
-    // t.render_h.run(
-    //     &t.loop,
-    //     &t.render_c,
-    //     10,
-    //     Thread,
-    //     t,
-    //     renderCallback,
-    // );
-
     return .rearm;
 }
 
@@ -530,11 +448,8 @@ fn drawNowCallback(
         log.err("error in draw now err={}", .{err});
         return .rearm;
     };
-
-    // Draw immediately
     const t = self_.?;
     t.drawFrame(true);
-
     return .rearm;
 }
 
@@ -546,7 +461,6 @@ fn drawCallback(
 ) xev.CallbackAction {
     _ = r catch unreachable;
     const t: *Thread = self_ orelse {
-        // This shouldn't happen so we log it.
         log.warn("render callback fired without data set", .{});
         return .disarm;
     };
@@ -575,12 +489,9 @@ fn renderCallback(
         return .disarm;
     };
 
-    // If we have an inspector, let the app know we want to rerender that.
-    if (t.flags.has_inspector) {
-        _ = t.app_mailbox.push(.{ .redraw_inspector = t.surface }, .{ .instant = {} });
-    }
-
-    // Update our frame data
+    // Run our thread start/end callbacks. This is important because some
+    // renderers have to do per-thread setup. For example, OpenGL has to set
+    // some thread-local state since that is how it works.
     t.renderer.updateFrame(
         t.surface,
         t.state,
@@ -588,7 +499,7 @@ fn renderCallback(
     ) catch |err|
         log.warn("error rendering err={}", .{err});
 
-    // Draw
+    // Draw immediately
     t.drawFrame(false);
 
     return .disarm;
@@ -601,60 +512,37 @@ fn cursorTimerCallback(
     r: xev.Timer.RunError!void,
 ) xev.CallbackAction {
     _ = r catch |err| switch (err) {
-        // This is sent when our timer is canceled. That's fine.
         error.Canceled => return .disarm,
-
         else => {
             log.warn("error in cursor timer callback err={}", .{err});
             unreachable;
         },
     };
-
     const t: *Thread = self_ orelse {
         // This shouldn't happen so we log it.
         log.warn("render callback fired without data set", .{});
         return .disarm;
     };
 
+    // Toggle cursor blink visibility.
     t.flags.cursor_blink_visible = !t.flags.cursor_blink_visible;
-    t.wakeup.notify() catch {};
 
-    t.cursor_h.run(&t.loop, &t.cursor_c, CURSOR_BLINK_INTERVAL, Thread, t, cursorTimerCallback);
-    return .disarm;
-}
-
-fn cursorCancelCallback(
-    _: ?*void,
-    _: *xev.Loop,
-    _: *xev.Completion,
-    r: xev.Timer.CancelError!void,
-) xev.CallbackAction {
-    // This makes it easier to work across platforms where different platforms
-    // support different sets of errors, so we just unify it.
-    const CancelError = xev.Timer.CancelError || error{
-        Canceled,
-        NotFound,
-        Unexpected,
-    };
+    // Wake up the renderer to repaint.
+    t.wakeup.notify() catch {};
 
-    _ = r catch |err| switch (@as(CancelError, @errorCast(err))) {
-        error.Canceled => {}, // success
-        error.NotFound => {}, // completed before it could cancel
-        else => {
-            log.warn("error in cursor cancel callback err={}", .{err});
-            unreachable;
-        },
-    };
+    // Restart the timer.
+    t.cursor_h.run(
+        &t.loop,
+        &t.cursor_c,
+        CURSOR_BLINK_INTERVAL,
+        Thread,
+        t,
+        cursorTimerCallback,
+    );
 
     return .disarm;
 }
 
-// fn prepFrameCallback(h: *libuv.Prepare) void {
-//     _ = h;
-//
-//     tracy.frameMark();
-// }
-
 fn stopCallback(
     self_: ?*Thread,
     _: *xev.Loop,
