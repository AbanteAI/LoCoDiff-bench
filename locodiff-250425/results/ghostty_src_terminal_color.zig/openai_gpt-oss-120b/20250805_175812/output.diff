
index c8bb6a6aa..43c4a959e 100644
--- a/ghostty_src_terminal_color.zig_expectedoutput.txt (expected):tmp/tmpvbhjurzq_expected.txt	
+++ b/ghostty_src_terminal_color.zig_extracted.txt (actual):tmp/tmp_iybuzr6_actual.txt	
@@ -25,7 +25,6 @@ pub const default: Palette = default: {
                     .g = if (g == 0) 0 else (g * 40 + 55),
                     .b = if (b == 0) 0 else (b * 40 + 55),
                 };
-
                 i += 1;
             }
         }
@@ -68,7 +67,6 @@ pub const Name = enum(u8) {
     // Remainders are valid unnamed values in the 256 color palette.
     _,
 
-    /// Default colors for tagged values.
     pub fn default(self: Name) !RGB {
         return switch (self) {
             .black => RGB{ .r = 0x1D, .g = 0x1F, .b = 0x21 },
@@ -104,78 +102,22 @@ pub const RGB = packed struct(u24) {
         return self.r == other.r and self.g == other.g and self.b == other.b;
     }
 
-    /// Calculates the contrast ratio between two colors. The contrast
-    /// ration is a value between 1 and 21 where 1 is the lowest contrast
-    /// and 21 is the highest contrast.
-    ///
-    /// https://www.w3.org/TR/WCAG20/#contrast-ratiodef
-    pub fn contrast(self: RGB, other: RGB) f64 {
-        // pair[0] = lighter, pair[1] = darker
-        const pair: [2]f64 = pair: {
-            const self_lum = self.luminance();
-            const other_lum = other.luminance();
-            if (self_lum > other_lum) break :pair .{ self_lum, other_lum };
-            break :pair .{ other_lum, self_lum };
-        };
-
-        return (pair[0] + 0.05) / (pair[1] + 0.05);
-    }
-
-    /// Calculates luminance based on the W3C formula. This returns a
-    /// normalized value between 0 and 1 where 0 is black and 1 is white.
-    ///
-    /// https://www.w3.org/TR/WCAG20/#relativeluminancedef
-    pub fn luminance(self: RGB) f64 {
-        const r_lum = componentLuminance(self.r);
-        const g_lum = componentLuminance(self.g);
-        const b_lum = componentLuminance(self.b);
-        return 0.2126 * r_lum + 0.7152 * g_lum + 0.0722 * b_lum;
-    }
-
-    /// Calculates single-component luminance based on the W3C formula.
-    ///
-    /// Expects sRGB color space which at the time of writing we don't
-    /// generally use but it's a good enough approximation until we fix that.
-    /// https://www.w3.org/TR/WCAG20/#relativeluminancedef
-    fn componentLuminance(c: u8) f64 {
-        const c_f64: f64 = @floatFromInt(c);
-        const normalized: f64 = c_f64 / 255;
-        if (normalized <= 0.03928) return normalized / 12.92;
-        return std.math.pow(f64, (normalized + 0.055) / 1.055, 2.4);
-    }
-
-    /// Calculates "perceived luminance" which is better for determining
-    /// light vs dark.
-    ///
-    /// Source: https://www.w3.org/TR/AERT/#color-contrast
-    pub fn perceivedLuminance(self: RGB) f64 {
-        const r_f64: f64 = @floatFromInt(self.r);
-        const g_f64: f64 = @floatFromInt(self.g);
-        const b_f64: f64 = @floatFromInt(self.b);
-        return 0.299 * (r_f64 / 255) + 0.587 * (g_f64 / 255) + 0.114 * (b_f64 / 255);
-    }
-
+    // Compile‑time sanity checks.
     comptime {
         assert(@bitSizeOf(RGB) == 24);
         assert(@sizeOf(RGB) == 4);
     }
 
-    /// Parse a color from a floating point intensity value.
-    ///
-    /// The value should be between 0.0 and 1.0, inclusive.
+    // Parse a color from a floating‑point intensity value.
     fn fromIntensity(value: []const u8) !u8 {
         const i = std.fmt.parseFloat(f64, value) catch return error.InvalidFormat;
         if (i < 0.0 or i > 1.0) {
             return error.InvalidFormat;
         }
-
         return @intFromFloat(i * std.math.maxInt(u8));
     }
 
-    /// Parse a color from a string of hexadecimal digits
-    ///
-    /// The string can contain 1, 2, 3, or 4 characters and represents the color
-    /// value scaled in 4, 8, 12, or 16 bits, respectively.
+    // Parse a color from a string of hexadecimal digits.
     fn fromHex(value: []const u8) !u8 {
         if (value.len == 0 or value.len > 4) {
             return error.InvalidFormat;
@@ -189,35 +131,30 @@ pub const RGB = packed struct(u24) {
             4 => std.math.maxInt(u16),
             else => unreachable,
         };
-
         return @intCast(@as(usize, color) * std.math.maxInt(u8) / divisor);
     }
 
-    /// Parse a color specification.
+    /// Parse a color.
     ///
     /// Any of the following forms are accepted:
     ///
     /// 1. rgb:<red>/<green>/<blue>
-    ///
     ///    <red>, <green>, <blue> := h | hh | hhh | hhhh
     ///
-    ///    where `h` is a single hexadecimal digit.
-    ///
     /// 2. rgbi:<red>/<green>/<blue>
+    ///    where <red>, <green>, and <blue> are floating point values
+    ///    between 0.0 and 1.0 (inclusive).
     ///
-    ///    where <red>, <green>, and <blue> are floating point values between
-    ///    0.0 and 1.0 (inclusive).
-    ///
-    /// 3. #rgb, #rrggbb, #rrrgggbbb #rrrrggggbbbb
-    ///
+    /// 3. #rgb, #rrggbb, #rrrgggbbb, #rrrrggggbbbb
     ///    where `r`, `g`, and `b` are a single hexadecimal digit.
     ///    These specify a color with 4, 8, 12, and 16 bits of precision
     ///    per color channel.
     pub fn parse(value: []const u8) !RGB {
         if (value.len == 0) {
-            return error.InvalidFormat;
+                return error.InvalidFormat;
         }
 
+        // Hex literals.
         if (value[0] == '#') {
             switch (value.len) {
                 4 => return RGB{
@@ -240,78 +177,91 @@ pub const RGB = packed struct(u24) {
                     .g = try RGB.fromHex(value[5..9]),
                     .b = try RGB.fromHex(value[9..13]),
                 },
-
                 else => return error.InvalidFormat,
             }
         }
 
-        // Check for X11 named colors. We allow whitespace around the edges
-        // of the color because Kitty allows whitespace. This is not part of
-        // any spec I could find.
-        if (x11_color.map.get(std.mem.trim(u8, value, " "))) |rgb| return rgb;
+        // X11 named colors (trimmed for whitespace compatibility).
+        if (x11_color.map.get(std.mem.trim(u8, value, " "))) |rgb| {
+            return rgb;
+        }
 
+        // RGB integer/float formats.
         if (value.len < "rgb:a/ghostty_src_terminal_color.zig_expectedoutput.txt (expected): usize = 3;
 
-        const use_intensity = if (value[i] == 'i') blk: {
-            i += 1;
-            break :blk true;
-        } else false;
+        const use_intensity = if (value[i] == 'i') (i += 1; true) else false;
 
         if (value[i] != ':') {
             return error.InvalidFormat;
         }
-
         i += 1;
 
-        const r = r: {
-            const slice = if (std.mem.indexOfScalarPos(u8, value, i, '/')) |end|
-                value[i..end]
-            else
+        const r = blk: {
+            const end = std.mem.indexOfScalarPos(u8, value, i, '/') orelse
                 return error.InvalidFormat;
-
-            i += slice.len + 1;
-
-            break :r if (use_intensity)
-                try RGB.fromIntensity(slice)
-            else
-                try RGB.fromHex(slice);
+            const slice = value[i..end];
+            i = end + 1;
+            break :blk if (use_intensity) try RGB.fromIntensity(slice) else try RGB.fromHex(slice);
         };
 
-        const g = g: {
-            const slice = if (std.mem.indexOfScalarPos(u8, value, i, '/')) |end|
-                value[i..end]
-            else
+        const g = blk: {
+            const end = std.mem.indexOfScalarPos(u8, value, i, '/') orelse
                 return error.InvalidFormat;
+            const slice = value[i..end];
+            i = end + 1;
+            break :blk if (use_intensity) try RGB.fromIntensity(slice) else try RGB.fromHex(slice);
+        };
 
-            i += slice.len + 1;
+        const b = if (use_intensity) try RGB.fromIntensity(value[i..]) else try RGB.fromHex(value[i..]);
 
-            break :g if (use_intensity)
-                try RGB.fromIntensity(slice)
-            else
-                try RGB.fromHex(slice);
-        };
+        return RGB{ .r = r, .g = g, .b = b };
+    }
 
-        const b = if (use_intensity)
-            try RGB.fromIntensity(value[i..])
-        else
-            try RGB.fromHex(value[i..]);
+    /// Calculates luminance based on the W3C formula. Returns a normalized
+    /// value between 0 and 1 (0 = black, 1 = white).
+    pub fn luminance(self: RGB) f64 {
+        const r_lum = componentLuminance(self.r);
+        const g_lum = componentLuminance(self.g);
+        const b_lum = componentLuminance(self.b);
+        return 0.2126 * r_lum + 0.7152 * g_lum + 0.0722 * b_lum;
+    }
 
-        return RGB{
-            .r = r,
-            .g = g,
-            .b = b,
+    /// Calculates single‑component luminance based on the W3C formula.
+    fn componentLuminance(c: u8) f64 {
+        const c_f: f64 = @floatFromInt(c);
+        const norm = c_f / 255;
+        if (norm <= 0.03928) {
+            return norm / 12.92;
+        }
+        return std.math.pow(f64, (norm + 0.055) / 1.055, 2.4);
+    }
+
+    /// Calculates the contrast ratio between two colors.
+    /// The ratio is from 1 (lowest) to 21 (highest).
+    pub fn contrast(self: RGB, other: RGB) f64 {
+        const pair: [2]f64 = blk: {
+            const a = self.luminance();
+            const b = other.luminance();
+            if (a > b) break :blk .{ a, b } else break :blk .{ b, a };
         };
+        return (pair[0] + 0.05) / (pair[1] + 0.05);
+    }
+
+    /// Calculates perceived luminance (improved light/dark detection).
+    pub fn perceivedLuminance(self: RGB) f64 {
+        const r = @floatFromInt(self.r);
+        const g = @floatFromInt(self.g);
+        const b = @floatFromInt(self.b);
+        return 0.299 * (r / 255) + 0.587 * (g / 255) + 0.114 * (b / 255);
     }
 };
 
 test "palette: default" {
     const testing = std.testing;
-
-    // Safety check
     var i: u8 = 0;
     while (i < 16) : (i += 1) {
         try testing.expectEqual(Name.default(@as(Name, @enumFromInt(i))), default[i]);
@@ -325,17 +275,15 @@ test "RGB.parse" {
     try testing.expectEqual(RGB{ .r = 127, .g = 160, .b = 0 }, try RGB.parse("rgb:7f/a0a0/0"));
     try testing.expectEqual(RGB{ .r = 255, .g = 255, .b = 255 }, try RGB.parse("rgb:f/ff/fff"));
     try testing.expectEqual(RGB{ .r = 255, .g = 255, .b = 255 }, try RGB.parse("#ffffff"));
+    try testing.expectEqual(RGB{ .r = 255, .g = 0, .b = 16 }, try RGB.parse("#ff0010"));
     try testing.expectEqual(RGB{ .r = 255, .g = 255, .b = 255 }, try RGB.parse("#fff"));
     try testing.expectEqual(RGB{ .r = 255, .g = 255, .b = 255 }, try RGB.parse("#fffffffff"));
     try testing.expectEqual(RGB{ .r = 255, .g = 255, .b = 255 }, try RGB.parse("#ffffffffffff"));
-    try testing.expectEqual(RGB{ .r = 255, .g = 0, .b = 16 }, try RGB.parse("#ff0010"));
-
     try testing.expectEqual(RGB{ .r = 0, .g = 0, .b = 0 }, try RGB.parse("black"));
     try testing.expectEqual(RGB{ .r = 255, .g = 0, .b = 0 }, try RGB.parse("red"));
     try testing.expectEqual(RGB{ .r = 0, .g = 255, .b = 0 }, try RGB.parse("green"));
     try testing.expectEqual(RGB{ .r = 0, .g = 0, .b = 255 }, try RGB.parse("blue"));
     try testing.expectEqual(RGB{ .r = 255, .g = 255, .b = 255 }, try RGB.parse("white"));
-
     try testing.expectEqual(RGB{ .r = 124, .g = 252, .b = 0 }, try RGB.parse("LawnGreen"));
     try testing.expectEqual(RGB{ .r = 0, .g = 250, .b = 154 }, try RGB.parse("medium spring green"));
     try testing.expectEqual(RGB{ .r = 34, .g = 139, .b = 34 }, try RGB.parse(" Forest Green "));
@@ -345,6 +293,8 @@ test "RGB.parse" {
     try testing.expectError(error.InvalidFormat, RGB.parse("rgb:"));
     try testing.expectError(error.InvalidFormat, RGB.parse(":a/ghostty_src_terminal_color.zig_expectedoutput.txt (expected):a/ghostty_src_terminal_color.zig_expectedoutput.txt (expected):00000///"));
     try testing.expectError(error.InvalidFormat, RGB.parse("rgb:000/"));
@@ -356,4 +306,5 @@ test "RGB.parse" {
     try testing.expectError(error.InvalidFormat, RGB.parse("#ffff"));
     try testing.expectError(error.InvalidFormat, RGB.parse("#fffff"));
     try testing.expectError(error.InvalidFormat, RGB.parse("#gggggg"));
-}
\ No newline at end of file
+}
+```
\ No newline at end of file
