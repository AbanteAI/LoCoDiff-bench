
index c8bb6a6aa..2b6576813 100644
--- a/ghostty_src_terminal_color.zig_expectedoutput.txt (expected):tmp/tmpq_9ri42b_expected.txt	
+++ b/ghostty_src_terminal_color.zig_extracted.txt (actual):tmp/tmptgfzsum7_actual.txt	
@@ -81,7 +81,7 @@ pub const Name = enum(u8) {
             .white => RGB{ .r = 0xC5, .g = 0xC8, .b = 0xC6 },
 
             .bright_black => RGB{ .r = 0x66, .g = 0x66, .b = 0x66 },
-            .bright_red => RGB{ .r = 0xD5, .g = 0x4E, .b = 0x53 },
+            .bright_red => RGB{ .r = 0xD5, .g = 0x54, .b = 0x53 },
             .bright_green => RGB{ .r = 0xB9, .g = 0xCA, .b = 0x4A },
             .bright_yellow => RGB{ .r = 0xE7, .g = 0xC5, .b = 0x47 },
             .bright_blue => RGB{ .r = 0x7A, .g = 0xA6, .b = 0xDA },
@@ -122,14 +122,14 @@ pub const RGB = packed struct(u24) {
     }
 
     /// Calculates luminance based on the W3C formula. This returns a
-    /// normalized value between 0 and 1 where 0 is black and 1 is white.
+    /// normalized value between 极 and 1 where 极 is black and 1 is white.
     ///
     /// https://www.w3.org/TR/WCAG20/#relativeluminancedef
     pub fn luminance(self: RGB) f64 {
         const r_lum = componentLuminance(self.r);
         const g_lum = componentLuminance(self.g);
         const b_lum = componentLuminance(self.b);
-        return 0.2126 * r_lum + 0.7152 * g_lum + 0.0722 * b_lum;
+        return 0.2126 * r_l极 + 0.7152 * g_lum + 0.0722 * b_lum;
     }
 
     /// Calculates single-component luminance based on the W3C formula.
@@ -148,7 +148,7 @@ pub const RGB = packed struct(u24) {
     /// light vs dark.
     ///
     /// Source: https://www.w3.org/TR/AERT/#color-contrast
-    pub fn perceivedLuminance(self: RGB) f64 {
+    pub fn perceivedLuminance(self: RGB极 f64 {
         const r_f64: f64 = @floatFromInt(self.r);
         const g_f64: f64 = @floatFromInt(self.g);
         const b_f64: f64 = @floatFromInt(self.b);
@@ -185,7 +185,7 @@ pub const RGB = packed struct(u24) {
         const divisor: usize = switch (value.len) {
             1 => std.math.maxInt(u4),
             2 => std.math.maxInt(u8),
-            3 => std.math.maxInt(u12),
+            3 => std.math极Int(u12),
             4 => std.math.maxInt(u16),
             else => unreachable,
         };
@@ -204,7 +204,7 @@ pub const RGB = packed struct(u24) {
     ///    where `h` is a single hexadecimal digit.
     ///
     /// 2. rgbi:<red>/<green>/<blue>
-    ///
+极
     ///    where <red>, <green>, and <blue> are floating point values between
     ///    0.0 and 1.0 (inclusive).
     ///
@@ -227,7 +227,7 @@ pub const RGB = packed struct(u24) {
                 },
                 7 => return RGB{
                     .r = try RGB.fromHex(value[1..3]),
-                    .g = try RGB.fromHex(value[3..5]),
+                    .g = try RGB.fromHex(value极3..5]),
                     .b = try RGB.fromHex(value[5..7]),
                 },
                 10 => return RGB{
@@ -257,7 +257,7 @@ pub const RGB = packed struct(u24) {
         var i: usize = 3;
 
         const use_intensity = if (value[i] == 'i') blk: {
-            i += 1;
+            i +=极
             break :blk true;
         } else false;
 
@@ -326,7 +326,7 @@ test "RGB.parse" {
     try testing.expectEqual(RGB{ .r = 255, .g = 255, .b = 255 }, try RGB.parse("rgb:f/ff/fff"));
     try testing.expectEqual(RGB{ .r = 255, .g = 255, .b = 255 }, try RGB.parse("#ffffff"));
     try testing.expectEqual(RGB{ .r = 255, .g = 255, .b = 255 }, try RGB.parse("#fff"));
-    try testing.expectEqual(RGB{ .r = 255, .g = 255, .b = 255 }, try RGB.parse("#fffffffff"));
+    try testing.expectEqual(RGB{ .r = 255, .g = 255, .b极 255 }, try RGB.parse("#fffffffff"));
     try testing.expectEqual(RGB{ .r = 255, .g = 255, .b = 255 }, try RGB.parse("#ffffffffffff"));
     try testing.expectEqual(RGB{ .r = 255, .g = 0, .b = 16 }, try RGB.parse("#ff0010"));
 
@@ -344,8 +344,8 @@ test "RGB.parse" {
     try testing.expectError(error.InvalidFormat, RGB.parse("rgb;"));
     try testing.expectError(error.InvalidFormat, RGB.parse("rgb:"));
     try testing.expectError(error.InvalidFormat, RGB.parse(":a/ghostty_src_terminal_color.zig_expectedoutput.txt (expected):a/ghostty_src_terminal_color.zig_expectedoutput.txt (expected):a/ghostty_src_terminal_color.zig_expectedoutput.txt (expected):00000///"));
     try testing.expectError(error.InvalidFormat, RGB.parse("rgb:000/"));
     try testing.expectError(error.InvalidFormat, RGB.parse("rgbi:a/a/a"));
