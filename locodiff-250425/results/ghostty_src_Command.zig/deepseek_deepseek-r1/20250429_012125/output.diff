--- ghostty_src_Command.zig_expectedoutput.txt (expected)+++ ghostty_src_Command.zig_extracted.txt (actual)@@ -13,7 +13,6 @@ //!   * No pre_exec callback for logic after fork but before exec.
 //!   * posix_spawn is used for Mac, but doesn't support the necessary
 //!     features for tty setup.
-//!
 const Command = @This();
 
 const std = @import("std");
@@ -143,7 +142,7 @@     else
         @compileError("missing env vars");
 
-    // Fork. If we have a cgroup specified on Linxu then we use clone
+    // Fork. If we have a cgroup specified on Linux then we use clone
     const pid: posix.pid_t = switch (builtin.os.tag) {
         .linux => if (self.linux_cgroup) |cgroup|
             try internal_os.cgroup.cloneInto(cgroup)
@@ -449,7 +448,6 @@     return mode & 0o0111 != 0;
 }
 
-// `uname -n` is the *nix equivalent of `hostname.exe` on Windows
 test "expandPath: hostname" {
     const executable = if (builtin.os.tag == .windows) "hostname.exe" else "uname";
     const path = (try expandPath(testing.allocator, executable)).?;
@@ -486,6 +484,223 @@     std.debug.assert(i == envp_count);
 
     return envp_buf;
+}
+
+test "createNullDelimitedEnvMap" {
+    const allocator = testing.allocator;
+    var envmap = EnvMap.init(allocator);
+    defer envmap.deinit();
+
+    try envmap.put("HOME", "/home/ifreund");
+    try envmap.put("WAYLAND_DISPLAY", "wayland-1");
+    try envmap.put("DISPLAY", ":1");
+    try envmap.put("DEBUGINFOD_URLS", " ");
+    try envmap.put("XCURSOR_SIZE", "24");
+
+    var arena = std.heap.ArenaAllocator.init(allocator);
+    defer arena.deinit();
+    const environ = try createNullDelimitedEnvMap(arena.allocator(), &envmap);
+
+    try testing.expectEqual(@as(usize, 5), environ.len);
+
+    inline for (.{
+        "HOME=/home/ifreund",
+        "WAYLAND_DISPLAY=wayland-1",
+        "DISPLAY=:1",
+        "DEBUGINFOD_URLS= ",
+        "XCURSOR_SIZE=24",
+    }) |target| {
+        for (environ) |variable| {
+            if (mem.eql(u8, mem.span(variable orelse continue), target)) break;
+        } else {
+            try testing.expect(false); // Environment variable not found
+        }
+    }
+}
+
+test "Command: pre exec" {
+    if (builtin.os.tag == .windows) return error.SkipZigTest;
+    var cmd: Command = .{
+        .path = "/bin/sh",
+        .args = &.{ "/bin/sh", "-v" },
+        .pre_exec = (struct {
+            fn do_() void {}
+            pub const do = do_;
+            //fn do(_: *Command) void {
+                // This runs in the child, so we can exit and it won't
+                // kill the test runner.
+                //posix.exit(42);
+            //}
+        }).do,
+    };
+
+    try cmd.testingStart();
+    try testing.expect(cmd.pid != null);
+    const exit = try cmd.wait(true);
+    try testing.expect(exit == .Exited);
+    try testing.expect(exit.Exited == 42);
+}
+
+fn createTestStdout(dir: std.fs.Dir) !File {
+    const file = try dir.createFile("stdout.txt", .{ .read = true });
+    if (builtin.os.tag == .windows) {
+        try windows.SetHandleInformation(
+            file.handle,
+            windows.HANDLE_FLAG_INHERIT,
+            windows.HANDLE_FLAG_INHERIT,
+        );
+    }
+
+    return file;
+}
+
+test "Command: redirect stdout to file" {
+    var td = try TempDir.init();
+    defer td.deinit();
+    var stdout = try createTestStdout(td.dir);
+    defer stdout.close();
+
+    var cmd: Command = if (builtin.os.tag == .windows) .{
+        .path = "C:\\Windows\\System32\\whoami.exe",
+        .args = &.{"C:\\Windows\\System32\\whoami.exe"},
+        .stdout = stdout,
+    } else .{
+        .path = "/bin/sh",
+        .args = &.{ "/bin/sh", "-c", "echo hello" },
+        .stdout = stdout,
+    };
+
+    try cmd.testingStart();
+    try testing.expect(cmd.pid != null);
+    const exit = try cmd.wait(true);
+    try testing.expect(exit == .Exited);
+    try testing.expectEqual(@as(u32, 0), @as(u32, exit.Exited));
+
+    // Read our stdout
+    try stdout.seekTo(0);
+    const contents = try stdout.readToEndAlloc(testing.allocator, 1024 * 128);
+    defer testing.allocator.free(contents);
+    try testing.expect(contents.len > 0);
+}
+
+test "Command: custom env vars" {
+    var td = try TempDir.init();
+    defer td.deinit();
+    var stdout = try createTestStdout(td.dir);
+    defer stdout.close();
+
+    var env = EnvMap.init(testing.allocator);
+    defer env.deinit();
+    try env.put("VALUE", "hello");
+
+    var cmd: Command = if (builtin.os.tag == .windows) .{
+        .path = "C:\\Windows\\System32\\cmd.exe",
+        .args = &.{ "C:\\Windows\\System32\\cmd.exe", "/C", "echo %VALUE%" },
+        .stdout = stdout,
+        .env = &env,
+    } else .{
+        .path = "/bin/sh",
+        .args = &.{ "/bin/sh", "-c", "echo $VALUE" },
+        .stdout = stdout,
+        .env = &env,
+    };
+
+    try cmd.testingStart();
+    try testing.expect(cmd.pid != null);
+    const exit = try cmd.wait(true);
+    try testing.expect(exit == .Exited);
+    try testing.expect(exit.Exited == 0);
+
+    // Read our stdout
+    try stdout.seekTo(0);
+    const contents = try stdout.readToEndAlloc(testing.allocator, 4096);
+    defer testing.allocator.free(contents);
+
+    if (builtin.os.tag == .windows) {
+        try testing.expectEqualStrings("hello\r\n", contents);
+    } else {
+        try testing.expectEqualStrings("hello\n", contents);
+    }
+}
+
+test "Command: custom working directory" {
+    var td = try TempDir.init();
+    defer td.deinit();
+    var stdout = try createTestStdout(td.dir);
+    defer stdout.close();
+
+    var cmd: Command = if (builtin.os.tag == .windows) .{
+        .path = "C:\\Windows\\System32\\cmd.exe",
+        .args = &.{ "C:\\Windows\\System32\\cmd.exe", "/C", "cd" },
+        .stdout = stdout,
+        .cwd = "C:\\Windows\\System32",
+    } else .{
+        .path = "/bin/sh",
+        .args = &.{ "/bin/sh", "-c", "pwd" },
+        .stdout = stdout,
+        .cwd = "/tmp",
+    };
+
+    try cmd.testingStart();
+    try testing.expect(cmd.pid != null);
+    const exit = try cmd.wait(true);
+    try testing.expect(exit == .Exited);
+    try testing.expect(exit.Exited == 0);
+
+    // Read our stdout
+    try stdout.seekTo(0);
+    const contents = try stdout.readToEndAlloc(testing.allocator, 4096);
+    defer testing.allocator.free(contents);
+
+    if (builtin.os.tag == .windows) {
+        try testing.expectEqualStrings("C:\\Windows\\System32\r\n", contents);
+    } else if (builtin.os.tag == .macos) {
+        try testing.expectEqualStrings("/private/tmp\n", contents);
+    } else {
+        try testing.expectEqualStrings("/tmp\n", contents);
+    }
+}
+
+// Test validate an execveZ failure correctly terminates when error.ExecFailedInChild is correctly handled
+//
+// Incorrectly handling an error.ExecFailedInChild results in a second copy of the test process running.
+// Duplicating the test process leads to weird behavior
+// zig build test will hang
+// test binary created via -Demit-test-exe will run 2 copies of the test suite
+test "Command: posix fork handles execveZ failure" {
+    if (builtin.os.tag == .windows) {
+        return error.SkipZigTest;
+    }
+    var td = try TempDir.init();
+    defer td.deinit();
+    var stdout = try createTestStdout(td.dir);
+    defer stdout.close();
+
+    var cmd: Command = .{
+        .path = "/not/a/binary",
+        .args = &.{ "/not/a/binary", "" },
+        .stdout = stdout,
+        .cwd = "/bin",
+    };
+
+    try cmd.testingStart();
+    try testing.expect(cmd.pid != null);
+    const exit = try cmd.wait(true);
+    try testing.expect(exit == .Exited);
+    try testing.expect(exit.Exited == 1);
+}
+
+// If cmd.start fails with error.ExecFailedInChild it's the _child_ process that is running. If it does not
+// terminate in response to that error both the parent and child will continue as if they _are_ the test suite
+// process.
+fn testingStart(self: *Command) !void {
+    self.start(testing.allocator) catch |err| {
+        if (err == error.ExecFailedInChild) {
+            // I am a child process, I must not get confused and continue running the rest of the test suite.
+            posix.exit(1);
+        }
+        return err;
+    };
 }
 
 // Copied from Zig. This is a publicly exported function but there is no
@@ -527,7 +742,7 @@ }
 
 /// Copied from Zig. This function could be made public in child_process.zig instead.
-fn windowsCreateCommandLine(allocator: mem.Allocator, argv: []const []const u8) ![:0]u8 {
+fn windowsCreateCommandLine(allocator: mem.Allocator, argv: []const [:0]const u8) ![:0]u8 {
     var buf = std.ArrayList(u8).init(allocator);
     defer buf.deinit();
 
@@ -559,219 +774,4 @@     }
 
     return buf.toOwnedSliceSentinel(0);
-}
-
-test "createNullDelimitedEnvMap" {
-    const allocator = testing.allocator;
-    var envmap = EnvMap.init(allocator);
-    defer envmap.deinit();
-
-    try envmap.put("HOME", "/home/ifreund");
-    try envmap.put("WAYLAND_DISPLAY", "wayland-1");
-    try envmap.put("DISPLAY", ":1");
-    try envmap.put("DEBUGINFOD_URLS", " ");
-    try envmap.put("XCURSOR_SIZE", "24");
-
-    var arena = std.heap.ArenaAllocator.init(allocator);
-    defer arena.deinit();
-    const environ = try createNullDelimitedEnvMap(arena.allocator(), &envmap);
-
-    try testing.expectEqual(@as(usize, 5), environ.len);
-
-    inline for (.{
-        "HOME=/home/ifreund",
-        "WAYLAND_DISPLAY=wayland-1",
-        "DISPLAY=:1",
-        "DEBUGINFOD_URLS= ",
-        "XCURSOR_SIZE=24",
-    }) |target| {
-        for (environ) |variable| {
-            if (mem.eql(u8, mem.span(variable orelse continue), target)) break;
-        } else {
-            try testing.expect(false); // Environment variable not found
-        }
-    }
-}
-
-test "Command: pre exec" {
-    if (builtin.os.tag == .windows) return error.SkipZigTest;
-    var cmd: Command = .{
-        .path = "/bin/sh",
-        .args = &.{ "/bin/sh", "-v" },
-        .pre_exec = (struct {
-            fn do(_: *Command) void {
-                // This runs in the child, so we can exit and it won't
-                // kill the test runner.
-                posix.exit(42);
-            }
-        }).do,
-    };
-
-    try cmd.testingStart();
-    try testing.expect(cmd.pid != null);
-    const exit = try cmd.wait(true);
-    try testing.expect(exit == .Exited);
-    try testing.expect(exit.Exited == 42);
-}
-
-fn createTestStdout(dir: std.fs.Dir) !File {
-    const file = try dir.createFile("stdout.txt", .{ .read = true });
-    if (builtin.os.tag == .windows) {
-        try windows.SetHandleInformation(
-            file.handle,
-            windows.HANDLE_FLAG_INHERIT,
-            windows.HANDLE_FLAG_INHERIT,
-        );
-    }
-
-    return file;
-}
-
-test "Command: redirect stdout to file" {
-    var td = try TempDir.init();
-    defer td.deinit();
-    var stdout = try createTestStdout(td.dir);
-    defer stdout.close();
-
-    var cmd: Command = if (builtin.os.tag == .windows) .{
-        .path = "C:\\Windows\\System32\\whoami.exe",
-        .args = &.{"C:\\Windows\\System32\\whoami.exe"},
-        .stdout = stdout,
-    } else .{
-        .path = "/bin/sh",
-        .args = &.{ "/bin/sh", "-c", "echo hello" },
-        .stdout = stdout,
-    };
-
-    try cmd.testingStart();
-    try testing.expect(cmd.pid != null);
-    const exit = try cmd.wait(true);
-    try testing.expect(exit == .Exited);
-    try testing.expectEqual(@as(u32, 0), @as(u32, exit.Exited));
-
-    // Read our stdout
-    try stdout.seekTo(0);
-    const contents = try stdout.readToEndAlloc(testing.allocator, 1024 * 128);
-    defer testing.allocator.free(contents);
-    try testing.expect(contents.len > 0);
-}
-
-test "Command: custom env vars" {
-    var td = try TempDir.init();
-    defer td.deinit();
-    var stdout = try createTestStdout(td.dir);
-    defer stdout.close();
-
-    var env = EnvMap.init(testing.allocator);
-    defer env.deinit();
-    try env.put("VALUE", "hello");
-
-    var cmd: Command = if (builtin.os.tag == .windows) .{
-        .path = "C:\\Windows\\System32\\cmd.exe",
-        .args = &.{ "C:\\Windows\\System32\\cmd.exe", "/C", "echo %VALUE%" },
-        .stdout = stdout,
-        .env = &env,
-    } else .{
-        .path = "/bin/sh",
-        .args = &.{ "/bin/sh", "-c", "echo $VALUE" },
-        .stdout = stdout,
-        .env = &env,
-    };
-
-    try cmd.testingStart();
-    try testing.expect(cmd.pid != null);
-    const exit = try cmd.wait(true);
-    try testing.expect(exit == .Exited);
-    try testing.expect(exit.Exited == 0);
-
-    // Read our stdout
-    try stdout.seekTo(0);
-    const contents = try stdout.readToEndAlloc(testing.allocator, 4096);
-    defer testing.allocator.free(contents);
-
-    if (builtin.os.tag == .windows) {
-        try testing.expectEqualStrings("hello\r\n", contents);
-    } else {
-        try testing.expectEqualStrings("hello\n", contents);
-    }
-}
-
-test "Command: custom working directory" {
-    var td = try TempDir.init();
-    defer td.deinit();
-    var stdout = try createTestStdout(td.dir);
-    defer stdout.close();
-
-    var cmd: Command = if (builtin.os.tag == .windows) .{
-        .path = "C:\\Windows\\System32\\cmd.exe",
-        .args = &.{ "C:\\Windows\\System32\\cmd.exe", "/C", "cd" },
-        .stdout = stdout,
-        .cwd = "C:\\Windows\\System32",
-    } else .{
-        .path = "/bin/sh",
-        .args = &.{ "/bin/sh", "-c", "pwd" },
-        .stdout = stdout,
-        .cwd = "/tmp",
-    };
-
-    try cmd.testingStart();
-    try testing.expect(cmd.pid != null);
-    const exit = try cmd.wait(true);
-    try testing.expect(exit == .Exited);
-    try testing.expect(exit.Exited == 0);
-
-    // Read our stdout
-    try stdout.seekTo(0);
-    const contents = try stdout.readToEndAlloc(testing.allocator, 4096);
-    defer testing.allocator.free(contents);
-
-    if (builtin.os.tag == .windows) {
-        try testing.expectEqualStrings("C:\\Windows\\System32\r\n", contents);
-    } else if (builtin.os.tag == .macos) {
-        try testing.expectEqualStrings("/private/tmp\n", contents);
-    } else {
-        try testing.expectEqualStrings("/tmp\n", contents);
-    }
-}
-
-// Test validate an execveZ failure correctly terminates when error.ExecFailedInChild is correctly handled
-//
-// Incorrectly handling an error.ExecFailedInChild results in a second copy of the test process running.
-// Duplicating the test process leads to weird behavior
-// zig build test will hang
-// test binary created via -Demit-test-exe will run 2 copies of the test suite
-test "Command: posix fork handles execveZ failure" {
-    if (builtin.os.tag == .windows) {
-        return error.SkipZigTest;
-    }
-    var td = try TempDir.init();
-    defer td.deinit();
-    var stdout = try createTestStdout(td.dir);
-    defer stdout.close();
-
-    var cmd: Command = .{
-        .path = "/not/a/binary",
-        .args = &.{ "/not/a/binary", "" },
-        .stdout = stdout,
-        .cwd = "/bin",
-    };
-
-    try cmd.testingStart();
-    try testing.expect(cmd.pid != null);
-    const exit = try cmd.wait(true);
-    try testing.expect(exit == .Exited);
-    try testing.expect(exit.Exited == 1);
-}
-
-// If cmd.start fails with error.ExecFailedInChild it's the _child_ process that is running. If it does not
-// terminate in response to that error both the parent and child will continue as if they _are_ the test suite
-// process.
-fn testingStart(self: *Command) !void {
-    self.start(testing.allocator) catch |err| {
-        if (err == error.ExecFailedInChild) {
-            // I am a child process, I must not get confused and continue running the rest of the test suite.
-            posix.exit(1);
-        }
-        return err;
-    };
 }