```zig
const SharedDeps = @This();

const std = @import("std");
const Config = @import("Config.zig");
const HelpStrings = @import("HelpStrings.zig");
const MetallibStep = @import("MetallibStep.zig");
const UnicodeTables = @import("UnicodeTables.zig");
const GhosttyFrameData = @import("GhosttyFrameData.zig");
const DistResource = @import("GhosttyDist.zig").Resource;

const gresource = @import("../apprt/gtk/gresource.zig");

config: *const Config,
options: *std.Build.Step.Options,
help_strings: HelpStrings,
metallib: ?*MetallibStep,
unicode_tables: UnicodeTables,
framedata: GhosttyFrameData,

/// Used to keep track of a list of file sources.
pub const LazyPathList = std.ArrayList(std.Build.LazyPath);

pub fn init(b: *std.Build, cfg: *const Config) !SharedDeps {
    var result: SharedDeps = .{
        .config = cfg,
        .help_strings = try HelpStrings.init(b, cfg),
        .unicode_tables = try UnicodeTables.init(b),
        .framedata = try GhosttyFrameData.init(b),
        .options = undefined,
        .metallib = undefined,
    };
    try result.initTarget(b, cfg.target);
    return result;
}

pub fn retarget(
    self: *const SharedDeps,
    b: *std.Build,
    target: std.Build.ResolvedTarget,
) !SharedDeps {
    var result = self.*;
    try result.initTarget(b, target);
    return result;
}

pub fn changeEntrypoint(
    self: *const SharedDeps,
    b: *std.Build,
    entrypoint: Config.ExeEntrypoint,
) !SharedDeps {
    const config = try b.allocator.create(Config);
    config.* = self.config.*;
    config.exe_entrypoint = entrypoint;

    var result = self.*;
    result.config = config;
    return result;
}

fn initTarget(
    self: *SharedDeps,
    b: *std.Build,
    target: std.Build.ResolvedTarget,
) !void {
    self.metallib = MetallibStep.create(b, .{
        .name = "Ghostty",
        .target = target,
        .sources = &.{b.path("src/renderer/shaders/cell.metal")},
    });

    const config = try b.allocator.create(Config);
    config.* = self.config.*;
    config.target = target;
    self.config = config;

    self.options = b.addOptions();
    try self.config.addOptions(self.options);
}

pub fn add(
    self: *const SharedDeps,
    step: *std.Build.Step.Compile,
) !LazyPathList {
    const b = step.step.owner;

    // We could use our config.target/optimize fields here but its more
    // correct to always match our step.
    const target = step.root_module.resolved_target.?;
    const optimize = step.root_module.optimize.?;

    // We maintain a list of our static libraries and return it so that
    // we can build a single fat static library for the final app.
    var static_libs = LazyPathList.init(b.allocator);
    errdefer static_libs.deinit();

    // Every exe gets build options populated
    step.root_module.addOptions("build_options", self.options);

    // Freetype
    _ = b.systemIntegrationOption("freetype", .{}); // Shows it in help
    if (self.config.font_backend.hasFreetype()) {
        if (b.lazyDependency("freetype", .{
            .target = target,
            .optimize = optimize,
            .@"enable-libpng" = true,
        })) |freetype_dep| {
            step.root_module.addImport("freetype", freetype_dep.module("freetype"));
            if (b.systemIntegrationOption("freetype", .{})) {
                step.linkSystemLibrary2("bzip2", dynamic_link_opts);
                step.linkSystemLibrary2("freetype2", dynamic_link_opts);
            } else {
                step.linkLibrary(freetype_dep.artifact("freetype"));
                try static_libs.append(freetype_dep.artifact("freetype").getEmittedBin());
                _ = static_libs;
            }
        }
    }

    // Harfbuzz
    _ = b.systemIntegrationOption("harfbuzz", .{});
    if (self.config.font_backend.hasHarfbuzz()) {
        if (b.lazyDependency("harfbuzz", .{
            .target = target,
            .optimize = optimize,
            .@"enable-freetype" = true,
            .@"enable-coretext" = self.config.font_backend.hasCoretext(),
        })) |harfbuzz_dep| {
            step.root_module.addImport("harfbuzz", harfbuzz_dep.module("harfbuzz"));
            if (b.systemIntegrationOption("harfbuzz", .{})) {
                step.linkSystemLibrary2("harfbuzz", dynamic_link_opts);
            } else {
                step.linkLibrary(harfbuzz_dep.artifact("harfbuzz"));
                try static_libs.append(harfbuzz_dep.artifact("harfbuzz").getEmittedBin());
                _ = static_libs;
            }
        }
    }

    // Fontconfig
    _ = b.systemIntegrationOption("fontconfig", .{});
    if (self.config.font_backend.hasFontconfig()) {
        if (b.lazyDependency("fontconfig", .{
            .target = target,
            .optimize = optimize,
        })) |fontconfig_dep| {
            step.root_module.addImport("fontconfig", fontconfig_dep.module("fontconfig"));
            if (b.systemIntegrationOption("fontconfig", .{})) {
                step.linkSystemLibrary2("fontconfig", dynamic_link_opts);
            } else {
                step.linkLibrary(fontconfig_dep.artifact("fontconfig"));
                try static_libs.append(fontconfig_dep.artifact("fontconfig").getEmittedBin());
                _ = static_libs;
            }
        }
    }

    // Libpng
    if (!b.systemIntegrationOption("libpng", .{})) {
        if (b.lazyDependency("libpng", .{
            .target = target,
            .optimize = optimize,
        })) |png_dep| {
            step.linkLibrary(png_dep.artifact("png"));
            try static_libs.append(png_dep.artifact("png").getEmittedBin());
            _ = static_libs;
        }
    }

    // Zlib
    if (!b.systemIntegrationOption("zlib", .{})) {
        if (b.lazyDependency("zlib", .{
            .target = target,
            .optimize = optimize,
        })) |zlib_dep| {
            step.linkLibrary(zlib_dep.artifact("z"));
            try static_libs.append(zlib_dep.artifact("z").getEmittedBin());
            _ = static_libs;
        }
    }

    // Oniguruma
    if (b.lazyDependency("oniguruma", .{
        .target = target,
        .optimize = optimize,
    })) |onig_dep| {
        step.root_module.addImport("oniguruma", onig_dep.module("oniguruma"));
        if (b.systemIntegrationOption("oniguruma", .{})) {
            step.linkSystemLibrary2("oniguruma", dynamic_link_opts);
        } else {
            step.linkLibrary(onig_dep.artifact("oniguruma"));
            try static_libs.append(onig_dep.artifact("oniguruma").getEmittedBin());
            _ = static_libs;
        }
    }

    // Glslang
    if (b.lazyDependency("glslang", .{
        .target = target,
        .optimize = optimize,
    })) |glslang_dep| {
        step.root_module.addImport("glslang", glslang_dep.module("glslang"));
        if (b.systemIntegrationOption("glslang", .{})) {
            step.linkSystemLibrary2("glslang", dynamic_link_opts);
            step.linkSystemLibrary2("glslang-default-resource-limits", dynamic_link_opts);
        } else {
            step.linkLibrary(glslang_dep.artifact("glslang"));
            try static_libs.append(glslang_dep.artifact("glslang").getEmittedBin());
            _ = static_libs;
        }
    }

    // Spirv-cross
    if (b.lazyDependency("spirv_cross", .{
        .target = target,
        .optimize = optimize,
    })) |spvc_dep| {
        step.root_module.addImport("spirv_cross", spvc_dep.module("spirv_cross"));
        if (b.systemIntegrationOption("spirv-cross", .{})) {
            step.linkSystemLibrary2("spirv-cross", dynamic_link_opts);
        } else {
            step.linkLibrary(spvc_dep.artifact("spirv_cross"));
            try static_libs.append(spvc_dep.artifact("spirv_cross").getEmittedBin());
            _ = static_libs;
        }
    }

    // Simdutf
    if (b.systemIntegrationOption("simdutf", .{})) {
        step.linkSystemLibrary2("simdutf", dynamic_link_opts);
    } else {
        if (b.lazyDependency("simdutf", .{
            .target = target,
            .optimize = optimize,
        })) |simdutf_dep| {
            step.linkLibrary(simdutf_dep.artifact("simdutf"));
            try static_libs.append(simdutf_dep.artifact("simdutf").getEmittedBin());
            _ = static_libs;
        }
    }

    // Sentry
    if (self.config.sentry) {
        if (b.lazyDependency("sentry", .{
            .target = target,
            .optimize = optimize,
            .backend = .breakpad,
        })) |sentry_dep| {
            step.root_module.addImport("sentry", sentry_dep.module("sentry"));
            step.linkLibrary(sentry_dep.artifact("sentry"));
            try static_libs.append(sentry_dep.artifact("sentry").getEmittedBin());
            _ = static_libs;

            if (sentry_dep.builder.lazyDependency("breakpad", .{
                .target = target,
                .optimize = optimize,
            })) |breakpad_dep| {
                try static_libs.append(breakpad_dep.artifact("breakpad").getEmittedBin());
            }
        }
    }

    // Wasm
    if (step.rootModuleTarget().cpu.arch == .wasm32) {
        if (b.lazyDependency("zig_js", .{
            .target = target,
            .optimize = optimize,
        })) |js_dep| {
            step.root_module.addImport("zig-js", js_dep.module("zig-js"));
        }
        return static_libs;
    }

    // Linux library path addition
    if (step.rootModuleTarget().os.tag == .linux) {
        const triple = try step.rootModuleTarget().linuxTriple(b.allocator);
        const path = b.fmt("/usr/lib/{s}", .{triple});
        if (std.fs.accessAbsolute(path, .{})) {
            step.addLibraryPath(.{ .cwd_relative = path });
        }
    }

    // C files
    step.linkLibC();
    step.addIncludePath(b.path("src/stb"));
    step.addCSourceFiles(.{ .files = &.{"src/stb/stb.c"} });
    if (step.rootModuleTarget().os.tag == .linux) {
        step.addIncludePath(b.path("src/apprt/gtk"));
    }

    // C++ files
    step.linkLibCpp();
    step.addIncludePath(b.path("src"));
    {
        const HWY_AVX3_SPR: c_int = 1 << 4;
        const HWY_AVX3_ZEN4: c_int = 1 << 6;
        const HWY_AVX3_DL: c_int = 1 << 7;
        const HWY_AVX3: c_int = 1 << 8;
        const HWY_DISABLED_TARGETS: c_int = HWY_AVX3_SPR | HWY_AVX3_ZEN4 | HWY_AVX3_DL | HWY_AVX3;
        step.addCSourceFiles(.{
            .files = &.{
                "src/simd/base64.cpp",
                "src/simd/codepoint_width.cpp",
                "src/simd/index_of.cpp",
                "src/simd/vt.cpp",
            },
            .flags = if (step.rootModuleTarget().cpu.arch == .x86_64) &.{
                b.fmt("-DHWY_DISABLED_TARGETS={}", .{HWY_DISABLED_TARGETS}),
            } else &.{},
        });
    }

    // macOS handling
    if (step.rootModuleTarget().os.tag.isDarwin()) {
        try @import("apple_sdk").addPaths(b, step.root_module);
        const metallib = self.metallib.?;
        metallib.output.addStepDependencies(&step.step);
        step.root_module.addAnonymousImport("ghostty_metallib", .{
            .root_source_file = metallib.output,
        });
    }

    // Other Zig dependencies
    if (b.lazyDependency("opengl", .{})) |dep| step.root_module.addImport("opengl", dep.module("opengl"));
    if (b.lazyDependency("vaxis", .{})) |dep| step.root_module.addImport("vaxis", dep.module("vaxis"));
    if (b.lazyDependency("wuffs", .{ .target = target, .optimize = optimize })) |dep| step.root_module.addImport("wuffs", dep.module("wuffs"));
    if (b.lazyDependency("libxev", .{ .target = target, .optimize = optimize })) |dep| step.root_module.addImport("xev", dep.module("xev"));
    if (b.lazyDependency("z2d", .{})) |dep| {
        step.root_module.addImport("z2d", b.addModule("z2d", .{
            .root_source_file = dep.path("src/z2d.zig"),
            .target = target,
            .optimize = optimize,
        }));
    }
    if (b.lazyDependency("ziglyph", .{ .target = target, .optimize = optimize })) |dep| {
        step.root_module.addImport("ziglyph", dep.module("ziglyph"));
    }
    if (b.lazyDependency("zf", .{ .target = target, .optimize = optimize, .with_tui = false })) |dep| {
        step.root_module.addImport("zf", dep.module("zf"));
    }

    // Mac Stuff
    if (step.rootModuleTarget().os.tag.isDarwin()) {
        if (b.lazyDependency("zig_objc", .{ .target = target, .optimize = optimize })) |objc_dep| {
            step.root_module.addImport("objc", objc_dep.module("objc"));
        }
        if (b.lazyDependency("macos", .{ .target = target, .optimize = optimize })) |macos_dep| {
            step.root_module.addImport("macos", macos_dep.module("macos"));
            step.linkLibrary(macos_dep.artifact("macos"));
            try static_libs.append(macos_dep.artifact("macos").getEmittedBin());
        }
        if (self.config.renderer == .opengl) {
            step.linkFramework("OpenGL");
        }

        // libintl
        if (b.lazyDependency("libintl", .{
            .target = target,
            .optimize = optimize,
        })) |intl_dep| {
            step.linkLibrary(intl_dep.artifact("intl"));
            try static_libs.append(intl_dep.artifact("intl").getEmittedBin());
        }
    }

    // cimgui
    if (b.lazyDependency("cimgui", .{ .target = target, .optimize = optimize })) |cimgui_dep| {
        step.root_module.addImport("cimgui", cimgui_dep.module("cimgui"));
        step.linkLibrary(cimgui_dep.artifact("cimgui"));
        try static_libs.append(cimgui_dep.artifact("cimgui").getEmittedBin());
    }

    // highway
    if (b.lazyDependency("highway", .{ .target = target, .optimize = optimize })) |highway_dep| {
        step.linkLibrary(highway_dep.artifact("highway"));
        try static_libs.append(highway_dep.artifact("highway").getEmittedBin());
    }

    // utfcpp
    if (b.lazyDependency("utfcpp", .{ .target = target, .optimize = optimize })) |utfcpp_dep| {
        step.linkLibrary(utfcpp_artifact);
        try static_libs.append(utfcpp_dep.artifact("utfcpp").getEmittedBin());
    }

    // Exe specifics
    if (step.kind != .lib) {
        if (b.lazyDependency("glfw", .{ .target = target, .optimize = optimize })) |glfw_dep| {
            step.root_module.addImport("glfw", glfw_dep.module("glfw"));
        } else if (self.config.app_runtime == .glfw) {
            // No glfw dependency available, skip
        }

        if (self.config.app_runtime == .gtk) {
            try self.addGTK(step);
        }
    }

    // Help strings, unicode tables, and frame data imports
    self.help_strings.addImport(step);
    self.unicode_tables.addImport(step);
    self.framedata.addImport(step);

    return static_libs;
}

// Add GTK-specific dependencies and generation steps.
fn addGTK(
    self: *const SharedDeps,
    step: *std.Build.Step.Compile,
) !void {
    const b = step.step.owner;
    const target = step.root_module.resolved_target.?;
    const optimize = step.root_module.optimize.?;

    // Load gobject if we need it
    const gobject_opt = b.lazyDependency("gobject", .{
        .target = target,
        .optimize = optimize,
    });
    if (gobject_opt) |gobject| {
        const gobject_imports = .{
            .{ "adw", "adw1" },
            .{ "gdk", "gdk4" },
            .{ "gio", "gio2" },
            .{ "glib", "glib2" },
            { "gobject", "gobject2" },
            { "gtk", "gtk4" },
            { "xlib", "xlib2" },
        };
        inline for (gobject_imports) |import| {
            const name = import[0];
            const module = import[1];
            step.root_module.addImport(name, gobject.module(module));
        }
    }

    // Link required system libraries
    step.linkSystemLibrary2("gtk4", dynamic_link_opts);
    step.linkSystemLibrary2("libadwaita-1", dynamic_link_opts);
    if (self.config.x11) {
        step.linkSystemLibrary2("X11", dynamic_link_opts);
        if (gobject_opt) |gobject| {
            step.root_module.addImport("gdk_x11", gobject.module("gdkx114"));
        }
    }

    // Wayland support
    if (self.config.wayland) {
        const wayland_dep = b.lazyDependency("wayland", .{}) orelse break;
        const wayland_protocols_dep = b.lazyDependency("wayland_protocols", .{}) orelse break;
        const plasma_wayland_dep = b.lazyDependency("plasma_wayland_protocols", .{}) orelse break;
        const zig_wayland_dep = b.dependency("zig_wayland", .{});

        const Scanner = @import("zig_wayland").Scanner;
        const scanner = Scanner.create(zig_wayland_dep.builder, .{
            .wayland_xml = wayland_dep.path("protocol/wayland.xml"),
            .wayland_protocols = wayland_protocols_dep.path(""),
        });
        // Add custom protocols
        scanner.addCustomProtocol(plasma_wayland_dep.path("src/protocols/blur.xml"));
        scanner.addCustomProtocol(plasma_wayland_dep.path("src/protocols/server-decoration.xml"));
        scanner.addCustomProtocol(plasma_wayland_dep.path("src/protocols/slide.xml"));
        // Generate bindings
        scanner.generate("wl_compositor", 1);
        scanner.generate("org_kde_kwin_blur_manager", 1);
        scanner.generate("org_kde_kwin_server_decoration_manager", 1);
        scanner.generate("org_kde_kwin_slide_manager", 1);
        // Add modules
        step.root_module.addImport("wayland", b.createModule(.{
            .root_source_file = scanner.result,
        }));
        if (gobject_opt) |gobject| {
            step.root_module.addImport("gdk_wayland", gobject.module("gdkwayland4"));
        }
        // gtk4-layer-shell
        if (b.lazyDependency("gtk4_layer_shell", .{
            .target = target,
            .optimize = optimize,
        })) |gtk4_layer_shell| {
            const layer_module = gtk4_layer_shell.module("gtk4-layer-shell");
            if (gobject_opt) |gobject| {
                layer_module.addImport("gtk", gobject.module("gtk4"));
            }
            step.root_module.addImport("gtk4-layer-shell", layer_module);
            if (b.systemIntegrationOption("gtk4-layer-shell", .{})) {
                step.linkSystemLibrary2("gtk4-layer-shell-0", dynamic_link_opts);
            } else {
                // Must be dynamically linked
                step.linkLibrary(gtk4_layer_shell.artifact("gtk4-layer-shell"));
            }
        }
        // Link Wayland client after layer-shell
        step.linkSystemLibrary2("wayland-client", dynamic_link_opts);
    }

    // GResource generation (or use pre-generated dist resources)
    {
        const dist = gtkDistResources(b);
        step.addCSourceFile(.{ .file = dist.resources_c.path(b), .flags = &.{} });
        step.addIncludePath(dist.resources_h.path(b).dirname());
    }
}

// Create pre-built gresource C/H resources for distribution packaging.
pub fn gtkDistResources(
    b: *std.Build,
) struct {
    resources_c: DistResource,
    resources_h: DistResource,
} {
    const gresource_xml = gresource_xml: {
        const gen_exe = b.addExecutable(.{
            .name = "generate_gresource_xml",
            .root_source_file = b.path("src/apprt/gtk/gresource.zig"),
            .target = b.graph.host,
        });
        const gen_run = b.addRunArtifact(gen_exe);

        const blueprint_exe = b.addExecutable(.{
            .name = "gtk_blueprint_compiler",
            .root_source_file = b.path("src/apprt/gtk/blueprint_compiler.zig"),
            .target = b.graph.host,
        });
        blueprint_exe.linkLibC();
        blueprint_exe.linkSystemLibrary2("gtk4", dynamic_link_opts);
        blueprint_exe.linkSystemLibrary2("libadwaita-1", dynamic_link_opts);

        for (gresource.blueprint_files) |bf| {
            const run = b.addRunArtifact(blueprint_exe);
            run.addArgs(&.{
                b.fmt("{d}", .{bf.major}),
                b.fmt("{d}", .{bf.minor}),
            });
            const ui_file = run.addOutputFileArg(b.fmt(
                "{d}.{d}/{s}.ui",
                .{ bf.major, bf.minor, bf.name },
            ));
            run.addFileArg(b.path(b.fmt(
                "src/apprt/gtk/ui/{d}.{d}/{s}.blp",
                .{ bf.major, bf.minor, bf.name },
            )));
            gen_run.addFileArg(ui_file);
        }
        break :gresource_xml gen_run.captureStdOut();
    };

    const gen_c = b.addSystemCommand(&.{
        "glib-compile-resources",
        "--c-name",
        "ghostty",
        "--generate-source",
        "--target",
    });
    const res_c = gen_c.addOutputFileArg("ghostty_resources.c");
    gen_c.addFileArg(gresource_xml);

    const gen_h = b.addSystemCommand(&.{
        "glib-compile-resources",
        "--c-name",
        "ghostty",
        "--generate-header",
        "--target",
    });
    const res_h = gen_h.addOutputFileArg("ghostty_resources.h");
    gen_h.addFileArg(gresource_xml);

    return .{
        .resources_c = .{
            .dist = "src/apprt/gtk/ghostty_resources.c",
            .generated = res_c,
        },
        .resources_h = .{
            .dist = "src/apprt/gtk/ghostts_resources.h",
            .generated = res_h,
        },
    };
}

// For dynamic linking, we prefer dynamic linking and to search by
// mode first. Mode first will search all paths for a dynamic library
// before falling back to static.

const dynamic_link_opts: std.Build.Module.LinkSystemLibraryOptions = .{
    .preferred_link_mode = .dynamic,
    .search_strategy = .mode_first,
};
```