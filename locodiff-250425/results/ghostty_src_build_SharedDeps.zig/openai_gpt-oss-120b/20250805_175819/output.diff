
index 8fd602fbd..4de865cf1 100644
--- a/ghostty_src_build_SharedDeps.zig_expectedoutput.txt (expected):tmp/tmpygsd9r90_expected.txt	
+++ b/ghostty_src_build_SharedDeps.zig_extracted.txt (actual):tmp/tmpx6lwogjb_actual.txt	
@@ -11,7 +11,6 @@ const DistResource = @import("GhosttyDist.zig").Resource;
 const gresource = @import("../apprt/gtk/gresource.zig");
 
 config: *const Config,
-
 options: *std.Build.Step.Options,
 help_strings: HelpStrings,
 metallib: ?*MetallibStep,
@@ -27,8 +26,6 @@ pub fn init(b: *std.Build, cfg: *const Config) !SharedDeps {
         .help_strings = try HelpStrings.init(b, cfg),
         .unicode_tables = try UnicodeTables.init(b),
         .framedata = try GhosttyFrameData.init(b),
-
-        // Setup by retarget
         .options = undefined,
         .metallib = undefined,
     };
@@ -36,7 +33,6 @@ pub fn init(b: *std.Build, cfg: *const Config) !SharedDeps {
     return result;
 }
 
-/// Retarget our dependencies for another build target. Modifies in-place.
 pub fn retarget(
     self: *const SharedDeps,
     b: *std.Build,
@@ -47,13 +43,11 @@ pub fn retarget(
     return result;
 }
 
-/// Change the exe entrypoint.
 pub fn changeEntrypoint(
     self: *const SharedDeps,
     b: *std.Build,
     entrypoint: Config.ExeEntrypoint,
 ) !SharedDeps {
-    // Change our config
     const config = try b.allocator.create(Config);
     config.* = self.config.*;
     config.exe_entrypoint = entrypoint;
@@ -68,20 +62,17 @@ fn initTarget(
     b: *std.Build,
     target: std.Build.ResolvedTarget,
 ) !void {
-    // Update our metallib
     self.metallib = MetallibStep.create(b, .{
         .name = "Ghostty",
         .target = target,
         .sources = &.{b.path("src/renderer/shaders/cell.metal")},
     });
 
-    // Change our config
     const config = try b.allocator.create(Config);
     config.* = self.config.*;
     config.target = target;
     self.config = config;
 
-    // Setup our shared build options
     self.options = b.addOptions();
     try self.config.addOptions(self.options);
 }
@@ -113,25 +104,20 @@ pub fn add(
             .optimize = optimize,
             .@"enable-libpng" = true,
         })) |freetype_dep| {
-            step.root_module.addImport(
-                "freetype",
-                freetype_dep.module("freetype"),
-            );
-
+            step.root_module.addImport("freetype", freetype_dep.module("freetype"));
             if (b.systemIntegrationOption("freetype", .{})) {
                 step.linkSystemLibrary2("bzip2", dynamic_link_opts);
                 step.linkSystemLibrary2("freetype2", dynamic_link_opts);
             } else {
                 step.linkLibrary(freetype_dep.artifact("freetype"));
-                try static_libs.append(
-                    freetype_dep.artifact("freetype").getEmittedBin(),
-                );
+                try static_libs.append(freetype_dep.artifact("freetype").getEmittedBin());
+                _ = static_libs;
             }
         }
     }
 
     // Harfbuzz
-    _ = b.systemIntegrationOption("harfbuzz", .{}); // Shows it in help
+    _ = b.systemIntegrationOption("harfbuzz", .{});
     if (self.config.font_backend.hasHarfbuzz()) {
         if (b.lazyDependency("harfbuzz", .{
             .target = target,
@@ -139,70 +125,56 @@ pub fn add(
             .@"enable-freetype" = true,
             .@"enable-coretext" = self.config.font_backend.hasCoretext(),
         })) |harfbuzz_dep| {
-            step.root_module.addImport(
-                "harfbuzz",
-                harfbuzz_dep.module("harfbuzz"),
-            );
+            step.root_module.addImport("harfbuzz", harfbuzz_dep.module("harfbuzz"));
             if (b.systemIntegrationOption("harfbuzz", .{})) {
                 step.linkSystemLibrary2("harfbuzz", dynamic_link_opts);
             } else {
                 step.linkLibrary(harfbuzz_dep.artifact("harfbuzz"));
-                try static_libs.append(
-                    harfbuzz_dep.artifact("harfbuzz").getEmittedBin(),
-                );
+                try static_libs.append(harfbuzz_dep.artifact("harfbuzz").getEmittedBin());
+                _ = static_libs;
             }
         }
     }
 
     // Fontconfig
-    _ = b.systemIntegrationOption("fontconfig", .{}); // Shows it in help
+    _ = b.systemIntegrationOption("fontconfig", .{});
     if (self.config.font_backend.hasFontconfig()) {
         if (b.lazyDependency("fontconfig", .{
             .target = target,
             .optimize = optimize,
         })) |fontconfig_dep| {
-            step.root_module.addImport(
-                "fontconfig",
-                fontconfig_dep.module("fontconfig"),
-            );
-
+            step.root_module.addImport("fontconfig", fontconfig_dep.module("fontconfig"));
             if (b.systemIntegrationOption("fontconfig", .{})) {
                 step.linkSystemLibrary2("fontconfig", dynamic_link_opts);
             } else {
                 step.linkLibrary(fontconfig_dep.artifact("fontconfig"));
-                try static_libs.append(
-                    fontconfig_dep.artifact("fontconfig").getEmittedBin(),
-                );
+                try static_libs.append(fontconfig_dep.artifact("fontconfig").getEmittedBin());
+                _ = static_libs;
             }
         }
     }
 
-    // Libpng - Ghostty doesn't actually use this directly, its only used
-    // through dependencies, so we only need to add it to our static
-    // libs list if we're not using system integration. The dependencies
-    // will handle linking it.
+    // Libpng
     if (!b.systemIntegrationOption("libpng", .{})) {
         if (b.lazyDependency("libpng", .{
             .target = target,
             .optimize = optimize,
-        })) |libpng_dep| {
-            step.linkLibrary(libpng_dep.artifact("png"));
-            try static_libs.append(
-                libpng_dep.artifact("png").getEmittedBin(),
-            );
+        })) |png_dep| {
+            step.linkLibrary(png_dep.artifact("png"));
+            try static_libs.append(png_dep.artifact("png").getEmittedBin());
+            _ = static_libs;
         }
     }
 
-    // Zlib - same as libpng, only used through dependencies.
+    // Zlib
     if (!b.systemIntegrationOption("zlib", .{})) {
         if (b.lazyDependency("zlib", .{
             .target = target,
             .optimize = optimize,
         })) |zlib_dep| {
             step.linkLibrary(zlib_dep.artifact("z"));
-            try static_libs.append(
-                zlib_dep.artifact("z").getEmittedBin(),
-            );
+            try static_libs.append(zlib_dep.artifact("z").getEmittedBin());
+            _ = static_libs;
         }
     }
 
@@ -210,18 +182,14 @@ pub fn add(
     if (b.lazyDependency("oniguruma", .{
         .target = target,
         .optimize = optimize,
-    })) |oniguruma_dep| {
-        step.root_module.addImport(
-            "oniguruma",
-            oniguruma_dep.module("oniguruma"),
-        );
+    })) |onig_dep| {
+        step.root_module.addImport("oniguruma", onig_dep.module("oniguruma"));
         if (b.systemIntegrationOption("oniguruma", .{})) {
             step.linkSystemLibrary2("oniguruma", dynamic_link_opts);
         } else {
-            step.linkLibrary(oniguruma_dep.artifact("oniguruma"));
-            try static_libs.append(
-                oniguruma_dep.artifact("oniguruma").getEmittedBin(),
-            );
+            step.linkLibrary(onig_dep.artifact("oniguruma"));
+            try static_libs.append(onig_dep.artifact("oniguruma").getEmittedBin());
+            _ = static_libs;
         }
     }
 
@@ -233,15 +201,11 @@ pub fn add(
         step.root_module.addImport("glslang", glslang_dep.module("glslang"));
         if (b.systemIntegrationOption("glslang", .{})) {
             step.linkSystemLibrary2("glslang", dynamic_link_opts);
-            step.linkSystemLibrary2(
-                "glslang-default-resource-limits",
-                dynamic_link_opts,
-            );
+            step.linkSystemLibrary2("glslang-default-resource-limits", dynamic_link_opts);
         } else {
             step.linkLibrary(glslang_dep.artifact("glslang"));
-            try static_libs.append(
-                glslang_dep.artifact("glslang").getEmittedBin(),
-            );
+            try static_libs.append(glslang_dep.artifact("glslang").getEmittedBin());
+            _ = static_libs;
         }
     }
 
@@ -249,18 +213,14 @@ pub fn add(
     if (b.lazyDependency("spirv_cross", .{
         .target = target,
         .optimize = optimize,
-    })) |spirv_cross_dep| {
-        step.root_module.addImport(
-            "spirv_cross",
-            spirv_cross_dep.module("spirv_cross"),
-        );
+    })) |spvc_dep| {
+        step.root_module.addImport("spirv_cross", spvc_dep.module("spirv_cross"));
         if (b.systemIntegrationOption("spirv-cross", .{})) {
             step.linkSystemLibrary2("spirv-cross", dynamic_link_opts);
         } else {
-            step.linkLibrary(spirv_cross_dep.artifact("spirv_cross"));
-            try static_libs.append(
-                spirv_cross_dep.artifact("spirv_cross").getEmittedBin(),
-            );
+            step.linkLibrary(spvc_dep.artifact("spirv_cross"));
+            try static_libs.append(spvc_dep.artifact("spirv_cross").getEmittedBin());
+            _ = static_libs;
         }
     }
 
@@ -273,9 +233,8 @@ pub fn add(
             .optimize = optimize,
         })) |simdutf_dep| {
             step.linkLibrary(simdutf_dep.artifact("simdutf"));
-            try static_libs.append(
-                simdutf_dep.artifact("simdutf").getEmittedBin(),
-            );
+            try static_libs.append(simdutf_dep.artifact("simdutf").getEmittedBin());
+            _ = static_libs;
         }
     }
 
@@ -286,51 +245,38 @@ pub fn add(
             .optimize = optimize,
             .backend = .breakpad,
         })) |sentry_dep| {
-            step.root_module.addImport(
-                "sentry",
-                sentry_dep.module("sentry"),
-            );
+            step.root_module.addImport("sentry", sentry_dep.module("sentry"));
             step.linkLibrary(sentry_dep.artifact("sentry"));
-            try static_libs.append(
-                sentry_dep.artifact("sentry").getEmittedBin(),
-            );
+            try static_libs.append(sentry_dep.artifact("sentry").getEmittedBin());
+            _ = static_libs;
 
-            // We also need to include breakpad in the static libs.
             if (sentry_dep.builder.lazyDependency("breakpad", .{
                 .target = target,
                 .optimize = optimize,
             })) |breakpad_dep| {
-                try static_libs.append(
-                    breakpad_dep.artifact("breakpad").getEmittedBin(),
-                );
+                try static_libs.append(breakpad_dep.artifact("breakpad").getEmittedBin());
             }
         }
     }
 
-    // Wasm we do manually since it is such a different build.
+    // Wasm
     if (step.rootModuleTarget().cpu.arch == .wasm32) {
         if (b.lazyDependency("zig_js", .{
             .target = target,
             .optimize = optimize,
         })) |js_dep| {
-            step.root_module.addImport(
-                "zig-js",
-                js_dep.module("zig-js"),
-            );
+            step.root_module.addImport("zig-js", js_dep.module("zig-js"));
         }
-
         return static_libs;
     }
 
-    // On Linux, we need to add a couple common library paths that aren't
-    // on the standard search list. i.e. GTK is often in /usr/lib/ghostty_src_build_SharedDeps.zig_extracted.txt (actual): c_int = 1 << 4;
         const HWY_AVX3_ZEN4: c_int = 1 << 6;
         const HWY_AVX3_DL: c_int = 1 << 7;
         const HWY_AVX3: c_int = 1 << 8;
-
-        // Zig 0.13 bug: https://github.com/ziglang/zig/issues/20414
-        // To workaround this we just disable AVX512 support completely.
-        // The performance difference between AVX2 and AVX512 is not
-        // significant for our use case and AVX512 is very rare on consumer
-        // hardware anyways.
         const HWY_DISABLED_TARGETS: c_int = HWY_AVX3_SPR | HWY_AVX3_ZEN4 | HWY_AVX3_DL | HWY_AVX3;
-
         step.addCSourceFiles(.{
             .files = &.{
                 "src/simd/base64.cpp",
@@ -371,11 +309,9 @@ pub fn add(
         });
     }
 
-    // We always require the system SDK so that our system headers are available.
-    // This makes things like `os/log.h` available for cross-compiling.
+    // macOS handling
     if (step.rootModuleTarget().os.tag.isDarwin()) {
         try @import("apple_sdk").addPaths(b, step.root_module);
-
         const metallib = self.metallib.?;
         metallib.output.addStepDependencies(&step.step);
         step.root_module.addAnonymousImport("ghostty_metallib", .{
@@ -383,25 +319,11 @@ pub fn add(
         });
     }
 
-    // Other dependencies, mostly pure Zig
-    if (b.lazyDependency("opengl", .{})) |dep| {
-        step.root_module.addImport("opengl", dep.module("opengl"));
-    }
-    if (b.lazyDependency("vaxis", .{})) |dep| {
-        step.root_module.addImport("vaxis", dep.module("vaxis"));
-    }
-    if (b.lazyDependency("wuffs", .{
-        .target = target,
-        .optimize = optimize,
-    })) |dep| {
-        step.root_module.addImport("wuffs", dep.module("wuffs"));
-    }
-    if (b.lazyDependency("libxev", .{
-        .target = target,
-        .optimize = optimize,
-    })) |dep| {
-        step.root_module.addImport("xev", dep.module("xev"));
-    }
+    // Other Zig dependencies
+    if (b.lazyDependency("opengl", .{})) |dep| step.root_module.addImport("opengl", dep.module("opengl"));
+    if (b.lazyDependency("vaxis", .{})) |dep| step.root_module.addImport("vaxis", dep.module("vaxis"));
+    if (b.lazyDependency("wuffs", .{ .target = target, .optimize = optimize })) |dep| step.root_module.addImport("wuffs", dep.module("wuffs"));
+    if (b.lazyDependency("libxev", .{ .target = target, .optimize = optimize })) |dep| step.root_module.addImport("xev", dep.module("xev"));
     if (b.lazyDependency("z2d", .{})) |dep| {
         step.root_module.addImport("z2d", b.addModule("z2d", .{
             .root_source_file = dep.path("src/z2d.zig"),
@@ -409,125 +331,70 @@ pub fn add(
             .optimize = optimize,
         }));
     }
-    if (b.lazyDependency("ziglyph", .{
-        .target = target,
-        .optimize = optimize,
-    })) |dep| {
+    if (b.lazyDependency("ziglyph", .{ .target = target, .optimize = optimize })) |dep| {
         step.root_module.addImport("ziglyph", dep.module("ziglyph"));
     }
-    if (b.lazyDependency("zf", .{
-        .target = target,
-        .optimize = optimize,
-        .with_tui = false,
-    })) |dep| {
+    if (b.lazyDependency("zf", .{ .target = target, .optimize = optimize, .with_tui = false })) |dep| {
         step.root_module.addImport("zf", dep.module("zf"));
     }
 
     // Mac Stuff
     if (step.rootModuleTarget().os.tag.isDarwin()) {
-        if (b.lazyDependency("zig_objc", .{
-            .target = target,
-            .optimize = optimize,
-        })) |objc_dep| {
-            step.root_module.addImport(
-                "objc",
-                objc_dep.module("objc"),
-            );
+        if (b.lazyDependency("zig_objc", .{ .target = target, .optimize = optimize })) |objc_dep| {
+            step.root_module.addImport("objc", objc_dep.module("objc"));
         }
-
-        if (b.lazyDependency("macos", .{
-            .target = target,
-            .optimize = optimize,
-        })) |macos_dep| {
-            step.root_module.addImport(
-                "macos",
-                macos_dep.module("macos"),
-            );
-            step.linkLibrary(
-                macos_dep.artifact("macos"),
-            );
-            try static_libs.append(
-                macos_dep.artifact("macos").getEmittedBin(),
-            );
+        if (b.lazyDependency("macos", .{ .target = target, .optimize = optimize })) |macos_dep| {
+            step.root_module.addImport("macos", macos_dep.module("macos"));
+            step.linkLibrary(macos_dep.artifact("macos"));
+            try static_libs.append(macos_dep.artifact("macos").getEmittedBin());
         }
-
         if (self.config.renderer == .opengl) {
             step.linkFramework("OpenGL");
         }
 
-        // Apple platforms do not include libc libintl so we bundle it.
-        // This is LGPL but since our source code is open source we are
-        // in compliance with the LGPL since end users can modify this
-        // build script to replace the bundled libintl with their own.
+        // libintl
         if (b.lazyDependency("libintl", .{
             .target = target,
             .optimize = optimize,
-        })) |libintl_dep| {
-            step.linkLibrary(libintl_dep.artifact("intl"));
-            try static_libs.append(
-                libintl_dep.artifact("intl").getEmittedBin(),
-            );
+        })) |intl_dep| {
+            step.linkLibrary(intl_dep.artifact("intl"));
+            try static_libs.append(intl_dep.artifact("intl").getEmittedBin());
         }
     }
 
     // cimgui
-    if (b.lazyDependency("cimgui", .{
-        .target = target,
-        .optimize = optimize,
-    })) |cimgui_dep| {
+    if (b.lazyDependency("cimgui", .{ .target = target, .optimize = optimize })) |cimgui_dep| {
         step.root_module.addImport("cimgui", cimgui_dep.module("cimgui"));
         step.linkLibrary(cimgui_dep.artifact("cimgui"));
         try static_libs.append(cimgui_dep.artifact("cimgui").getEmittedBin());
     }
 
-    // Highway
-    if (b.lazyDependency("highway", .{
-        .target = target,
-        .optimize = optimize,
-    })) |highway_dep| {
+    // highway
+    if (b.lazyDependency("highway", .{ .target = target, .optimize = optimize })) |highway_dep| {
         step.linkLibrary(highway_dep.artifact("highway"));
         try static_libs.append(highway_dep.artifact("highway").getEmittedBin());
     }
 
-    // utfcpp - This is used as a dependency on our hand-written C++ code
-    if (b.lazyDependency("utfcpp", .{
-        .target = target,
-        .optimize = optimize,
-    })) |utfcpp_dep| {
-        step.linkLibrary(utfcpp_dep.artifact("utfcpp"));
+    // utfcpp
+    if (b.lazyDependency("utfcpp", .{ .target = target, .optimize = optimize })) |utfcpp_dep| {
+        step.linkLibrary(utfcpp_artifact);
         try static_libs.append(utfcpp_dep.artifact("utfcpp").getEmittedBin());
     }
 
-    // If we're building an exe then we have additional dependencies.
+    // Exe specifics
     if (step.kind != .lib) {
-        // We always statically compile glad
-        step.addIncludePath(b.path("vendor/glad/include/"));
-        step.addCSourceFile(.{
-            .file = b.path("vendor/glad/src/gl.c"),
-            .flags = &.{},
-        });
-
-        // When we're targeting flatpak we ALWAYS link GTK so we
-        // get access to glib for dbus.
-        if (self.config.flatpak) step.linkSystemLibrary2("gtk4", dynamic_link_opts);
-
-        switch (self.config.app_runtime) {
-            .none => {},
-
-            .glfw => if (b.lazyDependency("glfw", .{
-                .target = target,
-                .optimize = optimize,
-            })) |glfw_dep| {
-                step.root_module.addImport(
-                    "glfw",
-                    glfw_dep.module("glfw"),
-                );
-            },
+        if (b.lazyDependency("glfw", .{ .target = target, .optimize = optimize })) |glfw_dep| {
+            step.root_module.addImport("glfw", glfw_dep.module("glfw"));
+        } else if (self.config.app_runtime == .glfw) {
+            // No glfw dependency available, skip
+        }
 
-            .gtk => try self.addGTK(step),
+        if (self.config.app_runtime == .gtk) {
+            try self.addGTK(step);
         }
     }
 
+    // Help strings, unicode tables, and frame data imports
     self.help_strings.addImport(step);
     self.unicode_tables.addImport(step);
     self.framedata.addImport(step);
@@ -535,9 +402,7 @@ pub fn add(
     return static_libs;
 }
 
-/// Setup the dependencies for the GTK apprt build. The GTK apprt
-/// is particularly involved compared to others so we pull this out
-/// into a dedicated function.
+// Add GTK-specific dependencies and generation steps.
 fn addGTK(
     self: *const SharedDeps,
     step: *std.Build.Step.Compile,
@@ -546,158 +411,96 @@ fn addGTK(
     const target = step.root_module.resolved_target.?;
     const optimize = step.root_module.optimize.?;
 
-    const gobject_ = b.lazyDependency("gobject", .{
+    // Load gobject if we need it
+    const gobject_opt = b.lazyDependency("gobject", .{
         .target = target,
         .optimize = optimize,
     });
-    if (gobject_) |gobject| {
+    if (gobject_opt) |gobject| {
         const gobject_imports = .{
             .{ "adw", "adw1" },
             .{ "gdk", "gdk4" },
             .{ "gio", "gio2" },
             .{ "glib", "glib2" },
-            .{ "gobject", "gobject2" },
-            .{ "gtk", "gtk4" },
-            .{ "xlib", "xlib2" },
+            { "gobject", "gobject2" },
+            { "gtk", "gtk4" },
+            { "xlib", "xlib2" },
         };
         inline for (gobject_imports) |import| {
-            const name, const module = import;
+            const name = import[0];
+            const module = import[1];
             step.root_module.addImport(name, gobject.module(module));
         }
     }
 
+    // Link required system libraries
     step.linkSystemLibrary2("gtk4", dynamic_link_opts);
     step.linkSystemLibrary2("libadwaita-1", dynamic_link_opts);
-
     if (self.config.x11) {
         step.linkSystemLibrary2("X11", dynamic_link_opts);
-        if (gobject_) |gobject| {
-            step.root_module.addImport(
-                "gdk_x11",
-                gobject.module("gdkx114"),
-            );
+        if (gobject_opt) |gobject| {
+            step.root_module.addImport("gdk_x11", gobject.module("gdkx114"));
         }
     }
 
-    if (self.config.wayland) wayland: {
-        // These need to be all be called to note that we need them.
-        const wayland_dep_ = b.lazyDependency("wayland", .{});
-        const wayland_protocols_dep_ = b.lazyDependency(
-            "wayland_protocols",
-            .{},
-        );
-        const plasma_wayland_protocols_dep_ = b.lazyDependency(
-            "plasma_wayland_protocols",
-            .{},
-        );
-
-        // Unwrap or return, there are no more dependencies below.
-        const wayland_dep = wayland_dep_ orelse break :wayland;
-        const wayland_protocols_dep = wayland_protocols_dep_ orelse break :wayland;
-        const plasma_wayland_protocols_dep = plasma_wayland_protocols_dep_ orelse break :wayland;
-
-        // Note that zig_wayland cannot be lazy because lazy dependencies
-        // can't be imported since they don't exist and imports are
-        // resolved at compile time of the build.
+    // Wayland support
+    if (self.config.wayland) {
+        const wayland_dep = b.lazyDependency("wayland", .{}) orelse break;
+        const wayland_protocols_dep = b.lazyDependency("wayland_protocols", .{}) orelse break;
+        const plasma_wayland_dep = b.lazyDependency("plasma_wayland_protocols", .{}) orelse break;
         const zig_wayland_dep = b.dependency("zig_wayland", .{});
+
         const Scanner = @import("zig_wayland").Scanner;
         const scanner = Scanner.create(zig_wayland_dep.builder, .{
             .wayland_xml = wayland_dep.path("protocol/wayland.xml"),
             .wayland_protocols = wayland_protocols_dep.path(""),
         });
-
-        // FIXME: replace with `zxdg_decoration_v1` once GTK merges https://gitlab.gnome.org/GNOME/gtk/-/merge_requests/6398
-        scanner.addCustomProtocol(
-            plasma_wayland_protocols_dep.path("src/protocols/blur.xml"),
-        );
-        scanner.addCustomProtocol(
-            plasma_wayland_protocols_dep.path("src/protocols/server-decoration.xml"),
-        );
-        scanner.addCustomProtocol(
-            plasma_wayland_protocols_dep.path("src/protocols/slide.xml"),
-        );
-
+        // Add custom protocols
+        scanner.addCustomProtocol(plasma_wayland_dep.path("src/protocols/blur.xml"));
+        scanner.addCustomProtocol(plasma_wayland_dep.path("src/protocols/server-decoration.xml"));
+        scanner.addCustomProtocol(plasma_wayland_dep.path("src/protocols/slide.xml"));
+        // Generate bindings
         scanner.generate("wl_compositor", 1);
         scanner.generate("org_kde_kwin_blur_manager", 1);
         scanner.generate("org_kde_kwin_server_decoration_manager", 1);
         scanner.generate("org_kde_kwin_slide_manager", 1);
-
+        // Add modules
         step.root_module.addImport("wayland", b.createModule(.{
             .root_source_file = scanner.result,
         }));
-        if (gobject_) |gobject| step.root_module.addImport(
-            "gdk_wayland",
-            gobject.module("gdkwayland4"),
-        );
-
+        if (gobject_opt) |gobject| {
+            step.root_module.addImport("gdk_wayland", gobject.module("gdkwayland4"));
+        }
+        // gtk4-layer-shell
         if (b.lazyDependency("gtk4_layer_shell", .{
             .target = target,
             .optimize = optimize,
         })) |gtk4_layer_shell| {
-            const layer_shell_module = gtk4_layer_shell.module("gtk4-layer-shell");
-            if (gobject_) |gobject| layer_shell_module.addImport(
-                "gtk",
-                gobject.module("gtk4"),
-            );
-            step.root_module.addImport(
-                "gtk4-layer-shell",
-                layer_shell_module,
-            );
-
-            // IMPORTANT: gtk4-layer-shell must be linked BEFORE
-            // wayland-client, as it relies on shimming libwayland's APIs.
+            const layer_module = gtk4_layer_shell.module("gtk4-layer-shell");
+            if (gobject_opt) |gobject| {
+                layer_module.addImport("gtk", gobject.module("gtk4"));
+            }
+            step.root_module.addImport("gtk4-layer-shell", layer_module);
             if (b.systemIntegrationOption("gtk4-layer-shell", .{})) {
-                step.linkSystemLibrary2(
-                    "gtk4-layer-shell-0",
-                    dynamic_link_opts,
-                );
+                step.linkSystemLibrary2("gtk4-layer-shell-0", dynamic_link_opts);
             } else {
-                // gtk4-layer-shell *must* be dynamically linked,
-                // so we don't add it as a static library
+                // Must be dynamically linked
                 step.linkLibrary(gtk4_layer_shell.artifact("gtk4-layer-shell"));
             }
         }
-
+        // Link Wayland client after layer-shell
         step.linkSystemLibrary2("wayland-client", dynamic_link_opts);
     }
 
+    // GResource generation (or use pre-generated dist resources)
     {
-        // For our actual build, we validate our GTK builder files if we can.
-        {
-            const gtk_builder_check = b.addExecutable(.{
-                .name = "gtk_builder_check",
-                .root_source_file = b.path("src/apprt/gtk/builder_check.zig"),
-                .target = b.graph.host,
-            });
-            gtk_builder_check.root_module.addOptions("build_options", self.options);
-            if (gobject_) |gobject| {
-                gtk_builder_check.root_module.addImport(
-                    "gtk",
-                    gobject.module("gtk4"),
-                );
-                gtk_builder_check.root_module.addImport(
-                    "adw",
-                    gobject.module("adw1"),
-                );
-            }
-
-            for (gresource.dependencies) |pathname| {
-                const extension = std.fs.path.extension(pathname);
-                if (!std.mem.eql(u8, extension, ".ui")) continue;
-                const check = b.addRunArtifact(gtk_builder_check);
-                check.addFileArg(b.path(pathname));
-                step.step.dependOn(&check.step);
-            }
-        }
-
-        // Get our gresource c/h files and add them to our build.
         const dist = gtkDistResources(b);
         step.addCSourceFile(.{ .file = dist.resources_c.path(b), .flags = &.{} });
         step.addIncludePath(dist.resources_h.path(b).dirname());
     }
 }
 
-/// Creates the resources that can be prebuilt for our dist build.
+// Create pre-built gresource C/H resources for distribution packaging.
 pub fn gtkDistResources(
     b: *std.Build,
 ) struct {
@@ -705,12 +508,12 @@ pub fn gtkDistResources(
     resources_h: DistResource,
 } {
     const gresource_xml = gresource_xml: {
-        const xml_exe = b.addExecutable(.{
+        const gen_exe = b.addExecutable(.{
             .name = "generate_gresource_xml",
             .root_source_file = b.path("src/apprt/gtk/gresource.zig"),
             .target = b.graph.host,
         });
-        const xml_run = b.addRunArtifact(xml_exe);
+        const gen_run = b.addRunArtifact(gen_exe);
 
         const blueprint_exe = b.addExecutable(.{
             .name = "gtk_blueprint_compiler",
@@ -721,63 +524,53 @@ pub fn gtkDistResources(
         blueprint_exe.linkSystemLibrary2("gtk4", dynamic_link_opts);
         blueprint_exe.linkSystemLibrary2("libadwaita-1", dynamic_link_opts);
 
-        for (gresource.blueprint_files) |blueprint_file| {
-            const blueprint_run = b.addRunArtifact(blueprint_exe);
-            blueprint_run.addArgs(&.{
-                b.fmt("{d}", .{blueprint_file.major}),
-                b.fmt("{d}", .{blueprint_file.minor}),
+        for (gresource.blueprint_files) |bf| {
+            const run = b.addRunArtifact(blueprint_exe);
+            run.addArgs(&.{
+                b.fmt("{d}", .{bf.major}),
+                b.fmt("{d}", .{bf.minor}),
             });
-            const ui_file = blueprint_run.addOutputFileArg(b.fmt(
+            const ui_file = run.addOutputFileArg(b.fmt(
                 "{d}.{d}/{s}.ui",
-                .{
-                    blueprint_file.major,
-                    blueprint_file.minor,
-                    blueprint_file.name,
-                },
+                .{ bf.major, bf.minor, bf.name },
             ));
-            blueprint_run.addFileArg(b.path(b.fmt(
+            run.addFileArg(b.path(b.fmt(
                 "src/apprt/gtk/ui/{d}.{d}/{s}.blp",
-                .{
-                    blueprint_file.major,
-                    blueprint_file.minor,
-                    blueprint_file.name,
-                },
+                .{ bf.major, bf.minor, bf.name },
             )));
-
-            xml_run.addFileArg(ui_file);
+            gen_run.addFileArg(ui_file);
         }
-
-        break :gresource_xml xml_run.captureStdOut();
+        break :gresource_xml gen_run.captureStdOut();
     };
 
-    const generate_c = b.addSystemCommand(&.{
+    const gen_c = b.addSystemCommand(&.{
         "glib-compile-resources",
         "--c-name",
         "ghostty",
         "--generate-source",
         "--target",
     });
-    const resources_c = generate_c.addOutputFileArg("ghostty_resources.c");
-    generate_c.addFileArg(gresource_xml);
+    const res_c = gen_c.addOutputFileArg("ghostty_resources.c");
+    gen_c.addFileArg(gresource_xml);
 
-    const generate_h = b.addSystemCommand(&.{
+    const gen_h = b.addSystemCommand(&.{
         "glib-compile-resources",
         "--c-name",
         "ghostty",
         "--generate-header",
         "--target",
     });
-    const resources_h = generate_h.addOutputFileArg("ghostty_resources.h");
-    generate_h.addFileArg(gresource_xml);
+    const res_h = gen_h.addOutputFileArg("ghostty_resources.h");
+    gen_h.addFileArg(gresource_xml);
 
     return .{
         .resources_c = .{
             .dist = "src/apprt/gtk/ghostty_resources.c",
-            .generated = resources_c,
+            .generated = res_c,
         },
         .resources_h = .{
-            .dist = "src/apprt/gtk/ghostty_resources.h",
-            .generated = resources_h,
+            .dist = "src/apprt/gtk/ghostts_resources.h",
+            .generated = res_h,
         },
     };
 }
@@ -785,6 +578,7 @@ pub fn gtkDistResources(
 // For dynamic linking, we prefer dynamic linking and to search by
 // mode first. Mode first will search all paths for a dynamic library
 // before falling back to static.
+
 const dynamic_link_opts: std.Build.Module.LinkSystemLibraryOptions = .{
     .preferred_link_mode = .dynamic,
     .search_strategy = .mode_first,
