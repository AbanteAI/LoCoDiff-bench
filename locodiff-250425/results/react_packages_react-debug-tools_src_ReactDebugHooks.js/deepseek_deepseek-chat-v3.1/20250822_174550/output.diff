
index 2048a82a3..7a8cef447 100644
--- a/react_packages_react-debug-tools_src_ReactDebugHooks.js_expectedoutput.txt (expected):tmp/tmpk654qrhr_expected.txt	
+++ b/react_packages_react-debug-tools_src_ReactDebugHooks.js_extracted.txt (actual):tmp/tmpee7tu0ox_actual.txt	
@@ -10,6 +10,7 @@
 import type {
   Awaited,
   ReactContext,
+  ReactProviderType,
   StartTransitionOptions,
   Usable,
   Thenable,
@@ -78,10 +79,6 @@ function getPrimitiveStackCache(): Map<string, Array<any>> {
       Dispatcher.useState(null);
       Dispatcher.useReducer((s: mixed, a: mixed) => s, null);
       Dispatcher.useRef(null);
-      if (typeof Dispatcher.useCacheRefresh === 'function') {
-        // This type check is for Flow only.
-        Dispatcher.useCacheRefresh();
-      }
       Dispatcher.useLayoutEffect(() => {});
       Dispatcher.useInsertionEffect(() => {});
       Dispatcher.useEffect(() => {});
@@ -239,9 +236,9 @@ function use<T>(usable: Usable<T>): T {
 
       hookLog.push({
         displayName: context.displayName || 'Context',
-        primitive: 'Context (use)',
+        primitive: 'Context (use',
         stackError: new Error(),
-        value,
+        value: value,
         debugInfo: null,
         dispatcherHookName: 'Use',
       });
@@ -371,7 +368,7 @@ function useInsertionEffect(
 
 function useEffect(
   create: () => (() => void) | void,
-  deps: Array<mixed> | void | null,
+  inputs: Array<mixed> | void | null,
 ): void {
   nextHook();
   hookLog.push({
@@ -449,6 +446,36 @@ function useMemo<T>(
   return value;
 }
 
+// useMemoCache is an implementation detail of Forget's memoization
+// it should not be called directly in user-generated code
+function useMemoCache(size: number): Array<mixed> {
+  const fiber = currentFiber;
+  // Don't throw, in case this is called from getPrimitiveStackCache
+  if (fiber == null) {
+    return [];
+  }
+
+  const memoCache =
+    // $FlowFixMe[incompatible-use]: updateQueue is mixed
+    fiber.updateQueue != null ? fiber.updateQueue.memoCache : null;
+  if (memoCache == null) {
+    return [];
+  }
+
+  let data = memoCache.data[memoCache.index];
+  if (data === undefined) {
+    data = memoCache.data[memoCache.index] = new Array(size);
+    for (let i = 0; i < size; i++) {
+      data[i] = REACT_MEMO_CACHE_SENTINEL;
+    }
+  }
+
+  // We don't write anything to hookLog on purpose, so this hook remains invisible to users.
+
+  memoCache.index++;
+  return data;
+}
+
 function useSyncExternalStore<T>(
   subscribe: (() => void) => () => void,
   getSnapshot: () => T,
@@ -522,36 +549,6 @@ function useId(): string {
   return id;
 }
 
-// useMemoCache is an implementation detail of Forget's memoization
-// it should not be called directly in user-generated code
-function useMemoCache(size: number): Array<mixed> {
-  const fiber = currentFiber;
-  // Don't throw, in case this is called from getPrimitiveStackCache
-  if (fiber == null) {
-    return [];
-  }
-
-  const memoCache =
-    // $FlowFixMe[incompatible-use]: updateQueue is mixed
-    fiber.updateQueue != null ? fiber.updateQueue.memoCache : null;
-  if (memoCache == null) {
-    return [];
-  }
-
-  let data = memoCache.data[memoCache.index];
-  if (data === undefined) {
-    data = memoCache.data[memoCache.index] = new Array(size);
-    for (let i = 0; i < size; i++) {
-      data[i] = REACT_MEMO_CACHE_SENTINEL;
-    }
-  }
-
-  // We don't write anything to hookLog on purpose, so this hook remains invisible to users.
-
-  memoCache.index++;
-  return data;
-}
-
 function useOptimistic<S, A>(
   passthrough: S,
   reducer: ?(S, A) => S,
@@ -978,368 +975,4 @@ function parseHookName(functionName: void | string): string {
 
 function buildTree(
   rootStack: any,
-  readHookLog: Array<HookLogEntry>,
-): HooksTree {
-  const rootChildren: Array<HooksNode> = [];
-  let prevStack = null;
-  let levelChildren = rootChildren;
-  let nativeHookID = 0;
-  const stackOfChildren = [];
-  for (let i = 0; i < readHookLog.length; i++) {
-    const hook = readHookLog[i];
-    const parseResult = parseTrimmedStack(rootStack, hook);
-    const primitiveFrame = parseResult[0];
-    const stack = parseResult[1];
-    let displayName = hook.displayName;
-    if (displayName === null && primitiveFrame !== null) {
-      displayName =
-        parseHookName(primitiveFrame.functionName) ||
-        // Older versions of React do not have sourcemaps.
-        // In those versions there was always a 1:1 mapping between wrapper and dispatcher method.
-        parseHookName(hook.dispatcherHookName);
-    }
-    if (stack !== null) {
-      // Note: The indices 0 <= n < length-1 will contain the names.
-      // The indices 1 <= n < length will contain the source locations.
-      // That's why we get the name from n - 1 and don't check the source
-      // of index 0.
-      let commonSteps = 0;
-      if (prevStack !== null) {
-        // Compare the current level's stack to the new stack.
-        while (commonSteps < stack.length && commonSteps < prevStack.length) {
-          const stackSource = stack[stack.length - commonSteps - 1].source;
-          const prevSource =
-            prevStack[prevStack.length - commonSteps - 1].source;
-          if (stackSource !== prevSource) {
-            break;
-          }
-          commonSteps++;
-        }
-        // Pop back the stack as many steps as were not common.
-        for (let j = prevStack.length - 1; j > commonSteps; j--) {
-          // $FlowFixMe[incompatible-type]
-          levelChildren = stackOfChildren.pop();
-        }
-      }
-      // The remaining part of the new stack are custom hooks. Push them
-      // to the tree.
-      for (let j = stack.length - commonSteps - 1; j >= 1; j--) {
-        const children: Array<HooksNode> = [];
-        const stackFrame = stack[j];
-        const levelChild: HooksNode = {
-          id: null,
-          isStateEditable: false,
-          name: parseHookName(stack[j - 1].functionName),
-          value: undefined,
-          subHooks: children,
-          debugInfo: null,
-          hookSource: {
-            lineNumber: stackFrame.lineNumber,
-            columnNumber: stackFrame.columnNumber,
-            functionName: stackFrame.functionName,
-            fileName: stackFrame.fileName,
-          },
-        };
-
-        levelChildren.push(levelChild);
-        stackOfChildren.push(levelChildren);
-        levelChildren = children;
-      }
-      prevStack = stack;
-    }
-    const {primitive, debugInfo} = hook;
-
-    // For now, the "id" of stateful hooks is just the stateful hook index.
-    // Custom hooks have no ids, nor do non-stateful native hooks (e.g. Context, DebugValue).
-    const id =
-      primitive === 'Context' ||
-      primitive === 'Context (use)' ||
-      primitive === 'DebugValue' ||
-      primitive === 'Promise' ||
-      primitive === 'Unresolved' ||
-      primitive === 'HostTransitionStatus'
-        ? null
-        : nativeHookID++;
-
-    // For the time being, only State and Reducer hooks support runtime overrides.
-    const isStateEditable = primitive === 'Reducer' || primitive === 'State';
-    const name = displayName || primitive;
-    const levelChild: HooksNode = {
-      id,
-      isStateEditable,
-      name,
-      value: hook.value,
-      subHooks: [],
-      debugInfo: debugInfo,
-      hookSource: null,
-    };
-
-    const hookSource: HookSource = {
-      lineNumber: null,
-      functionName: null,
-      fileName: null,
-      columnNumber: null,
-    };
-    if (stack && stack.length >= 1) {
-      const stackFrame = stack[0];
-      hookSource.lineNumber = stackFrame.lineNumber;
-      hookSource.functionName = stackFrame.functionName;
-      hookSource.fileName = stackFrame.fileName;
-      hookSource.columnNumber = stackFrame.columnNumber;
-    }
-
-    levelChild.hookSource = hookSource;
-
-    levelChildren.push(levelChild);
-  }
-
-  // Associate custom hook values (useDebugValue() hook entries) with the correct hooks.
-  processDebugValues(rootChildren, null);
-
-  return rootChildren;
-}
-
-// Custom hooks support user-configurable labels (via the special useDebugValue() hook).
-// That hook adds user-provided values to the hooks tree,
-// but these values aren't intended to appear alongside of the other hooks.
-// Instead they should be attributed to their parent custom hook.
-// This method walks the tree and assigns debug values to their custom hook owners.
-function processDebugValues(
-  hooksTree: HooksTree,
-  parentHooksNode: HooksNode | null,
-): void {
-  const debugValueHooksNodes: Array<HooksNode> = [];
-
-  for (let i = 0; i < hooksTree.length; i++) {
-    const hooksNode = hooksTree[i];
-    if (hooksNode.name === 'DebugValue' && hooksNode.subHooks.length === 0) {
-      hooksTree.splice(i, 1);
-      i--;
-      debugValueHooksNodes.push(hooksNode);
-    } else {
-      processDebugValues(hooksNode.subHooks, hooksNode);
-    }
-  }
-
-  // Bubble debug value labels to their custom hook owner.
-  // If there is no parent hook, just ignore them for now.
-  // (We may warn about this in the future.)
-  if (parentHooksNode !== null) {
-    if (debugValueHooksNodes.length === 1) {
-      parentHooksNode.value = debugValueHooksNodes[0].value;
-    } else if (debugValueHooksNodes.length > 1) {
-      parentHooksNode.value = debugValueHooksNodes.map(({value}) => value);
-    }
-  }
-}
-
-function handleRenderFunctionError(error: any): void {
-  // original error might be any type.
-  if (error === SuspenseException) {
-    // An uncached Promise was used. We can't synchronously resolve the rest of
-    // the Hooks but we can at least show what ever we got so far.
-    return;
-  }
-  if (
-    error instanceof Error &&
-    error.name === 'ReactDebugToolsUnsupportedHookError'
-  ) {
-    throw error;
-  }
-  // If the error is not caused by an unsupported feature, it means
-  // that the error is caused by user's code in renderFunction.
-  // In this case, we should wrap the original error inside a custom error
-  // so that devtools can give a clear message about it.
-  // $FlowFixMe[extra-arg]: Flow doesn't know about 2nd argument of Error constructor
-  const wrapperError = new Error('Error rendering inspected component', {
-    cause: error,
-  });
-  // Note: This error name needs to stay in sync with react-devtools-shared
-  // TODO: refactor this if we ever combine the devtools and debug tools packages
-  wrapperError.name = 'ReactDebugToolsRenderError';
-  // this stage-4 proposal is not supported by all environments yet.
-  // $FlowFixMe[prop-missing] Flow doesn't have this type yet.
-  wrapperError.cause = error;
-  throw wrapperError;
-}
-
-export function inspectHooks<Props>(
-  renderFunction: Props => React$Node,
-  props: Props,
-  currentDispatcher: ?CurrentDispatcherRef,
-): HooksTree {
-  // DevTools will pass the current renderer's injected dispatcher.
-  // Other apps might compile debug hooks as part of their app though.
-  if (currentDispatcher == null) {
-    currentDispatcher = ReactSharedInternals;
-  }
-
-  const previousDispatcher = currentDispatcher.H;
-  currentDispatcher.H = DispatcherProxy;
-
-  let readHookLog;
-  let ancestorStackError;
-
-  try {
-    ancestorStackError = new Error();
-    renderFunction(props);
-  } catch (error) {
-    handleRenderFunctionError(error);
-  } finally {
-    readHookLog = hookLog;
-    hookLog = [];
-    // $FlowFixMe[incompatible-use] found when upgrading Flow
-    currentDispatcher.H = previousDispatcher;
-  }
-  const rootStack = ErrorStackParser.parse(ancestorStackError);
-  return buildTree(rootStack, readHookLog);
-}
-
-function setupContexts(contextMap: Map<ReactContext<any>, any>, fiber: Fiber) {
-  let current: null | Fiber = fiber;
-  while (current) {
-    if (current.tag === ContextProvider) {
-      let context: ReactContext<any> = current.type;
-      if ((context: any)._context !== undefined) {
-        // Support inspection of pre-19+ providers.
-        context = (context: any)._context;
-      }
-      if (!contextMap.has(context)) {
-        // Store the current value that we're going to restore later.
-        contextMap.set(context, context._currentValue);
-        // Set the inner most provider value on the context.
-        context._currentValue = current.memoizedProps.value;
-      }
-    }
-    current = current.return;
-  }
-}
-
-function restoreContexts(contextMap: Map<ReactContext<any>, any>) {
-  contextMap.forEach((value, context) => (context._currentValue = value));
-}
-
-function inspectHooksOfForwardRef<Props, Ref>(
-  renderFunction: (Props, Ref) => React$Node,
-  props: Props,
-  ref: Ref,
-  currentDispatcher: CurrentDispatcherRef,
-): HooksTree {
-  const previousDispatcher = currentDispatcher.H;
-  let readHookLog;
-  currentDispatcher.H = DispatcherProxy;
-  let ancestorStackError;
-  try {
-    ancestorStackError = new Error();
-    renderFunction(props, ref);
-  } catch (error) {
-    handleRenderFunctionError(error);
-  } finally {
-    readHookLog = hookLog;
-    hookLog = [];
-    currentDispatcher.H = previousDispatcher;
-  }
-  const rootStack = ErrorStackParser.parse(ancestorStackError);
-  return buildTree(rootStack, readHookLog);
-}
-
-function resolveDefaultProps(Component: any, baseProps: any) {
-  if (Component && Component.defaultProps) {
-    // Resolve default props. Taken from ReactElement
-    const props = assign({}, baseProps);
-    const defaultProps = Component.defaultProps;
-    for (const propName in defaultProps) {
-      if (props[propName] === undefined) {
-        props[propName] = defaultProps[propName];
-      }
-    }
-    return props;
-  }
-  return baseProps;
-}
-
-export function inspectHooksOfFiber(
-  fiber: Fiber,
-  currentDispatcher: ?CurrentDispatcherRef,
-): HooksTree {
-  // DevTools will pass the current renderer's injected dispatcher.
-  // Other apps might compile debug hooks as part of their app though.
-  if (currentDispatcher == null) {
-    currentDispatcher = ReactSharedInternals;
-  }
-
-  if (
-    fiber.tag !== FunctionComponent &&
-    fiber.tag !== SimpleMemoComponent &&
-    fiber.tag !== ForwardRef
-  ) {
-    throw new Error(
-      'Unknown Fiber. Needs to be a function component to inspect hooks.',
-    );
-  }
-
-  // Warm up the cache so that it doesn't consume the currentHook.
-  getPrimitiveStackCache();
-
-  // Set up the current hook so that we can step through and read the
-  // current state from them.
-  currentHook = (fiber.memoizedState: Hook);
-  currentFiber = fiber;
-
-  if (hasOwnProperty.call(currentFiber, 'dependencies')) {
-    // $FlowFixMe[incompatible-use]: Flow thinks hasOwnProperty might have nulled `currentFiber`
-    const dependencies = currentFiber.dependencies;
-    currentContextDependency =
-      dependencies !== null ? dependencies.firstContext : null;
-  } else if (hasOwnProperty.call(currentFiber, 'dependencies_old')) {
-    const dependencies: Dependencies = (currentFiber: any).dependencies_old;
-    currentContextDependency =
-      dependencies !== null ? dependencies.firstContext : null;
-  } else if (hasOwnProperty.call(currentFiber, 'dependencies_new')) {
-    const dependencies: Dependencies = (currentFiber: any).dependencies_new;
-    currentContextDependency =
-      dependencies !== null ? dependencies.firstContext : null;
-  } else if (hasOwnProperty.call(currentFiber, 'contextDependencies')) {
-    const contextDependencies = (currentFiber: any).contextDependencies;
-    currentContextDependency =
-      contextDependencies !== null ? contextDependencies.first : null;
-  } else {
-    throw new Error(
-      'Unsupported React version. This is a bug in React Debug Tools.',
-    );
-  }
-
-  const type = fiber.type;
-  let props = fiber.memoizedProps;
-  if (type !== fiber.elementType) {
-    props = resolveDefaultProps(type, props);
-  }
-
-  // Only used for versions of React without memoized context value in context dependencies.
-  const contextMap = new Map<ReactContext<any>, any>();
-  try {
-    if (
-      currentContextDependency !== null &&
-      !hasOwnProperty.call(currentContextDependency, 'memoizedValue')
-    ) {
-      setupContexts(contextMap, fiber);
-    }
-
-    if (fiber.tag === ForwardRef) {
-      return inspectHooksOfForwardRef(
-        type.render,
-        props,
-        fiber.ref,
-        currentDispatcher,
-      );
-    }
-
-    return inspectHooks(type, props, currentDispatcher);
-  } finally {
-    currentFiber = null;
-    currentHook = null;
-    currentContextDependency = null;
-
-    restoreContexts(contextMap);
-  }
-}
\ No newline at end of file
+  readHookLog: Array<HookLogEntry>,
\ No newline at end of file
