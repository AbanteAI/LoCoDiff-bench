
index 2048a82a3..6bc08a7b4 100644
--- a/react_packages_react-debug-tools_src_ReactDebugHooks.js_expectedoutput.txt (expected):tmp/tmpxwxpm9go_expected.txt	
+++ b/react_packages_react-debug-tools_src_ReactDebugHooks.js_extracted.txt (actual):tmp/tmpe5_ptum8_actual.txt	
@@ -20,6 +20,7 @@ import type {
   Dependencies,
   Fiber,
   Dispatcher as DispatcherType,
+  ContextDependencyWithSelect,
 } from 'react-reconciler/src/ReactInternalTypes';
 import type {TransitionStatus} from 'react-reconciler/src/ReactFiberConfig';
 
@@ -61,11 +62,6 @@ type Dispatch<A> = A => void;
 
 let primitiveStackCache: null | Map<string, Array<any>> = null;
 
-type Hook = {
-  memoizedState: any,
-  next: Hook | null,
-};
-
 function getPrimitiveStackCache(): Map<string, Array<any>> {
   // This initializes a cache of all primitive hooks so that the top
   // most stack frames added by calling the primitive hook can be removed.
@@ -75,6 +71,13 @@ function getPrimitiveStackCache(): Map<string, Array<any>> {
     try {
       // Use all hooks here to add them to the hook log.
       Dispatcher.useContext(({_currentValue: null}: any));
+      if (typeof Dispatcher.unstable_useContextWithBailout === 'function') {
+        // This type check is for Flow only.
+        Dispatcher.unstable_useContextWithBailout(
+          ({_currentValue: null}: any),
+          null,
+        );
+      }
       Dispatcher.useState(null);
       Dispatcher.useReducer((s: mixed, a: mixed) => s, null);
       Dispatcher.useRef(null);
@@ -96,14 +99,22 @@ function getPrimitiveStackCache(): Map<string, Array<any>> {
       );
       Dispatcher.useDeferredValue(null);
       Dispatcher.useMemo(() => null);
-      Dispatcher.useOptimistic(null, (s: mixed, a: mixed) => s);
-      Dispatcher.useFormState((s: mixed, p: mixed) => s, null);
-      Dispatcher.useActionState((s: mixed, p: mixed) => s, null);
-      Dispatcher.useHostTransitionStatus();
       if (typeof Dispatcher.useMemoCache === 'function') {
         // This type check is for Flow only.
         Dispatcher.useMemoCache(0);
       }
+      if (typeof Dispatcher.useOptimistic === 'function') {
+        // This type check is for Flow only.
+        Dispatcher.useOptimistic(null, (s: mixed, a: mixed) => s);
+      }
+      if (typeof Dispatcher.useFormState === 'function') {
+        // This type check is for Flow only.
+        Dispatcher.useFormState((s: mixed, p: mixed) => s, null);
+      }
+      if (typeof Dispatcher.useActionState === 'function') {
+        // This type check is for Flow only.
+        Dispatcher.useActionState((s: mixed, p: mixed) => s, null);
+      }
       if (typeof Dispatcher.use === 'function') {
         // This type check is for Flow only.
         Dispatcher.use(
@@ -128,8 +139,9 @@ function getPrimitiveStackCache(): Map<string, Array<any>> {
 
       Dispatcher.useId();
 
-      if (typeof Dispatcher.useEffectEvent === 'function') {
-        Dispatcher.useEffectEvent((args: empty) => {});
+      if (typeof Dispatcher.useHostTransitionStatus === 'function') {
+        // This type check is for Flow only.
+        Dispatcher.useHostTransitionStatus();
       }
     } finally {
       readHookLog = hookLog;
@@ -144,9 +156,17 @@ function getPrimitiveStackCache(): Map<string, Array<any>> {
   return primitiveStackCache;
 }
 
+type Hook = {
+  memoizedState: any,
+  next: Hook | null,
+};
+
 let currentFiber: null | Fiber = null;
 let currentHook: null | Hook = null;
-let currentContextDependency: null | ContextDependency<mixed> = null;
+let currentContextDependency:
+  | null
+  | ContextDependency<mixed>
+  | ContextDependencyWithSelect<mixed> = null;
 
 function nextHook(): null | Hook {
   const hook = currentHook;
@@ -194,7 +214,7 @@ const SuspenseException: mixed = new Error(
     '`try/catch` block. Capturing without rethrowing will lead to ' +
     'unexpected behavior.\n\n' +
     'To handle async errors, wrap your component in an error boundary, or ' +
-    "call the promise's `.catch` method and pass the result to `use`.",
+    "call the promise's `.catch` method and pass the result to `use`",
 );
 
 function use<T>(usable: Usable<T>): T {
@@ -267,6 +287,22 @@ function useContext<T>(context: ReactContext<T>): T {
   return value;
 }
 
+function unstable_useContextWithBailout<T>(
+  context: ReactContext<T>,
+  select: (T => Array<mixed>) | null,
+): T {
+  const value = readContext(context);
+  hookLog.push({
+    displayName: context.displayName || null,
+    primitive: 'Context',
+    stackError: new Error(),
+    value: value,
+    debugInfo: null,
+    dispatcherHookName: 'Context',
+  });
+  return value;
+}
+
 function useState<S>(
   initialState: (() => S) | S,
 ): [S, Dispatch<BasicStateAction<S>>] {
@@ -371,7 +407,7 @@ function useInsertionEffect(
 
 function useEffect(
   create: () => (() => void) | void,
-  deps: Array<mixed> | void | null,
+  inputs: Array<mixed> | void | null,
 ): void {
   nextHook();
   hookLog.push({
@@ -524,16 +560,15 @@ function useId(): string {
 
 // useMemoCache is an implementation detail of Forget's memoization
 // it should not be called directly in user-generated code
-function useMemoCache(size: number): Array<mixed> {
+function useMemoCache(size: number): Array<any> {
   const fiber = currentFiber;
   // Don't throw, in case this is called from getPrimitiveStackCache
   if (fiber == null) {
     return [];
   }
 
-  const memoCache =
-    // $FlowFixMe[incompatible-use]: updateQueue is mixed
-    fiber.updateQueue != null ? fiber.updateQueue.memoCache : null;
+  // $FlowFixMe[incompatible-use]: updateQueue is mixed
+  const memoCache = fiber.updateQueue?.memoCache;
   if (memoCache == null) {
     return [];
   }
@@ -735,46 +770,31 @@ function useHostTransitionStatus(): TransitionStatus {
   return status;
 }
 
-function useEffectEvent<Args, F: (...Array<Args>) => mixed>(callback: F): F {
-  nextHook();
-  hookLog.push({
-    displayName: null,
-    primitive: 'EffectEvent',
-    stackError: new Error(),
-    value: callback,
-    debugInfo: null,
-    dispatcherHookName: 'EffectEvent',
-  });
-
-  return callback;
-}
-
 const Dispatcher: DispatcherType = {
-  readContext,
-
   use,
+  readContext,
+  useCacheRefresh,
   useCallback,
   useContext,
+  unstable_useContextWithBailout,
   useEffect,
   useImperativeHandle,
+  useDebugValue,
   useLayoutEffect,
   useInsertionEffect,
   useMemo,
+  useMemoCache,
+  useOptimistic,
   useReducer,
   useRef,
   useState,
-  useDebugValue,
-  useDeferredValue,
   useTransition,
   useSyncExternalStore,
+  useDeferredValue,
   useId,
-  useHostTransitionStatus,
   useFormState,
   useActionState,
-  useOptimistic,
-  useMemoCache,
-  useCacheRefresh,
-  useEffectEvent,
+  useHostTransitionStatus,
 };
 
 // create a proxy to throw a custom error
@@ -958,15 +978,6 @@ function parseHookName(functionName: void | string): string {
   } else {
     startIndex += 1;
   }
-
-  if (functionName.slice(startIndex).startsWith('unstable_')) {
-    startIndex += 'unstable_'.length;
-  }
-
-  if (functionName.slice(startIndex).startsWith('experimental_')) {
-    startIndex += 'experimental_'.length;
-  }
-
   if (functionName.slice(startIndex, startIndex + 3) === 'use') {
     if (functionName.length - startIndex === 3) {
       return 'Use';
@@ -1017,7 +1028,6 @@ function buildTree(
         }
         // Pop back the stack as many steps as were not common.
         for (let j = prevStack.length - 1; j > commonSteps; j--) {
-          // $FlowFixMe[incompatible-type]
           levelChildren = stackOfChildren.pop();
         }
       }
