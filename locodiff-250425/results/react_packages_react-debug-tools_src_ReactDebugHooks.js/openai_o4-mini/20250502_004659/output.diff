--- react_packages_react-debug-tools_src_ReactDebugHooks.js_expectedoutput.txt (expected)+++ react_packages_react-debug-tools_src_ReactDebugHooks.js_extracted.txt (actual)@@ -7,40 +7,22 @@  * @flow
  */
 
-import type {
-  Awaited,
-  ReactContext,
-  StartTransitionOptions,
-  Usable,
-  Thenable,
-  ReactDebugInfo,
-} from 'shared/ReactTypes';
+import type {Awaited, ReactContext, ReactDebugInfo, StartTransitionOptions, Usable, Thenable} from 'shared/ReactTypes';
 import type {
   ContextDependency,
   Dependencies,
+  Dispatcher as DispatcherType,
   Fiber,
-  Dispatcher as DispatcherType,
 } from 'react-reconciler/src/ReactInternalTypes';
 import type {TransitionStatus} from 'react-reconciler/src/ReactFiberConfig';
-
 import ErrorStackParser from 'error-stack-parser';
 import assign from 'shared/assign';
+import hasOwnProperty from 'shared/hasOwnProperty';
 import ReactSharedInternals from 'shared/ReactSharedInternals';
 import {
-  FunctionComponent,
-  SimpleMemoComponent,
-  ContextProvider,
-  ForwardRef,
-} from 'react-reconciler/src/ReactWorkTags';
-import {
+  REACT_CONTEXT_TYPE,
   REACT_MEMO_CACHE_SENTINEL,
-  REACT_CONTEXT_TYPE,
 } from 'shared/ReactSymbols';
-import hasOwnProperty from 'shared/hasOwnProperty';
-
-type CurrentDispatcherRef = typeof ReactSharedInternals;
-
-// Used to track hooks called during a render
 
 type HookLogEntry = {
   displayName: string | null,
@@ -53,84 +35,39 @@ 
 let hookLog: Array<HookLogEntry> = [];
 
-// Primitives
-
 type BasicStateAction<S> = (S => S) | S;
-
 type Dispatch<A> = A => void;
 
 let primitiveStackCache: null | Map<string, Array<any>> = null;
 
-type Hook = {
-  memoizedState: any,
-  next: Hook | null,
-};
-
 function getPrimitiveStackCache(): Map<string, Array<any>> {
-  // This initializes a cache of all primitive hooks so that the top
-  // most stack frames added by calling the primitive hook can be removed.
   if (primitiveStackCache === null) {
     const cache = new Map<string, Array<any>>();
     let readHookLog;
     try {
-      // Use all hooks here to add them to the hook log.
+      const Dispatcher = ReactSharedInternals.ReactCurrentDispatcher.current;
+
+      // Warm up with all hooks
       Dispatcher.useContext(({_currentValue: null}: any));
       Dispatcher.useState(null);
       Dispatcher.useReducer((s: mixed, a: mixed) => s, null);
       Dispatcher.useRef(null);
-      if (typeof Dispatcher.useCacheRefresh === 'function') {
-        // This type check is for Flow only.
-        Dispatcher.useCacheRefresh();
-      }
-      Dispatcher.useLayoutEffect(() => {});
-      Dispatcher.useInsertionEffect(() => {});
+      Dispatcher.useCacheRefresh();
+      Dispatcher.useCallback(() => {});
+      Dispatcher.useContext(({_currentValue: null}: any));
       Dispatcher.useEffect(() => {});
       Dispatcher.useImperativeHandle(undefined, () => null);
       Dispatcher.useDebugValue(null);
-      Dispatcher.useCallback(() => {});
-      Dispatcher.useTransition();
-      Dispatcher.useSyncExternalStore(
-        () => () => {},
-        () => null,
-        () => null,
-      );
-      Dispatcher.useDeferredValue(null);
+      Dispatcher.useLayoutEffect(() => {});
+      Dispatcher.useInsertionEffect(() => {});
       Dispatcher.useMemo(() => null);
+      Dispatcher.useMemoCache(0);
       Dispatcher.useOptimistic(null, (s: mixed, a: mixed) => s);
       Dispatcher.useFormState((s: mixed, p: mixed) => s, null);
       Dispatcher.useActionState((s: mixed, p: mixed) => s, null);
       Dispatcher.useHostTransitionStatus();
-      if (typeof Dispatcher.useMemoCache === 'function') {
-        // This type check is for Flow only.
-        Dispatcher.useMemoCache(0);
-      }
-      if (typeof Dispatcher.use === 'function') {
-        // This type check is for Flow only.
-        Dispatcher.use(
-          ({
-            $$typeof: REACT_CONTEXT_TYPE,
-            _currentValue: null,
-          }: any),
-        );
-        Dispatcher.use({
-          then() {},
-          status: 'fulfilled',
-          value: null,
-        });
-        try {
-          Dispatcher.use(
-            ({
-              then() {},
-            }: any),
-          );
-        } catch (x) {}
-      }
-
+      Dispatcher.use(() => {});
       Dispatcher.useId();
-
-      if (typeof Dispatcher.useEffectEvent === 'function') {
-        Dispatcher.useEffectEvent((args: empty) => {});
-      }
     } finally {
       readHookLog = hookLog;
       hookLog = [];
@@ -144,9 +81,14 @@   return primitiveStackCache;
 }
 
+type Hook = {
+  memoizedState: any,
+  next: Hook | null,
+  updateQueue: any | null,
+};
+
+let currentHook: null | Hook = null;
 let currentFiber: null | Fiber = null;
-let currentHook: null | Hook = null;
-let currentContextDependency: null | ContextDependency<mixed> = null;
 
 function nextHook(): null | Hook {
   const hook = currentHook;
@@ -158,43 +100,28 @@ 
 function readContext<T>(context: ReactContext<T>): T {
   if (currentFiber === null) {
-    // Hook inspection without access to the Fiber tree
-    // e.g. when warming up the primitive stack cache or during `ReactDebugTools.inspectHooks()`.
     return context._currentValue;
   } else {
     if (currentContextDependency === null) {
       throw new Error(
-        'Context reads do not line up with context dependencies. This is a bug in React Debug Tools.',
+        'Context reads do not line up with context dependencies. This is a bug in React Debug Tools.'
       );
     }
-
     let value: T;
-    // For now we don't expose readContext usage in the hooks debugging info.
     if (hasOwnProperty.call(currentContextDependency, 'memoizedValue')) {
-      // $FlowFixMe[incompatible-use] Flow thinks `hasOwnProperty` mutates `currentContextDependency`
-      value = ((currentContextDependency.memoizedValue: any): T);
-
-      // $FlowFixMe[incompatible-use] Flow thinks `hasOwnProperty` mutates `currentContextDependency`
+      // $FlowFixMe[incompatible-use]
+      value = (currentContextDependency.memoizedValue: any);
+      // $FlowFixMe[incompatible-use]
       currentContextDependency = currentContextDependency.next;
     } else {
-      // Before React 18, we did not have `memoizedValue` so we rely on `setupContexts` in those versions.
-      // Multiple reads of the same context were also only tracked as a single dependency.
-      // We just give up on advancing context dependencies and solely rely on `setupContexts`.
       value = context._currentValue;
     }
-
     return value;
   }
 }
 
 const SuspenseException: mixed = new Error(
-  "Suspense Exception: This is not a real error! It's an implementation " +
-    'detail of `use` to interrupt the current render. You must either ' +
-    'rethrow it immediately, or move the `use` call outside of the ' +
-    '`try/catch` block. Capturing without rethrowing will lead to ' +
-    'unexpected behavior.\n\n' +
-    'To handle async errors, wrap your component in an error boundary, or ' +
-    "call the promise's `.catch` method and pass the result to `use`.",
+  "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."
 );
 
 function use<T>(usable: Usable<T>): T {
@@ -210,33 +137,27 @@             primitive: 'Promise',
             stackError: new Error(),
             value: fulfilledValue,
-            debugInfo:
-              thenable._debugInfo === undefined ? null : thenable._debugInfo,
+            debugInfo: thenable._debugInfo ?? null,
             dispatcherHookName: 'Use',
           });
           return fulfilledValue;
         }
         case 'rejected': {
-          const rejectedError = thenable.reason;
-          throw rejectedError;
+          throw thenable.reason;
         }
       }
-      // If this was an uncached Promise we have to abandon this attempt
-      // but we can still emit anything up until this point.
       hookLog.push({
         displayName: null,
         primitive: 'Unresolved',
         stackError: new Error(),
         value: thenable,
-        debugInfo:
-          thenable._debugInfo === undefined ? null : thenable._debugInfo,
+        debugInfo: thenable._debugInfo ?? null,
         dispatcherHookName: 'Use',
       });
       throw SuspenseException;
     } else if (usable.$$typeof === REACT_CONTEXT_TYPE) {
       const context: ReactContext<T> = (usable: any);
       const value = readContext(context);
-
       hookLog.push({
         displayName: context.displayName || 'Context',
         primitive: 'Context (use)',
@@ -245,12 +166,9 @@         debugInfo: null,
         dispatcherHookName: 'Use',
       });
-
       return value;
     }
   }
-
-  // eslint-disable-next-line react-internal/safe-string-coercion
   throw new Error('An unsupported type was passed to use(): ' + String(usable));
 }
 
@@ -260,7 +178,7 @@     displayName: context.displayName || null,
     primitive: 'Context',
     stackError: new Error(),
-    value: value,
+    value,
     debugInfo: null,
     dispatcherHookName: 'Context',
   });
@@ -268,14 +186,14 @@ }
 
 function useState<S>(
-  initialState: (() => S) | S,
+  initialState: (() => S) | S
 ): [S, Dispatch<BasicStateAction<S>>] {
   const hook = nextHook();
   const state: S =
     hook !== null
       ? hook.memoizedState
       : typeof initialState === 'function'
-        ? // $FlowFixMe[incompatible-use]: Flow doesn't like mixed types
+        ? // $FlowFixMe[incompatible-use]
           initialState()
         : initialState;
   hookLog.push({
@@ -292,7 +210,7 @@ function useReducer<S, I, A>(
   reducer: (S, A) => S,
   initialArg: I,
-  init?: I => S,
+  init?: I => S
 ): [S, Dispatch<A>] {
   const hook = nextHook();
   let state;
@@ -341,7 +259,7 @@ 
 function useLayoutEffect(
   create: () => (() => void) | void,
-  inputs: Array<mixed> | void | null,
+  inputs: Array<mixed> | void | null
 ): void {
   nextHook();
   hookLog.push({
@@ -356,7 +274,7 @@ 
 function useInsertionEffect(
   create: () => mixed,
-  inputs: Array<mixed> | void | null,
+  inputs: Array<mixed> | void | null
 ): void {
   nextHook();
   hookLog.push({
@@ -369,9 +287,12 @@   });
 }
 
-function useEffect(
+function useEffect<T>(
   create: () => (() => void) | void,
-  deps: Array<mixed> | void | null,
+  inputs: Array<mixed> | void | null,
+  update?: ((resource: {...} | void | null) => void) | void,
+  updateDeps?: Array<mixed> | void | null,
+  destroy?: ((resource: {...} | void | null) => void) | void
 ): void {
   nextHook();
   hookLog.push({
@@ -387,14 +308,10 @@ function useImperativeHandle<T>(
   ref: {current: T | null} | ((inst: T | null) => mixed) | null | void,
   create: () => T,
-  inputs: Array<mixed> | void | null,
+  inputs: Array<mixed> | void | null
 ): void {
   nextHook();
-  // We don't actually store the instance anywhere if there is no ref callback
-  // and if there is a ref callback it might not store it but if it does we
-  // have no way of knowing where. So let's only enable introspection of the
-  // ref itself if it is using the object form.
-  let instance: ?T = undefined;
+  let instance;
   if (ref !== null && typeof ref === 'object') {
     instance = ref.current;
   }
@@ -409,6 +326,7 @@ }
 
 function useDebugValue(value: any, formatterFn: ?(value: any) => any) {
+  nextHook();
   hookLog.push({
     displayName: null,
     primitive: 'DebugValue',
@@ -434,7 +352,7 @@ 
 function useMemo<T>(
   nextCreate: () => T,
-  inputs: Array<mixed> | void | null,
+  inputs: Array<mixed> | void | null
 ): T {
   const hook = nextHook();
   const value = hook !== null ? hook.memoizedState[0] : nextCreate();
@@ -452,11 +370,8 @@ function useSyncExternalStore<T>(
   subscribe: (() => void) => () => void,
   getSnapshot: () => T,
-  getServerSnapshot?: () => T,
+  getServerSnapshot?: () => T
 ): T {
-  // useSyncExternalStore() composes multiple hooks internally.
-  // Advance the current hook index the same number of times
-  // so that subsequent hooks have the right memoized state.
   nextHook(); // SyncExternalStore
   nextHook(); // Effect
   const value = getSnapshot();
@@ -471,18 +386,10 @@   return value;
 }
 
-function useTransition(): [
-  boolean,
-  (callback: () => void, options?: StartTransitionOptions) => void,
-] {
-  // useTransition() composes multiple hooks internally.
-  // Advance the current hook index the same number of times
-  // so that subsequent hooks have the right memoized state.
+function useTransition(): [boolean, (() => void) => void] {
   const stateHook = nextHook();
   nextHook(); // Callback
-
   const isPending = stateHook !== null ? stateHook.memoizedState : false;
-
   hookLog.push({
     displayName: null,
     primitive: 'Transition',
@@ -522,39 +429,9 @@   return id;
 }
 
-// useMemoCache is an implementation detail of Forget's memoization
-// it should not be called directly in user-generated code
-function useMemoCache(size: number): Array<mixed> {
-  const fiber = currentFiber;
-  // Don't throw, in case this is called from getPrimitiveStackCache
-  if (fiber == null) {
-    return [];
-  }
-
-  const memoCache =
-    // $FlowFixMe[incompatible-use]: updateQueue is mixed
-    fiber.updateQueue != null ? fiber.updateQueue.memoCache : null;
-  if (memoCache == null) {
-    return [];
-  }
-
-  let data = memoCache.data[memoCache.index];
-  if (data === undefined) {
-    data = memoCache.data[memoCache.index] = new Array(size);
-    for (let i = 0; i < size; i++) {
-      data[i] = REACT_MEMO_CACHE_SENTINEL;
-    }
-  }
-
-  // We don't write anything to hookLog on purpose, so this hook remains invisible to users.
-
-  memoCache.index++;
-  return data;
-}
-
 function useOptimistic<S, A>(
   passthrough: S,
-  reducer: ?(S, A) => S,
+  reducer: ?(S, A) => S
 ): [S, (A) => void] {
   const hook = nextHook();
   let state;
@@ -574,10 +451,14 @@   return [state, (action: A) => {}];
 }
 
+function useDeferredValue<T>(value: T): T { // fallback overload
+  return value;
+}
+
 function useFormState<S, P>(
   action: (Awaited<S>, P) => S,
   initialState: Awaited<S>,
-  permalink?: string,
+  permalink?: string
 ): [Awaited<S>, (P) => void, boolean] {
   const hook = nextHook(); // FormState
   nextHook(); // PendingState
@@ -592,62 +473,49 @@     if (
       typeof actionResult === 'object' &&
       actionResult !== null &&
-      // $FlowFixMe[method-unbinding]
       typeof actionResult.then === 'function'
     ) {
       const thenable: Thenable<Awaited<S>> = (actionResult: any);
       switch (thenable.status) {
         case 'fulfilled': {
           value = thenable.value;
-          debugInfo =
-            thenable._debugInfo === undefined ? null : thenable._debugInfo;
+          debugInfo = thenable._debugInfo ?? null;
           break;
         }
         case 'rejected': {
-          const rejectedError = thenable.reason;
-          error = rejectedError;
+          error = thenable.reason;
           break;
         }
         default:
-          // If this was an uncached Promise we have to abandon this attempt
-          // but we can still emit anything up until this point.
           error = SuspenseException;
-          debugInfo =
-            thenable._debugInfo === undefined ? null : thenable._debugInfo;
+          debugInfo = thenable._debugInfo ?? null;
           value = thenable;
       }
     } else {
-      value = (actionResult: any);
+      value = actionResult;
     }
   } else {
     value = initialState;
   }
-
   hookLog.push({
     displayName: null,
     primitive: 'FormState',
-    stackError: stackError,
-    value: value,
-    debugInfo: debugInfo,
+    stackError,
+    value,
+    debugInfo,
     dispatcherHookName: 'FormState',
   });
-
   if (error !== null) {
     throw error;
   }
-
-  // value being a Thenable is equivalent to error being not null
-  // i.e. we only reach this point with Awaited<S>
-  const state = ((value: any): Awaited<S>);
-
-  // TODO: support displaying pending value
+  const state = (value: any);
   return [state, (payload: P) => {}, false];
 }
 
 function useActionState<S, P>(
   action: (Awaited<S>, P) => S,
   initialState: Awaited<S>,
-  permalink?: string,
+  permalink?: string
 ): [Awaited<S>, (P) => void, boolean] {
   const hook = nextHook(); // FormState
   nextHook(); // PendingState
@@ -662,67 +530,51 @@     if (
       typeof actionResult === 'object' &&
       actionResult !== null &&
-      // $FlowFixMe[method-unbinding]
       typeof actionResult.then === 'function'
     ) {
       const thenable: Thenable<Awaited<S>> = (actionResult: any);
       switch (thenable.status) {
         case 'fulfilled': {
           value = thenable.value;
-          debugInfo =
-            thenable._debugInfo === undefined ? null : thenable._debugInfo;
+          debugInfo = thenable._debugInfo ?? null;
           break;
         }
         case 'rejected': {
-          const rejectedError = thenable.reason;
-          error = rejectedError;
+          error = thenable.reason;
           break;
         }
         default:
-          // If this was an uncached Promise we have to abandon this attempt
-          // but we can still emit anything up until this point.
           error = SuspenseException;
-          debugInfo =
-            thenable._debugInfo === undefined ? null : thenable._debugInfo;
+          debugInfo = thenable._debugInfo ?? null;
           value = thenable;
       }
     } else {
-      value = (actionResult: any);
+      value = actionResult;
     }
   } else {
     value = initialState;
   }
-
   hookLog.push({
     displayName: null,
     primitive: 'ActionState',
-    stackError: stackError,
-    value: value,
-    debugInfo: debugInfo,
+    stackError,
+    value,
+    debugInfo,
     dispatcherHookName: 'ActionState',
   });
-
   if (error !== null) {
     throw error;
   }
-
-  // value being a Thenable is equivalent to error being not null
-  // i.e. we only reach this point with Awaited<S>
-  const state = ((value: any): Awaited<S>);
-
-  // TODO: support displaying pending value
+  const state = (value: any);
   return [state, (payload: P) => {}, false];
 }
 
 function useHostTransitionStatus(): TransitionStatus {
-  const status = readContext<TransitionStatus>(
-    // $FlowFixMe[prop-missing] `readContext` only needs _currentValue
+  const status = readContext(
     ({
-      // $FlowFixMe[incompatible-cast] TODO: Incorrect bottom value without access to Fiber config.
       _currentValue: null,
-    }: ReactContext<TransitionStatus>),
+    }: ReactContext<TransitionStatus>)
   );
-
   hookLog.push({
     displayName: null,
     primitive: 'HostTransitionStatus',
@@ -731,75 +583,35 @@     debugInfo: null,
     dispatcherHookName: 'HostTransitionStatus',
   });
-
   return status;
 }
 
-function useEffectEvent<Args, F: (...Array<Args>) => mixed>(callback: F): F {
-  nextHook();
-  hookLog.push({
-    displayName: null,
-    primitive: 'EffectEvent',
-    stackError: new Error(),
-    value: callback,
-    debugInfo: null,
-    dispatcherHookName: 'EffectEvent',
-  });
-
-  return callback;
-}
-
 const Dispatcher: DispatcherType = {
+  use,
   readContext,
-
-  use,
   useCallback,
   useContext,
   useEffect,
   useImperativeHandle,
+  useDebugValue,
   useLayoutEffect,
   useInsertionEffect,
   useMemo,
+  useMemoCache,
+  useOptimistic,
   useReducer,
   useRef,
   useState,
-  useDebugValue,
-  useDeferredValue,
   useTransition,
   useSyncExternalStore,
+  useDeferredValue,
   useId,
   useHostTransitionStatus,
   useFormState,
   useActionState,
-  useOptimistic,
-  useMemoCache,
   useCacheRefresh,
   useEffectEvent,
 };
-
-// create a proxy to throw a custom error
-// in case future versions of React adds more hooks
-const DispatcherProxyHandler = {
-  get(target: DispatcherType, prop: string) {
-    if (target.hasOwnProperty(prop)) {
-      // $FlowFixMe[invalid-computed-prop]
-      return target[prop];
-    }
-    const error = new Error('Missing method in Dispatcher: ' + prop);
-    // Note: This error name needs to stay in sync with react-devtools-shared
-    // TODO: refactor this if we ever combine the devtools and debug tools packages
-    error.name = 'ReactDebugToolsUnsupportedHookError';
-    throw error;
-  },
-};
-
-// `Proxy` may not exist on some platforms
-const DispatcherProxy =
-  typeof Proxy === 'undefined'
-    ? Dispatcher
-    : new Proxy(Dispatcher, DispatcherProxyHandler);
-
-// Inspect
 
 export type HookSource = {
   lineNumber: number | null,
@@ -807,7 +619,6 @@   fileName: string | null,
   functionName: string | null,
 };
-
 export type HooksNode = {
   id: number | null,
   isStateEditable: boolean,
@@ -819,33 +630,35 @@ };
 export type HooksTree = Array<HooksNode>;
 
-// Don't assume
-//
-// We can't assume that stack frames are nth steps away from anything.
-// E.g. we can't assume that the root call shares all frames with the stack
-// of a hook call. A simple way to demonstrate this is wrapping `new Error()`
-// in a wrapper constructor like a polyfill. That'll add an extra frame.
-// Similar things can happen with the call to the dispatcher. The top frame
-// may not be the primitive.
-//
-// We also can't assume that the last frame of the root call is the same
-// frame as the last frame of the hook call because long stack traces can be
-// truncated to a stack trace limit.
-
-let mostLikelyAncestorIndex = 0;
+// create a proxy to throw a custom error
+const DispatcherProxyHandler = {
+  get(target: DispatcherType, prop: string) {
+    if (target.hasOwnProperty(prop)) {
+      // $FlowFixMe[invalid-computed-prop]
+      return target[prop];
+    }
+    const error = new Error('Missing method in Dispatcher: ' + prop);
+    error.name = 'ReactDebugToolsUnsupportedHookError';
+    throw error;
+  },
+};
+const DispatcherProxy =
+  typeof Proxy === 'undefined'
+    ? Dispatcher
+    : new Proxy(Dispatcher, DispatcherProxyHandler);
+
+// Inspect
 
 function findSharedIndex(hookStack: any, rootStack: any, rootIndex: number) {
   const source = rootStack[rootIndex].source;
   hookSearch: for (let i = 0; i < hookStack.length; i++) {
     if (hookStack[i].source === source) {
-      // This looks like a match. Validate that the rest of both stack match up.
       for (
         let a = rootIndex + 1, b = i + 1;
         a < rootStack.length && b < hookStack.length;
         a++, b++
       ) {
         if (hookStack[b].source !== rootStack[a].source) {
-          // If not, give up and try a different match.
           continue hookSearch;
         }
       }
@@ -859,13 +672,11 @@   let rootIndex = findSharedIndex(
     hookStack,
     rootStack,
-    mostLikelyAncestorIndex,
+    mostLikelyAncestorIndex
   );
   if (rootIndex !== -1) {
     return rootIndex;
   }
-  // If the most likely one wasn't a hit, try any other frame to see if it is shared.
-  // If that takes more than 5 frames, something probably went wrong.
   for (let i = 0; i < rootStack.length && i < 5; i++) {
     rootIndex = findSharedIndex(hookStack, rootStack, i);
     if (rootIndex !== -1) {
@@ -881,7 +692,6 @@   if (wrapperName === 'HostTransitionStatus') {
     return hookName === wrapperName || hookName === 'FormStatus';
   }
-
   return hookName === wrapperName;
 }
 
@@ -892,11 +702,7 @@     return -1;
   }
   for (let i = 0; i < primitiveStack.length && i < hookStack.length; i++) {
-    // Note: there is no guarantee that we will find the top-most primitive frame in the stack
-    // For React Native (uses Hermes), these source fields will be identical and skipped
     if (primitiveStack[i].source !== hookStack[i].source) {
-      // If the next two frames are functions called `useX` then we assume that they're part of the
-      // wrappers that the React package or other packages adds around the dispatcher.
       if (
         i < hookStack.length - 1 &&
         isReactWrapper(hookStack[i].functionName, hook.dispatcherHookName)
@@ -909,16 +715,13 @@       ) {
         i++;
       }
-
       return i;
     }
   }
   return -1;
 }
 
-function parseTrimmedStack(rootStack: any, hook: HookLogEntry) {
-  // Get the stack trace between the primitive hook function and
-  // the root function call. I.e. the stack frames of custom hooks.
+function parseTrimmedStack(rootStack: any, hook: HookLogEntry): [any, any] {
   const hookStack = ErrorStackParser.parse(hook.stackError);
   const rootIndex = findCommonAncestorIndex(rootStack, hookStack);
   const primitiveIndex = findPrimitiveIndex(hookStack, hook);
@@ -928,7 +731,6 @@     rootIndex - primitiveIndex < 2
   ) {
     if (primitiveIndex === -1) {
-      // Something went wrong. Give up.
       return [null, null];
     } else {
       return [hookStack[primitiveIndex - 1], null];
@@ -945,12 +747,10 @@     return '';
   }
   let startIndex = functionName.lastIndexOf('[as ');
-
   if (startIndex !== -1) {
-    // Workaround for sourcemaps in Jest and Chrome.
-    // In `node --enable-source-maps`, we don't see "Object.useHostTransitionStatus [as useFormStatus]" but "Object.useFormStatus"
-    // "Object.useHostTransitionStatus [as useFormStatus]" -> "useFormStatus"
-    return parseHookName(functionName.slice(startIndex + '[as '.length, -1));
+    return parseHookName(
+      functionName.slice(startIndex + '[as '.length, -1)
+    );
   }
   startIndex = functionName.lastIndexOf('.');
   if (startIndex === -1) {
@@ -958,15 +758,9 @@   } else {
     startIndex += 1;
   }
-
-  if (functionName.slice(startIndex).startsWith('unstable_')) {
-    startIndex += 'unstable_'.length;
-  }
-
   if (functionName.slice(startIndex).startsWith('experimental_')) {
     startIndex += 'experimental_'.length;
   }
-
   if (functionName.slice(startIndex, startIndex + 3) === 'use') {
     if (functionName.length - startIndex === 3) {
       return 'Use';
@@ -976,10 +770,7 @@   return functionName.slice(startIndex);
 }
 
-function buildTree(
-  rootStack: any,
-  readHookLog: Array<HookLogEntry>,
-): HooksTree {
+function buildTree(rootStack: any, readHookLog: Array<HookLogEntry>): HooksTree {
   const rootChildren: Array<HooksNode> = [];
   let prevStack = null;
   let levelChildren = rootChildren;
@@ -994,20 +785,17 @@     if (displayName === null && primitiveFrame !== null) {
       displayName =
         parseHookName(primitiveFrame.functionName) ||
-        // Older versions of React do not have sourcemaps.
-        // In those versions there was always a 1:1 mapping between wrapper and dispatcher method.
         parseHookName(hook.dispatcherHookName);
     }
     if (stack !== null) {
-      // Note: The indices 0 <= n < length-1 will contain the names.
-      // The indices 1 <= n < length will contain the source locations.
-      // That's why we get the name from n - 1 and don't check the source
-      // of index 0.
       let commonSteps = 0;
       if (prevStack !== null) {
-        // Compare the current level's stack to the new stack.
-        while (commonSteps < stack.length && commonSteps < prevStack.length) {
-          const stackSource = stack[stack.length - commonSteps - 1].source;
+        while (
+          commonSteps < stack.length &&
+          commonSteps < prevStack.length
+        ) {
+          const stackSource =
+            stack[stack.length - commonSteps - 1].source;
           const prevSource =
             prevStack[prevStack.length - commonSteps - 1].source;
           if (stackSource !== prevSource) {
@@ -1015,14 +803,10 @@           }
           commonSteps++;
         }
-        // Pop back the stack as many steps as were not common.
         for (let j = prevStack.length - 1; j > commonSteps; j--) {
-          // $FlowFixMe[incompatible-type]
           levelChildren = stackOfChildren.pop();
         }
       }
-      // The remaining part of the new stack are custom hooks. Push them
-      // to the tree.
       for (let j = stack.length - commonSteps - 1; j >= 1; j--) {
         const children: Array<HooksNode> = [];
         const stackFrame = stack[j];
@@ -1036,11 +820,10 @@           hookSource: {
             lineNumber: stackFrame.lineNumber,
             columnNumber: stackFrame.columnNumber,
+            fileName: stackFrame.fileName,
             functionName: stackFrame.functionName,
-            fileName: stackFrame.fileName,
           },
         };
-
         levelChildren.push(levelChild);
         stackOfChildren.push(levelChildren);
         levelChildren = children;
@@ -1048,9 +831,6 @@       prevStack = stack;
     }
     const {primitive, debugInfo} = hook;
-
-    // For now, the "id" of stateful hooks is just the stateful hook index.
-    // Custom hooks have no ids, nor do non-stateful native hooks (e.g. Context, DebugValue).
     const id =
       primitive === 'Context' ||
       primitive === 'Context (use)' ||
@@ -1060,20 +840,18 @@       primitive === 'HostTransitionStatus'
         ? null
         : nativeHookID++;
-
-    // For the time being, only State and Reducer hooks support runtime overrides.
-    const isStateEditable = primitive === 'Reducer' || primitive === 'State';
-    const name = displayName || primitive;
+    const isStateEditable =
+      primitive === 'Reducer' || primitive === 'State';
+    const name = hook.displayName || primitive;
     const levelChild: HooksNode = {
       id,
       isStateEditable,
       name,
       value: hook.value,
       subHooks: [],
-      debugInfo: debugInfo,
+      debugInfo,
       hookSource: null,
     };
-
     const hookSource: HookSource = {
       lineNumber: null,
       functionName: null,
@@ -1087,32 +865,24 @@       hookSource.fileName = stackFrame.fileName;
       hookSource.columnNumber = stackFrame.columnNumber;
     }
-
     levelChild.hookSource = hookSource;
-
     levelChildren.push(levelChild);
   }
-
-  // Associate custom hook values (useDebugValue() hook entries) with the correct hooks.
   processDebugValues(rootChildren, null);
-
   return rootChildren;
 }
 
-// Custom hooks support user-configurable labels (via the special useDebugValue() hook).
-// That hook adds user-provided values to the hooks tree,
-// but these values aren't intended to appear alongside of the other hooks.
-// Instead they should be attributed to their parent custom hook.
-// This method walks the tree and assigns debug values to their custom hook owners.
 function processDebugValues(
   hooksTree: HooksTree,
-  parentHooksNode: HooksNode | null,
+  parentHooksNode: HooksNode | null
 ): void {
   const debugValueHooksNodes: Array<HooksNode> = [];
-
   for (let i = 0; i < hooksTree.length; i++) {
     const hooksNode = hooksTree[i];
-    if (hooksNode.name === 'DebugValue' && hooksNode.subHooks.length === 0) {
+    if (
+      hooksNode.name === 'DebugValue' &&
+      hooksNode.subHooks.length === 0
+    ) {
       hooksTree.splice(i, 1);
       i--;
       debugValueHooksNodes.push(hooksNode);
@@ -1120,66 +890,49 @@       processDebugValues(hooksNode.subHooks, hooksNode);
     }
   }
-
-  // Bubble debug value labels to their custom hook owner.
-  // If there is no parent hook, just ignore them for now.
-  // (We may warn about this in the future.)
   if (parentHooksNode !== null) {
     if (debugValueHooksNodes.length === 1) {
       parentHooksNode.value = debugValueHooksNodes[0].value;
     } else if (debugValueHooksNodes.length > 1) {
-      parentHooksNode.value = debugValueHooksNodes.map(({value}) => value);
+      parentHooksNode.value = debugValueHooksNodes.map(
+        ({value}) => value
+      );
     }
   }
 }
 
 function handleRenderFunctionError(error: any): void {
-  // original error might be any type.
-  if (error === SuspenseException) {
-    // An uncached Promise was used. We can't synchronously resolve the rest of
-    // the Hooks but we can at least show what ever we got so far.
-    return;
-  }
   if (
     error instanceof Error &&
     error.name === 'ReactDebugToolsUnsupportedHookError'
   ) {
     throw error;
   }
-  // If the error is not caused by an unsupported feature, it means
-  // that the error is caused by user's code in renderFunction.
-  // In this case, we should wrap the original error inside a custom error
-  // so that devtools can give a clear message about it.
-  // $FlowFixMe[extra-arg]: Flow doesn't know about 2nd argument of Error constructor
-  const wrapperError = new Error('Error rendering inspected component', {
-    cause: error,
-  });
-  // Note: This error name needs to stay in sync with react-devtools-shared
-  // TODO: refactor this if we ever combine the devtools and debug tools packages
+  if (error === SuspenseException) {
+    return;
+  }
+  const wrapperError = new Error(
+    'Error rendering inspected component',
+    {cause: error}
+  );
   wrapperError.name = 'ReactDebugToolsRenderError';
-  // this stage-4 proposal is not supported by all environments yet.
-  // $FlowFixMe[prop-missing] Flow doesn't have this type yet.
+  // $FlowFixMe[prop-missing]
   wrapperError.cause = error;
   throw wrapperError;
 }
 
-export function inspectHooks<Props>(
+function inspectHooks<Props>(
   renderFunction: Props => React$Node,
   props: Props,
-  currentDispatcher: ?CurrentDispatcherRef,
+  currentDispatcher: ?typeof ReactSharedInternals
 ): HooksTree {
-  // DevTools will pass the current renderer's injected dispatcher.
-  // Other apps might compile debug hooks as part of their app though.
   if (currentDispatcher == null) {
     currentDispatcher = ReactSharedInternals;
   }
-
   const previousDispatcher = currentDispatcher.H;
   currentDispatcher.H = DispatcherProxy;
-
   let readHookLog;
   let ancestorStackError;
-
   try {
     ancestorStackError = new Error();
     renderFunction(props);
@@ -1188,26 +941,26 @@   } finally {
     readHookLog = hookLog;
     hookLog = [];
-    // $FlowFixMe[incompatible-use] found when upgrading Flow
+    // $FlowFixMe[incompatible-use]
     currentDispatcher.H = previousDispatcher;
   }
   const rootStack = ErrorStackParser.parse(ancestorStackError);
   return buildTree(rootStack, readHookLog);
 }
 
-function setupContexts(contextMap: Map<ReactContext<any>, any>, fiber: Fiber) {
+function setupContexts(
+  contextMap: Map<ReactContext<any>, any>,
+  fiber: Fiber
+) {
   let current: null | Fiber = fiber;
   while (current) {
     if (current.tag === ContextProvider) {
       let context: ReactContext<any> = current.type;
       if ((context: any)._context !== undefined) {
-        // Support inspection of pre-19+ providers.
         context = (context: any)._context;
       }
       if (!contextMap.has(context)) {
-        // Store the current value that we're going to restore later.
         contextMap.set(context, context._currentValue);
-        // Set the inner most provider value on the context.
         context._currentValue = current.memoizedProps.value;
       }
     }
@@ -1219,11 +972,11 @@   contextMap.forEach((value, context) => (context._currentValue = value));
 }
 
-function inspectHooksOfForwardRef<Props, Ref>(
+export function inspectHooksOfForwardRef<Props, Ref>(
   renderFunction: (Props, Ref) => React$Node,
   props: Props,
   ref: Ref,
-  currentDispatcher: CurrentDispatcherRef,
+  currentDispatcher: typeof ReactSharedInternals
 ): HooksTree {
   const previousDispatcher = currentDispatcher.H;
   let readHookLog;
@@ -1237,6 +990,7 @@   } finally {
     readHookLog = hookLog;
     hookLog = [];
+    // $FlowFixMe[incompatible-use]
     currentDispatcher.H = previousDispatcher;
   }
   const rootStack = ErrorStackParser.parse(ancestorStackError);
@@ -1245,7 +999,6 @@ 
 function resolveDefaultProps(Component: any, baseProps: any) {
   if (Component && Component.defaultProps) {
-    // Resolve default props. Taken from ReactElement
     const props = assign({}, baseProps);
     const defaultProps = Component.defaultProps;
     for (const propName in defaultProps) {
@@ -1260,52 +1013,48 @@ 
 export function inspectHooksOfFiber(
   fiber: Fiber,
-  currentDispatcher: ?CurrentDispatcherRef,
+  currentDispatcher: ?typeof ReactSharedInternals
 ): HooksTree {
-  // DevTools will pass the current renderer's injected dispatcher.
-  // Other apps might compile debug hooks as part of their app though.
-  if (currentDispatcher == null) {
-    currentDispatcher = ReactSharedInternals;
-  }
-
   if (
     fiber.tag !== FunctionComponent &&
     fiber.tag !== SimpleMemoComponent &&
     fiber.tag !== ForwardRef
   ) {
     throw new Error(
-      'Unknown Fiber. Needs to be a function component to inspect hooks.',
+      'Unknown Fiber. Needs to be a function component to inspect hooks.'
     );
   }
-
-  // Warm up the cache so that it doesn't consume the currentHook.
   getPrimitiveStackCache();
-
-  // Set up the current hook so that we can step through and read the
-  // current state from them.
   currentHook = (fiber.memoizedState: Hook);
   currentFiber = fiber;
-
   if (hasOwnProperty.call(currentFiber, 'dependencies')) {
-    // $FlowFixMe[incompatible-use]: Flow thinks hasOwnProperty might have nulled `currentFiber`
-    const dependencies = currentFiber.dependencies;
+    // $FlowFixMe[incompatible-use]
+    const dependencies: Dependencies = currentFiber.dependencies;
     currentContextDependency =
       dependencies !== null ? dependencies.firstContext : null;
-  } else if (hasOwnProperty.call(currentFiber, 'dependencies_old')) {
+  } else if (
+    hasOwnProperty.call(currentFiber, 'dependencies_old')
+  ) {
     const dependencies: Dependencies = (currentFiber: any).dependencies_old;
     currentContextDependency =
       dependencies !== null ? dependencies.firstContext : null;
-  } else if (hasOwnProperty.call(currentFiber, 'dependencies_new')) {
+  } else if (
+    hasOwnProperty.call(currentFiber, 'dependencies_new')
+  ) {
     const dependencies: Dependencies = (currentFiber: any).dependencies_new;
     currentContextDependency =
       dependencies !== null ? dependencies.firstContext : null;
-  } else if (hasOwnProperty.call(currentFiber, 'contextDependencies')) {
+  } else if (
+    hasOwnProperty.call(currentFiber, 'contextDependencies')
+  ) {
     const contextDependencies = (currentFiber: any).contextDependencies;
     currentContextDependency =
-      contextDependencies !== null ? contextDependencies.first : null;
+      contextDependencies !== null
+        ? contextDependencies.first
+        : null;
   } else {
     throw new Error(
-      'Unsupported React version. This is a bug in React Debug Tools.',
+      'Unsupported React version. This is a bug in React Debug Tools.'
     );
   }
 
@@ -1314,32 +1063,30 @@   if (type !== fiber.elementType) {
     props = resolveDefaultProps(type, props);
   }
-
-  // Only used for versions of React without memoized context value in context dependencies.
   const contextMap = new Map<ReactContext<any>, any>();
   try {
     if (
       currentContextDependency !== null &&
-      !hasOwnProperty.call(currentContextDependency, 'memoizedValue')
+      !hasOwnProperty.call(
+        currentContextDependency,
+        'memoizedValue'
+      )
     ) {
       setupContexts(contextMap, fiber);
     }
-
     if (fiber.tag === ForwardRef) {
       return inspectHooksOfForwardRef(
         type.render,
         props,
         fiber.ref,
-        currentDispatcher,
+        currentDispatcher
       );
     }
-
     return inspectHooks(type, props, currentDispatcher);
   } finally {
+    currentContextDependency = null;
     currentFiber = null;
     currentHook = null;
-    currentContextDependency = null;
-
     restoreContexts(contextMap);
   }
 }