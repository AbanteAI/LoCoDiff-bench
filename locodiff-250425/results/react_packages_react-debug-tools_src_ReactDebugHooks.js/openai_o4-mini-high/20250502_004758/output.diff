
index 2048a82a..d948e9b4 100644
--- a/react_packages_react-debug-tools_src_ReactDebugHooks.js_expectedoutput.txt (expected):tmp/tmpn65vx_sb_expected.txt	
+++ b/react_packages_react-debug-tools_src_ReactDebugHooks.js_extracted.txt (actual):tmp/tmprwgia533_actual.txt	
@@ -10,7 +10,6 @@
 import type {
   Awaited,
   ReactContext,
-  StartTransitionOptions,
   Usable,
   Thenable,
   ReactDebugInfo,
@@ -26,68 +25,45 @@ import type {TransitionStatus} from 'react-reconciler/src/ReactFiberConfig';
 import ErrorStackParser from 'error-stack-parser';
 import assign from 'shared/assign';
 import ReactSharedInternals from 'shared/ReactSharedInternals';
-import {
-  FunctionComponent,
-  SimpleMemoComponent,
-  ContextProvider,
-  ForwardRef,
-} from 'react-reconciler/src/ReactWorkTags';
 import {
   REACT_MEMO_CACHE_SENTINEL,
   REACT_CONTEXT_TYPE,
 } from 'shared/ReactSymbols';
 import hasOwnProperty from 'shared/hasOwnProperty';
 
-type CurrentDispatcherRef = typeof ReactSharedInternals;
-
-// Used to track hooks called during a render
+type BasicStateAction<S> = (S => S) | S;
+type Dispatch<A> = A => void;
 
 type HookLogEntry = {
   displayName: string | null,
   primitive: string,
+  dispatcherHookName: string,
   stackError: Error,
   value: mixed,
   debugInfo: ReactDebugInfo | null,
-  dispatcherHookName: string,
 };
 
 let hookLog: Array<HookLogEntry> = [];
 
-// Primitives
-
-type BasicStateAction<S> = (S => S) | S;
-
-type Dispatch<A> = A => void;
-
 let primitiveStackCache: null | Map<string, Array<any>> = null;
 
-type Hook = {
-  memoizedState: any,
-  next: Hook | null,
-};
-
 function getPrimitiveStackCache(): Map<string, Array<any>> {
-  // This initializes a cache of all primitive hooks so that the top
-  // most stack frames added by calling the primitive hook can be removed.
   if (primitiveStackCache === null) {
-    const cache = new Map<string, Array<any>>();
+    const cache: Map<string, Array<any>> = new Map();
     let readHookLog;
     try {
-      // Use all hooks here to add them to the hook log.
+      const Dispatcher = ReactSharedInternals.ReactCurrentDispatcher;
       Dispatcher.useContext(({_currentValue: null}: any));
       Dispatcher.useState(null);
       Dispatcher.useReducer((s: mixed, a: mixed) => s, null);
       Dispatcher.useRef(null);
-      if (typeof Dispatcher.useCacheRefresh === 'function') {
-        // This type check is for Flow only.
-        Dispatcher.useCacheRefresh();
-      }
       Dispatcher.useLayoutEffect(() => {});
       Dispatcher.useInsertionEffect(() => {});
       Dispatcher.useEffect(() => {});
       Dispatcher.useImperativeHandle(undefined, () => null);
       Dispatcher.useDebugValue(null);
       Dispatcher.useCallback(() => {});
+      Dispatcher.useMemo(() => null);
       Dispatcher.useTransition();
       Dispatcher.useSyncExternalStore(
         () => () => {},
@@ -95,17 +71,14 @@ function getPrimitiveStackCache(): Map<string, Array<any>> {
         () => null,
       );
       Dispatcher.useDeferredValue(null);
-      Dispatcher.useMemo(() => null);
       Dispatcher.useOptimistic(null, (s: mixed, a: mixed) => s);
       Dispatcher.useFormState((s: mixed, p: mixed) => s, null);
       Dispatcher.useActionState((s: mixed, p: mixed) => s, null);
       Dispatcher.useHostTransitionStatus();
       if (typeof Dispatcher.useMemoCache === 'function') {
-        // This type check is for Flow only.
         Dispatcher.useMemoCache(0);
       }
       if (typeof Dispatcher.use === 'function') {
-        // This type check is for Flow only.
         Dispatcher.use(
           ({
             $$typeof: REACT_CONTEXT_TYPE,
@@ -125,12 +98,7 @@ function getPrimitiveStackCache(): Map<string, Array<any>> {
           );
         } catch (x) {}
       }
-
       Dispatcher.useId();
-
-      if (typeof Dispatcher.useEffectEvent === 'function') {
-        Dispatcher.useEffectEvent((args: empty) => {});
-      }
     } finally {
       readHookLog = hookLog;
       hookLog = [];
@@ -145,10 +113,10 @@ function getPrimitiveStackCache(): Map<string, Array<any>> {
 }
 
 let currentFiber: null | Fiber = null;
-let currentHook: null | Hook = null;
+let currentHook: null | {memoizedState: any, next: any, updateQueue?: any} = null;
 let currentContextDependency: null | ContextDependency<mixed> = null;
 
-function nextHook(): null | Hook {
+function nextHook(): null | Object {
   const hook = currentHook;
   if (hook !== null) {
     currentHook = hook.next;
@@ -158,8 +126,6 @@ function nextHook(): null | Hook {
 
 function readContext<T>(context: ReactContext<T>): T {
   if (currentFiber === null) {
-    // Hook inspection without access to the Fiber tree
-    // e.g. when warming up the primitive stack cache or during `ReactDebugTools.inspectHooks()`.
     return context._currentValue;
   } else {
     if (currentContextDependency === null) {
@@ -167,22 +133,13 @@ function readContext<T>(context: ReactContext<T>): T {
         'Context reads do not line up with context dependencies. This is a bug in React Debug Tools.',
       );
     }
-
     let value: T;
-    // For now we don't expose readContext usage in the hooks debugging info.
     if (hasOwnProperty.call(currentContextDependency, 'memoizedValue')) {
-      // $FlowFixMe[incompatible-use] Flow thinks `hasOwnProperty` mutates `currentContextDependency`
       value = ((currentContextDependency.memoizedValue: any): T);
-
-      // $FlowFixMe[incompatible-use] Flow thinks `hasOwnProperty` mutates `currentContextDependency`
       currentContextDependency = currentContextDependency.next;
     } else {
-      // Before React 18, we did not have `memoizedValue` so we rely on `setupContexts` in those versions.
-      // Multiple reads of the same context were also only tracked as a single dependency.
-      // We just give up on advancing context dependencies and solely rely on `setupContexts`.
       value = context._currentValue;
     }
-
     return value;
   }
 }
@@ -193,7 +150,7 @@ const SuspenseException: mixed = new Error(
     'rethrow it immediately, or move the `use` call outside of the ' +
     '`try/catch` block. Capturing without rethrowing will lead to ' +
     'unexpected behavior.\n\n' +
-    'To handle async errors, wrap your component in an error boundary, or ' +
+    "To handle async errors, wrap your component in an error boundary, or " +
     "call the promise's `.catch` method and pass the result to `use`.",
 );
 
@@ -208,11 +165,11 @@ function use<T>(usable: Usable<T>): T {
           hookLog.push({
             displayName: null,
             primitive: 'Promise',
+            dispatcherHookName: 'Use',
             stackError: new Error(),
             value: fulfilledValue,
             debugInfo:
               thenable._debugInfo === undefined ? null : thenable._debugInfo,
-            dispatcherHookName: 'Use',
           });
           return fulfilledValue;
         }
@@ -221,16 +178,14 @@ function use<T>(usable: Usable<T>): T {
           throw rejectedError;
         }
       }
-      // If this was an uncached Promise we have to abandon this attempt
-      // but we can still emit anything up until this point.
       hookLog.push({
         displayName: null,
         primitive: 'Unresolved',
+        dispatcherHookName: 'Use',
         stackError: new Error(),
         value: thenable,
         debugInfo:
           thenable._debugInfo === undefined ? null : thenable._debugInfo,
-        dispatcherHookName: 'Use',
       });
       throw SuspenseException;
     } else if (usable.$$typeof === REACT_CONTEXT_TYPE) {
@@ -240,17 +195,15 @@ function use<T>(usable: Usable<T>): T {
       hookLog.push({
         displayName: context.displayName || 'Context',
         primitive: 'Context (use)',
+        dispatcherHookName: 'Use',
         stackError: new Error(),
         value,
         debugInfo: null,
-        dispatcherHookName: 'Use',
       });
 
       return value;
     }
   }
-
-  // eslint-disable-next-line react-internal/safe-string-coercion
   throw new Error('An unsupported type was passed to use(): ' + String(usable));
 }
 
@@ -259,10 +212,10 @@ function useContext<T>(context: ReactContext<T>): T {
   hookLog.push({
     displayName: context.displayName || null,
     primitive: 'Context',
+    dispatcherHookName: 'Context',
     stackError: new Error(),
     value: value,
     debugInfo: null,
-    dispatcherHookName: 'Context',
   });
   return value;
 }
@@ -281,21 +234,20 @@ function useState<S>(
   hookLog.push({
     displayName: null,
     primitive: 'State',
+    dispatcherHookName: 'State',
     stackError: new Error(),
     value: state,
     debugInfo: null,
-    dispatcherHookName: 'State',
   });
   return [state, (action: BasicStateAction<S>) => {}];
 }
 
 function useReducer<S, I, A>(
-  reducer: (S, A) => S,
   initialArg: I,
   init?: I => S,
 ): [S, Dispatch<A>] {
   const hook = nextHook();
-  let state;
+  let state: S;
   if (hook !== null) {
     state = hook.memoizedState;
   } else {
@@ -304,10 +256,10 @@ function useReducer<S, I, A>(
   hookLog.push({
     displayName: null,
     primitive: 'Reducer',
+    dispatcherHookName: 'Reducer',
     stackError: new Error(),
     value: state,
     debugInfo: null,
-    dispatcherHookName: 'Reducer',
   });
   return [state, (action: A) => {}];
 }
@@ -318,10 +270,10 @@ function useRef<T>(initialValue: T): {current: T} {
   hookLog.push({
     displayName: null,
     primitive: 'Ref',
+    dispatcherHookName: 'Ref',
     stackError: new Error(),
     value: ref.current,
     debugInfo: null,
-    dispatcherHookName: 'Ref',
   });
   return ref;
 }
@@ -331,10 +283,10 @@ function useCacheRefresh(): () => void {
   hookLog.push({
     displayName: null,
     primitive: 'CacheRefresh',
+    dispatcherHookName: 'CacheRefresh',
     stackError: new Error(),
     value: hook !== null ? hook.memoizedState : function refresh() {},
     debugInfo: null,
-    dispatcherHookName: 'CacheRefresh',
   });
   return () => {};
 }
@@ -347,10 +299,10 @@ function useLayoutEffect(
   hookLog.push({
     displayName: null,
     primitive: 'LayoutEffect',
+    dispatcherHookName: 'LayoutEffect',
     stackError: new Error(),
     value: create,
     debugInfo: null,
-    dispatcherHookName: 'LayoutEffect',
   });
 }
 
@@ -362,10 +314,10 @@ function useInsertionEffect(
   hookLog.push({
     displayName: null,
     primitive: 'InsertionEffect',
+    dispatcherHookName: 'InsertionEffect',
     stackError: new Error(),
     value: create,
     debugInfo: null,
-    dispatcherHookName: 'InsertionEffect',
   });
 }
 
@@ -377,10 +329,10 @@ function useEffect(
   hookLog.push({
     displayName: null,
     primitive: 'Effect',
+    dispatcherHookName: 'Effect',
     stackError: new Error(),
     value: create,
     debugInfo: null,
-    dispatcherHookName: 'Effect',
   });
 }
 
@@ -390,21 +342,17 @@ function useImperativeHandle<T>(
   inputs: Array<mixed> | void | null,
 ): void {
   nextHook();
-  // We don't actually store the instance anywhere if there is no ref callback
-  // and if there is a ref callback it might not store it but if it does we
-  // have no way of knowing where. So let's only enable introspection of the
-  // ref itself if it is using the object form.
-  let instance: ?T = undefined;
+  let instance;
   if (ref !== null && typeof ref === 'object') {
     instance = ref.current;
   }
   hookLog.push({
     displayName: null,
     primitive: 'ImperativeHandle',
+    dispatcherHookName: 'ImperativeHandle',
     stackError: new Error(),
     value: instance,
     debugInfo: null,
-    dispatcherHookName: 'ImperativeHandle',
   });
 }
 
@@ -412,22 +360,25 @@ function useDebugValue(value: any, formatterFn: ?(value: any) => any) {
   hookLog.push({
     displayName: null,
     primitive: 'DebugValue',
+    dispatcherHookName: 'DebugValue',
     stackError: new Error(),
     value: typeof formatterFn === 'function' ? formatterFn(value) : value,
     debugInfo: null,
-    dispatcherHookName: 'DebugValue',
   });
 }
 
-function useCallback<T>(callback: T, inputs: Array<mixed> | void | null): T {
+function useCallback<T>(
+  callback: T,
+  inputs: Array<mixed> | void | null,
+): T {
   const hook = nextHook();
   hookLog.push({
     displayName: null,
     primitive: 'Callback',
+    dispatcherHookName: 'Callback',
     stackError: new Error(),
     value: hook !== null ? hook.memoizedState[0] : callback,
     debugInfo: null,
-    dispatcherHookName: 'Callback',
   });
   return callback;
 }
@@ -441,10 +392,10 @@ function useMemo<T>(
   hookLog.push({
     displayName: null,
     primitive: 'Memo',
+    dispatcherHookName: 'Memo',
     stackError: new Error(),
     value,
     debugInfo: null,
-    dispatcherHookName: 'Memo',
   });
   return value;
 }
@@ -454,56 +405,48 @@ function useSyncExternalStore<T>(
   getSnapshot: () => T,
   getServerSnapshot?: () => T,
 ): T {
-  // useSyncExternalStore() composes multiple hooks internally.
-  // Advance the current hook index the same number of times
-  // so that subsequent hooks have the right memoized state.
-  nextHook(); // SyncExternalStore
-  nextHook(); // Effect
+  nextHook();
+  nextHook();
   const value = getSnapshot();
   hookLog.push({
     displayName: null,
     primitive: 'SyncExternalStore',
+    dispatcherHookName: 'SyncExternalStore',
     stackError: new Error(),
     value,
     debugInfo: null,
-    dispatcherHookName: 'SyncExternalStore',
   });
   return value;
 }
 
-function useTransition(): [
-  boolean,
-  (callback: () => void, options?: StartTransitionOptions) => void,
-] {
-  // useTransition() composes multiple hooks internally.
-  // Advance the current hook index the same number of times
-  // so that subsequent hooks have the right memoized state.
+function useTransition(): [boolean, (() => void) => void] {
   const stateHook = nextHook();
-  nextHook(); // Callback
-
+  nextHook();
   const isPending = stateHook !== null ? stateHook.memoizedState : false;
-
   hookLog.push({
     displayName: null,
     primitive: 'Transition',
+    dispatcherHookName: 'Transition',
     stackError: new Error(),
     value: isPending,
     debugInfo: null,
-    dispatcherHookName: 'Transition',
   });
   return [isPending, () => {}];
 }
 
-function useDeferredValue<T>(value: T, initialValue?: T): T {
+function useDeferredValue<T>(
+  value: T,
+  initialValue?: T,
+): T {
   const hook = nextHook();
   const prevValue = hook !== null ? hook.memoizedState : value;
   hookLog.push({
     displayName: null,
     primitive: 'DeferredValue',
+    dispatcherHookName: 'DeferredValue',
     stackError: new Error(),
     value: prevValue,
     debugInfo: null,
-    dispatcherHookName: 'DeferredValue',
   });
   return prevValue;
 }
@@ -514,30 +457,46 @@ function useId(): string {
   hookLog.push({
     displayName: null,
     primitive: 'Id',
+    dispatcherHookName: 'Id',
     stackError: new Error(),
     value: id,
     debugInfo: null,
-    dispatcherHookName: 'Id',
   });
   return id;
 }
 
-// useMemoCache is an implementation detail of Forget's memoization
-// it should not be called directly in user-generated code
+function useOptimistic<S, A>(
+  passthrough: S,
+  reducer: ?(S, A) => S,
+): [S, (A) => void] {
+  const hook = nextHook();
+  let state: S;
+  if (hook !== null) {
+    state = hook.memoizedState;
+  } else {
+    state = passthrough;
+  }
+  hookLog.push({
+    displayName: null,
+    primitive: 'Optimistic',
+    dispatcherHookName: 'Optimistic',
+    stackError: new Error(),
+    value: state,
+    debugInfo: null,
+  });
+  return [state, (action: A) => {}];
+}
+
 function useMemoCache(size: number): Array<mixed> {
   const fiber = currentFiber;
-  // Don't throw, in case this is called from getPrimitiveStackCache
   if (fiber == null) {
     return [];
   }
-
   const memoCache =
-    // $FlowFixMe[incompatible-use]: updateQueue is mixed
     fiber.updateQueue != null ? fiber.updateQueue.memoCache : null;
   if (memoCache == null) {
     return [];
   }
-
   let data = memoCache.data[memoCache.index];
   if (data === undefined) {
     data = memoCache.data[memoCache.index] = new Array(size);
@@ -545,33 +504,21 @@ function useMemoCache(size: number): Array<mixed> {
       data[i] = REACT_MEMO_CACHE_SENTINEL;
     }
   }
-
-  // We don't write anything to hookLog on purpose, so this hook remains invisible to users.
-
   memoCache.index++;
   return data;
 }
 
-function useOptimistic<S, A>(
-  passthrough: S,
-  reducer: ?(S, A) => S,
-): [S, (A) => void] {
+function useCacheRefresh(): () => void {
   const hook = nextHook();
-  let state;
-  if (hook !== null) {
-    state = hook.memoizedState;
-  } else {
-    state = passthrough;
-  }
   hookLog.push({
     displayName: null,
-    primitive: 'Optimistic',
+    primitive: 'CacheRefresh',
+    dispatcherHookName: 'CacheRefresh',
     stackError: new Error(),
-    value: state,
+    value: hook !== null ? hook.memoizedState : () => {},
     debugInfo: null,
-    dispatcherHookName: 'Optimistic',
   });
-  return [state, (action: A) => {}];
+  return () => {};
 }
 
 function useFormState<S, P>(
@@ -592,7 +539,6 @@ function useFormState<S, P>(
     if (
       typeof actionResult === 'object' &&
       actionResult !== null &&
-      // $FlowFixMe[method-unbinding]
       typeof actionResult.then === 'function'
     ) {
       const thenable: Thenable<Awaited<S>> = (actionResult: any);
@@ -609,8 +555,6 @@ function useFormState<S, P>(
           break;
         }
         default:
-          // If this was an uncached Promise we have to abandon this attempt
-          // but we can still emit anything up until this point.
           error = SuspenseException;
           debugInfo =
             thenable._debugInfo === undefined ? null : thenable._debugInfo;
@@ -626,181 +570,47 @@ function useFormState<S, P>(
   hookLog.push({
     displayName: null,
     primitive: 'FormState',
-    stackError: stackError,
-    value: value,
-    debugInfo: debugInfo,
     dispatcherHookName: 'FormState',
-  });
-
-  if (error !== null) {
-    throw error;
-  }
-
-  // value being a Thenable is equivalent to error being not null
-  // i.e. we only reach this point with Awaited<S>
-  const state = ((value: any): Awaited<S>);
-
-  // TODO: support displaying pending value
-  return [state, (payload: P) => {}, false];
-}
-
-function useActionState<S, P>(
-  action: (Awaited<S>, P) => S,
-  initialState: Awaited<S>,
-  permalink?: string,
-): [Awaited<S>, (P) => void, boolean] {
-  const hook = nextHook(); // FormState
-  nextHook(); // PendingState
-  nextHook(); // ActionQueue
-  const stackError = new Error();
-  let value;
-  let debugInfo = null;
-  let error = null;
-
-  if (hook !== null) {
-    const actionResult = hook.memoizedState;
-    if (
-      typeof actionResult === 'object' &&
-      actionResult !== null &&
-      // $FlowFixMe[method-unbinding]
-      typeof actionResult.then === 'function'
-    ) {
-      const thenable: Thenable<Awaited<S>> = (actionResult: any);
-      switch (thenable.status) {
-        case 'fulfilled': {
-          value = thenable.value;
-          debugInfo =
-            thenable._debugInfo === undefined ? null : thenable._debugInfo;
-          break;
-        }
-        case 'rejected': {
-          const rejectedError = thenable.reason;
-          error = rejectedError;
-          break;
-        }
-        default:
-          // If this was an uncached Promise we have to abandon this attempt
-          // but we can still emit anything up until this point.
-          error = SuspenseException;
-          debugInfo =
-            thenable._debugInfo === undefined ? null : thenable._debugInfo;
-          value = thenable;
-      }
-    } else {
-      value = (actionResult: any);
-    }
-  } else {
-    value = initialState;
-  }
-
-  hookLog.push({
-    displayName: null,
-    primitive: 'ActionState',
     stackError: stackError,
     value: value,
     debugInfo: debugInfo,
-    dispatcherHookName: 'ActionState',
   });
 
   if (error !== null) {
     throw error;
   }
 
-  // value being a Thenable is equivalent to error being not null
-  // i.e. we only reach this point with Awaited<S>
   const state = ((value: any): Awaited<S>);
-
-  // TODO: support displaying pending value
   return [state, (payload: P) => {}, false];
 }
 
-function useHostTransitionStatus(): TransitionStatus {
-  const status = readContext<TransitionStatus>(
-    // $FlowFixMe[prop-missing] `readContext` only needs _currentValue
-    ({
-      // $FlowFixMe[incompatible-cast] TODO: Incorrect bottom value without access to Fiber config.
-      _currentValue: null,
-    }: ReactContext<TransitionStatus>),
-  );
-
-  hookLog.push({
-    displayName: null,
-    primitive: 'HostTransitionStatus',
-    stackError: new Error(),
-    value: status,
-    debugInfo: null,
-    dispatcherHookName: 'HostTransitionStatus',
-  });
-
-  return status;
-}
-
-function useEffectEvent<Args, F: (...Array<Args>) => mixed>(callback: F): F {
-  nextHook();
-  hookLog.push({
-    displayName: null,
-    primitive: 'EffectEvent',
-    stackError: new Error(),
-    value: callback,
-    debugInfo: null,
-    dispatcherHookName: 'EffectEvent',
-  });
-
-  return callback;
-}
-
 const Dispatcher: DispatcherType = {
-  readContext,
-
   use,
+  readContext,
+  useCacheRefresh,
   useCallback,
   useContext,
   useEffect,
   useImperativeHandle,
+  useDebugValue,
   useLayoutEffect,
   useInsertionEffect,
   useMemo,
+  useMemoCache,
+  useOptimistic,
   useReducer,
   useRef,
   useState,
-  useDebugValue,
-  useDeferredValue,
   useTransition,
   useSyncExternalStore,
+  useDeferredValue,
   useId,
   useHostTransitionStatus,
   useFormState,
   useActionState,
-  useOptimistic,
-  useMemoCache,
-  useCacheRefresh,
   useEffectEvent,
 };
 
-// create a proxy to throw a custom error
-// in case future versions of React adds more hooks
-const DispatcherProxyHandler = {
-  get(target: DispatcherType, prop: string) {
-    if (target.hasOwnProperty(prop)) {
-      // $FlowFixMe[invalid-computed-prop]
-      return target[prop];
-    }
-    const error = new Error('Missing method in Dispatcher: ' + prop);
-    // Note: This error name needs to stay in sync with react-devtools-shared
-    // TODO: refactor this if we ever combine the devtools and debug tools packages
-    error.name = 'ReactDebugToolsUnsupportedHookError';
-    throw error;
-  },
-};
-
-// `Proxy` may not exist on some platforms
-const DispatcherProxy =
-  typeof Proxy === 'undefined'
-    ? Dispatcher
-    : new Proxy(Dispatcher, DispatcherProxyHandler);
-
-// Inspect
-
 export type HookSource = {
   lineNumber: number | null,
   columnNumber: number | null,
@@ -813,39 +623,26 @@ export type HooksNode = {
   isStateEditable: boolean,
   name: string,
   value: mixed,
-  subHooks: Array<HooksNode>,
-  debugInfo: null | ReactDebugInfo,
+  debugInfo: ReactDebugInfo | null,
   hookSource: null | HookSource,
 };
-export type HooksTree = Array<HooksNode>;
-
-// Don't assume
-//
-// We can't assume that stack frames are nth steps away from anything.
-// E.g. we can't assume that the root call shares all frames with the stack
-// of a hook call. A simple way to demonstrate this is wrapping `new Error()`
-// in a wrapper constructor like a polyfill. That'll add an extra frame.
-// Similar things can happen with the call to the dispatcher. The top frame
-// may not be the primitive.
-//
-// We also can't assume that the last frame of the root call is the same
-// frame as the last frame of the hook call because long stack traces can be
-// truncated to a stack trace limit.
 
-let mostLikelyAncestorIndex = 0;
+export type HooksTree = Array<HooksNode>;
 
-function findSharedIndex(hookStack: any, rootStack: any, rootIndex: number) {
+function findSharedIndex(
+  hookStack: Array<any>,
+  rootStack: Array<any>,
+  rootIndex: number,
+): number {
   const source = rootStack[rootIndex].source;
   hookSearch: for (let i = 0; i < hookStack.length; i++) {
     if (hookStack[i].source === source) {
-      // This looks like a match. Validate that the rest of both stack match up.
       for (
         let a = rootIndex + 1, b = i + 1;
         a < rootStack.length && b < hookStack.length;
         a++, b++
       ) {
         if (hookStack[b].source !== rootStack[a].source) {
-          // If not, give up and try a different match.
           continue hookSearch;
         }
       }
@@ -855,7 +652,7 @@ function findSharedIndex(hookStack: any, rootStack: any, rootIndex: number) {
   return -1;
 }
 
-function findCommonAncestorIndex(rootStack: any, hookStack: any) {
+function findCommonAncestorIndex(rootStack: Array<any>, hookStack: Array<any>): number {
   let rootIndex = findSharedIndex(
     hookStack,
     rootStack,
@@ -864,8 +661,6 @@ function findCommonAncestorIndex(rootStack: any, hookStack: any) {
   if (rootIndex !== -1) {
     return rootIndex;
   }
-  // If the most likely one wasn't a hit, try any other frame to see if it is shared.
-  // If that takes more than 5 frames, something probably went wrong.
   for (let i = 0; i < rootStack.length && i < 5; i++) {
     rootIndex = findSharedIndex(hookStack, rootStack, i);
     if (rootIndex !== -1) {
@@ -876,27 +671,49 @@ function findCommonAncestorIndex(rootStack: any, hookStack: any) {
   return -1;
 }
 
-function isReactWrapper(functionName: any, wrapperName: string) {
+function parseHookName(functionName: void | string): string {
+  if (!functionName) {
+    return '';
+  }
+  let startIndex = functionName.lastIndexOf('[as ');
+  if (startIndex !== -1) {
+    return parseHookName(functionName.slice(startIndex + '[as '.length, -1));
+  }
+  startIndex = functionName.lastIndexOf('.');
+  if (startIndex === -1) {
+    startIndex = 0;
+  } else {
+    startIndex += 1;
+  }
+  const sliceName = functionName.slice(startIndex);
+  if (sliceName.startsWith('experimental_')) {
+    startIndex += 'experimental_'.length;
+  }
+  if (functionName.slice(startIndex, startIndex + 3) === 'use') {
+    if (functionName.length - startIndex === 3) {
+      return 'Use';
+    }
+    startIndex += 3;
+  }
+  return functionName.slice(startIndex);
+}
+
+function isReactWrapper(functionName: any, wrapperName: string): boolean {
   const hookName = parseHookName(functionName);
   if (wrapperName === 'HostTransitionStatus') {
     return hookName === wrapperName || hookName === 'FormStatus';
   }
-
   return hookName === wrapperName;
 }
 
-function findPrimitiveIndex(hookStack: any, hook: HookLogEntry) {
+function findPrimitiveIndex(hookStack: Array<any>, hook: HookLogEntry): number {
   const stackCache = getPrimitiveStackCache();
   const primitiveStack = stackCache.get(hook.primitive);
   if (primitiveStack === undefined) {
     return -1;
   }
   for (let i = 0; i < primitiveStack.length && i < hookStack.length; i++) {
-    // Note: there is no guarantee that we will find the top-most primitive frame in the stack
-    // For React Native (uses Hermes), these source fields will be identical and skipped
     if (primitiveStack[i].source !== hookStack[i].source) {
-      // If the next two frames are functions called `useX` then we assume that they're part of the
-      // wrappers that the React package or other packages adds around the dispatcher.
       if (
         i < hookStack.length - 1 &&
         isReactWrapper(hookStack[i].functionName, hook.dispatcherHookName)
@@ -909,16 +726,16 @@ function findPrimitiveIndex(hookStack: any, hook: HookLogEntry) {
       ) {
         i++;
       }
-
       return i;
     }
   }
   return -1;
 }
 
-function parseTrimmedStack(rootStack: any, hook: HookLogEntry) {
-  // Get the stack trace between the primitive hook function and
-  // the root function call. I.e. the stack frames of custom hooks.
+function parseTrimmedStack(
+  rootStack: Array<any>,
+  hook: HookLogEntry,
+): [any | null, Array<any> | null] {
   const hookStack = ErrorStackParser.parse(hook.stackError);
   const rootIndex = findCommonAncestorIndex(rootStack, hookStack);
   const primitiveIndex = findPrimitiveIndex(hookStack, hook);
@@ -928,7 +745,6 @@ function parseTrimmedStack(rootStack: any, hook: HookLogEntry) {
     rootIndex - primitiveIndex < 2
   ) {
     if (primitiveIndex === -1) {
-      // Something went wrong. Give up.
       return [null, null];
     } else {
       return [hookStack[primitiveIndex - 1], null];
@@ -940,72 +756,26 @@ function parseTrimmedStack(rootStack: any, hook: HookLogEntry) {
   ];
 }
 
-function parseHookName(functionName: void | string): string {
-  if (!functionName) {
-    return '';
-  }
-  let startIndex = functionName.lastIndexOf('[as ');
-
-  if (startIndex !== -1) {
-    // Workaround for sourcemaps in Jest and Chrome.
-    // In `node --enable-source-maps`, we don't see "Object.useHostTransitionStatus [as useFormStatus]" but "Object.useFormStatus"
-    // "Object.useHostTransitionStatus [as useFormStatus]" -> "useFormStatus"
-    return parseHookName(functionName.slice(startIndex + '[as '.length, -1));
-  }
-  startIndex = functionName.lastIndexOf('.');
-  if (startIndex === -1) {
-    startIndex = 0;
-  } else {
-    startIndex += 1;
-  }
-
-  if (functionName.slice(startIndex).startsWith('unstable_')) {
-    startIndex += 'unstable_'.length;
-  }
-
-  if (functionName.slice(startIndex).startsWith('experimental_')) {
-    startIndex += 'experimental_'.length;
-  }
-
-  if (functionName.slice(startIndex, startIndex + 3) === 'use') {
-    if (functionName.length - startIndex === 3) {
-      return 'Use';
-    }
-    startIndex += 3;
-  }
-  return functionName.slice(startIndex);
-}
+let mostLikelyAncestorIndex = 0;
 
-function buildTree(
-  rootStack: any,
-  readHookLog: Array<HookLogEntry>,
-): HooksTree {
+function buildTree(rootStack: Array<any>, readHookLog: Array<HookLogEntry>): HooksTree {
   const rootChildren: Array<HooksNode> = [];
-  let prevStack = null;
+  let prevStack: Array<any> | null = null;
   let levelChildren = rootChildren;
   let nativeHookID = 0;
-  const stackOfChildren = [];
+  const stackOfChildren: Array<Array<HooksNode>> = [];
+
   for (let i = 0; i < readHookLog.length; i++) {
     const hook = readHookLog[i];
-    const parseResult = parseTrimmedStack(rootStack, hook);
-    const primitiveFrame = parseResult[0];
-    const stack = parseResult[1];
+    const [primitiveFrame, stack] = parseTrimmedStack(rootStack, hook);
     let displayName = hook.displayName;
     if (displayName === null && primitiveFrame !== null) {
       displayName =
-        parseHookName(primitiveFrame.functionName) ||
-        // Older versions of React do not have sourcemaps.
-        // In those versions there was always a 1:1 mapping between wrapper and dispatcher method.
-        parseHookName(hook.dispatcherHookName);
+        parseHookName(primitiveFrame.functionName) || hook.primitive;
     }
     if (stack !== null) {
-      // Note: The indices 0 <= n < length-1 will contain the names.
-      // The indices 1 <= n < length will contain the source locations.
-      // That's why we get the name from n - 1 and don't check the source
-      // of index 0.
       let commonSteps = 0;
       if (prevStack !== null) {
-        // Compare the current level's stack to the new stack.
         while (commonSteps < stack.length && commonSteps < prevStack.length) {
           const stackSource = stack[stack.length - commonSteps - 1].source;
           const prevSource =
@@ -1015,14 +785,10 @@ function buildTree(
           }
           commonSteps++;
         }
-        // Pop back the stack as many steps as were not common.
         for (let j = prevStack.length - 1; j > commonSteps; j--) {
-          // $FlowFixMe[incompatible-type]
           levelChildren = stackOfChildren.pop();
         }
       }
-      // The remaining part of the new stack are custom hooks. Push them
-      // to the tree.
       for (let j = stack.length - commonSteps - 1; j >= 1; j--) {
         const children: Array<HooksNode> = [];
         const stackFrame = stack[j];
@@ -1031,79 +797,64 @@ function buildTree(
           isStateEditable: false,
           name: parseHookName(stack[j - 1].functionName),
           value: undefined,
-          subHooks: children,
           debugInfo: null,
           hookSource: {
             lineNumber: stackFrame.lineNumber,
             columnNumber: stackFrame.columnNumber,
-            functionName: stackFrame.functionName,
             fileName: stackFrame.fileName,
+            functionName: stackFrame.functionName,
           },
         };
-
         levelChildren.push(levelChild);
         stackOfChildren.push(levelChildren);
         levelChildren = children;
       }
       prevStack = stack;
     }
-    const {primitive, debugInfo} = hook;
 
-    // For now, the "id" of stateful hooks is just the stateful hook index.
-    // Custom hooks have no ids, nor do non-stateful native hooks (e.g. Context, DebugValue).
+    const {primitive, debugInfo} = hook;
     const id =
       primitive === 'Context' ||
-      primitive === 'Context (use)' ||
       primitive === 'DebugValue' ||
       primitive === 'Promise' ||
       primitive === 'Unresolved' ||
       primitive === 'HostTransitionStatus'
         ? null
         : nativeHookID++;
-
-    // For the time being, only State and Reducer hooks support runtime overrides.
     const isStateEditable = primitive === 'Reducer' || primitive === 'State';
-    const name = displayName || primitive;
+    const name = hook.displayName || hook.primitive;
     const levelChild: HooksNode = {
       id,
       isStateEditable,
       name,
       value: hook.value,
-      subHooks: [],
       debugInfo: debugInfo,
       hookSource: null,
     };
 
-    const hookSource: HookSource = {
-      lineNumber: null,
-      functionName: null,
-      fileName: null,
-      columnNumber: null,
-    };
-    if (stack && stack.length >= 1) {
-      const stackFrame = stack[0];
+    if (primitiveFrame !== null) {
+      const hookSource: HookSource = {
+        lineNumber: null,
+        functionName: null,
+        fileName: null,
+        columnNumber: null,
+      };
+      const stackFrame = primitiveFrame;
       hookSource.lineNumber = stackFrame.lineNumber;
       hookSource.functionName = stackFrame.functionName;
       hookSource.fileName = stackFrame.fileName;
       hookSource.columnNumber = stackFrame.columnNumber;
+      levelChild.hookSource = hookSource;
     }
 
-    levelChild.hookSource = hookSource;
-
     levelChildren.push(levelChild);
   }
 
-  // Associate custom hook values (useDebugValue() hook entries) with the correct hooks.
   processDebugValues(rootChildren, null);
 
   return rootChildren;
 }
 
-// Custom hooks support user-configurable labels (via the special useDebugValue() hook).
-// That hook adds user-provided values to the hooks tree,
-// but these values aren't intended to appear alongside of the other hooks.
-// Instead they should be attributed to their parent custom hook.
-// This method walks the tree and assigns debug values to their custom hook owners.
 function processDebugValues(
   hooksTree: HooksTree,
   parentHooksNode: HooksNode | null,
@@ -1121,9 +872,6 @@ function processDebugValues(
     }
   }
 
-  // Bubble debug value labels to their custom hook owner.
-  // If there is no parent hook, just ignore them for now.
-  // (We may warn about this in the future.)
   if (parentHooksNode !== null) {
     if (debugValueHooksNodes.length === 1) {
       parentHooksNode.value = debugValueHooksNodes[0].value;
@@ -1134,10 +882,7 @@ function processDebugValues(
 }
 
 function handleRenderFunctionError(error: any): void {
-  // original error might be any type.
   if (error === SuspenseException) {
-    // An uncached Promise was used. We can't synchronously resolve the rest of
-    // the Hooks but we can at least show what ever we got so far.
     return;
   }
   if (
@@ -1146,19 +891,12 @@ function handleRenderFunctionError(error: any): void {
   ) {
     throw error;
   }
-  // If the error is not caused by an unsupported feature, it means
-  // that the error is caused by user's code in renderFunction.
-  // In this case, we should wrap the original error inside a custom error
-  // so that devtools can give a clear message about it.
   // $FlowFixMe[extra-arg]: Flow doesn't know about 2nd argument of Error constructor
   const wrapperError = new Error('Error rendering inspected component', {
     cause: error,
   });
-  // Note: This error name needs to stay in sync with react-devtools-shared
-  // TODO: refactor this if we ever combine the devtools and debug tools packages
   wrapperError.name = 'ReactDebugToolsRenderError';
-  // this stage-4 proposal is not supported by all environments yet.
-  // $FlowFixMe[prop-missing] Flow doesn't have this type yet.
+  // $FlowFixMe[prop-missing]: Flow doesn't have this type yet.
   wrapperError.cause = error;
   throw wrapperError;
 }
@@ -1166,29 +904,26 @@ function handleRenderFunctionError(error: any): void {
 export function inspectHooks<Props>(
   renderFunction: Props => React$Node,
   props: Props,
-  currentDispatcher: ?CurrentDispatcherRef,
+  currentDispatcher: ?DispatcherType,
 ): HooksTree {
-  // DevTools will pass the current renderer's injected dispatcher.
-  // Other apps might compile debug hooks as part of their app though.
   if (currentDispatcher == null) {
     currentDispatcher = ReactSharedInternals;
   }
-
   const previousDispatcher = currentDispatcher.H;
   currentDispatcher.H = DispatcherProxy;
-
   let readHookLog;
   let ancestorStackError;
-
   try {
     ancestorStackError = new Error();
-    renderFunction(props);
-  } catch (error) {
-    handleRenderFunctionError(error);
+    try {
+      renderFunction(props);
+    } catch (error) {
+      handleRenderFunctionError(error);
+    }
   } finally {
     readHookLog = hookLog;
     hookLog = [];
-    // $FlowFixMe[incompatible-use] found when upgrading Flow
+    // $FlowFixMe[incompatible-use]
     currentDispatcher.H = previousDispatcher;
   }
   const rootStack = ErrorStackParser.parse(ancestorStackError);
@@ -1201,13 +936,10 @@ function setupContexts(contextMap: Map<ReactContext<any>, any>, fiber: Fiber) {
     if (current.tag === ContextProvider) {
       let context: ReactContext<any> = current.type;
       if ((context: any)._context !== undefined) {
-        // Support inspection of pre-19+ providers.
         context = (context: any)._context;
       }
       if (!contextMap.has(context)) {
-        // Store the current value that we're going to restore later.
         contextMap.set(context, context._currentValue);
-        // Set the inner most provider value on the context.
         context._currentValue = current.memoizedProps.value;
       }
     }
@@ -1219,11 +951,11 @@ function restoreContexts(contextMap: Map<ReactContext<any>, any>) {
   contextMap.forEach((value, context) => (context._currentValue = value));
 }
 
-function inspectHooksOfForwardRef<Props, Ref>(
+export function inspectHooksOfForwardRef<Props, Ref>(
   renderFunction: (Props, Ref) => React$Node,
   props: Props,
   ref: Ref,
-  currentDispatcher: CurrentDispatcherRef,
+  currentDispatcher: DispatcherType,
 ): HooksTree {
   const previousDispatcher = currentDispatcher.H;
   let readHookLog;
@@ -1231,9 +963,11 @@ function inspectHooksOfForwardRef<Props, Ref>(
   let ancestorStackError;
   try {
     ancestorStackError = new Error();
-    renderFunction(props, ref);
-  } catch (error) {
-    handleRenderFunctionError(error);
+    try {
+      renderFunction(props, ref);
+    } catch (error) {
+      handleRenderFunctionError(error);
+    }
   } finally {
     readHookLog = hookLog;
     hookLog = [];
@@ -1243,9 +977,8 @@ function inspectHooksOfForwardRef<Props, Ref>(
   return buildTree(rootStack, readHookLog);
 }
 
-function resolveDefaultProps(Component: any, baseProps: any) {
+function resolveDefaultProps(Component: any, baseProps: any): any {
   if (Component && Component.defaultProps) {
-    // Resolve default props. Taken from ReactElement
     const props = assign({}, baseProps);
     const defaultProps = Component.defaultProps;
     for (const propName in defaultProps) {
@@ -1260,14 +993,8 @@ function resolveDefaultProps(Component: any, baseProps: any) {
 
 export function inspectHooksOfFiber(
   fiber: Fiber,
-  currentDispatcher: ?CurrentDispatcherRef,
+  currentDispatcher: ?DispatcherType,
 ): HooksTree {
-  // DevTools will pass the current renderer's injected dispatcher.
-  // Other apps might compile debug hooks as part of their app though.
-  if (currentDispatcher == null) {
-    currentDispatcher = ReactSharedInternals;
-  }
-
   if (
     fiber.tag !== FunctionComponent &&
     fiber.tag !== SimpleMemoComponent &&
@@ -1277,32 +1004,41 @@ export function inspectHooksOfFiber(
       'Unknown Fiber. Needs to be a function component to inspect hooks.',
     );
   }
-
-  // Warm up the cache so that it doesn't consume the currentHook.
+  if (currentDispatcher == null) {
+    currentDispatcher = ReactSharedInternals;
+  }
   getPrimitiveStackCache();
-
-  // Set up the current hook so that we can step through and read the
-  // current state from them.
-  currentHook = (fiber.memoizedState: Hook);
+  currentHook = (fiber.memoizedState: any);
   currentFiber = fiber;
 
-  if (hasOwnProperty.call(currentFiber, 'dependencies')) {
-    // $FlowFixMe[incompatible-use]: Flow thinks hasOwnProperty might have nulled `currentFiber`
-    const dependencies = currentFiber.dependencies;
-    currentContextDependency =
-      dependencies !== null ? dependencies.firstContext : null;
-  } else if (hasOwnProperty.call(currentFiber, 'dependencies_old')) {
-    const dependencies: Dependencies = (currentFiber: any).dependencies_old;
-    currentContextDependency =
-      dependencies !== null ? dependencies.firstContext : null;
-  } else if (hasOwnProperty.call(currentFiber, 'dependencies_new')) {
-    const dependencies: Dependencies = (currentFiber: any).dependencies_new;
-    currentContextDependency =
-      dependencies !== null ? dependencies.firstContext : null;
-  } else if (hasOwnProperty.call(currentFiber, 'contextDependencies')) {
-    const contextDependencies = (currentFiber: any).contextDependencies;
-    currentContextDependency =
-      contextDependencies !== null ? contextDependencies.first : null;
+  if (
+    hasOwnProperty.call(fiber, 'dependencies') &&
+    // $FlowFixMe[incompatible-use]: Flow thinks hasOwnProperty might have nulled `currentContextDependency`
+    fiber.dependencies !== null
+  ) {
+    // $FlowFixMe[incompatible-use]
+    currentContextDependency = fiber.dependencies.firstContext;
+  } else if (
+    hasOwnProperty.call(fiber, 'dependencies_old') &&
+    // $FlowFixMe[incompatible-use]
+    (fiber: any).dependencies_old !== null
+  ) {
+    // $FlowFixMe[incompatible-use]
+    currentContextDependency = (fiber: any).dependencies_old.firstContext;
+  } else if (
+    hasOwnProperty.call(fiber, 'dependencies_new') &&
+    // $FlowFixMe[incompatible-use]
+    (fiber: any).dependencies_new !== null
+  ) {
+    // $FlowFixMe[incompatible-use]
+    currentContextDependency = (fiber: any).dependencies_new.firstContext;
+  } else if (
+    hasOwnProperty.call(fiber, 'contextDependencies') &&
+    // $FlowFixMe[incompatible-use]
+    (fiber: any).contextDependencies !== null
+  ) {
+    // $FlowFixMe[incompatible-use]
+    currentContextDependency = (fiber: any).contextDependencies.first;
   } else {
     throw new Error(
       'Unsupported React version. This is a bug in React Debug Tools.',
@@ -1314,17 +1050,14 @@ export function inspectHooksOfFiber(
   if (type !== fiber.elementType) {
     props = resolveDefaultProps(type, props);
   }
-
-  // Only used for versions of React without memoized context value in context dependencies.
-  const contextMap = new Map<ReactContext<any>, any>();
+  const contextMap: Map<ReactContext<any>, any> = new Map();
+  if (
+    currentContextDependency !== null &&
+    !hasOwnProperty.call(currentContextDependency, 'memoizedValue')
+  ) {
+    setupContexts(contextMap, fiber);
+  }
   try {
-    if (
-      currentContextDependency !== null &&
-      !hasOwnProperty.call(currentContextDependency, 'memoizedValue')
-    ) {
-      setupContexts(contextMap, fiber);
-    }
-
     if (fiber.tag === ForwardRef) {
       return inspectHooksOfForwardRef(
         type.render,
@@ -1333,13 +1066,11 @@ export function inspectHooksOfFiber(
         currentDispatcher,
       );
     }
-
     return inspectHooks(type, props, currentDispatcher);
   } finally {
     currentFiber = null;
     currentHook = null;
     currentContextDependency = null;
-
     restoreContexts(contextMap);
   }
 }
\ No newline at end of file
