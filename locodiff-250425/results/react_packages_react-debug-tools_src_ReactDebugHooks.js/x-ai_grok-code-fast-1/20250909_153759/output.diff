
index 2048a82a3..fb73e7c7f 100644
--- a/react_packages_react-debug-tools_src_ReactDebugHooks.js_expectedoutput.txt (expected):tmp/tmp2ujwbz9h_expected.txt	
+++ b/react_packages_react-debug-tools_src_ReactDebugHooks.js_extracted.txt (actual):tmp/tmpvp5bnr6m_actual.txt	
@@ -8,8 +8,11 @@
  */
 
 import type {
-  Awaited,
+  MutableSource,
+  MutableSourceGetSnapshotFn,
+  MutableSourceSubscribeFn,
   ReactContext,
+  ReactProviderType,
   StartTransitionOptions,
   Usable,
   Thenable,
@@ -25,20 +28,9 @@ import type {TransitionStatus} from 'react-reconciler/src/ReactFiberConfig';
 
 import ErrorStackParser from 'error-stack-parser';
 import assign from 'shared/assign';
+assign;
 import ReactSharedInternals from 'shared/ReactSharedInternals';
-import {
-  FunctionComponent,
-  SimpleMemoComponent,
-  ContextProvider,
-  ForwardRef,
-} from 'react-reconciler/src/ReactWorkTags';
-import {
-  REACT_MEMO_CACHE_SENTINEL,
-  REACT_CONTEXT_TYPE,
-} from 'shared/ReactSymbols';
-import hasOwnProperty from 'shared/hasOwnProperty';
-
-type CurrentDispatcherRef = typeof ReactSharedInternals;
+import {REACT_MEMO_CACHE_SENTINEL} from 'shared/ReactSymbols';
 
 // Used to track hooks called during a render
 
@@ -48,7 +40,7 @@ type HookLogEntry = {
   stackError: Error,
   value: mixed,
   debugInfo: ReactDebugInfo | null,
-  dispatcherHookName: string,
+  ...
 };
 
 let hookLog: Array<HookLogEntry> = [];
@@ -59,6 +51,9 @@ type BasicStateAction<S> = (S => S) | S;
 
 type Dispatch<A> = A => void;
 
+// Used to track hooks called during a render
+type CurrentDispatcherRef = typeof ReactSharedInternals;
+
 let primitiveStackCache: null | Map<string, Array<any>> = null;
 
 type Hook = {
@@ -66,6 +61,10 @@ type Hook = {
   next: Hook | null,
 };
 
+type TimeoutConfig = {|
+  timeoutMs: number,
+|};
+
 function getPrimitiveStackCache(): Map<string, Array<any>> {
   // This initializes a cache of all primitive hooks so that the top
   // most stack frames added by calling the primitive hook can be removed.
@@ -78,16 +77,12 @@ function getPrimitiveStackCache(): Map<string, Array<any>> {
       Dispatcher.useState(null);
       Dispatcher.useReducer((s: mixed, a: mixed) => s, null);
       Dispatcher.useRef(null);
-      if (typeof Dispatcher.useCacheRefresh === 'function') {
-        // This type check is for Flow only.
-        Dispatcher.useCacheRefresh();
-      }
       Dispatcher.useLayoutEffect(() => {});
-      Dispatcher.useInsertionEffect(() => {});
       Dispatcher.useEffect(() => {});
       Dispatcher.useImperativeHandle(undefined, () => null);
       Dispatcher.useDebugValue(null);
       Dispatcher.useCallback(() => {});
+      Dispatcher.useMemo(() => null);
       Dispatcher.useTransition();
       Dispatcher.useSyncExternalStore(
         () => () => {},
@@ -100,31 +95,29 @@ function getPrimitiveStackCache(): Map<string, Array<any>> {
       Dispatcher.useFormState((s: mixed, p: mixed) => s, null);
       Dispatcher.useActionState((s: mixed, p: mixed) => s, null);
       Dispatcher.useHostTransitionStatus();
-      if (typeof Dispatcher.useMemoCache === 'function') {
+      Dispatcher.useMemoCache(0);
+      if (typeof Dispatcher.useCacheRefresh === 'function') {
         // This type check is for Flow only.
-        Dispatcher.useMemoCache(0);
+        Dispatcher.useCacheRefresh();
       }
-      if (typeof Dispatcher.use === 'function') {
-        // This type check is for Flow only.
+      Dispatcher.use(
+        ({
+          $$typeof: REACT_CONTEXT_TYPE,
+          _currentValue: null,
+        }: any),
+      );
+      Dispatcher.use({
+        then() {},
+        status: 'fulfilled',
+        value: null,
+      });
+      try {
         Dispatcher.use(
           ({
-            $$typeof: REACT_CONTEXT_TYPE,
-            _currentValue: null,
+            then() {},
           }: any),
         );
-        Dispatcher.use({
-          then() {},
-          status: 'fulfilled',
-          value: null,
-        });
-        try {
-          Dispatcher.use(
-            ({
-              then() {},
-            }: any),
-          );
-        } catch (x) {}
-      }
+      } catch (x) {}
 
       Dispatcher.useId();
 
@@ -156,37 +149,6 @@ function nextHook(): null | Hook {
   return hook;
 }
 
-function readContext<T>(context: ReactContext<T>): T {
-  if (currentFiber === null) {
-    // Hook inspection without access to the Fiber tree
-    // e.g. when warming up the primitive stack cache or during `ReactDebugTools.inspectHooks()`.
-    return context._currentValue;
-  } else {
-    if (currentContextDependency === null) {
-      throw new Error(
-        'Context reads do not line up with context dependencies. This is a bug in React Debug Tools.',
-      );
-    }
-
-    let value: T;
-    // For now we don't expose readContext usage in the hooks debugging info.
-    if (hasOwnProperty.call(currentContextDependency, 'memoizedValue')) {
-      // $FlowFixMe[incompatible-use] Flow thinks `hasOwnProperty` mutates `currentContextDependency`
-      value = ((currentContextDependency.memoizedValue: any): T);
-
-      // $FlowFixMe[incompatible-use] Flow thinks `hasOwnProperty` mutates `currentContextDependency`
-      currentContextDependency = currentContextDependency.next;
-    } else {
-      // Before React 18, we did not have `memoizedValue` so we rely on `setupContexts` in those versions.
-      // Multiple reads of the same context were also only tracked as a single dependency.
-      // We just give up on advancing context dependencies and solely rely on `setupContexts`.
-      value = context._currentValue;
-    }
-
-    return value;
-  }
-}
-
 const SuspenseException: mixed = new Error(
   "Suspense Exception: This is not a real error! It's an implementation " +
     'detail of `use` to interrupt the current render. You must either ' +
@@ -212,7 +174,6 @@ function use<T>(usable: Usable<T>): T {
             value: fulfilledValue,
             debugInfo:
               thenable._debugInfo === undefined ? null : thenable._debugInfo,
-            dispatcherHookName: 'Use',
           });
           return fulfilledValue;
         }
@@ -230,7 +191,6 @@ function use<T>(usable: Usable<T>): T {
         value: thenable,
         debugInfo:
           thenable._debugInfo === undefined ? null : thenable._debugInfo,
-        dispatcherHookName: 'Use',
       });
       throw SuspenseException;
     } else if (usable.$$typeof === REACT_CONTEXT_TYPE) {
@@ -243,7 +203,6 @@ function use<T>(usable: Usable<T>): T {
         stackError: new Error(),
         value,
         debugInfo: null,
-        dispatcherHookName: 'Use',
       });
 
       return value;
@@ -254,6 +213,37 @@ function use<T>(usable: Usable<T>): T {
   throw new Error('An unsupported type was passed to use(): ' + String(usable));
 }
 
+// For now we don't expose readContext usage in the hooks debugging info.
+function readContext<T>(context: ReactContext<T>): T {
+  if (currentFiber === null) {
+    // Hook inspection without access to the Fiber tree
+    // e.g. when warming up the primitive stack cache or during `ReactDebugTools.inspectHooks()`.
+    return context._currentValue;
+  } else {
+    if (currentContextDependency === null) {
+      throw new Error(
+        'Context reads do not line up with context dependencies. This is a bug in React Debug Tools.',
+      );
+    }
+
+    let value: T;
+    if (hasOwnProperty.call(currentContextDependency, 'memoizedValue')) {
+      // $FlowFixMe[incompatible-use] Flow thinks `hasOwnProperty` mutates `currentContextDependency`
+      value = ((currentContextDependency.memoizedValue: any): T);
+
+      // $FlowFixMe[incompatible-use] Flow thinks `hasOwnProperty` mutates `currentContextDependency`
+      currentContextDependency = currentContextDependency.next;
+    } else {
+      // Before React 18, we did not have `memoizedValue` so we rely on `setupContexts` in those versions.
+      // Multiple reads of the same context were also only tracked as a single dependency.
+      // We just give up on advancing context dependencies and solely rely on `setupContexts`.
+      value = context._currentValue;
+    }
+
+    return value;
+  }
+}
+
 function useContext<T>(context: ReactContext<T>): T {
   const value = readContext(context);
   hookLog.push({
@@ -262,7 +252,6 @@ function useContext<T>(context: ReactContext<T>): T {
     stackError: new Error(),
     value: value,
     debugInfo: null,
-    dispatcherHookName: 'Context',
   });
   return value;
 }
@@ -284,7 +273,6 @@ function useState<S>(
     stackError: new Error(),
     value: state,
     debugInfo: null,
-    dispatcherHookName: 'State',
   });
   return [state, (action: BasicStateAction<S>) => {}];
 }
@@ -307,7 +295,6 @@ function useReducer<S, I, A>(
     stackError: new Error(),
     value: state,
     debugInfo: null,
-    dispatcherHookName: 'Reducer',
   });
   return [state, (action: A) => {}];
 }
@@ -321,7 +308,6 @@ function useRef<T>(initialValue: T): {current: T} {
     stackError: new Error(),
     value: ref.current,
     debugInfo: null,
-    dispatcherHookName: 'Ref',
   });
   return ref;
 }
@@ -334,13 +320,12 @@ function useCacheRefresh(): () => void {
     stackError: new Error(),
     value: hook !== null ? hook.memoizedState : function refresh() {},
     debugInfo: null,
-    dispatcherHookName: 'CacheRefresh',
   });
   return () => {};
 }
 
 function useLayoutEffect(
-  create: () => (() => void) | void,
+  create: () => mixed,
   inputs: Array<mixed> | void | null,
 ): void {
   nextHook();
@@ -350,7 +335,6 @@ function useLayoutEffect(
     stackError: new Error(),
     value: create,
     debugInfo: null,
-    dispatcherHookName: 'LayoutEffect',
   });
 }
 
@@ -365,7 +349,6 @@ function useInsertionEffect(
     stackError: new Error(),
     value: create,
     debugInfo: null,
-    dispatcherHookName: 'InsertionEffect',
   });
 }
 
@@ -380,7 +363,6 @@ function useEffect(
     stackError: new Error(),
     value: create,
     debugInfo: null,
-    dispatcherHookName: 'Effect',
   });
 }
 
@@ -389,11 +371,6 @@ function useImperativeHandle<T>(
   create: () => T,
   inputs: Array<mixed> | void | null,
 ): void {
-  nextHook();
-  // We don't actually store the instance anywhere if there is no ref callback
-  // and if there is a ref callback it might not store it but if it does we
-  // have no way of knowing where. So let's only enable introspection of the
-  // ref itself if it is using the object form.
   let instance: ?T = undefined;
   if (ref !== null && typeof ref === 'object') {
     instance = ref.current;
@@ -404,7 +381,6 @@ function useImperativeHandle<T>(
     stackError: new Error(),
     value: instance,
     debugInfo: null,
-    dispatcherHookName: 'ImperativeHandle',
   });
 }
 
@@ -415,7 +391,6 @@ function useDebugValue(value: any, formatterFn: ?(value: any) => any) {
     stackError: new Error(),
     value: typeof formatterFn === 'function' ? formatterFn(value) : value,
     debugInfo: null,
-    dispatcherHookName: 'DebugValue',
   });
 }
 
@@ -427,7 +402,6 @@ function useCallback<T>(callback: T, inputs: Array<mixed> | void | null): T {
     stackError: new Error(),
     value: hook !== null ? hook.memoizedState[0] : callback,
     debugInfo: null,
-    dispatcherHookName: 'Callback',
   });
   return callback;
 }
@@ -444,7 +418,6 @@ function useMemo<T>(
     stackError: new Error(),
     value,
     debugInfo: null,
-    dispatcherHookName: 'Memo',
   });
   return value;
 }
@@ -466,7 +439,6 @@ function useSyncExternalStore<T>(
     stackError: new Error(),
     value,
     debugInfo: null,
-    dispatcherHookName: 'SyncExternalStore',
   });
   return value;
 }
@@ -489,7 +461,6 @@ function useTransition(): [
     stackError: new Error(),
     value: isPending,
     debugInfo: null,
-    dispatcherHookName: 'Transition',
   });
   return [isPending, () => {}];
 }
@@ -503,7 +474,6 @@ function useDeferredValue<T>(value: T, initialValue?: T): T {
     stackError: new Error(),
     value: prevValue,
     debugInfo: null,
-    dispatcherHookName: 'DeferredValue',
   });
   return prevValue;
 }
@@ -517,13 +487,10 @@ function useId(): string {
     stackError: new Error(),
     value: id,
     debugInfo: null,
-    dispatcherHookName: 'Id',
   });
   return id;
 }
 
-// useMemoCache is an implementation detail of Forget's memoization
-// it should not be called directly in user-generated code
 function useMemoCache(size: number): Array<mixed> {
   const fiber = currentFiber;
   // Don't throw, in case this is called from getPrimitiveStackCache
@@ -569,7 +536,6 @@ function useOptimistic<S, A>(
     stackError: new Error(),
     value: state,
     debugInfo: null,
-    dispatcherHookName: 'Optimistic',
   });
   return [state, (action: A) => {}];
 }
@@ -629,7 +595,6 @@ function useFormState<S, P>(
     stackError: stackError,
     value: value,
     debugInfo: debugInfo,
-    dispatcherHookName: 'FormState',
   });
 
   if (error !== null) {
@@ -639,8 +604,6 @@ function useFormState<S, P>(
   // value being a Thenable is equivalent to error being not null
   // i.e. we only reach this point with Awaited<S>
   const state = ((value: any): Awaited<S>);
-
-  // TODO: support displaying pending value
   return [state, (payload: P) => {}, false];
 }
 
@@ -699,7 +662,6 @@ function useActionState<S, P>(
     stackError: stackError,
     value: value,
     debugInfo: debugInfo,
-    dispatcherHookName: 'ActionState',
   });
 
   if (error !== null) {
@@ -709,11 +671,26 @@ function useActionState<S, P>(
   // value being a Thenable is equivalent to error being not null
   // i.e. we only reach this point with Awaited<S>
   const state = ((value: any): Awaited<S>);
-
-  // TODO: support displaying pending value
   return [state, (payload: P) => {}, false];
 }
 
+function useMutableSource<Source, Snapshot>(
+  source: MutableSource<Source>,
+  getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,
+  subscribe: MutableSourceSubscribeFn<Source, Snapshot>,
+): Snapshot {
+  // useMutableSource() composes multiple hooks internally.
+  // Advance the current hook index the same number of times
+  // so that subsequent hooks have the right memoized state.
+  nextHook(); // MutableSource
+  nextHook(); // State
+  nextHook(); // Effect
+  nextHook(); // Effect
+  const value = getSnapshot(source._source);
+  hookLog.push({primitive: 'MutableSource', stackError: new Error(), value});
+  return value;
+}
+
 function useHostTransitionStatus(): TransitionStatus {
   const status = readContext<TransitionStatus>(
     // $FlowFixMe[prop-missing] `readContext` only needs _currentValue
@@ -775,6 +752,7 @@ const Dispatcher: DispatcherType = {
   useMemoCache,
   useCacheRefresh,
   useEffectEvent,
+  useMutableSource,
 };
 
 // create a proxy to throw a custom error
@@ -819,19 +797,6 @@ export type HooksNode = {
 };
 export type HooksTree = Array<HooksNode>;
 
-// Don't assume
-//
-// We can't assume that stack frames are nth steps away from anything.
-// E.g. we can't assume that the root call shares all frames with the stack
-// of a hook call. A simple way to demonstrate this is wrapping `new Error()`
-// in a wrapper constructor like a polyfill. That'll add an extra frame.
-// Similar things can happen with the call to the dispatcher. The top frame
-// may not be the primitive.
-//
-// We also can't assume that the last frame of the root call is the same
-// frame as the last frame of the hook call because long stack traces can be
-// truncated to a stack trace limit.
-
 let mostLikelyAncestorIndex = 0;
 
 function findSharedIndex(hookStack: any, rootStack: any, rootIndex: number) {
@@ -976,6 +941,16 @@ function parseHookName(functionName: void | string): string {
   return functionName.slice(startIndex);
 }
 
+function parseCustomHookName(functionName: void | string): string {
+  if (!functionName) {
+    return '';
+  }
+  if (functionName.slice(0, 3) === 'use') {
+    return functionName.slice(3);
+  }
+  return functionName;
+}
+
 function buildTree(
   rootStack: any,
   readHookLog: Array<HookLogEntry>,
@@ -1094,25 +1069,23 @@ function buildTree(
   }
 
   // Associate custom hook values (useDebugValue() hook entries) with the correct hooks.
-  processDebugValues(rootChildren, null);
+  for (let i = 0; i < rootChildren.length; i++) {
+    processDebugValues(rootChildren[i], null);
+  }
 
   return rootChildren;
 }
 
-// Custom hooks support user-configurable labels (via the special useDebugValue() hook).
-// That hook adds user-provided values to the hooks tree,
-// but these values aren't intended to appear alongside of the other hooks.
-// Instead they should be attributed to their parent custom hook.
-// This method walks the tree and assigns debug values to their custom hook owners.
-function processDebugValues(
-  hooksTree: HooksTree,
-  parentHooksNode: HooksNode | null,
-): void {
-  const debugValueHooksNodes: Array<HooksNode> = [];
+function processDebugValues(hooksTree: any, parentHooksNode: any): void {
+  const debugValueHooksNodes = [];
 
   for (let i = 0; i < hooksTree.length; i++) {
     const hooksNode = hooksTree[i];
-    if (hooksNode.name === 'DebugValue' && hooksNode.subHooks.length === 0) {
+    if (
+      hooksNode.name === 'DebugValue' &&
+      hooksNode.subHooks.length === 0 &&
+      parentHooksNode !== null
+    ) {
       hooksTree.splice(i, 1);
       i--;
       debugValueHooksNodes.push(hooksNode);
@@ -1166,180 +1139,4 @@ function handleRenderFunctionError(error: any): void {
 export function inspectHooks<Props>(
   renderFunction: Props => React$Node,
   props: Props,
-  currentDispatcher: ?CurrentDispatcherRef,
-): HooksTree {
-  // DevTools will pass the current renderer's injected dispatcher.
-  // Other apps might compile debug hooks as part of their app though.
-  if (currentDispatcher == null) {
-    currentDispatcher = ReactSharedInternals;
-  }
-
-  const previousDispatcher = currentDispatcher.H;
-  currentDispatcher.H = DispatcherProxy;
-
-  let readHookLog;
-  let ancestorStackError;
-
-  try {
-    ancestorStackError = new Error();
-    renderFunction(props);
-  } catch (error) {
-    handleRenderFunctionError(error);
-  } finally {
-    readHookLog = hookLog;
-    hookLog = [];
-    // $FlowFixMe[incompatible-use] found when upgrading Flow
-    currentDispatcher.H = previousDispatcher;
-  }
-  const rootStack = ErrorStackParser.parse(ancestorStackError);
-  return buildTree(rootStack, readHookLog);
-}
-
-function setupContexts(contextMap: Map<ReactContext<any>, any>, fiber: Fiber) {
-  let current: null | Fiber = fiber;
-  while (current) {
-    if (current.tag === ContextProvider) {
-      let context: ReactContext<any> = current.type;
-      if ((context: any)._context !== undefined) {
-        // Support inspection of pre-19+ providers.
-        context = (context: any)._context;
-      }
-      if (!contextMap.has(context)) {
-        // Store the current value that we're going to restore later.
-        contextMap.set(context, context._currentValue);
-        // Set the inner most provider value on the context.
-        context._currentValue = current.memoizedProps.value;
-      }
-    }
-    current = current.return;
-  }
-}
-
-function restoreContexts(contextMap: Map<ReactContext<any>, any>) {
-  contextMap.forEach((value, context) => (context._currentValue = value));
-}
-
-function inspectHooksOfForwardRef<Props, Ref>(
-  renderFunction: (Props, Ref) => React$Node,
-  props: Props,
-  ref: Ref,
-  currentDispatcher: CurrentDispatcherRef,
-): HooksTree {
-  const previousDispatcher = currentDispatcher.H;
-  let readHookLog;
-  currentDispatcher.H = DispatcherProxy;
-  let ancestorStackError;
-  try {
-    ancestorStackError = new Error();
-    renderFunction(props, ref);
-  } catch (error) {
-    handleRenderFunctionError(error);
-  } finally {
-    readHookLog = hookLog;
-    hookLog = [];
-    currentDispatcher.H = previousDispatcher;
-  }
-  const rootStack = ErrorStackParser.parse(ancestorStackError);
-  return buildTree(rootStack, readHookLog);
-}
-
-function resolveDefaultProps(Component: any, baseProps: any) {
-  if (Component && Component.defaultProps) {
-    // Resolve default props. Taken from ReactElement
-    const props = assign({}, baseProps);
-    const defaultProps = Component.defaultProps;
-    for (const propName in defaultProps) {
-      if (props[propName] === undefined) {
-        props[propName] = defaultProps[propName];
-      }
-    }
-    return props;
-  }
-  return baseProps;
-}
-
-export function inspectHooksOfFiber(
-  fiber: Fiber,
-  currentDispatcher: ?CurrentDispatcherRef,
-): HooksTree {
-  // DevTools will pass the current renderer's injected dispatcher.
-  // Other apps might compile debug hooks as part of their app though.
-  if (currentDispatcher == null) {
-    currentDispatcher = ReactSharedInternals;
-  }
-
-  if (
-    fiber.tag !== FunctionComponent &&
-    fiber.tag !== SimpleMemoComponent &&
-    fiber.tag !== ForwardRef
-  ) {
-    throw new Error(
-      'Unknown Fiber. Needs to be a function component to inspect hooks.',
-    );
-  }
-
-  // Warm up the cache so that it doesn't consume the currentHook.
-  getPrimitiveStackCache();
-
-  // Set up the current hook so that we can step through and read the
-  // current state from them.
-  currentHook = (fiber.memoizedState: Hook);
-  currentFiber = fiber;
-
-  if (hasOwnProperty.call(currentFiber, 'dependencies')) {
-    // $FlowFixMe[incompatible-use]: Flow thinks hasOwnProperty might have nulled `currentFiber`
-    const dependencies = currentFiber.dependencies;
-    currentContextDependency =
-      dependencies !== null ? dependencies.firstContext : null;
-  } else if (hasOwnProperty.call(currentFiber, 'dependencies_old')) {
-    const dependencies: Dependencies = (currentFiber: any).dependencies_old;
-    currentContextDependency =
-      dependencies !== null ? dependencies.firstContext : null;
-  } else if (hasOwnProperty.call(currentFiber, 'dependencies_new')) {
-    const dependencies: Dependencies = (currentFiber: any).dependencies_new;
-    currentContextDependency =
-      dependencies !== null ? dependencies.firstContext : null;
-  } else if (hasOwnProperty.call(currentFiber, 'contextDependencies')) {
-    const contextDependencies = (currentFiber: any).contextDependencies;
-    currentContextDependency =
-      contextDependencies !== null ? contextDependencies.first : null;
-  } else {
-    throw new Error(
-      'Unsupported React version. This is a bug in React Debug Tools.',
-    );
-  }
-
-  const type = fiber.type;
-  let props = fiber.memoizedProps;
-  if (type !== fiber.elementType) {
-    props = resolveDefaultProps(type, props);
-  }
-
-  // Only used for versions of React without memoized context value in context dependencies.
-  const contextMap = new Map<ReactContext<any>, any>();
-  try {
-    if (
-      currentContextDependency !== null &&
-      !hasOwnProperty.call(currentContextDependency, 'memoizedValue')
-    ) {
-      setupContexts(contextMap, fiber);
-    }
-
-    if (fiber.tag === ForwardRef) {
-      return inspectHooksOfForwardRef(
-        type.render,
-        props,
-        fiber.ref,
-        currentDispatcher,
-      );
-    }
-
-    return inspectHooks(type, props, currentDispatcher);
-  } finally {
-    currentFiber = null;
-    currentHook = null;
-    currentContextDependency = null;
-
-    restoreContexts(contextMap);
-  }
-}
\ No newline at end of file
+  currentDispatcher: ?CurrentDispatcherRef,
\ No newline at end of file
