
index 2048a82a3..59cde9ca5 100644
--- a/react_packages_react-debug-tools_src_ReactDebugHooks.js_expectedoutput.txt (expected):tmp/tmpihup8a2a_expected.txt	
+++ b/react_packages_react-debug-tools_src_ReactDebugHooks.js_extracted.txt (actual):tmp/tmpuq1g1u27_actual.txt	
@@ -10,6 +10,7 @@
 import type {
   Awaited,
   ReactContext,
+  ReactProviderType,
   StartTransitionOptions,
   Usable,
   Thenable,
@@ -40,8 +41,6 @@ import hasOwnProperty from 'shared/hasOwnProperty';
 
 type CurrentDispatcherRef = typeof ReactSharedInternals;
 
-// Used to track hooks called during a render
-
 type HookLogEntry = {
   displayName: string | null,
   primitive: string,
@@ -53,14 +52,6 @@ type HookLogEntry = {
 
 let hookLog: Array<HookLogEntry> = [];
 
-// Primitives
-
-type BasicStateAction<S> = (S => S) | S;
-
-type Dispatch<A> = A => void;
-
-let primitiveStackCache: null | Map<string, Array<any>> = null;
-
 type Hook = {
   memoizedState: any,
   next: Hook | null,
@@ -79,33 +70,18 @@ function getPrimitiveStackCache(): Map<string, Array<any>> {
       Dispatcher.useReducer((s: mixed, a: mixed) => s, null);
       Dispatcher.useRef(null);
       if (typeof Dispatcher.useCacheRefresh === 'function') {
-        // This type check is for Flow only.
         Dispatcher.useCacheRefresh();
       }
-      Dispatcher.useLayoutEffect(() => {});
-      Dispatcher.useInsertionEffect(() => {});
-      Dispatcher.useEffect(() => {});
-      Dispatcher.useImperativeHandle(undefined, () => null);
-      Dispatcher.useDebugValue(null);
-      Dispatcher.useCallback(() => {});
-      Dispatcher.useTransition();
-      Dispatcher.useSyncExternalStore(
-        () => () => {},
-        () => null,
-        () => null,
-      );
-      Dispatcher.useDeferredValue(null);
-      Dispatcher.useMemo(() => null);
-      Dispatcher.useOptimistic(null, (s: mixed, a: mixed) => s);
-      Dispatcher.useFormState((s: mixed, p: mixed) => s, null);
-      Dispatcher.useActionState((s: mixed, p: mixed) => s, null);
-      Dispatcher.useHostTransitionStatus();
-      if (typeof Dispatcher.useMemoCache === 'function') {
-        // This type check is for Flow only.
-        Dispatcher.useMemoCache(0);
+      if (typeof Dispatcher.useOptimistic === 'function') {
+        Dispatcher.useOptimistic(null, (s: mixed, a: mixed) => s);
+      }
+      if (typeof Dispatcher.useFormState === 'function') {
+        Dispatcher.useFormState((s: mixed, p: mixed) => s, null);
+      }
+      if (typeof Dispatcher.useActionState === 'function') {
+        Dispatcher.useActionState((s: mixed, p: mixed) => s, null);
       }
       if (typeof Dispatcher.use === 'function') {
-        // This type check is for Flow only.
         Dispatcher.use(
           ({
             $$typeof: REACT_CONTEXT_TYPE,
@@ -125,11 +101,12 @@ function getPrimitiveStackCache(): Map<string, Array<any>> {
           );
         } catch (x) {}
       }
-
       Dispatcher.useId();
-
-      if (typeof Dispatcher.useEffectEvent === 'function') {
-        Dispatcher.useEffectEvent((args: empty) => {});
+      if (typeof Dispatcher.useHostTransitionStatus === 'function') {
+        Dispatcher.useHostTransitionStatus();
+      }
+      if (typeof Dispatcher.useMemoCache === 'function') {
+        Dispatcher.useMemoCache(0);
       }
     } finally {
       readHookLog = hookLog;
@@ -144,6 +121,8 @@ function getPrimitiveStackCache(): Map<string, Array<any>> {
   return primitiveStackCache;
 }
 
+let primitiveStackCache: null | Map<string, Array<any>> = null;
+
 let currentFiber: null | Fiber = null;
 let currentHook: null | Hook = null;
 let currentContextDependency: null | ContextDependency<mixed> = null;
@@ -158,8 +137,7 @@ function nextHook(): null | Hook {
 
 function readContext<T>(context: ReactContext<T>): T {
   if (currentFiber === null) {
-    // Hook inspection without access to the Fiber tree
-    // e.g. when warming up the primitive stack cache or during `ReactDebugTools.inspectHooks()`.
+    // Hook inspection without access to the Fiber tree.
     return context._currentValue;
   } else {
     if (currentContextDependency === null) {
@@ -168,27 +146,23 @@ function readContext<T>(context: ReactContext<T>): T {
       );
     }
 
-    let value: T;
-    // For now we don't expose readContext usage in the hooks debugging info.
-    if (hasOwnProperty.call(currentContextDependency, 'memoizedValue')) {
-      // $FlowFixMe[incompatible-use] Flow thinks `hasOwnProperty` mutates `currentContextDependency`
-      value = ((currentContextDependency.memoizedValue: any): T);
+    const value: T = hasOwnProperty.call(currentContextDependency, 'memoizedValue')
+      ? // $FlowFixMe[incompatible-use] Flow thinks `hasOwnProperty` mutates `currentContextDependency`
+        ((currentContextDependency.memoizedValue: any): T)
+      : // Before React 18, we did not have `memoizedValue` so we rely on `setupContexts` in those versions.
+        // $FlowFixMe[incompatible-use] Flow thinks `hasOwnProperty` mutates `currentContextDependency`
+        ((currentContextDependency.context._currentValue: any): T);
 
-      // $FlowFixMe[incompatible-use] Flow thinks `hasOwnProperty` mutates `currentContextDependency`
-      currentContextDependency = currentContextDependency.next;
-    } else {
-      // Before React 18, we did not have `memoizedValue` so we rely on `setupContexts` in those versions.
-      // Multiple reads of the same context were also only tracked as a single dependency.
-      // We just give up on advancing context dependencies and solely rely on `setupContexts`.
-      value = context._currentValue;
-    }
+    // $FlowFixMe[incompatible-use] Flow thinks `hasOwnProperty` mutates `currentContextDependency`
+    currentContextDependency = currentContextDependency.next;
 
     return value;
   }
 }
 
+/* eslint-disable-next-line no-restricted-globals */
 const SuspenseException: mixed = new Error(
-  "Suspense Exception: This is not a real error! It's an implementation " +
+  'Suspense Exception: This is not a real error! It\'s an implementation ' +
     'detail of `use` to interrupt the current render. You must either ' +
     'rethrow it immediately, or move the `use` call outside of the ' +
     '`try/catch` block. Capturing without rethrowing will lead to ' +
@@ -221,8 +195,7 @@ function use<T>(usable: Usable<T>): T {
           throw rejectedError;
         }
       }
-      // If this was an uncached Promise we have to abandon this attempt
-      // but we can still emit anything up until this point.
+      // If the promise is still pending we abort the current render.
       hookLog.push({
         displayName: null,
         primitive: 'Unresolved',
@@ -249,7 +222,6 @@ function use<T>(usable: Usable<T>): T {
       return value;
     }
   }
-
   // eslint-disable-next-line react-internal/safe-string-coercion
   throw new Error('An unsupported type was passed to use(): ' + String(usable));
 }
@@ -260,7 +232,7 @@ function useContext<T>(context: ReactContext<T>): T {
     displayName: context.displayName || null,
     primitive: 'Context',
     stackError: new Error(),
-    value: value,
+    value,
     debugInfo: null,
     dispatcherHookName: 'Context',
   });
@@ -371,7 +343,7 @@ function useInsertionEffect(
 
 function useEffect(
   create: () => (() => void) | void,
-  deps: Array<mixed> | void | null,
+  inputs: Array<mixed> | void | null,
 ): void {
   nextHook();
   hookLog.push({
@@ -390,10 +362,6 @@ function useImperativeHandle<T>(
   inputs: Array<mixed> | void | null,
 ): void {
   nextHook();
-  // We don't actually store the instance anywhere if there is no ref callback
-  // and if there is a ref callback it might not store it but if it does we
-  // have no way of knowing where. So let's only enable introspection of the
-  // ref itself if it is using the object form.
   let instance: ?T = undefined;
   if (ref !== null && typeof ref === 'object') {
     instance = ref.current;
@@ -452,12 +420,8 @@ function useMemo<T>(
 function useSyncExternalStore<T>(
   subscribe: (() => void) => () => void,
   getSnapshot: () => T,
-  getServerSnapshot?: () => T,
 ): T {
-  // useSyncExternalStore() composes multiple hooks internally.
-  // Advance the current hook index the same number of times
-  // so that subsequent hooks have the right memoized state.
-  nextHook(); // SyncExternalStore
+  nextHook(); // State
   nextHook(); // Effect
   const value = getSnapshot();
   hookLog.push({
@@ -471,18 +435,10 @@ function useSyncExternalStore<T>(
   return value;
 }
 
-function useTransition(): [
-  boolean,
-  (callback: () => void, options?: StartTransitionOptions) => void,
-] {
-  // useTransition() composes multiple hooks internally.
-  // Advance the current hook index the same number of times
-  // so that subsequent hooks have the right memoized state.
-  const stateHook = nextHook();
+function useTransition(): [boolean, (() => void) => void] {
+  const stateHook = nextHook(); // State
   nextHook(); // Callback
-
   const isPending = stateHook !== null ? stateHook.memoizedState : false;
-
   hookLog.push({
     displayName: null,
     primitive: 'Transition',
@@ -496,16 +452,15 @@ function useTransition(): [
 
 function useDeferredValue<T>(value: T, initialValue?: T): T {
   const hook = nextHook();
-  const prevValue = hook !== null ? hook.memoizedState : value;
   hookLog.push({
     displayName: null,
     primitive: 'DeferredValue',
     stackError: new Error(),
-    value: prevValue,
+    value: hook !== null ? hook.memoizedState : value,
     debugInfo: null,
     dispatcherHookName: 'DeferredValue',
   });
-  return prevValue;
+  return value;
 }
 
 function useId(): string {
@@ -524,16 +479,15 @@ function useId(): string {
 
 // useMemoCache is an implementation detail of Forget's memoization
 // it should not be called directly in user-generated code
-function useMemoCache(size: number): Array<mixed> {
+function useMemoCache(size: number): Array<any> {
   const fiber = currentFiber;
   // Don't throw, in case this is called from getPrimitiveStackCache
   if (fiber == null) {
     return [];
   }
 
-  const memoCache =
-    // $FlowFixMe[incompatible-use]: updateQueue is mixed
-    fiber.updateQueue != null ? fiber.updateQueue.memoCache : null;
+  // $FlowFixMe[incompatible-use]: updateQueue is mixed
+  const memoCache = fiber.updateQueue?.memoCache;
   if (memoCache == null) {
     return [];
   }
@@ -578,9 +532,8 @@ function useFormState<S, P>(
   action: (Awaited<S>, P) => S,
   initialState: Awaited<S>,
   permalink?: string,
-): [Awaited<S>, (P) => void, boolean] {
+): [Awaited<S>, (P) => void] {
   const hook = nextHook(); // FormState
-  nextHook(); // PendingState
   nextHook(); // ActionQueue
   const stackError = new Error();
   let value;
@@ -609,8 +562,7 @@ function useFormState<S, P>(
           break;
         }
         default:
-          // If this was an uncached Promise we have to abandon this attempt
-          // but we can still emit anything up until this point.
+          // If the promise is still pending we abort the current render.
           error = SuspenseException;
           debugInfo =
             thenable._debugInfo === undefined ? null : thenable._debugInfo;
@@ -627,8 +579,8 @@ function useFormState<S, P>(
     displayName: null,
     primitive: 'FormState',
     stackError: stackError,
-    value: value,
-    debugInfo: debugInfo,
+    value,
+    debugInfo,
     dispatcherHookName: 'FormState',
   });
 
@@ -636,18 +588,13 @@ function useFormState<S, P>(
     throw error;
   }
 
-  // value being a Thenable is equivalent to error being not null
-  // i.e. we only reach this point with Awaited<S>
   const state = ((value: any): Awaited<S>);
-
-  // TODO: support displaying pending value
-  return [state, (payload: P) => {}, false];
+  return [state, (payload: P) => {}];
 }
 
 function useActionState<S, P>(
-  action: (Awaited<S>, P) => S,
-  initialState: Awaited<S>,
-  permalink?: string,
+  passthrough: S,
+  reducer: ?(S, A) => S,
 ): [Awaited<S>, (P) => void, boolean] {
   const hook = nextHook(); // FormState
   nextHook(); // PendingState
@@ -679,8 +626,6 @@ function useActionState<S, P>(
           break;
         }
         default:
-          // If this was an uncached Promise we have to abandon this attempt
-          // but we can still emit anything up until this point.
           error = SuspenseException;
           debugInfo =
             thenable._debugInfo === undefined ? null : thenable._debugInfo;
@@ -697,8 +642,8 @@ function useActionState<S, P>(
     displayName: null,
     primitive: 'ActionState',
     stackError: stackError,
-    value: value,
-    debugInfo: debugInfo,
+    value,
+    debugInfo,
     dispatcherHookName: 'ActionState',
   });
 
@@ -706,11 +651,7 @@ function useActionState<S, P>(
     throw error;
   }
 
-  // value being a Thenable is equivalent to error being not null
-  // i.e. we only reach this point with Awaited<S>
   const state = ((value: any): Awaited<S>);
-
-  // TODO: support displaying pending value
   return [state, (payload: P) => {}, false];
 }
 
@@ -750,57 +691,29 @@ function useEffectEvent<Args, F: (...Array<Args>) => mixed>(callback: F): F {
 }
 
 const Dispatcher: DispatcherType = {
-  readContext,
-
   use,
+  readContext,
+  useCacheRefresh,
   useCallback,
   useContext,
   useEffect,
   useImperativeHandle,
+  useDebugValue,
   useLayoutEffect,
   useInsertionEffect,
   useMemo,
+  useMemoCache,
+  useOptimistic,
   useReducer,
   useRef,
   useState,
-  useDebugValue,
-  useDeferredValue,
-  useTransition,
-  useSyncExternalStore,
   useId,
   useHostTransitionStatus,
   useFormState,
   useActionState,
-  useOptimistic,
-  useMemoCache,
-  useCacheRefresh,
   useEffectEvent,
 };
 
-// create a proxy to throw a custom error
-// in case future versions of React adds more hooks
-const DispatcherProxyHandler = {
-  get(target: DispatcherType, prop: string) {
-    if (target.hasOwnProperty(prop)) {
-      // $FlowFixMe[invalid-computed-prop]
-      return target[prop];
-    }
-    const error = new Error('Missing method in Dispatcher: ' + prop);
-    // Note: This error name needs to stay in sync with react-devtools-shared
-    // TODO: refactor this if we ever combine the devtools and debug tools packages
-    error.name = 'ReactDebugToolsUnsupportedHookError';
-    throw error;
-  },
-};
-
-// `Proxy` may not exist on some platforms
-const DispatcherProxy =
-  typeof Proxy === 'undefined'
-    ? Dispatcher
-    : new Proxy(Dispatcher, DispatcherProxyHandler);
-
-// Inspect
-
 export type HookSource = {
   lineNumber: number | null,
   columnNumber: number | null,
@@ -817,35 +730,21 @@ export type HooksNode = {
   debugInfo: null | ReactDebugInfo,
   hookSource: null | HookSource,
 };
-export type HooksTree = Array<HooksNode>;
 
-// Don't assume
-//
-// We can't assume that stack frames are nth steps away from anything.
-// E.g. we can't assume that the root call shares all frames with the stack
-// of a hook call. A simple way to demonstrate this is wrapping `new Error()`
-// in a wrapper constructor like a polyfill. That'll add an extra frame.
-// Similar things can happen with the call to the dispatcher. The top frame
-// may not be the primitive.
-//
-// We also can't assume that the last frame of the root call is the same
-// frame as the last frame of the hook call because long stack traces can be
-// truncated to a stack trace limit.
+export type HooksTree = Array<HooksNode>;
 
 let mostLikelyAncestorIndex = 0;
 
-function findSharedIndex(hookStack: any, rootStack: any, rootIndex: number) {
+function findSharedIndex(hookStack, rootStack, rootIndex) {
   const source = rootStack[rootIndex].source;
   hookSearch: for (let i = 0; i < hookStack.length; i++) {
     if (hookStack[i].source === source) {
-      // This looks like a match. Validate that the rest of both stack match up.
       for (
         let a = rootIndex + 1, b = i + 1;
         a < rootStack.length && b < hookStack.length;
         a++, b++
       ) {
         if (hookStack[b].source !== rootStack[a].source) {
-          // If not, give up and try a different match.
           continue hookSearch;
         }
       }
@@ -855,7 +754,7 @@ function findSharedIndex(hookStack: any, rootStack: any, rootIndex: number) {
   return -1;
 }
 
-function findCommonAncestorIndex(rootStack: any, hookStack: any) {
+function findCommonAncestorIndex(rootStack, hookStack) {
   let rootIndex = findSharedIndex(
     hookStack,
     rootStack,
@@ -864,8 +763,6 @@ function findCommonAncestorIndex(rootStack: any, hookStack: any) {
   if (rootIndex !== -1) {
     return rootIndex;
   }
-  // If the most likely one wasn't a hit, try any other frame to see if it is shared.
-  // If that takes more than 5 frames, something probably went wrong.
   for (let i = 0; i < rootStack.length && i < 5; i++) {
     rootIndex = findSharedIndex(hookStack, rootStack, i);
     if (rootIndex !== -1) {
@@ -881,7 +778,6 @@ function isReactWrapper(functionName: any, wrapperName: string) {
   if (wrapperName === 'HostTransitionStatus') {
     return hookName === wrapperName || hookName === 'FormStatus';
   }
-
   return hookName === wrapperName;
 }
 
@@ -892,11 +788,7 @@ function findPrimitiveIndex(hookStack: any, hook: HookLogEntry) {
     return -1;
   }
   for (let i = 0; i < primitiveStack.length && i < hookStack.length; i++) {
-    // Note: there is no guarantee that we will find the top-most primitive frame in the stack
-    // For React Native (uses Hermes), these source fields will be identical and skipped
     if (primitiveStack[i].source !== hookStack[i].source) {
-      // If the next two frames are functions called `useX` then we assume that they're part of the
-      // wrappers that the React package or other packages adds around the dispatcher.
       if (
         i < hookStack.length - 1 &&
         isReactWrapper(hookStack[i].functionName, hook.dispatcherHookName)
@@ -909,7 +801,6 @@ function findPrimitiveIndex(hookStack: any, hook: HookLogEntry) {
       ) {
         i++;
       }
-
       return i;
     }
   }
@@ -917,8 +808,6 @@ function findPrimitiveIndex(hookStack: any, hook: HookLogEntry) {
 }
 
 function parseTrimmedStack(rootStack: any, hook: HookLogEntry) {
-  // Get the stack trace between the primitive hook function and
-  // the root function call. I.e. the stack frames of custom hooks.
   const hookStack = ErrorStackParser.parse(hook.stackError);
   const rootIndex = findCommonAncestorIndex(rootStack, hookStack);
   const primitiveIndex = findPrimitiveIndex(hookStack, hook);
@@ -928,29 +817,21 @@ function parseTrimmedStack(rootStack: any, hook: HookLogEntry) {
     rootIndex - primitiveIndex < 2
   ) {
     if (primitiveIndex === -1) {
-      // Something went wrong. Give up.
       return [null, null];
     } else {
       return [hookStack[primitiveIndex - 1], null];
     }
   }
-  return [
-    hookStack[primitiveIndex - 1],
-    hookStack.slice(primitiveIndex, rootIndex - 1),
-  ];
+  return [hookStack[primitiveIndex - 1], hookStack.slice(primitiveIndex, rootIndex - 1)];
 }
 
-function parseHookName(functionName: void | string): string {
+function parseCustomHookName(functionName: void | string): string {
   if (!functionName) {
     return '';
   }
   let startIndex = functionName.lastIndexOf('[as ');
-
   if (startIndex !== -1) {
-    // Workaround for sourcemaps in Jest and Chrome.
-    // In `node --enable-source-maps`, we don't see "Object.useHostTransitionStatus [as useFormStatus]" but "Object.useFormStatus"
-    // "Object.useHostTransitionStatus [as useFormStatus]" -> "useFormStatus"
-    return parseHookName(functionName.slice(startIndex + '[as '.length, -1));
+    return parseCustomHookName(functionName.slice(startIndex + '[as '.length, -1));
   }
   startIndex = functionName.lastIndexOf('.');
   if (startIndex === -1) {
@@ -958,15 +839,6 @@ function parseHookName(functionName: void | string): string {
   } else {
     startIndex += 1;
   }
-
-  if (functionName.slice(startIndex).startsWith('unstable_')) {
-    startIndex += 'unstable_'.length;
-  }
-
-  if (functionName.slice(startIndex).startsWith('experimental_')) {
-    startIndex += 'experimental_'.length;
-  }
-
   if (functionName.slice(startIndex, startIndex + 3) === 'use') {
     if (functionName.length - startIndex === 3) {
       return 'Use';
@@ -990,57 +862,37 @@ function buildTree(
     const parseResult = parseTrimmedStack(rootStack, hook);
     const primitiveFrame = parseResult[0];
     const stack = parseResult[1];
-    let displayName = hook.displayName;
-    if (displayName === null && primitiveFrame !== null) {
-      displayName =
-        parseHookName(primitiveFrame.functionName) ||
-        // Older versions of React do not have sourcemaps.
-        // In those versions there was always a 1:1 mapping between wrapper and dispatcher method.
-        parseHookName(hook.dispatcherHookName);
-    }
     if (stack !== null) {
-      // Note: The indices 0 <= n < length-1 will contain the names.
-      // The indices 1 <= n < length will contain the source locations.
-      // That's why we get the name from n - 1 and don't check the source
-      // of index 0.
-      let commonSteps = 0;
       if (prevStack !== null) {
-        // Compare the current level's stack to the new stack.
+        let commonSteps = 0;
         while (commonSteps < stack.length && commonSteps < prevStack.length) {
           const stackSource = stack[stack.length - commonSteps - 1].source;
-          const prevSource =
-            prevStack[prevStack.length - commonSteps - 1].source;
+          const prevSource = prevStack[prevStack.length - commonSteps - 1].source;
           if (stackSource !== prevSource) {
             break;
           }
           commonSteps++;
         }
-        // Pop back the stack as many steps as were not common.
         for (let j = prevStack.length - 1; j > commonSteps; j--) {
-          // $FlowFixMe[incompatible-type]
           levelChildren = stackOfChildren.pop();
         }
       }
-      // The remaining part of the new stack are custom hooks. Push them
-      // to the tree.
       for (let j = stack.length - commonSteps - 1; j >= 1; j--) {
         const children: Array<HooksNode> = [];
-        const stackFrame = stack[j];
         const levelChild: HooksNode = {
           id: null,
           isStateEditable: false,
-          name: parseHookName(stack[j - 1].functionName),
+          name: parseCustomHookName(stack[j - 1].functionName),
           value: undefined,
           subHooks: children,
           debugInfo: null,
           hookSource: {
-            lineNumber: stackFrame.lineNumber,
-            columnNumber: stackFrame.columnNumber,
-            functionName: stackFrame.functionName,
-            fileName: stackFrame.fileName,
+            lineNumber: stack[j].lineNumber,
+            columnNumber: stack[j].columnNumber,
+            functionName: stack[j].functionName,
+            fileName: stack[j].fileName,
           },
         };
-
         levelChildren.push(levelChild);
         stackOfChildren.push(levelChildren);
         levelChildren = children;
@@ -1049,8 +901,6 @@ function buildTree(
     }
     const {primitive, debugInfo} = hook;
 
-    // For now, the "id" of stateful hooks is just the stateful hook index.
-    // Custom hooks have no ids, nor do non-stateful native hooks (e.g. Context, DebugValue).
     const id =
       primitive === 'Context' ||
       primitive === 'Context (use)' ||
@@ -1061,49 +911,34 @@ function buildTree(
         ? null
         : nativeHookID++;
 
-    // For the time being, only State and Reducer hooks support runtime overrides.
     const isStateEditable = primitive === 'Reducer' || primitive === 'State';
-    const name = displayName || primitive;
+    const name = primitive === 'Context (use)' ? 'Context' : primitive;
     const levelChild: HooksNode = {
       id,
       isStateEditable,
       name,
       value: hook.value,
       subHooks: [],
-      debugInfo: debugInfo,
+      debugInfo,
       hookSource: null,
     };
-
-    const hookSource: HookSource = {
-      lineNumber: null,
-      functionName: null,
-      fileName: null,
-      columnNumber: null,
-    };
     if (stack && stack.length >= 1) {
       const stackFrame = stack[0];
-      hookSource.lineNumber = stackFrame.lineNumber;
-      hookSource.functionName = stackFrame.functionName;
-      hookSource.fileName = stackFrame.fileName;
-      hookSource.columnNumber = stackFrame.columnNumber;
+      levelChild.hookSource = {
+        lineNumber: stackFrame.lineNumber,
+        functionName: stackFrame.functionName,
+        fileName: stackFrame.fileName,
+        columnNumber: stackFrame.columnNumber,
+      };
     }
-
-    levelChild.hookSource = hookSource;
-
     levelChildren.push(levelChild);
   }
 
   // Associate custom hook values (useDebugValue() hook entries) with the correct hooks.
   processDebugValues(rootChildren, null);
-
   return rootChildren;
 }
 
-// Custom hooks support user-configurable labels (via the special useDebugValue() hook).
-// That hook adds user-provided values to the hooks tree,
-// but these values aren't intended to appear alongside of the other hooks.
-// Instead they should be attributed to their parent custom hook.
-// This method walks the tree and assigns debug values to their custom hook owners.
 function processDebugValues(
   hooksTree: HooksTree,
   parentHooksNode: HooksNode | null,
@@ -1121,9 +956,6 @@ function processDebugValues(
     }
   }
 
-  // Bubble debug value labels to their custom hook owner.
-  // If there is no parent hook, just ignore them for now.
-  // (We may warn about this in the future.)
   if (parentHooksNode !== null) {
     if (debugValueHooksNodes.length === 1) {
       parentHooksNode.value = debugValueHooksNodes[0].value;
@@ -1134,10 +966,7 @@ function processDebugValues(
 }
 
 function handleRenderFunctionError(error: any): void {
-  // original error might be any type.
   if (error === SuspenseException) {
-    // An uncached Promise was used. We can't synchronously resolve the rest of
-    // the Hooks but we can at least show what ever we got so far.
     return;
   }
   if (
@@ -1146,18 +975,10 @@ function handleRenderFunctionError(error: any): void {
   ) {
     throw error;
   }
-  // If the error is not caused by an unsupported feature, it means
-  // that the error is caused by user's code in renderFunction.
-  // In this case, we should wrap the original error inside a custom error
-  // so that devtools can give a clear message about it.
-  // $FlowFixMe[extra-arg]: Flow doesn't know about 2nd argument of Error constructor
   const wrapperError = new Error('Error rendering inspected component', {
     cause: error,
   });
-  // Note: This error name needs to stay in sync with react-devtools-shared
-  // TODO: refactor this if we ever combine the devtools and debug tools packages
   wrapperError.name = 'ReactDebugToolsRenderError';
-  // this stage-4 proposal is not supported by all environments yet.
   // $FlowFixMe[prop-missing] Flow doesn't have this type yet.
   wrapperError.cause = error;
   throw wrapperError;
@@ -1168,18 +989,14 @@ export function inspectHooks<Props>(
   props: Props,
   currentDispatcher: ?CurrentDispatcherRef,
 ): HooksTree {
-  // DevTools will pass the current renderer's injected dispatcher.
-  // Other apps might compile debug hooks as part of their app though.
   if (currentDispatcher == null) {
     currentDispatcher = ReactSharedInternals;
   }
 
   const previousDispatcher = currentDispatcher.H;
-  currentDispatcher.H = DispatcherProxy;
-
   let readHookLog;
+  currentDispatcher.H = Dispatcher;
   let ancestorStackError;
-
   try {
     ancestorStackError = new Error();
     renderFunction(props);
@@ -1188,7 +1005,6 @@ export function inspectHooks<Props>(
   } finally {
     readHookLog = hookLog;
     hookLog = [];
-    // $FlowFixMe[incompatible-use] found when upgrading Flow
     currentDispatcher.H = previousDispatcher;
   }
   const rootStack = ErrorStackParser.parse(ancestorStackError);
@@ -1201,13 +1017,10 @@ function setupContexts(contextMap: Map<ReactContext<any>, any>, fiber: Fiber) {
     if (current.tag === ContextProvider) {
       let context: ReactContext<any> = current.type;
       if ((context: any)._context !== undefined) {
-        // Support inspection of pre-19+ providers.
         context = (context: any)._context;
       }
       if (!contextMap.has(context)) {
-        // Store the current value that we're going to restore later.
         contextMap.set(context, context._currentValue);
-        // Set the inner most provider value on the context.
         context._currentValue = current.memoizedProps.value;
       }
     }
@@ -1227,7 +1040,7 @@ function inspectHooksOfForwardRef<Props, Ref>(
 ): HooksTree {
   const previousDispatcher = currentDispatcher.H;
   let readHookLog;
-  currentDispatcher.H = DispatcherProxy;
+  currentDispatcher.H = Dispatcher;
   let ancestorStackError;
   try {
     ancestorStackError = new Error();
@@ -1245,7 +1058,6 @@ function inspectHooksOfForwardRef<Props, Ref>(
 
 function resolveDefaultProps(Component: any, baseProps: any) {
   if (Component && Component.defaultProps) {
-    // Resolve default props. Taken from ReactElement
     const props = assign({}, baseProps);
     const defaultProps = Component.defaultProps;
     for (const propName in defaultProps) {
@@ -1262,12 +1074,6 @@ export function inspectHooksOfFiber(
   fiber: Fiber,
   currentDispatcher: ?CurrentDispatcherRef,
 ): HooksTree {
-  // DevTools will pass the current renderer's injected dispatcher.
-  // Other apps might compile debug hooks as part of their app though.
-  if (currentDispatcher == null) {
-    currentDispatcher = ReactSharedInternals;
-  }
-
   if (
     fiber.tag !== FunctionComponent &&
     fiber.tag !== SimpleMemoComponent &&
@@ -1278,16 +1084,12 @@ export function inspectHooksOfFiber(
     );
   }
 
-  // Warm up the cache so that it doesn't consume the currentHook.
   getPrimitiveStackCache();
 
-  // Set up the current hook so that we can step through and read the
-  // current state from them.
   currentHook = (fiber.memoizedState: Hook);
   currentFiber = fiber;
 
   if (hasOwnProperty.call(currentFiber, 'dependencies')) {
-    // $FlowFixMe[incompatible-use]: Flow thinks hasOwnProperty might have nulled `currentFiber`
     const dependencies = currentFiber.dependencies;
     currentContextDependency =
       dependencies !== null ? dependencies.firstContext : null;
@@ -1315,7 +1117,6 @@ export function inspectHooksOfFiber(
     props = resolveDefaultProps(type, props);
   }
 
-  // Only used for versions of React without memoized context value in context dependencies.
   const contextMap = new Map<ReactContext<any>, any>();
   try {
     if (
