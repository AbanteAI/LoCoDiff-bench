--- ghostty_src_apprt_gtk_Split.zig_expectedoutput.txt (expected)+++ ghostty_src_apprt_gtk_Split.zig_extracted.txt (actual)@@ -1,5 +1,3 @@-/// Split represents a surface split where two surfaces are shown side-by-side
-/// within the same window either vertically or horizontally.
 const Split = @This();
 
 const std = @import("std");
@@ -168,7 +166,7 @@     self.removeChild(self.top_left, self.bottom_right);
 }
 
-/// Remove the top left child.
+/// Remove the bottom right child.
 pub fn removeBottomRight(self: *Split) void {
     self.removeChild(self.bottom_right, self.top_left);
 }
@@ -194,62 +192,6 @@     // When a child is removed we are no longer a split, so destroy ourself
     remove.deinit(alloc);
     alloc.destroy(self);
-}
-
-/// Move the divider in the given direction by the given amount.
-pub fn moveDivider(
-    self: *Split,
-    direction: apprt.action.ResizeSplit.Direction,
-    amount: u16,
-) void {
-    const min_pos = 10;
-
-    const pos = self.paned.getPosition();
-    const new = switch (direction) {
-        .up, .left => @max(pos - amount, min_pos),
-        .down, .right => new_pos: {
-            const max_pos: u16 = @as(u16, @intFromFloat(self.maxPosition())) - min_pos;
-            break :new_pos @min(pos + amount, max_pos);
-        },
-    };
-
-    self.paned.setPosition(new);
-}
-
-/// Equalize the splits in this split panel. Each split is equalized based on
-/// its weight, i.e. the number of Surfaces it contains.
-///
-/// It works recursively by equalizing the children of each split.
-///
-/// It returns this split's weight.
-pub fn equalize(self: *Split) f64 {
-    // Calculate weights of top_left/bottom_right
-    const top_left_weight = self.top_left.equalize();
-    const bottom_right_weight = self.bottom_right.equalize();
-    const weight = top_left_weight + bottom_right_weight;
-
-    // Ratio of top_left weight to overall weight, which gives the split ratio
-    const ratio = top_left_weight / weight;
-
-    // Convert split ratio into new position for divider
-    self.paned.setPosition(@intFromFloat(self.maxPosition() * ratio));
-
-    return weight;
-}
-
-// maxPosition returns the maximum position of the GtkPaned, which is the
-// "max-position" attribute.
-fn maxPosition(self: *Split) f64 {
-    var value: gobject.Value = std.mem.zeroes(gobject.Value);
-    defer value.unset();
-
-    _ = value.init(gobject.ext.types.int);
-    self.paned.as(gobject.Object).getProperty(
-        "max-position",
-        &value,
-    );
-
-    return @floatFromInt(value.getInt());
 }
 
 // This replaces the element at the given pointer with a new element.
@@ -272,7 +214,62 @@     self.updateChildren();
 }
 
-// grabFocus grabs the focus of the top-left element.
+/// Move the divider in the given direction by the given amount.
+pub fn moveDivider(
+    self: *Split,
+    direction: apprt.action.ResizeSplit.Direction,
+    amount: u16,
+) void {
+    const min_pos = 10;
+
+    const pos = self.paned.getPosition();
+    const new = switch (direction) {
+        .up, .left => @max(pos - amount, min_pos),
+        .down, .right => new_pos: {
+            const max_pos: u16 = @as(u16, @intFromFloat(self.maxPosition())) - min_pos;
+            break :new_pos @min(pos + amount, max_pos);
+        },
+    };
+
+    self.paned.setPosition(new);
+}
+
+/// Equalize the splits in this split panel. Each split is equalized based on
+/// its weight, i.e. the number of Surfaces it contains.
+///
+/// It works recursively by equalizing the children of each split.
+///
+/// It returns this split's weight.
+pub fn equalize(self: *Split) f64 {
+    // Calculate weights of top_left/bottom_right
+    const top_left_weight = self.top_left.equalize();
+    const bottom_right_weight = self.bottom_right.equalize();
+    const weight = top_left_weight + bottom_right_weight;
+
+    // Ratio of top_left weight to overall weight, which gives the split ratio
+    const ratio = top_left_weight / weight;
+
+    // Convert split ratio into new position for divider
+    self.paned.setPosition(@intFromFloat(self.maxPosition() * ratio));
+
+    return weight;
+}
+
+// maxPosition returns the maximum position of the GtkPaned, which is the
+// "max-position" attribute.
+fn maxPosition(self: *Split) f64 {
+    var value: gobject.Value = std.mem.zeroes(gobject.Value);
+    defer value.unset();
+
+    _ = value.init(gobject.ext.types.int);
+    self.paned.as(gobject.Object).getProperty(
+        "max-position",
+        &value,
+    );
+
+    return @floatFromInt(value.getInt());
+}
+
 pub fn grabFocus(self: *Split) void {
     self.top_left.grabFocus();
 }
@@ -411,7 +408,6 @@         // From the bottom right is more compliated. It is the deepest
         // (last) surface in the
         .bottom_right => {
-            // If we have no parent split then there can be no next.
             const parent = self.container.split() orelse return .{
                 .surface = self.top_left.deepestSurface(.top_left) orelse return null,
                 .wrapped = true,
@@ -438,4 +434,18 @@ fn removeChildren(self: *const Split) void {
     self.detachTopLeft();
     self.detachBottomRight();
+}
+
+/// Get the most deeply nested surface for a given side.
+fn deepestSurface(self: *const Split, side: Side) ?*Surface {
+    return switch (side) {
+        .bottom_right => switch (self.bottom_right) {
+            .surface => |s| s,
+            .split => |s| s.deepestSurface(.bottom_right),
+        },
+        .top_left => switch (self.top_left) {
+            .surface => |s| s,
+            .split => |s| s.deepestSurface(.top_left),
+        },
+    };
 }