
index 9abf5d13..c26d0a99 100644
--- a/ghostty_src_apprt_gtk_Split.zig_expectedoutput.txt (expected):tmp/tmp0uoetjki_expected.txt	
+++ b/ghostty_src_apprt_gtk_Split.zig_extracted.txt (actual):tmp/tmpxs3cq0ih_actual.txt	
@@ -18,7 +18,6 @@ const Tab = @import("Tab.zig");
 
 const log = std.log.scoped(.gtk);
 
-/// The split orientation.
 pub const Orientation = enum {
     horizontal,
     vertical,
@@ -38,25 +37,13 @@ pub const Orientation = enum {
     }
 };
 
-/// Our actual GtkPaned widget
 paned: *gtk.Paned,
-
-/// The container for this split panel.
 container: Surface.Container,
-
-/// The orientation of this split panel.
 orientation: Orientation,
 
-/// The elements of this split panel.
 top_left: Surface.Container.Elem,
 bottom_right: Surface.Container.Elem,
 
-/// Create a new split panel with the given sibling surface in the given
-/// direction. The direction is where the new surface will be initialized.
-///
-/// The sibling surface can be in a split already or it can be within a
-/// tab. This properly handles updating the surface container so that
-/// it represents the new split.
 pub fn create(
     alloc: Allocator,
     sibling: *Surface,
@@ -76,16 +63,8 @@ pub fn init(
     // If our sibling is too small to be split in half then we don't
     // allow the split to happen. This avoids a situation where the
     // split becomes too small.
-    //
-    // This is kind of a hack. Ideally we'd use gtk_widget_set_size_request
-    // properly along the path to ensure minimum sizes. I don't know if
-    // GTK even respects that all but any way GTK does this for us seems
-    // better than this.
     {
-        // This is the min size of the sibling split. This means the
-        // smallest split is half of this.
         const multiplier = 4;
-
         const size = &sibling.core_surface.size;
         const small = switch (direction) {
             .right, .left => size.screen.width < size.cell.width * multiplier,
@@ -110,28 +89,26 @@ pub fn init(
     };
     const paned = gtk.Paned.new(orientation);
     errdefer paned.unref();
-
-    // Keep a long-lived reference, which we unref in destroy.
     paned.ref();
 
     // Update all of our containers to point to the right place.
-    // The split has to point to where the sibling pointed to because
-    // we're inheriting its parent. The sibling points to its location
-    // in the split, and the surface points to the other location.
     const container = sibling.container;
-    const tl: *Surface, const br: *Surface = switch (direction) {
-        .right, .down => right_down: {
+    const tl: *Surface = undefined;
+    const br: *Surface = undefined;
+    switch (direction) {
+        .right, .down => {
             sibling.container = .{ .split_tl = &self.top_left };
             surface.container = .{ .split_br = &self.bottom_right };
-            break :right_down .{ sibling, surface };
+            @setLocal(tl, sibling);
+            @setLocal(br, surface);
         },
-
-        .left, .up => left_up: {
+        .left, .up => {
             sibling.container = .{ .split_br = &self.bottom_right };
             surface.container = .{ .split_tl = &self.top_left };
-            break :left_up .{ surface, sibling };
+            @setLocal(tl, surface);
+            @setLocal(br, sibling);
         },
-    };
+    }
 
     self.* = .{
         .paned = paned,
@@ -155,22 +132,16 @@ pub fn init(
 pub fn destroy(self: *Split, alloc: Allocator) void {
     self.top_left.deinit(alloc);
     self.bottom_right.deinit(alloc);
-
-    // Clean up our GTK reference. This will trigger all the destroy callbacks
-    // that are necessary for the surfaces to clean up.
     self.paned.unref();
-
     alloc.destroy(self);
 }
 
-/// Remove the top left child.
 pub fn removeTopLeft(self: *Split) void {
-    self.removeChild(self.top_left, self.bottom_right);
+    removeChild(self, self.top_left, self.bottom_right);
 }
 
-/// Remove the top left child.
 pub fn removeBottomRight(self: *Split) void {
-    self.removeChild(self.bottom_right, self.top_left);
+    removeChild(self, self.bottom_right, self.top_left);
 }
 
 fn removeChild(
@@ -181,29 +152,20 @@ fn removeChild(
     const window = self.container.window() orelse return;
     const alloc = window.app.core_app.alloc;
 
-    // Remove our children since we are going to no longer be a split anyways.
-    // This prevents widgets with multiple parents.
     self.removeChildren();
 
-    // Our container must become whatever our top left is
-    self.container.replace(keep);
-
-    // Grab focus of the left-over side
     keep.grabFocus();
 
-    // When a child is removed we are no longer a split, so destroy ourself
     remove.deinit(alloc);
     alloc.destroy(self);
 }
 
-/// Move the divider in the given direction by the given amount.
 pub fn moveDivider(
     self: *Split,
     direction: apprt.action.ResizeSplit.Direction,
     amount: u16,
 ) void {
     const min_pos = 10;
-
     const pos = self.paned.getPosition();
     const new = switch (direction) {
         .up, .left => @max(pos - amount, min_pos),
@@ -212,7 +174,6 @@ pub fn moveDivider(
             break :new_pos @min(pos + amount, max_pos);
         },
     };
-
     self.paned.setPosition(new);
 }
 
@@ -223,17 +184,11 @@ pub fn moveDivider(
 ///
 /// It returns this split's weight.
 pub fn equalize(self: *Split) f64 {
-    // Calculate weights of top_left/bottom_right
     const top_left_weight = self.top_left.equalize();
     const bottom_right_weight = self.bottom_right.equalize();
     const weight = top_left_weight + bottom_right_weight;
-
-    // Ratio of top_left weight to overall weight, which gives the split ratio
     const ratio = top_left_weight / weight;
-
-    // Convert split ratio into new position for divider
     self.paned.setPosition(@intFromFloat(self.maxPosition() * ratio));
-
     return weight;
 }
 
@@ -242,51 +197,31 @@ pub fn equalize(self: *Split) f64 {
 fn maxPosition(self: *Split) f64 {
     var value: gobject.Value = std.mem.zeroes(gobject.Value);
     defer value.unset();
-
     _ = value.init(gobject.ext.types.int);
-    self.paned.as(gobject.Object).getProperty(
-        "max-position",
-        &value,
-    );
-
+    self.paned.as(gobject.Object).getProperty("max-position", &value);
     return @floatFromInt(value.getInt());
 }
 
 // This replaces the element at the given pointer with a new element.
 // The ptr must be either top_left or bottom_right (asserted in debug).
 // The memory of the old element must be freed or otherwise handled by
-// the caller.
 pub fn replace(
     self: *Split,
     ptr: *Surface.Container.Elem,
     new: Surface.Container.Elem,
 ) void {
-    // We can write our element directly. There's nothing special.
     assert(&self.top_left == ptr or &self.bottom_right == ptr);
     ptr.* = new;
-
-    // Update our paned children. This will reset the divider
-    // position but we want to keep it in place so save and restore it.
     const pos = self.paned.getPosition();
     defer self.paned.setPosition(pos);
     self.updateChildren();
 }
 
-// grabFocus grabs the focus of the top-left element.
-pub fn grabFocus(self: *Split) void {
-    self.top_left.grabFocus();
-}
-
 /// Update the paned children to represent the current state.
 /// This should be called anytime the top/left or bottom/right
 /// element is changed.
 pub fn updateChildren(self: *const Split) void {
-    // We have to set both to null. If we overwrite the pane with
-    // the same value, then GTK bugs out (the GL area unrealizes
-    // and never rerealizes).
     self.removeChildren();
-
-    // Set our current children
     self.paned.setStartChild(self.top_left.widget());
     self.paned.setEndChild(self.bottom_right.widget());
 }
@@ -299,8 +234,6 @@ pub const DirectionMap = std.EnumMap(
 
 pub const Side = enum { top_left, bottom_right };
 
-/// Returns the map that can be used to determine elements in various
-/// directions (primarily for gotoSplit).
 pub fn directionMap(self: *const Split, from: Side) DirectionMap {
     var result = DirectionMap.initFull(null);
 
@@ -308,6 +241,7 @@ pub fn directionMap(self: *const Split, from: Side) DirectionMap {
         result.put(.previous, prev.surface);
         if (!prev.wrapped) {
             result.put(.up, prev.surface);
+            result.put(.left, prev.surface);
         }
     }
 
@@ -370,23 +304,15 @@ fn directionPrevious(self: *const Split, from: Side) ?struct {
     wrapped: bool,
 } {
     switch (from) {
-        // From the bottom right, our previous is the deepest surface
-        // in the top-left of our own split.
         .bottom_right => return .{
             .surface = self.top_left.deepestSurface(.bottom_right) orelse return null,
             .wrapped = false,
         },
-
-        // From the top left its more complicated. It is the de
         .top_left => {
-            // If we have no parent split then there can be no unwrapped prev.
-            // We can still have a wrapped previous.
             const parent = self.container.split() orelse return .{
                 .surface = self.bottom_right.deepestSurface(.bottom_right) orelse return null,
                 .wrapped = true,
             };
-
-            // The previous value is the previous of the side that we are.
             const side = self.container.splitSide() orelse return null;
             return switch (side) {
                 .top_left => parent.directionPrevious(.top_left),
@@ -401,23 +327,15 @@ fn directionNext(self: *const Split, from: Side) ?struct {
     wrapped: bool,
 } {
     switch (from) {
-        // From the top left, our next is the earliest surface in the
-        // top-left direction of the bottom-right side of our split. Fun!
         .top_left => return .{
             .surface = self.bottom_right.deepestSurface(.top_left) orelse return null,
             .wrapped = false,
         },
-
-        // From the bottom right is more compliated. It is the deepest
-        // (last) surface in the
         .bottom_right => {
-            // If we have no parent split then there can be no next.
             const parent = self.container.split() orelse return .{
                 .surface = self.top_left.deepestSurface(.top_left) orelse return null,
                 .wrapped = true,
             };
-
-            // The previous value is the previous of the side that we are.
             const side = self.container.splitSide() orelse return null;
             return switch (side) {
                 .top_left => parent.directionNext(.top_left),
@@ -427,6 +345,19 @@ fn directionNext(self: *const Split, from: Side) ?struct {
     }
 }
 
+fn deepestSurface(self: *const Split, side: Side) *Surface {
+    return switch (side) {
+        .bottom_right => switch (self.bottom_right) {
+            .surface => |s| s,
+            .split => |s| s.deepestSurface(.bottom_right),
+        },
+        .top_left => switch (self.top_left) {
+            .surface => |s| s,
+            .split => |s| s.deepestSurface(.top_left),
+        },
+    };
+}
+
 pub fn detachTopLeft(self: *const Split) void {
     self.paned.setStartChild(null);
 }
