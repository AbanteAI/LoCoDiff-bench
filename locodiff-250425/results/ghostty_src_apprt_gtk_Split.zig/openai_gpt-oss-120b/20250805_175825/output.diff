
index 9abf5d134..935814c38 100644
--- a/ghostty_src_apprt_gtk_Split.zig_expectedoutput.txt (expected):tmp/tmprjx7htqc_expected.txt	
+++ b/ghostty_src_apprt_gtk_Split.zig_extracted.txt (actual):tmp/tmpu6ky811x_actual.txt	
@@ -1,7 +1,4 @@
-/// Split represents a surface split where two surfaces are shown side-by-side
-/// within the same window either vertically or horizontally.
 const Split = @This();
-
 const std = @import("std");
 const Allocator = std.mem.Allocator;
 const assert = std.debug.assert;
@@ -9,7 +6,7 @@ const assert = std.debug.assert;
 const gobject = @import("gobject");
 const gtk = @import("gtk");
 
-const apprt = @import("../../apprt.zig");
+const appr = @import("../../apprt.zig");
 const font = @import("../../font/main.zig");
 const CoreSurface = @import("../../Surface.zig");
 
@@ -23,14 +20,14 @@ pub const Orientation = enum {
     horizontal,
     vertical,
 
-    pub fn fromDirection(direction: apprt.action.SplitDirection) Orientation {
+    pub fn fromDirection(direction: appr.action.SplitDirection) Orientation {
         return switch (direction) {
             .right, .left => .horizontal,
             .down, .up => .vertical,
         };
     }
 
-    pub fn fromResizeDirection(direction: apprt.action.ResizeSplit.Direction) Orientation {
+    pub fn fromResizeDirection(direction: appr.action.ResizeSplit.Direction) Orientation {
         return switch (direction) {
             .up, .down => .vertical,
             .left, .right => .horizontal,
@@ -38,7 +35,7 @@ pub const Orientation = enum {
     }
 };
 
-/// Our actual GtkPaned widget
+/// Our actual GtkPaned widget.
 paned: *gtk.Paned,
 
 /// The container for this split panel.
@@ -51,16 +48,11 @@ orientation: Orientation,
 top_left: Surface.Container.Elem,
 bottom_right: Surface.Container.Elem,
 
-/// Create a new split panel with the given sibling surface in the given
-/// direction. The direction is where the new surface will be initialized.
-///
-/// The sibling surface can be in a split already or it can be within a
-/// tab. This properly handles updating the surface container so that
-/// it represents the new split.
+/// Create a new split panel.
 pub fn create(
     alloc: Allocator,
     sibling: *Surface,
-    direction: apprt.action.SplitDirection,
+    direction: appr.action.SplitDirection,
 ) !*Split {
     var split = try alloc.create(Split);
     errdefer alloc.destroy(split);
@@ -71,21 +63,11 @@ pub fn create(
 pub fn init(
     self: *Split,
     sibling: *Surface,
-    direction: apprt.action.SplitDirection,
+    direction: appr.action.SplitDirection,
 ) !void {
-    // If our sibling is too small to be split in half then we don't
-    // allow the split to happen. This avoids a situation where the
-    // split becomes too small.
-    //
-    // This is kind of a hack. Ideally we'd use gtk_widget_set_size_request
-    // properly along the path to ensure minimum sizes. I don't know if
-    // GTK even respects that all but any way GTK does this for us seems
-    // better than this.
+    // If our sibling is too small to be split in half we prevent the split.
     {
-        // This is the min size of the sibling split. This means the
-        // smallest split is half of this.
         const multiplier = 4;
-
         const size = &sibling.core_surface.size;
         const small = switch (direction) {
             .right, .left => size.screen.width < size.cell.width * multiplier,
@@ -94,7 +76,7 @@ pub fn init(
         if (small) return error.SplitTooSmall;
     }
 
-    // Create the new child surface for the other direction.
+    // Create the new child surface.
     const alloc = sibling.app.core_app.alloc;
     var surface = try Surface.create(alloc, sibling.app, .{
         .parent = &sibling.core_surface,
@@ -102,8 +84,9 @@ pub fn init(
     errdefer surface.destroy(alloc);
     sibling.dimSurface();
     sibling.setSplitZoom(false);
+    sibling.setSplitZoom(false);
 
-    // Create the actual GTKPaned, attach the proper children.
+    // Create the actual GtkPaned widget.
     const orientation: gtk.Orientation = switch (direction) {
         .right, .left => .horizontal,
         .down, .up => .vertical,
@@ -114,11 +97,7 @@ pub fn init(
     // Keep a long-lived reference, which we unref in destroy.
     paned.ref();
 
-    // Update all of our containers to point to the right place.
-    // The split has to point to where the sibling pointed to because
-    // we're inheriting its parent. The sibling points to its location
-    // in the split, and the surface points to the other location.
-    const container = sibling.container;
+    // Determine the top/left and bottom/right elements.
     const tl: *Surface, const br: *Surface = switch (direction) {
         .right, .down => right_down: {
             sibling.container = .{ .split_tl = &self.top_left };
@@ -135,20 +114,19 @@ pub fn init(
 
     self.* = .{
         .paned = paned,
-        .container = container,
+        .container = self.container,
         .top_left = .{ .surface = tl },
         .bottom_right = .{ .surface = br },
         .orientation = Orientation.fromDirection(direction),
     };
 
-    // Replace the previous containers element with our split. This allows a
-    // non-split to become a split, a split to become a nested split, etc.
-    container.replace(.{ .split = self });
+    // Replace the previous container's element with this split.
+    self.container.replace(.{ .split = self });
 
-    // Update our children so that our GL area is properly added to the paned.
+    // Update children so GL areas are correctly attached.
     self.updateChildren();
 
-    // The new surface should always grab focus
+    // Focus the new surface.
     surface.grabFocus();
 }
 
@@ -156,23 +134,13 @@ pub fn destroy(self: *Split, alloc: Allocator) void {
     self.top_left.deinit(alloc);
     self.bottom_right.deinit(alloc);
 
-    // Clean up our GTK reference. This will trigger all the destroy callbacks
-    // that are necessary for the surfaces to clean up.
+    // Clean up our GTK reference. This triggers destroy callbacks.
     self.paned.unref();
 
     alloc.destroy(self);
 }
 
-/// Remove the top left child.
-pub fn removeTopLeft(self: *Split) void {
-    self.removeChild(self.top_left, self.bottom_right);
-}
-
-/// Remove the top left child.
-pub fn removeBottomRight(self: *Split) void {
-    self.removeChild(self.bottom_right, self.top_left);
-}
-
+// Remove a child element, making this split a regular container.
 fn removeChild(
     self: *Split,
     remove: Surface.Container.Elem,
@@ -181,29 +149,27 @@ fn removeChild(
     const window = self.container.window() orelse return;
     const alloc = window.app.core_app.alloc;
 
-    // Remove our children since we are going to no longer be a split anyways.
-    // This prevents widgets with multiple parents.
+    // Remove our children since we no longer are a split.
     self.removeChildren();
 
-    // Our container must become whatever our top left is
+    // Our container now points at the remaining element.
     self.container.replace(keep);
 
-    // Grab focus of the left-over side
+    // Focus the remaining side.
     keep.grabFocus();
 
-    // When a child is removed we are no longer a split, so destroy ourself
+    // When a child is removed we are no longer a split.
     remove.deinit(alloc);
     alloc.destroy(self);
 }
 
-/// Move the divider in the given direction by the given amount.
+// Move the divider in the given direction by the given amount.
 pub fn moveDivider(
     self: *Split,
-    direction: apprt.action.ResizeSplit.Direction,
+    direction: appr.action.ResizeSplit.Direction,
     amount: u16,
 ) void {
     const min_pos = 10;
-
     const pos = self.paned.getPosition();
     const new = switch (direction) {
         .up, .left => @max(pos - amount, min_pos),
@@ -212,95 +178,59 @@ pub fn moveDivider(
             break :new_pos @min(pos + amount, max_pos);
         },
     };
-
     self.paned.setPosition(new);
 }
 
-/// Equalize the splits in this split panel. Each split is equalized based on
-/// its weight, i.e. the number of Surfaces it contains.
-///
-/// It works recursively by equalizing the children of each split.
-///
-/// It returns this split's weight.
+// Equalize splits based on weight.
 pub fn equalize(self: *Split) f64 {
-    // Calculate weights of top_left/bottom_right
+    // Compute weights of child elements.
     const top_left_weight = self.top_left.equalize();
     const bottom_right_weight = self.bottom_right.equalize();
     const weight = top_left_weight + bottom_right_weight;
-
-    // Ratio of top_left weight to overall weight, which gives the split ratio
     const ratio = top_left_weight / weight;
 
-    // Convert split ratio into new position for divider
+    // Set divider position based on weight ratio.
     self.paned.setPosition(@intFromFloat(self.maxPosition() * ratio));
 
     return weight;
 }
 
-// maxPosition returns the maximum position of the GtkPaned, which is the
-// "max-position" attribute.
+// Returns the max position of the GtkPaned ("max-position" property).
 fn maxPosition(self: *Split) f64 {
     var value: gobject.Value = std.mem.zeroes(gobject.Value);
     defer value.unset();
 
     _ = value.init(gobject.ext.types.int);
-    self.paned.as(gobject.Object).getProperty(
-        "max-position",
-        &value,
-    );
-
+    self.paned.as(gobject.Object).getProperty("max-position", &value);
     return @floatFromInt(value.getInt());
 }
 
-// This replaces the element at the given pointer with a new element.
-// The ptr must be either top_left or bottom_right (asserted in debug).
-// The memory of the old element must be freed or otherwise handled by
-// the caller.
+// Replace an element at the given pointer.
 pub fn replace(
     self: *Split,
     ptr: *Surface.Container.Elem,
     new: Surface.Container.Elem,
 ) void {
-    // We can write our element directly. There's nothing special.
-    assert(&self.top_left == ptr or &self.bottom_right == ptr);
-    ptr.* = new;
-
-    // Update our paned children. This will reset the divider
-    // position but we want to keep it in place so save and restore it.
-    const pos = self.paned.getPosition();
-    defer self.paned.setPosition(pos);
+    const saved = self.paned.getPosition();
+    defer self.paned.setPosition(saved);
+    *ptr = new;
     self.updateChildren();
 }
 
-// grabFocus grabs the focus of the top-left element.
-pub fn grabFocus(self: *Split) void {
-    self.top_left.grabFocus();
-}
-
-/// Update the paned children to represent the current state.
-/// This should be called anytime the top/left or bottom/right
-/// element is changed.
+// Update children widgets.
 pub fn updateChildren(self: *const Split) void {
-    // We have to set both to null. If we overwrite the pane with
-    // the same value, then GTK bugs out (the GL area unrealizes
-    // and never rerealizes).
     self.removeChildren();
-
-    // Set our current children
     self.paned.setStartChild(self.top_left.widget());
     self.paned.setEndChild(self.bottom_right.widget());
 }
 
-/// A mapping of direction to the element (if any) in that direction.
+// Mapping of directions to elements.
 pub const DirectionMap = std.EnumMap(
-    apprt.action.GotoSplit,
+    appr.action.GotoSplit,
     ?*Surface,
 );
 
-pub const Side = enum { top_left, bottom_right };
-
-/// Returns the map that can be used to determine elements in various
-/// directions (primarily for gotoSplit).
+// Map of directional navigation.
 pub fn directionMap(self: *const Split, from: Side) DirectionMap {
     var result = DirectionMap.initFull(null);
 
@@ -308,6 +238,7 @@ pub fn directionMap(self: *const Split, from: Side) DirectionMap {
         result.put(.previous, prev.surface);
         if (!prev.wrapped) {
             result.put(.up, prev.surface);
+            result.put(.left, prev.surface);
         }
     }
 
@@ -315,8 +246,9 @@ pub fn directionMap(self: *const Split, from: Side) DirectionMap {
         result.put(.next, next.surface);
         if (!next.wrapped) {
             result.put(.down, next.surface);
+                result.put(.right, next.surface);
+            }
         }
-    }
 
     if (self.directionLeft(from)) |left| {
         result.put(.left, left);
@@ -329,113 +261,84 @@ pub fn directionMap(self: *const Split, from: Side) DirectionMap {
     return result;
 }
 
-fn directionLeft(self: *const Split, from: Side) ?*Surface {
-    switch (from) {
-        .bottom_right => {
-            switch (self.orientation) {
-                .horizontal => return self.top_left.deepestSurface(.bottom_right),
-                .vertical => return directionLeft(
-                    self.container.split() orelse return null,
-                    .bottom_right,
-                ),
-            }
-        },
-        .top_left => return directionLeft(
-            self.container.split() orelse return null,
-            .bottom_right,
-        ),
-    }
-}
-
-fn directionRight(self: *const Split, from: Side) ?*Surface {
-    switch (from) {
-        .top_left => {
-            switch (self.orientation) {
-                .horizontal => return self.bottom_right.deepestSurface(.top_left),
-                .vertical => return directionRight(
-                    self.container.split() orelse return null,
-                    .top_left,
-                ),
-            }
-        },
-        .bottom_right => return directionRight(
-            self.container.split() orelse return null,
-            .top_left,
-        ),
-    }
-}
-
+// Navigation: previous.
 fn directionPrevious(self: *const Split, from: Side) ?struct {
     surface: *Surface,
     wrapped: bool,
 } {
     switch (from) {
-        // From the bottom right, our previous is the deepest surface
-        // in the top-left of our own split.
-        .bottom_right => return .{
-            .surface = self.top_left.deepestSurface(.bottom_right) orelse return null,
-            .wrapped = false,
-        },
+        // From bottom right, previous is deepest surface in top left.
+        .bottom_right => return .{ .surface = self.top_left.deepestSurface(.bottom_right).?, .wrapped = false },
 
-        // From the top left its more complicated. It is the de
         .top_left => {
-            // If we have no parent split then there can be no unwrapped prev.
-            // We can still have a wrapped previous.
             const parent = self.container.split() orelse return .{
                 .surface = self.bottom_right.deepestSurface(.bottom_right) orelse return null,
-                .wrapped = true,
-            };
-
-            // The previous value is the previous of the side that we are.
-            const side = self.container.splitSide() orelse return null;
-            return switch (side) {
-                .top_left => parent.directionPrevious(.top_left),
-                .bottom_right => parent.directionPrevious(.bottom_right),
-            };
-        },
+                        .wrapped = true,
+                    };
+                const side = self.container.splitSide() orelse return null;
+                return switch (side) {
+                    .top_left => parent.directionPrevious(.top_left),
+                    .bottom_right => parent.directionPrevious(.bottom_right),
+                };
+            }
     }
 }
 
+// Navigation: next.
 fn directionNext(self: *const Split, from: Side) ?struct {
     surface: *Surface,
     wrapped: bool,
 } {
     switch (from) {
-        // From the top left, our next is the earliest surface in the
-        // top-left direction of the bottom-right side of our split. Fun!
-        .top_left => return .{
-            .surface = self.bottom_right.deepestSurface(.top_left) orelse return null,
-            .wrapped = false,
-        },
+        // From top left, next is deepest surface in bottom right.
+        .top_left => return .{ .surface = self.bottom_right.deepestSurface(.top_left) orelse return null, .wrapped = false },
 
-        // From the bottom right is more compliated. It is the deepest
-        // (last) surface in the
         .bottom_right => {
-            // If we have no parent split then there can be no next.
             const parent = self.container.split() orelse return .{
-                .surface = self.top_left.deepestSurface(.top_left) orelse return null,
-                .wrapped = true,
-            };
-
-            // The previous value is the previous of the side that we are.
-            const side = self.container.splitSide() orelse return null;
-            return switch (side) {
-                .top_left => parent.directionNext(.top_left),
-                .bottom_right => parent.directionNext(.bottom_right),
-            };
+                    .surface = self.top_left.deepestSurface(.top_left) orelse return null,
+                    .wrapped = true,
+                };
+                const side = self.container.splitSide() orelse return null;
+                return switch (side) {
+                    .top_left => parent.directionNext(.bottom_right),
+                    .bottom_right => parent.directionNext(.bottom_right),
+                };
+            }
+    }
+}
+
+// Horizontal navigation: left.
+fn directionLeft(self: *const Split, from: Side) ?*Surface {
+    switch (from) {
+        .bottom_right => switch (self.orientation) {
+            .horizontal => return self.top_left.deepestSurface(.bottom_right),
+            .vertical => self.container.split().?.directionLeft(.top_left),
         },
+        .top_left => self.container.split()?.directionLeft(.bottom_right),
     }
 }
 
+// Horizontal navigation: right.
+fn directionRight(self: *const Split, from: Side) ?*Surface {
+    switch (from) {
+        .top_left => switch (self.orientation) {
+            .horizontal => return self.bottom_right.deepestSurface(.top_left),
+            .vertical => self.container.split().?.directionRight(.bottom_right),
+        },
+        .bottom_right => self.split()?.directionRight(.top_left),
+    }
+}
+
+// Helper: detach children.
 pub fn detachTopLeft(self: *const Split) void {
     self.paned.setStartChild(null);
 }
-
 pub fn detachBottomRight(self: *const Split) void {
     self.paned.setEndChild(null);
 }
 
+// Remove children from the GtkPaned.
 fn removeChildren(self: *const Split) void {
-    self.detachTopLeft();
-    self.detachBottomRight();
+    self.paned.setStartChild(null);
+    self.paned.setEndChild(null);
 }
\ No newline at end of file
