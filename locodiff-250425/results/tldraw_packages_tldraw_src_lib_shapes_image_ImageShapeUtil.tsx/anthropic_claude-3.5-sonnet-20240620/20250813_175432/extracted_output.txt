export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
  static override type = 'image' as const
  static override props = imageShapeProps
  static override migrations = imageShapeMigrations

  override isAspectRatioLocked() {
    return true
  }
  override canCrop() {
    return true
  }

  override getDefaultProps(): TLImageShape['props'] {
    return {
      w: 100,
      h: 100,
      assetId: null,
      playing: true,
      url: '',
      crop: null,
      flipX: false, 
      flipY: false,
      altText: '',
    }
  }

  override getAriaDescriptor(shape: TLImageShape) {
    return shape.props.altText
  }

  override onResize(shape: TLImageShape, info: TLResizeInfo<TLImageShape>) {
    let resized: TLImageShape = resizeBox(shape, info)
    const { flipX, flipY } = info.initialShape.props
    const { scaleX, scaleY, mode } = info

    resized = {
      ...resized,
      props: {
        ...resized.props,
        flipX: scaleX < 0 !== flipX,
        flipY: scaleY < 0 !== flipY,
      },
    }
    if (!shape.props.crop) return resized

    const flipCropHorizontally =
      (mode === 'scale_shape' && scaleX === -1) ||
      (mode === 'resize_bounds' && flipX !== resized.props.flipX)
    const flipCropVertically =
      (mode === 'scale_shape' && scaleY === -1) ||
      (mode === 'resize_bounds' && flipY !== resized.props.flipY)

    const { topLeft, bottomRight } = shape.props.crop
    resized.props.crop = {
      topLeft: {
        x: flipCropHorizontally ? 1 - bottomRight.x : topLeft.x,
        y: flipCropVertically ? 1 - bottomRight.y : topLeft.y,
      },
      bottomRight: {
        x: flipCropHorizontally ? 1 - topLeft.x : bottomRight.x,
        y: flipCropVertically ? 1 - topLeft.y : bottomRight.y,
      },
    }
    return resized
  }

  component(shape: TLImageShape) {
    return <ImageShape shape={shape} />
  }

  indicator(shape: TLImageShape) {
    const isCropping = this.editor.getCroppingShapeId() === shape.id
    if (isCropping) return null
    return <rect width={toDomPrecision(shape.props.w)} height={toDomPrecision(shape.props.h)} />
  }

  override async toSvg(shape: TLImageShape, ctx: SvgExportContext) {
    if (!shape.props.assetId) return null

    const asset = this.editor.getAsset(shape.props.assetId)

    if (!asset) return null

    const { w } = getUncroppedSize(shape.props, shape.props.crop)

    const src = await imageSvgExportCache.get(asset, async () => {
      let src = await ctx.resolveAssetUrl(asset.id, w)
      if (!src) return null
      if (
        src.startsWith('blob:') ||
        src.startsWith('http') ||
        src.startsWith('/') ||
        src.startsWith('./')
      ) {
        src = (await getDataURIFromURL(src)) || ''
      }

      if (getIsAnimated(this.editor, asset.id)) {
        const { promise } = getFirstFrameOfAnimatedImage(src)
        src = await promise
      }
      return src
    })

    if (!src) return null

    return <SvgImage shape={shape} src={src} />
  }

  override onDoubleClickEdge(shape: TLImageShape) {
    const props = shape.props
    if (!props) return

    if (this.editor.getCroppingShapeId() !== shape.id) {
      return
    }

    const crop = structuredClone(props.crop) || {
      topLeft: { x: 0, y: 0 },
      bottomRight: { x: 1, y: 1 },
    }

    const { w, h } = getUncroppedSize(shape.props, crop)

    const pointDelta = new Vec(crop.topLeft.x * w, crop.topLeft.y * h).rot(shape.rotation)

    const partial: TLShapePartial<TLImageShape> = {
      id: shape.id,
      type: shape.type,
      x: shape.x - pointDelta.x,
      y: shape.y - pointDelta.y,
      props: {
        crop: {
          topLeft: { x: 0, y: 0 },
          bottomRight: { x: 1, y: 1 },
        },
        w,
        h,
      },
    }

    this.editor.updateShapes([partial])
  }

  override getInterpolatedProps(
    startShape: TLImageShape,
    endShape: TLImageShape,
    t: number
  ): TLImageShapeProps {
    function interpolateCrop(
      startShape: TLImageShape,
      endShape: TLImageShape
    ): TLImageShapeProps['crop'] {
      if (startShape.props.crop === null && endShape.props.crop === null) return null

      const startTL = startShape.props.crop?.topLeft || { x: 0, y: 0 }
      const startBR = startShape.props.crop?.bottomRight || { x: 1, y: 1 }
      const endTL = endShape.props.crop?.topLeft || { x: 0, y: 0 }
      const endBR = endShape.props.crop?.bottomRight || { x: 1, y: 1 }

      return {
        topLeft: { x: lerp(startTL.x, endTL.x, t), y: lerp(startTL.y, endTL.y, t) },
        bottomRight: { x: lerp(startBR.x, endBR.x, t), y: lerp(startBR.y, endBR.y, t) },
      }
    }

    return {
      ...(t > 0.5 ? endShape.props : startShape.props),
      w: lerp(startShape.props.w, endShape.props.w, t),
      h: lerp(startShape.props.h, endShape.props.h, t),
      crop: interpolateCrop(startShape, endShape),
    }
  }
}