/* eslint-disable react-hooks/rules-of-hooks */
import {
	BaseBoxShapeUtil,
	Editor,
	FileHelpers,
	HTMLContainer,
	Image,
	MediaHelpers,
	SvgExportContext,
	TAAsset,
	TLAssetId,
	TLImageShape,
	TLImageShapeProps,
	TLResizeInfo,
	TLShapePartial,
	Vec,
	fetch,
	imageShapeMigrations,
	imageShapeProps,
	lerp,
	resizeBox,
	structuredClone,
	toDomPrecision,
	useEditor,
	useUniqueSafeId,
	useValue,
	WeakCache,
} from '@tldraw/editor'
import classNames from 'classnames'
import { memo, useEffect, useState } from 'react'
import { BrokenAssetIcon } from '../shared/BrokenAssetIcon'
import { HyperlinkButton } from '../shared/HyperlinkButton'
import { getUncroppedSize } from '../shared/crop'
import { useImageOrVideoAsset } from '../shared/useImageOrVideoAsset'
import { usePrefersReducedMotion } from '../shared/usePrefersReducedMotion'

async function getDataURIFromURL(url: string): Promise<string> {
	const response = await fetch(url)
	const blob = await response.blob()
	return FileHelpers.blobToDataUrl(blob)
}

const imageSvgExportCache = new WeakCache<TLAsset, Promise<string | null>>()

/** @public */
export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
	static override type = 'image' as const
	static override props = imageShapeProps
	static override migrations = imageShapeMigrations

	override isAspectRatioLocked() {
		return true
	}
	override canCrop() {
		return true
	}

	override getDefaultProps(): TLImageShape['props'] {
		return {
			w: 100,
			h: 100,
			assetId: null,
			playing: true,
			url: '',
			crop: null,
			flipX: false,
			flipY: false,
			altText: '',
		}
	}

	override getAriaDescriptor(shape: TLImageShape) {
		return shape.props.altText
	}

	override onResize(shape: TLImageShape, info: TLResizeInfo<TLImageShape>) {
		let resized: TLImageShape = resizeBox(shape, info)
		const { flipX, flipY } = info.initialShape.props
		const { scaleX, scaleY, mode } = info

		resized = {
			...resized,
			props: {
				...resized.props,
				flipX: scaleX < 0 !== flipX,
				flipY: scaleY < 0 !== flipY,
			},
		}

		if (!shape.props.crop) return resized

		const flipCropHorizontally =
			// Used the flip horizontally feature
			(mode === 'scale_shape' && scaleX === -1) ||
			// Resized past bounds, causing flip
			(mode === 'resize_bounds' && flipX !== resized.props.flipX)
		const flipCropVertically =
			(mode === 'scale_shape' && scaleY === -1) ||
			(mode === 'resize_bounds' && flipY !== resized.props.flipY)

		const { topLeft, bottomRight } = shape.props.crop
		resized.props.crop = {
			topLeft: {
				x: flipCropHorizontally ? 1 - bottomRight.x : topLeft.x,
				y: flipCropVertically ? 1 - bottomRight.y : topLeft.y,
			},
			bottomRight: {
				x: flipCropHorizontally ? 1 - topLeft.x : bottomRight.x,
				y: flipCropVertically ? 1 - topLeft.y : bottomRight.y,
			},
		}
		return resized
	}

	override async toSvg(shape: TLImageShape, ctx: SvgExportContext) {
		if (!shape.props.assetId) return null

		const asset = this.editor.getAsset(shape.props.assetId)
		if (!asset) return null

		const { w: uncroppedWidth } = getUncroppedSize(shape.props, shape.props.crop)

		const src = await imageSvgExportCache.get(asset, async () => {
			let src = await ctx.resolveAssetUrl(asset.id, uncroppedWidth)
			if (!src) return null
			if (
				src.startsWith('blob:') ||
				src.startsWith('http') ||
				src.startsWith('/') ||
				src.startsWith('./')
			) {
				// Convert remote image to data URI
				src = (await getDataURIFromURL(src)) || ''
			}
			// If animated, use first frame
			if (getIsAnimated(this.editor, asset.id)) {
				const { promise } = getFirstFrameOfAnimatedImage(src)
				src = await promise
			}
			return src
		})
		if (!src) return null

		return <SvgImage shape={shape} src={src} />
	}

	indicator(shape: TLImageShape) {
		const isCropping = this.editor.getCroppingShapeId() === shape.id
		if (isCropping) return null
		return <rect width={toDomPrecision(shape.props.w)} height={toDomPrecision(shape.props.h)} />
	}

	component(shape: TLImageShape) {
		return <ImageShape shape={shape} />
	}
}

/** React component for rendering the image shape */
const ImageShape = memo(function ImageShape({ shape }: { shape: TLImageShape }) {
	const editor = useEditor()

	const { w: uncroppedW } = getUncroppedSize(shape.props, shape.props.crop)
	const { asset, url } = useImageOrVideoAsset({
		shapeId: shape.id,
		assetId: shape.props.assetId,
		width: uncroppedW,
	})

	const prefersReducedMotion = usePrefersReducedMotion()
	const [staticFrameSrc, setStaticFrameSrc] = useState('')
	const [loadedUrl, setLoadedUrl] = useState<null | string>(null)

	const isAnimated = asset && getIsAnimated(editor, asset.id)

	// Load first frame for animated images
	useEffect(() => {
		if (url && isAnimated) {
			const { promise, cancel } = getFirstFrameOfAnimatedImage(url)
			promise.then((dataUrl) => {
				setStaticFrameSrc(dataUrl)
				setLoadedUrl(url)
			})
			return () => cancel()
		}
	}, [editor, isAnimated, url])

	const showCropPreview = useValue(
		'show crop preview',
		() =>
			shape.id === editor.getOnlySelectedShapeId() &&
			editor.getCroppingShapeId() === shape.id &&
			editor.isIn('select.crop'),
		[editor, shape.id],
	)

	const reduceMotion =
		usePrefersReducedMotion() && (asset?.props.mimeType?.includes('video') || isAnimated)

	const containerStyle = getCroppedContainerStyle(shape)

	const nextSrc = url && url !== loadedUrl ? url : null
	const loadedSrc = reduceMotion ? staticFrameSrc : loadedUrl

	// Render placeholder for missing/broken asset
	if (!url && !asset?.props.src) {
		return (
			<HTMLContainer
				id={shape.id}
				style={{
					overflow: 'hidden',
					width: shape.props.w,
					height: shape.props.h,
					color: 'var(--color-text-3)',
					backgroundColor: 'var(--color-low)',
					border: '1px solid var(--color-low-border)',
				}}
			>
				<div
					className={classNames('tl-image-container', asset && 'tl-image-container-loading')}
					style={containerStyle}
				>
					{asset ? null : <BrokenAssetIcon />}
				</div>
				{shape.props.url && <HyperlinkButton url={shape.props.url} />}
			</HTMLContainer>
		)
	}

	const crossOrigin = isAnimated ? 'anonymous' : undefined

	return (
		<>
			{showCropPreview && loadedSrc && (
				<div style={containerStyle}>
					<img
						className="tl-image"
						style={{ ...getFlipStyle(shape), opacity: 0.1 }}
						crossOrigin={crossOrigin}
						src={loadedSrc}
						referrerPolicy="strict-origin-when-cross-origin"
						draggable={false}
					/>
				</div>
			)}
			<HTMLContainer
				id={shape.id}
				style={{ overflow: 'hidden', width: shape.props.w, height: shape.props.h }}
			>
				<div className={classNames('tl-image-container')} style={containerStyle}>
					{loadedSrc && (
						<img
							key={loadedSrc}
							className="tl-image"
							style={getFlipStyle(shape)}
							crossOrigin={crossOrigin}
							src={loadedSrc}
							referrerPolicy="strict-origin-when-cross-origin"
							draggable={false}
						/>
					)}
					{nextSrc && (
						<img
							key={nextSrc}
							className="tl-image"
							style={getFlipStyle(shape)}
							crossOrigin={crossOrigin}
							src={nextSrc}
							referrerPolicy="strict-origin-when-cross-origin"
							draggable={false}
							onLoad={() => setLoadedUrl(nextSrc)}
						/>
					)}
				</div>
				{shape.props.url && <HyperlinkButton url={shape.props.url} />}
			</HTMLContainer>
		</>
	)
})

function getIsAnimated(editor: Editor, assetId: TLAssetId) {
	const asset = assetId ? editor.getAsset(assetId) : undefined
	if (!asset) return false
	return (
		('mimeType' in (asset as any).props && MediaHelpers.isAnimatedImageType((asset as any).props.mimeType)) ||
		('isAnimated' in (asset as any).props && (asset as any).props.isAnimated
	)
}

/** When an image is cropped we need to translate the image to show the portion within the cropped
 * area. We do this by translating the image by the negative of the top left corner of the
 * crop rectangle.
 */
function getCroppedContainerStyle(shape: TLImageShape) {
	const crop = shape.props.crop
	const topLeft = crop?.topLeft
	if (!topLeft) {
		return {
			width: shape.props.w,
			height: shape.props.h,
			 }
	}
	const w = (1 / (crop.bottomRight.x - crop.topLeft.x)) * shape.props.w
	const h = (1 / (crop.bottomRight.y - crop.topLeft.y)) * shape.props.h
	const offsetX = -topLeft.x * w
	const offsetY = -topLeft.y * h
	return {
		transform: `translate(${offsetX}px, ${offsetY}px)`,
		width: w,
		height: h,
	}
}

/**
 * Returns CSS transform to apply for flipX / flipY
 */
function getFlipStyle(
	shape: TLImageShape,
	size?: { width: number; height: number }
) {
	const { flipX, flipY } = shape.props
	if (!flipX && !flipY) return undefined

	const scale = `scale(${flipX ? -1 : 1}, ${flipY ? -1 : 1})`
	const translate = size ? `translate(${flipX ? size.width : 0}px, ${flipY ? size.height : 0}px)` : ''

	return {
		transform: `${translate} ${scale}`,
		transformOrigin: size ? '0 0' : 'center center',
	}
}

function SvgImage({ shape, src }: { shape: TLImageShape; src: string }) {
	const cropClipId = useUniqueSafeId()
	const containerStyle = getCroppedContainerStyle(shape)
	const crop = shape.props.crop
	if (containerStyle.transform && crop) {
		const { transform: cropTransform, width, height } = containerStyle
		const croppedWidth = (crop.bottomRight.x - crop.topLeft.x) * width
		const croppedHeight = (crop.bottomRight.y - crop.topLeft.y) * height

		const points = [
			new Vec(0, 0),
			new Vec(croppedWidth, 0),
			new Vec(croppedWidth, croppedHeight),
			new Vec(0, croppedHeight),
		]

		const flip = getFlipStyle(shape, { width, height })

		return (
			<>
				<defs>
					<clipPath id={cropClipId}>
						<polygon points={points.map((p) => `${p.x},${p.y}`).join(' ')} />
					</clipPath>
				</defs>
				<g clipPath={`url(#${cropClipId})`}>
					<image
						href={src}
						width={width}
						height={height}
						style={flip ? { ...flip, transform: `${cropTransform} ${flip.transform}` } : { transform: cropTransform }}
					/>
				</g>
			</>
		)
	} else {
		return <image href={src} width={shape.props.w} height={shape.props.h} style={getFlipStyle(shape, { width: shape.props.w, height: shape.props.h })} />
	}
}

/* Helper to get first frame of animated image */
function getFirstFrameOfAnimatedImage(url: string) {
	let cancelled = false
	const image = Image()
	const promise = new Promise<string>((resolve) => {
		image.onload = () => {
			if (cancelled) return
			const canvas = document.createElement('canvas')
			canvas.width = image.width
			canvas.height = image.height
			const ctx = canvas.getContext('2d')
			if (!ctx) return
			ctx.drawImage(image, 0, 0)
			resolve(canvas.toDataURL())
		}
		image.crossOrigin = 'anonymous'
		image.src = url
	})
	return {
		promise,
		cancel: () => (cancelled = true),
	}
}