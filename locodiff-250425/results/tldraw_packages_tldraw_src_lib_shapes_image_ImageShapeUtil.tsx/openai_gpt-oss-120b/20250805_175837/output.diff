
index 2e4a3e7b2..0aa4e0da0 100644
--- a/tldraw_packages_tldraw_src_lib_shapes_image_ImageShapeUtil.tsx_expectedoutput.txt (expected):tmp/tmpw9u88cqg_expected.txt	
+++ b/tldraw_packages_tldraw_src_lib_shapes_image_ImageShapeUtil.tsx_extracted.txt (actual):tmp/tmp8sst5_80_actual.txt	
@@ -1,3 +1,4 @@
+/* eslint-disable react-hooks/rules-of-hooks */
 import {
 	BaseBoxShapeUtil,
 	Editor,
@@ -6,14 +7,13 @@ import {
 	Image,
 	MediaHelpers,
 	SvgExportContext,
-	TLAsset,
+	TAAsset,
 	TLAssetId,
 	TLImageShape,
 	TLImageShapeProps,
 	TLResizeInfo,
 	TLShapePartial,
 	Vec,
-	WeakCache,
 	fetch,
 	imageShapeMigrations,
 	imageShapeProps,
@@ -24,10 +24,10 @@ import {
 	useEditor,
 	useUniqueSafeId,
 	useValue,
+	WeakCache,
 } from '@tldraw/editor'
 import classNames from 'classnames'
 import { memo, useEffect, useState } from 'react'
-
 import { BrokenAssetIcon } from '../shared/BrokenAssetIcon'
 import { HyperlinkButton } from '../shared/HyperlinkButton'
 import { getUncroppedSize } from '../shared/crop'
@@ -86,17 +86,16 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 				flipY: scaleY < 0 !== flipY,
 			},
 		}
+
 		if (!shape.props.crop) return resized
 
 		const flipCropHorizontally =
-			// We used the flip horizontally feature
+			// Used the flip horizontally feature
 			(mode === 'scale_shape' && scaleX === -1) ||
-			// We resized the shape past it's bounds, so it flipped
+			// Resized past bounds, causing flip
 			(mode === 'resize_bounds' && flipX !== resized.props.flipX)
 		const flipCropVertically =
-			// We used the flip vertically feature
 			(mode === 'scale_shape' && scaleY === -1) ||
-			// We resized the shape past it's bounds, so it flipped
 			(mode === 'resize_bounds' && flipY !== resized.props.flipY)
 
 		const { topLeft, bottomRight } = shape.props.crop
@@ -113,27 +112,16 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 		return resized
 	}
 
-	component(shape: TLImageShape) {
-		return <ImageShape shape={shape} />
-	}
-
-	indicator(shape: TLImageShape) {
-		const isCropping = this.editor.getCroppingShapeId() === shape.id
-		if (isCropping) return null
-		return <rect width={toDomPrecision(shape.props.w)} height={toDomPrecision(shape.props.h)} />
-	}
-
 	override async toSvg(shape: TLImageShape, ctx: SvgExportContext) {
 		if (!shape.props.assetId) return null
 
 		const asset = this.editor.getAsset(shape.props.assetId)
-
 		if (!asset) return null
 
-		const { w } = getUncroppedSize(shape.props, shape.props.crop)
+		const { w: uncroppedWidth } = getUncroppedSize(shape.props, shape.props.crop)
 
 		const src = await imageSvgExportCache.get(asset, async () => {
-			let src = await ctx.resolveAssetUrl(asset.id, w)
+			let src = await ctx.resolveAssetUrl(asset.id, uncroppedWidth)
 			if (!src) return null
 			if (
 				src.startsWith('blob:') ||
@@ -141,97 +129,41 @@ export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
 				src.startsWith('/') ||
 				src.startsWith('./')
 			) {
-				// If it's a remote image, we need to fetch it and convert it to a data URI
+				// Convert remote image to data URI
 				src = (await getDataURIFromURL(src)) || ''
 			}
-
-			// If it's animated then we need to get the first frame
+			// If animated, use first frame
 			if (getIsAnimated(this.editor, asset.id)) {
 				const { promise } = getFirstFrameOfAnimatedImage(src)
 				src = await promise
 			}
 			return src
 		})
-
 		if (!src) return null
 
 		return <SvgImage shape={shape} src={src} />
 	}
 
-	override onDoubleClickEdge(shape: TLImageShape) {
-		const props = shape.props
-		if (!props) return
-
-		if (this.editor.getCroppingShapeId() !== shape.id) {
-			return
-		}
-
-		const crop = structuredClone(props.crop) || {
-			topLeft: { x: 0, y: 0 },
-			bottomRight: { x: 1, y: 1 },
-		}
-
-		// The true asset dimensions
-		const { w, h } = getUncroppedSize(shape.props, crop)
-
-		const pointDelta = new Vec(crop.topLeft.x * w, crop.topLeft.y * h).rot(shape.rotation)
-
-		const partial: TLShapePartial<TLImageShape> = {
-			id: shape.id,
-			type: shape.type,
-			x: shape.x - pointDelta.x,
-			y: shape.y - pointDelta.y,
-			props: {
-				crop: {
-					topLeft: { x: 0, y: 0 },
-					bottomRight: { x: 1, y: 1 },
-				},
-				w,
-				h,
-			},
-		}
-
-		this.editor.updateShapes([partial])
+	indicator(shape: TLImageShape) {
+		const isCropping = this.editor.getCroppingShapeId() === shape.id
+		if (isCropping) return null
+		return <rect width={toDomPrecision(shape.props.w)} height={toDomPrecision(shape.props.h)} />
 	}
-	override getInterpolatedProps(
-		startShape: TLImageShape,
-		endShape: TLImageShape,
-		t: number
-	): TLImageShapeProps {
-		function interpolateCrop(
-			startShape: TLImageShape,
-			endShape: TLImageShape
-		): TLImageShapeProps['crop'] {
-			if (startShape.props.crop === null && endShape.props.crop === null) return null
-
-			const startTL = startShape.props.crop?.topLeft || { x: 0, y: 0 }
-			const startBR = startShape.props.crop?.bottomRight || { x: 1, y: 1 }
-			const endTL = endShape.props.crop?.topLeft || { x: 0, y: 0 }
-			const endBR = endShape.props.crop?.bottomRight || { x: 1, y: 1 }
-
-			return {
-				topLeft: { x: lerp(startTL.x, endTL.x, t), y: lerp(startTL.y, endTL.y, t) },
-				bottomRight: { x: lerp(startBR.x, endBR.x, t), y: lerp(startBR.y, endBR.y, t) },
-			}
-		}
 
-		return {
-			...(t > 0.5 ? endShape.props : startShape.props),
-			w: lerp(startShape.props.w, endShape.props.w, t),
-			h: lerp(startShape.props.h, endShape.props.h, t),
-			crop: interpolateCrop(startShape, endShape),
-		}
+	component(shape: TLImageShape) {
+		return <ImageShape shape={shape} />
 	}
 }
 
+/** React component for rendering the image shape */
 const ImageShape = memo(function ImageShape({ shape }: { shape: TLImageShape }) {
 	const editor = useEditor()
 
-	const { w } = getUncroppedSize(shape.props, shape.props.crop)
+	const { w: uncroppedW } = getUncroppedSize(shape.props, shape.props.crop)
 	const { asset, url } = useImageOrVideoAsset({
 		shapeId: shape.id,
 		assetId: shape.props.assetId,
-		width: w,
+		width: uncroppedW,
 	})
 
 	const prefersReducedMotion = usePrefersReducedMotion()
@@ -240,20 +172,17 @@ const ImageShape = memo(function ImageShape({ shape }: { shape: TLImageShape })
 
 	const isAnimated = asset && getIsAnimated(editor, asset.id)
 
+	// Load first frame for animated images
 	useEffect(() => {
 		if (url && isAnimated) {
 			const { promise, cancel } = getFirstFrameOfAnimatedImage(url)
-
 			promise.then((dataUrl) => {
 				setStaticFrameSrc(dataUrl)
 				setLoadedUrl(url)
 			})
-
-			return () => {
-				cancel()
-			}
+			return () => cancel()
 		}
-	}, [editor, isAnimated, prefersReducedMotion, url])
+	}, [editor, isAnimated, url])
 
 	const showCropPreview = useValue(
 		'show crop preview',
@@ -261,19 +190,18 @@ const ImageShape = memo(function ImageShape({ shape }: { shape: TLImageShape })
 			shape.id === editor.getOnlySelectedShapeId() &&
 			editor.getCroppingShapeId() === shape.id &&
 			editor.isIn('select.crop'),
-		[editor, shape.id]
+		[editor, shape.id],
 	)
 
-	// We only want to reduce motion for mimeTypes that have motion
 	const reduceMotion =
-		prefersReducedMotion && (asset?.props.mimeType?.includes('video') || isAnimated)
+		usePrefersReducedMotion() && (asset?.props.mimeType?.includes('video') || isAnimated)
 
 	const containerStyle = getCroppedContainerStyle(shape)
 
-	const nextSrc = url === loadedUrl ? null : url
+	const nextSrc = url && url !== loadedUrl ? url : null
 	const loadedSrc = reduceMotion ? staticFrameSrc : loadedUrl
 
-	// This logic path is for when it's broken/missing asset.
+	// Render placeholder for missing/broken asset
 	if (!url && !asset?.props.src) {
 		return (
 			<HTMLContainer
@@ -293,13 +221,11 @@ const ImageShape = memo(function ImageShape({ shape }: { shape: TLImageShape })
 				>
 					{asset ? null : <BrokenAssetIcon />}
 				</div>
-				{'url' in shape.props && shape.props.url && <HyperlinkButton url={shape.props.url} />}
+				{shape.props.url && <HyperlinkButton url={shape.props.url} />}
 			</HTMLContainer>
 		)
 	}
 
-	// We don't set crossOrigin for non-animated images because for Cloudflare we don't currently
-	// have that set up.
 	const crossOrigin = isAnimated ? 'anonymous' : undefined
 
 	return (
@@ -321,12 +247,6 @@ const ImageShape = memo(function ImageShape({ shape }: { shape: TLImageShape })
 				style={{ overflow: 'hidden', width: shape.props.w, height: shape.props.h }}
 			>
 				<div className={classNames('tl-image-container')} style={containerStyle}>
-					{/* We have two images: the currently loaded image, and the next image that
-					we're waiting to load. we keep the loaded image mounted while we're waiting
-					for the next one by storing the loaded URL in state. We use `key` props with
-					the src of the image so that when the next image is ready, the previous one will
-					be unmounted and the next will be shown with the browser having to remount a
-					fresh image and decoded it again from the cache. */}
 					{loadedSrc && (
 						<img
 							key={loadedSrc}
@@ -359,22 +279,16 @@ const ImageShape = memo(function ImageShape({ shape }: { shape: TLImageShape })
 
 function getIsAnimated(editor: Editor, assetId: TLAssetId) {
 	const asset = assetId ? editor.getAsset(assetId) : undefined
-
 	if (!asset) return false
-
 	return (
-		('mimeType' in asset.props && MediaHelpers.isAnimatedImageType(asset?.props.mimeType)) ||
-		('isAnimated' in asset.props && asset.props.isAnimated)
+		('mimeType' in (asset as any).props && MediaHelpers.isAnimatedImageType((asset as any).props.mimeType)) ||
+		('isAnimated' in (asset as any).props && (asset as any).props.isAnimated
 	)
 }
 
-/**
- * When an image is cropped we need to translate the image to show the portion withing the cropped
- * area. We do this by translating the image by the negative of the top left corner of the crop
- * area.
- *
- * @param shape - Shape The image shape for which to get the container style
- * @returns - Styles to apply to the image container
+/** When an image is cropped we need to translate the image to show the portion within the cropped
+ * area. We do this by translating the image by the negative of the top left corner of the
+ * crop rectangle.
  */
 function getCroppedContainerStyle(shape: TLImageShape) {
 	const crop = shape.props.crop
@@ -383,10 +297,10 @@ function getCroppedContainerStyle(shape: TLImageShape) {
 		return {
 			width: shape.props.w,
 			height: shape.props.h,
-		}
+			 }
 	}
-
-	const { w, h } = getUncroppedSize(shape.props, crop)
+	const w = (1 / (crop.bottomRight.x - crop.topLeft.x)) * shape.props.w
+	const h = (1 / (crop.bottomRight.y - crop.topLeft.y)) * shape.props.h
 	const offsetX = -topLeft.x * w
 	const offsetY = -topLeft.y * h
 	return {
@@ -396,18 +310,21 @@ function getCroppedContainerStyle(shape: TLImageShape) {
 	}
 }
 
-function getFlipStyle(shape: TLImageShape, size?: { width: number; height: number }) {
+/**
+ * Returns CSS transform to apply for flipX / flipY
+ */
+function getFlipStyle(
+	shape: TLImageShape,
+	size?: { width: number; height: number }
+) {
 	const { flipX, flipY } = shape.props
 	if (!flipX && !flipY) return undefined
 
 	const scale = `scale(${flipX ? -1 : 1}, ${flipY ? -1 : 1})`
-	const translate = size
-		? `translate(${flipX ? size.width : 0}px, ${flipY ? size.height : 0}px)`
-		: ''
+	const translate = size ? `translate(${flipX ? size.width : 0}px, ${flipY ? size.height : 0}px)` : ''
 
 	return {
 		transform: `${translate} ${scale}`,
-		// in SVG, flipping around the center doesn't work so we use explicit width/height
 		transformOrigin: size ? '0 0' : 'center center',
 	}
 }
@@ -416,7 +333,6 @@ function SvgImage({ shape, src }: { shape: TLImageShape; src: string }) {
 	const cropClipId = useUniqueSafeId()
 	const containerStyle = getCroppedContainerStyle(shape)
 	const crop = shape.props.crop
-
 	if (containerStyle.transform && crop) {
 		const { transform: cropTransform, width, height } = containerStyle
 		const croppedWidth = (crop.bottomRight.x - crop.topLeft.x) * width
@@ -443,48 +359,36 @@ function SvgImage({ shape, src }: { shape: TLImageShape; src: string }) {
 						href={src}
 						width={width}
 						height={height}
-						style={
-							flip
-								? { ...flip, transform: `${cropTransform} ${flip.transform}` }
-								: { transform: cropTransform }
-						}
+						style={flip ? { ...flip, transform: `${cropTransform} ${flip.transform}` } : { transform: cropTransform }}
 					/>
 				</g>
 			</>
 		)
 	} else {
-		return (
-			<image
-				href={src}
-				width={shape.props.w}
-				height={shape.props.h}
-				style={getFlipStyle(shape, { width: shape.props.w, height: shape.props.h })}
-			/>
-		)
+		return <image href={src} width={shape.props.w} height={shape.props.h} style={getFlipStyle(shape, { width: shape.props.w, height: shape.props.h })} />
 	}
 }
 
+/* Helper to get first frame of animated image */
 function getFirstFrameOfAnimatedImage(url: string) {
 	let cancelled = false
-
+	const image = Image()
 	const promise = new Promise<string>((resolve) => {
-		const image = Image()
 		image.onload = () => {
 			if (cancelled) return
-
 			const canvas = document.createElement('canvas')
 			canvas.width = image.width
 			canvas.height = image.height
-
 			const ctx = canvas.getContext('2d')
 			if (!ctx) return
-
 			ctx.drawImage(image, 0, 0)
 			resolve(canvas.toDataURL())
 		}
 		image.crossOrigin = 'anonymous'
 		image.src = url
 	})
-
-	return { promise, cancel: () => (cancelled = true) }
+	return {
+		promise,
+		cancel: () => (cancelled = true),
+	}
 }
\ No newline at end of file
