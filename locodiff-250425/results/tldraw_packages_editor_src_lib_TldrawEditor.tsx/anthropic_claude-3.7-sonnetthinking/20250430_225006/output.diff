--- tldraw_packages_editor_src_lib_TldrawEditor.tsx_expectedoutput.txt (expected)+++ tldraw_packages_editor_src_lib_TldrawEditor.tsx_extracted.txt (actual)@@ -317,10 +317,7 @@ })
 
 function TldrawEditorWithOwnStore(
-	props: Required<
-		TldrawEditorProps & { store: undefined; user: TLUser },
-		'shapeUtils' | 'bindingUtils' | 'tools'
-	>
+	props: Required<TldrawEditorProps & { store: undefined; user: TLUser }, 'shapeUtils' | 'bindingUtils' | 'tools'>
 ) {
 	const {
 		defaultName,
@@ -465,7 +462,6 @@ 				getContainer: () => container,
 				user,
 				initialState,
-				// we should check for some kind of query parameter that turns off autofocus
 				autoFocus,
 				inferDarkMode,
 				cameraOptions,
@@ -529,6 +525,75 @@ 		}
 	}, [editor, cameraOptions])
 
+	// For our examples site, we want autoFocus to be true on the examples site, but not
+	// when embedded in our docs site. If present, the `tldraw_preserve_focus` search param
+	// overrides the `autoFocus` prop and prevents the editor from focusing immediately,
+	// however here we also add some logic to focus the editor when the user clicks
+	// on it and unfocus it when the user clicks away from it.
+	useEffect(
+		function handleFocusOnPointerDownForPreserveFocusMode() {
+			if (!editor) return
+
+			function handleFocusOnPointerDown() {
+				if (!editor) return
+				editor.focus()
+			}
+
+			function handleBlurOnPointerDown() {
+				if (!editor) return
+				editor.blur()
+			}
+
+			if (autoFocus && noAutoFocus()) {
+				editor.getContainer().addEventListener('pointerdown', handleFocusOnPointerDown)
+				document.body.addEventListener('pointerdown', handleBlurOnPointerDown)
+
+				return () => {
+					editor.getContainer()?.removeEventListener('pointerdown', handleFocusOnPointerDown)
+					document.body.removeEventListener('pointerdown', handleBlurOnPointerDown)
+				}
+			}
+		},
+		[editor, autoFocus]
+	)
+
+	const [_fontLoadingState, setFontLoadingState] = useState<{
+		editor: Editor
+		isLoaded: boolean
+	} | null>(null)
+	let fontLoadingState = _fontLoadingState
+	if (editor !== fontLoadingState?.editor) {
+		fontLoadingState = null
+	}
+	useEffect(() => {
+		if (!editor) return
+		let isCancelled = false
+
+		setFontLoadingState({ editor, isLoaded: false })
+
+		editor.fonts
+			.loadRequiredFontsForCurrentPage(editor.options.maxFontsToLoadBeforeRender)
+			.finally(() => {
+				if (isCancelled) return
+				setFontLoadingState({ editor, isLoaded: true })
+			})
+
+		return () => {
+			isCancelled = true
+		}
+	}, [editor])
+
+	const { Canvas, LoadingScreen } = useEditorComponents()
+
+	if (!editor || !fontLoadingState?.isLoaded) {
+		return (
+			<>
+				{LoadingScreen && <LoadingScreen />}
+				<div className="tl-canvas" ref={canvasRef} />
+			</>
+		)
+	}
+
 	const crashingError = useSyncExternalStore(
 		useCallback(
 			(onStoreChange) => {
@@ -545,82 +610,7 @@ 		() => editor?.getCrashingError() ?? null
 	)
 
-	// For our examples site, we want autoFocus to be true on the examples site, but not
-	// when embedded in our docs site. If present, the `tldraw_preserve_focus` search param
-	// overrides the `autoFocus` prop and prevents the editor from focusing immediately,
-	// however here we also add some logic to focus the editor when the user clicks
-	// on it and unfocus it when the user clicks away from it.
-	useEffect(
-		function handleFocusOnPointerDownForPreserveFocusMode() {
-			if (!editor) return
-
-			function handleFocusOnPointerDown() {
-				if (!editor) return
-				editor.focus()
-			}
-
-			function handleBlurOnPointerDown() {
-				if (!editor) return
-				editor.blur()
-			}
-
-			if (autoFocus && noAutoFocus()) {
-				editor.getContainer().addEventListener('pointerdown', handleFocusOnPointerDown)
-				document.body.addEventListener('pointerdown', handleBlurOnPointerDown)
-
-				return () => {
-					editor.getContainer()?.removeEventListener('pointerdown', handleFocusOnPointerDown)
-					document.body.removeEventListener('pointerdown', handleBlurOnPointerDown)
-				}
-			}
-		},
-		[editor, autoFocus]
-	)
-
-	const [_fontLoadingState, setFontLoadingState] = useState<{
-		editor: Editor
-		isLoaded: boolean
-	} | null>(null)
-	let fontLoadingState = _fontLoadingState
-	if (editor !== fontLoadingState?.editor) {
-		fontLoadingState = null
-	}
-	useEffect(() => {
-		if (!editor) return
-		let isCancelled = false
-
-		setFontLoadingState({ editor, isLoaded: false })
-
-		editor.fonts
-			.loadRequiredFontsForCurrentPage(editor.options.maxFontsToLoadBeforeRender)
-			.finally(() => {
-				if (isCancelled) return
-				setFontLoadingState({ editor, isLoaded: true })
-			})
-
-		return () => {
-			isCancelled = true
-		}
-	}, [editor])
-
-	const { Canvas, LoadingScreen } = useEditorComponents()
-
-	if (!editor || !fontLoadingState?.isLoaded) {
-		return (
-			<>
-				{LoadingScreen && <LoadingScreen />}
-				<div className="tl-canvas" ref={canvasRef} />
-			</>
-		)
-	}
-
 	return (
-		// the top-level tldraw component also renders an error boundary almost
-		// identical to this one. the reason we have two is because this one has
-		// access to `App`, which means that here we can enrich errors with data
-		// from app for reporting, and also still attempt to render the user's
-		// document in the event of an error to reassure them that their work is
-		// not lost.
 		<OptionalErrorBoundary
 			fallback={ErrorFallback as any}
 			onError={(error) =>
