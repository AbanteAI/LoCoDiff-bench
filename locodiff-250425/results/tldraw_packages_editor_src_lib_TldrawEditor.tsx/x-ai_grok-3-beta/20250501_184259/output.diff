--- tldraw_packages_editor_src_lib_TldrawEditor.tsx_expectedoutput.txt (expected)+++ tldraw_packages_editor_src_lib_TldrawEditor.tsx_extracted.txt (actual)@@ -1,6 +1,6 @@ import { MigrationSequence, Store } from '@tldraw/store'
 import { TLShape, TLStore, TLStoreSnapshot } from '@tldraw/tlschema'
-import { Required, annotateError } from '@tldraw/utils'
+import { Expand, Required, annotateError } from '@tldraw/utils'
 import React, {
 	ReactNode,
 	memo,
@@ -99,8 +99,10 @@  * Props for the {@link tldraw#Tldraw} and {@link TldrawEditor} components.
  *
  * @public
- **/
-export type TldrawEditorProps = TldrawEditorBaseProps & TldrawEditorStoreProps
+ */
+export type TldrawEditorProps = Expand<
+	TldrawEditorBaseProps & TldrawEditorStoreProps
+>
 
 /**
  * Base props for the {@link tldraw#Tldraw} and {@link TldrawEditor} components.
@@ -187,13 +189,6 @@ 	 * Options for syncing the editor's camera state with the URL.
 	 */
 	deepLinks?: true | TLDeepLinkOptions
-
-	/**
-	 * Predicate for whether or not a shape should be hidden.
-	 *
-	 * @deprecated Use {@link TldrawEditorBaseProps#getShapeVisibility} instead.
-	 */
-	isShapeHidden?(shape: TLShape, editor: Editor): boolean
 
 	/**
 	 * Provides a way to hide shapes.
@@ -213,6 +208,28 @@ 	 *
 	 * @param shape - The shape to check.
 	 * @param editor - The editor instance.
+	 * @deprecated Use {@link TldrawEditorBaseProps#getShapeVisibility} instead.
+	 */
+	isShapeHidden?(shape: TLShape, editor: Editor): boolean
+
+	/**
+	 * Provides a way to hide shapes.
+	 *
+	 * Hidden shapes will not render in the editor, and they will not be eligible for hit test via
+	 * {@link Editor#getShapeAtPoint} and {@link Editor#getShapesAtPoint}. But otherwise they will
+	 * remain in the store and participate in all other operations.
+	 *
+	 * @example
+	 * ```ts
+	 * getShapeVisibility={(shape, editor) => shape.meta.hidden ? 'hidden' : 'inherit'}
+	 * ```
+	 *
+	 * - `'inherit' | undefined` - (default) The shape will be visible unless its parent is hidden.
+	 * - `'hidden'` - The shape will be hidden.
+	 * - `'visible'` - The shape will be visible.
+	 *
+	 * @param shape - The shape to check.
+	 * @param editor - The editor instance.
 	 */
 	getShapeVisibility?(
 		shape: TLShape,
@@ -243,11 +260,12 @@ 	}
 }
 
+/** @internal */
+export const TL_CONTAINER_CLASS = 'tl-container'
+
 const EMPTY_SHAPE_UTILS_ARRAY = [] as const
 const EMPTY_BINDING_UTILS_ARRAY = [] as const
 const EMPTY_TOOLS_ARRAY = [] as const
-/** @internal */
-export const TL_CONTAINER_CLASS = 'tl-container'
 
 /** @public @react */
 export const TldrawEditor = memo(function TldrawEditor({
@@ -264,6 +282,9 @@ 	const ErrorFallback =
 		components?.ErrorFallback === undefined ? DefaultErrorFallback : components?.ErrorFallback
 
+	const ErrorFallback =
+		components?.ErrorFallback === undefined ? DefaultErrorFallback : components?.ErrorFallback
+
 	// apply defaults. if you're using the bare @tldraw/editor package, we
 	// default these to the "tldraw zero" configuration. We have different
 	// defaults applied in tldraw.
@@ -278,7 +299,6 @@ 
 	return (
 		<div
-			ref={setContainer}
 			data-tldraw={version}
 			draggable={false}
 			className={classNames(`${TL_CONTAINER_CLASS} tl-theme__light`, className)}
@@ -377,7 +397,7 @@ 			throw store.error
 		}
 		case 'loading': {
-			return LoadingScreen ? <LoadingScreen /> : null
+			return LoadingScreen && <LoadingScreen />
 		}
 		case 'not-synced': {
 			break
@@ -393,7 +413,7 @@ 	return <TldrawEditorWithReadyStore {...rest} store={store.store} user={user} />
 })
 
-const noAutoFocus = () => document.location.search.includes('tldraw_preserve_focus') // || !document.hasFocus() // breaks in nextjs
+const noAutoFocus = () => document.location.search.includes('tldraw_preserve_focus')
 
 function TldrawEditorWithReadyStore({
 	onMount,
@@ -425,7 +445,16 @@ 	const { ErrorFallback } = useEditorComponents()
 	const container = useContainer()
 
-	const [editor, setEditor] = useRefState<Editor | null>(null)
+	const editorRef = useRef<Editor | null>(null)
+	// we need to store the editor instance in a ref so that it persists across strict-mode
+	// remounts, but that won't trigger re-renders, so we use this hook to make sure all child
+	// components get the most up to date editor reference when needed.
+	const [renderEditor, setRenderEditor] = useState<Editor | null>(null)
+
+	const editor = editorRef.current
+	if (renderEditor !== editor) {
+		setRenderEditor(editor)
+	}
 
 	const canvasRef = useRef<HTMLDivElement | null>(null)
 
@@ -491,7 +520,8 @@ 				}
 			}
 
-			setEditor(editor)
+			editorRef.current = editor
+			setRenderEditor(editor)
 
 			return () => {
 				editor.dispose()
@@ -506,7 +536,7 @@ 			store,
 			tools,
 			user,
-			setEditor,
+			setRenderEditor,
 			licenseKey,
 			isShapeHidden,
 			getShapeVisibility,
@@ -528,6 +558,38 @@ 			editor.setCameraOptions(cameraOptions)
 		}
 	}, [editor, cameraOptions])
+
+	// For our examples site, we want autoFocus to be true on the examples site, but not
+	// when embedded in our docs site. If present, the `tldraw_preserve_focus` search param
+	// overrides the `autoFocus` prop and prevents the editor from focusing immediately,
+	// however here we also add some logic to focus the editor when the user clicks
+	// on it and unfocus it when the user clicks away from it.
+	useEffect(
+		function handleFocusOnPointerDownForPreserveFocusMode() {
+			if (!editor) return
+
+			function handleFocusOnPointerDown() {
+				if (!editor) return
+				editor.focus()
+			}
+
+			function handleBlurOnPointerDown() {
+				if (!editor) return
+				editor.blur()
+			}
+
+			if (autoFocus && noAutoFocus()) {
+				editor.getContainer().addEventListener('pointerdown', handleFocusOnPointerDown)
+				document.body.addEventListener('pointerdown', handleBlurOnPointerDown)
+
+				return () => {
+					editor.getContainer()?.removeEventListener('pointerdown', handleFocusOnPointerDown)
+					document.body.removeEventListener('pointerdown', handleBlurOnPointerDown)
+				}
+			}
+		},
+		[editor, autoFocus]
+	)
 
 	const crashingError = useSyncExternalStore(
 		useCallback(
@@ -545,38 +607,6 @@ 		() => editor?.getCrashingError() ?? null
 	)
 
-	// For our examples site, we want autoFocus to be true on the examples site, but not
-	// when embedded in our docs site. If present, the `tldraw_preserve_focus` search param
-	// overrides the `autoFocus` prop and prevents the editor from focusing immediately,
-	// however here we also add some logic to focus the editor when the user clicks
-	// on it and unfocus it when the user clicks away from it.
-	useEffect(
-		function handleFocusOnPointerDownForPreserveFocusMode() {
-			if (!editor) return
-
-			function handleFocusOnPointerDown() {
-				if (!editor) return
-				editor.focus()
-			}
-
-			function handleBlurOnPointerDown() {
-				if (!editor) return
-				editor.blur()
-			}
-
-			if (autoFocus && noAutoFocus()) {
-				editor.getContainer().addEventListener('pointerdown', handleFocusOnPointerDown)
-				document.body.addEventListener('pointerdown', handleBlurOnPointerDown)
-
-				return () => {
-					editor.getContainer()?.removeEventListener('pointerdown', handleFocusOnPointerDown)
-					document.body.removeEventListener('pointerdown', handleBlurOnPointerDown)
-				}
-			}
-		},
-		[editor, autoFocus]
-	)
-
 	const [_fontLoadingState, setFontLoadingState] = useState<{
 		editor: Editor
 		isLoaded: boolean
@@ -622,7 +652,7 @@ 		// document in the event of an error to reassure them that their work is
 		// not lost.
 		<OptionalErrorBoundary
-			fallback={ErrorFallback as any}
+			fallback={ErrorFallback}
 			onError={(error) =>
 				editor.annotateError(error, { origin: 'react.tldraw', willCrashApp: true })
 			}
@@ -641,19 +671,26 @@ 	)
 }
 
+const noAutoFocus = () => document.location.search.includes('tldraw_preserve_focus')
+
 function Layout({ children, onMount }: { children: ReactNode; onMount?: TLOnMountHandler }) {
 	useZoomCss()
 	useCursor()
 	useDarkMode()
 	useForceUpdate()
 	useOnMount((editor) => {
-		const teardownStore = editor.store.props.onMount(editor)
-		const teardownCallback = onMount?.(editor)
-
-		return () => {
-			teardownStore?.()
-			teardownCallback?.()
-		}
+		let teardown: (() => void) | void = undefined
+		// If the user wants to do something when the editor mounts, we make sure it doesn't effect the history.
+		// todo: is this reeeeally what we want to do, or should we leave it up to the caller?
+		editor.run(
+			() => {
+				teardown = onMount?.(editor)
+				editor.emit('mount')
+			},
+			{ history: 'ignore' }
+		)
+		window.tldrawReady = true
+		return teardown
 	})
 
 	return children
