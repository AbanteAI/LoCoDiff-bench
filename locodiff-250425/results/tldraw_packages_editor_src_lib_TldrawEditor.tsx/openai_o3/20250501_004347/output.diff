--- tldraw_packages_editor_src_lib_TldrawEditor.tsx_expectedoutput.txt (expected)+++ tldraw_packages_editor_src_lib_TldrawEditor.tsx_extracted.txt (actual)@@ -1,5 +1,9 @@ import { MigrationSequence, Store } from '@tldraw/store'
-import { TLShape, TLStore, TLStoreSnapshot } from '@tldraw/tlschema'
+import {
+	TLShape,
+	TLStore,
+	TLStoreSnapshot,
+} from '@tldraw/tlschema'
 import { Required, annotateError } from '@tldraw/utils'
 import React, {
 	ReactNode,
@@ -28,17 +32,17 @@ import { ContainerProvider, useContainer } from './hooks/useContainer'
 import { useCursor } from './hooks/useCursor'
 import { useDarkMode } from './hooks/useDarkMode'
-import { EditorProvider, useEditor } from './hooks/useEditor'
 import {
 	EditorComponentsProvider,
 	TLEditorComponents,
 	useEditorComponents,
 } from './hooks/useEditorComponents'
+import { EditorProvider, useEditor } from './hooks/useEditor'
 import { useEvent } from './hooks/useEvent'
 import { useForceUpdate } from './hooks/useForceUpdate'
-import { useShallowObjectIdentity } from './hooks/useIdentity'
 import { useLocalStore } from './hooks/useLocalStore'
 import { useRefState } from './hooks/useRefState'
+import { useShallowObjectIdentity } from './hooks/useIdentity'
 import { useZoomCss } from './hooks/useZoomCss'
 import { LicenseProvider } from './license/LicenseProvider'
 import { Watermark } from './license/Watermark'
@@ -96,13 +100,6 @@ export type TldrawEditorStoreProps = TldrawEditorWithStoreProps | TldrawEditorWithoutStoreProps
 
 /**
- * Props for the {@link tldraw#Tldraw} and {@link TldrawEditor} components.
- *
- * @public
- **/
-export type TldrawEditorProps = TldrawEditorBaseProps & TldrawEditorStoreProps
-
-/**
  * Base props for the {@link tldraw#Tldraw} and {@link TldrawEditor} components.
  *
  * @public
@@ -128,35 +125,28 @@ 	 */
 	tools?: readonly TLStateNodeConstructor[]
 
+	/** Urls for where to find fonts and other assets. */
+	assetUrls?: { fonts?: { [key: string]: string | undefined } }
+
 	/**
 	 * Whether to automatically focus the editor when it mounts.
 	 */
 	autoFocus?: boolean
 
-	/**
-	 * Overrides for the editor's components, such as handles, collaborator cursors, etc.
-	 */
+	/** Overrides for the tldraw user interface components. */
 	components?: TLEditorComponents
 
 	/**
 	 * Called when the editor has mounted.
+	 * @example
+	 * ```ts
+	 * <Tldraw onMount={(editor) => editor.selectAll()} />
+	 * ```
+	 * @param editor - The editor instance.
+	 *
+	 * @public
 	 */
 	onMount?: TLOnMountHandler
-
-	/**
-	 * The editor's initial state (usually the id of the first active tool).
-	 */
-	initialState?: string
-
-	/**
-	 * A classname to pass to the editor's container.
-	 */
-	className?: string
-
-	/**
-	 * The user interacting with the editor.
-	 */
-	user?: TLUser
 
 	/**
 	 * Whether to infer dark mode from the user's OS. Defaults to false.
@@ -218,24 +208,7 @@ 		shape: TLShape,
 		editor: Editor
 	): 'visible' | 'hidden' | 'inherit' | null | undefined
-
-	/**
-	 * The URLs for the fonts to use in the editor.
-	 */
-	assetUrls?: { fonts?: { [key: string]: string | undefined } }
-}
-
-/**
- * Called when the editor has mounted.
- * @example
- * ```ts
- * <Tldraw onMount={(editor) => editor.selectAll()} />
- * ```
- * @param editor - The editor instance.
- *
- * @public
- */
-export type TLOnMountHandler = (editor: Editor) => (() => void | undefined) | undefined | void
+}
 
 declare global {
 	interface Window {
@@ -354,10 +327,7 @@ 	store,
 	user,
 	...rest
-}: Required<
-	TldrawEditorProps & { store: TLStoreWithStatus; user: TLUser },
-	'shapeUtils' | 'bindingUtils' | 'tools'
->) {
+}: Required<TldrawEditorProps & { store: TLStoreWithStatus; user: TLUser }, 'shapeUtils' | 'bindingUtils' | 'tools'>) {
 	const container = useContainer()
 
 	useLayoutEffect(() => {
@@ -366,8 +336,6 @@ 			container.classList.add('tl-theme__dark')
 		}
 	}, [container, user])
-
-	const { LoadingScreen } = useEditorComponents()
 
 	switch (store.status) {
 		case 'error': {
@@ -377,6 +345,7 @@ 			throw store.error
 		}
 		case 'loading': {
+			const { LoadingScreen } = useEditorComponents()
 			return LoadingScreen ? <LoadingScreen /> : null
 		}
 		case 'not-synced': {
@@ -465,7 +434,6 @@ 				getContainer: () => container,
 				user,
 				initialState,
-				// we should check for some kind of query parameter that turns off autofocus
 				autoFocus,
 				inferDarkMode,
 				cameraOptions,
@@ -510,8 +478,6 @@ 			licenseKey,
 			isShapeHidden,
 			getShapeVisibility,
-			textOptions,
-			assetUrls,
 		]
 	)
 
@@ -528,6 +494,83 @@ 			editor.setCameraOptions(cameraOptions)
 		}
 	}, [editor, cameraOptions])
+
+	const { Canvas } = useEditorComponents()
+
+	// focus + blur (for docs site) ------------
+
+	// For our examples site, we want autoFocus to be true on the examples site, but not
+	// when embedded in our docs site. If present, the `tldraw_preserve_focus` search param
+	// overrides the `autoFocus` prop and prevents the editor from focusing immediately,
+	// however here we also add some logic to focus the editor when the user clicks
+	// on it and unfocus it when the user clicks away from it.
+	useEffect(
+		function handleFocusOnPointerDownForPreserveFocusMode() {
+			if (!editor) return
+
+			function handleFocusOnPointerDown() {
+				if (!editor) return
+				editor.focus()
+			}
+
+			function handleBlurOnPointerDown() {
+				if (!editor) return
+				editor.blur()
+			}
+
+			if (autoFocus && noAutoFocus()) {
+				editor.getContainer().addEventListener('pointerdown', handleFocusOnPointerDown)
+				document.body.addEventListener('pointerdown', handleBlurOnPointerDown)
+
+				return () => {
+					editor.getContainer()?.removeEventListener('pointerdown', handleFocusOnPointerDown)
+					document.body.removeEventListener('pointerdown', handleBlurOnPointerDown)
+				}
+			}
+		},
+		[editor, autoFocus]
+	)
+
+	// font loading state ----------------------
+
+	const [_fontLoadingState, setFontLoadingState] = useState<{
+		editor: Editor
+		isLoaded: boolean
+	} | null>(null)
+	let fontLoadingState = _fontLoadingState
+	if (editor !== fontLoadingState?.editor) {
+		fontLoadingState = null
+	}
+	useEffect(() => {
+		if (!editor) return
+		let isCancelled = false
+
+		setFontLoadingState({ editor, isLoaded: false })
+
+		editor.fonts
+			.loadRequiredFontsForCurrentPage(editor.options.maxFontsToLoadBeforeRender)
+			.finally(() => {
+				if (isCancelled) return
+				setFontLoadingState({ editor, isLoaded: true })
+			})
+
+		return () => {
+			isCancelled = true
+		}
+	}, [editor])
+
+	const { LoadingScreen } = useEditorComponents()
+
+	if (!editor || !fontLoadingState?.isLoaded) {
+		return (
+			<>
+				{LoadingScreen && <LoadingScreen />}
+				<div className="tl-canvas" ref={canvasRef} />
+			</>
+		)
+	}
+
+	// crash page ------------------------------
 
 	const crashingError = useSyncExternalStore(
 		useCallback(
@@ -545,99 +588,31 @@ 		() => editor?.getCrashingError() ?? null
 	)
 
-	// For our examples site, we want autoFocus to be true on the examples site, but not
-	// when embedded in our docs site. If present, the `tldraw_preserve_focus` search param
-	// overrides the `autoFocus` prop and prevents the editor from focusing immediately,
-	// however here we also add some logic to focus the editor when the user clicks
-	// on it and unfocus it when the user clicks away from it.
-	useEffect(
-		function handleFocusOnPointerDownForPreserveFocusMode() {
-			if (!editor) return
-
-			function handleFocusOnPointerDown() {
-				if (!editor) return
-				editor.focus()
-			}
-
-			function handleBlurOnPointerDown() {
-				if (!editor) return
-				editor.blur()
-			}
-
-			if (autoFocus && noAutoFocus()) {
-				editor.getContainer().addEventListener('pointerdown', handleFocusOnPointerDown)
-				document.body.addEventListener('pointerdown', handleBlurOnPointerDown)
-
-				return () => {
-					editor.getContainer()?.removeEventListener('pointerdown', handleFocusOnPointerDown)
-					document.body.removeEventListener('pointerdown', handleBlurOnPointerDown)
+	if (crashingError) {
+		return (
+			<OptionalErrorBoundary
+				fallback={ErrorFallback}
+				onError={(error) =>
+					editor.annotateError(error, {
+						origin: 'react.tldraw',
+						willCrashApp: false,
+					})
 				}
-			}
-		},
-		[editor, autoFocus]
-	)
-
-	const [_fontLoadingState, setFontLoadingState] = useState<{
-		editor: Editor
-		isLoaded: boolean
-	} | null>(null)
-	let fontLoadingState = _fontLoadingState
-	if (editor !== fontLoadingState?.editor) {
-		fontLoadingState = null
-	}
-	useEffect(() => {
-		if (!editor) return
-		let isCancelled = false
-
-		setFontLoadingState({ editor, isLoaded: false })
-
-		editor.fonts
-			.loadRequiredFontsForCurrentPage(editor.options.maxFontsToLoadBeforeRender)
-			.finally(() => {
-				if (isCancelled) return
-				setFontLoadingState({ editor, isLoaded: true })
-			})
-
-		return () => {
-			isCancelled = true
-		}
-	}, [editor])
-
-	const { Canvas, LoadingScreen } = useEditorComponents()
-
-	if (!editor || !fontLoadingState?.isLoaded) {
-		return (
-			<>
-				{LoadingScreen && <LoadingScreen />}
-				<div className="tl-canvas" ref={canvasRef} />
-			</>
+			>
+				<Crash crashingError={crashingError} />
+			</OptionalErrorBoundary>
 		)
 	}
 
+	// normal page ------------------------------
+
 	return (
-		// the top-level tldraw component also renders an error boundary almost
-		// identical to this one. the reason we have two is because this one has
-		// access to `App`, which means that here we can enrich errors with data
-		// from app for reporting, and also still attempt to render the user's
-		// document in the event of an error to reassure them that their work is
-		// not lost.
-		<OptionalErrorBoundary
-			fallback={ErrorFallback as any}
-			onError={(error) =>
-				editor.annotateError(error, { origin: 'react.tldraw', willCrashApp: true })
-			}
-		>
-			{crashingError ? (
-				<Crash crashingError={crashingError} />
-			) : (
-				<EditorProvider editor={editor}>
-					<Layout onMount={onMount}>
-						{children ?? (Canvas ? <Canvas key={editor.contextId} /> : null)}
-						<Watermark />
-					</Layout>
-				</EditorProvider>
-			)}
-		</OptionalErrorBoundary>
+		<EditorProvider editor={editor}>
+			<Layout onMount={onMount}>
+				{children ?? (Canvas ? <Canvas key={editor.contextId} /> : null)}
+				<Watermark />
+			</Layout>
+		</EditorProvider>
 	)
 }
 
@@ -704,4 +679,16 @@ 	React.useLayoutEffect(() => {
 		if (editor) return onMountEvent?.(editor)
 	}, [editor, onMountEvent])
-}+}
+
+/**
+ * Called when the editor has mounted.
+ * @example
+ * ```ts
+ * <Tldraw onMount={(editor) => editor.selectAll()} />
+ * ```
+ * @param editor - The editor instance.
+ *
+ * @public
+ */
+export type TLOnMountHandler = (editor: Editor) => (() => void | undefined) | undefined | void