
index 237415b4d..24bcc40b9 100644
--- a/qdrant_lib_collection_src_collection_manager_optimizers_indexing_optimizer.rs_expectedoutput.txt (expected):tmp/tmpmuzl6g03_expected.txt	
+++ b/qdrant_lib_collection_src_collection_manager_optimizers_indexing_optimizer.rs_extracted.txt (actual):tmp/tmp2lrrof6c_actual.txt	
@@ -815,193 +815,4 @@ mod tests {
             );
         }
 
-        // Ensure that the total number of segments did not change
-        assert_eq!(locked_holder.read().len(), number_of_segments);
-    }
-
-    /// This tests things are as we expect when we define both `on_disk: false` and `memmap_threshold`
-    ///
-    /// Before this PR (<https://github.com/qdrant/qdrant/pull/3167>) such configuration would create an infinite optimization loop.
-    ///
-    /// It tests whether:
-    /// - the on_disk flag is preferred over memmap_threshold
-    /// - the index optimizer and config mismatch optimizer don't conflict with this preference
-    /// - there is no infinite optiization loop with the above configuration
-    ///
-    /// In short, this is what happens in this test:
-    /// - create randomized segment as base with `on_disk: false` and `memmap_threshold`
-    /// - test that indexing optimizer and config mismatch optimizer dont trigger
-    /// - test that current storage is in memory
-    /// - change `on_disk: None`
-    /// - test that indexing optimizer now wants to optimize for `memmap_threshold`
-    /// - optimize with indexing optimizer to put storage on disk
-    /// - test that config mismatch optimizer doesn't try to revert on disk storage
-    #[test]
-    fn test_on_disk_memmap_threshold_conflict() {
-        // Collection configuration
-        let (point_count, dim) = (1000, 10);
-        let thresholds_config = OptimizerThresholds {
-            max_segment_size_kb: usize::MAX,
-            memmap_threshold_kb: 10,
-            indexing_threshold_kb: usize::MAX,
-        };
-        let mut collection_params = CollectionParams {
-            vectors: VectorsConfig::Single(
-                VectorParamsBuilder::new(dim as u64, Distance::Dot)
-                    .with_on_disk(false)
-                    .build(),
-            ),
-            ..CollectionParams::empty()
-        };
-
-        // Base segment
-        let temp_dir = Builder::new().prefix("segment_temp_dir").tempdir().unwrap();
-        let dir = Builder::new().prefix("segment_dir").tempdir().unwrap();
-        let mut holder = SegmentHolder::default();
-
-        let segment = random_segment(dir.path(), 100, point_count, dim as usize);
-
-        let segment_id = holder.add_new(segment);
-        let locked_holder: Arc<parking_lot::RwLock<_>> = Arc::new(RwLock::new(holder));
-
-        let hnsw_config = HnswConfig {
-            m: 16,
-            ef_construct: 100,
-            full_scan_threshold: 10,
-            max_indexing_threads: 0,
-            on_disk: None,
-            payload_m: None,
-        };
-
-        {
-            // Optimizers used in test
-            let index_optimizer = IndexingOptimizer::new(
-                2,
-                thresholds_config,
-                dir.path().to_owned(),
-                temp_dir.path().to_owned(),
-                collection_params.clone(),
-                hnsw_config.clone(),
-                Default::default(),
-            );
-            let config_mismatch_optimizer = ConfigMismatchOptimizer::new(
-                thresholds_config,
-                dir.path().to_owned(),
-                temp_dir.path().to_owned(),
-                collection_params.clone(),
-                hnsw_config.clone(),
-                Default::default(),
-            );
-
-            // Index optimizer should not optimize and put storage back in memory, nothing changed
-            let suggested_to_optimize =
-                index_optimizer.check_condition(locked_holder.clone(), &Default::default());
-            assert_eq!(
-                suggested_to_optimize.len(),
-                0,
-                "index optimizer should not run for index nor mmap"
-            );
-
-            // Config mismatch optimizer should not try to change the current state
-            let suggested_to_optimize = config_mismatch_optimizer
-                .check_condition(locked_holder.clone(), &Default::default());
-            assert_eq!(
-                suggested_to_optimize.len(),
-                0,
-                "config mismatch optimizer should not change anything"
-            );
-
-            // Ensure segment is not on disk
-            locked_holder
-                .read()
-                .iter()
-                .map(|(_, segment)| match segment {
-                    LockedSegment::Original(s) => s.read(),
-                    LockedSegment::Proxy(_) => unreachable!(),
-                })
-                .filter(|segment| segment.total_point_count() > 0)
-                .for_each(|segment| {
-                    assert!(
-                        !segment.config().vector_data[DEFAULT_VECTOR_NAME]
-                            .storage_type
-                            .is_on_disk(),
-                        "segment must not be on disk with mmap",
-                    );
-                });
-        }
-
-        // Remove explicit on_disk flag and go back to default
-        collection_params
-            .vectors
-            .get_params_mut(DEFAULT_VECTOR_NAME)
-            .unwrap()
-            .on_disk
-            .take();
-
-        // Optimizers used in test
-        let index_optimizer = IndexingOptimizer::new(
-            2,
-            thresholds_config,
-            dir.path().to_owned(),
-            temp_dir.path().to_owned(),
-            collection_params.clone(),
-            hnsw_config.clone(),
-            Default::default(),
-        );
-        let config_mismatch_optimizer = ConfigMismatchOptimizer::new(
-            thresholds_config,
-            dir.path().to_owned(),
-            temp_dir.path().to_owned(),
-            collection_params,
-            hnsw_config,
-            Default::default(),
-        );
-
-        let permit_cpu_count = num_rayon_threads(0);
-        let budget = ResourceBudget::new(permit_cpu_count, permit_cpu_count);
-        let permit = budget.try_acquire(0, permit_cpu_count).unwrap();
-
-        // Use indexing optimizer to build mmap
-        let changed = index_optimizer
-            .optimize(
-                locked_holder.clone(),
-                vec![segment_id],
-                permit,
-                budget.clone(),
-                &false.into(),
-            )
-            .unwrap();
-        assert!(
-            changed > 0,
-            "optimizer should have rebuilt this segment for mmap"
-        );
-        assert!(
-            locked_holder.read().get(segment_id).is_none(),
-            "optimized segment should be gone",
-        );
-        assert_eq!(locked_holder.read().len(), 2, "mmap must be built");
-
-        // Mismatch optimizer should not optimize yet, HNSW config is not changed yet
-        let suggested_to_optimize =
-            config_mismatch_optimizer.check_condition(locked_holder.clone(), &Default::default());
-        assert_eq!(suggested_to_optimize.len(), 0);
-
-        // Ensure new segment is on disk now
-        locked_holder
-            .read()
-            .iter()
-            .map(|(_, segment)| match segment {
-                LockedSegment::Original(s) => s.read(),
-                LockedSegment::Proxy(_) => unreachable!(),
-            })
-            .filter(|segment| segment.total_point_count() > 0)
-            .for_each(|segment| {
-                assert!(
-                    segment.config().vector_data[DEFAULT_VECTOR_NAME]
-                        .storage_type
-                        .is_on_disk(),
-                    "segment must be on disk with mmap",
-                );
-            });
-    }
-}
\ No newline at end of file
+        // Ensure that
\ No newline at end of file
