--- qdrant_lib_collection_src_collection_manager_optimizers_indexing_optimizer.rs_expectedoutput.txt (expected)+++ qdrant_lib_collection_src_collection_manager_optimizers_indexing_optimizer.rs_extracted.txt (actual)@@ -2,6 +2,7 @@ use std::path::{Path, PathBuf};
 use std::sync::Arc;
 
+use common::budget::ResourceBudget;
 use parking_lot::Mutex;
 use segment::common::operation_time_statistics::OperationDurationsAggregator;
 use segment::types::{HnswConfig, QuantizationConfig, SegmentType};
@@ -110,6 +111,10 @@                     return None; // Never optimize already optimized segment
                 }
 
+                // Apply indexing to plain segments which have grown too big
+                let are_all_vectors_indexed = segment_config.are_all_vectors_indexed();
+                let is_any_on_disk = segment_config.is_any_on_disk();
+
                 let indexing_threshold_bytes = self
                     .thresholds_config
                     .indexing_threshold_kb
@@ -132,8 +137,7 @@                         let is_big_for_mmap = storage_size_bytes >= mmap_threshold_bytes;
 
                         let optimize_for_index = is_big_for_index && !is_indexed;
-                        let optimize_for_mmap = if let Some(on_disk_config) = vector_config.on_disk
-                        {
+                        let optimize_for_mmap = if let Some(on_disk_config) = vector_config.on_disk {
                             on_disk_config && !is_on_disk
                         } else {
                             is_big_for_mmap && !is_on_disk
@@ -486,7 +490,7 @@             index_optimizer.check_condition(locked_holder.clone(), &excluded_ids);
         assert!(suggested_to_optimize.is_empty());
 
-        index_optimizer.thresholds_config.memmap_threshold_kb = 1000;
+        index_optimizer.thresholds_config.memmap_threshold_kb = 150;
         index_optimizer.thresholds_config.indexing_threshold_kb = 50;
 
         let suggested_to_optimize =
@@ -527,13 +531,13 @@ 
         let permit_cpu_count = num_rayon_threads(0);
         let budget = ResourceBudget::new(permit_cpu_count, permit_cpu_count);
-        let permit = budget.try_acquire(0, permit_cpu_count).unwrap();
 
         // ------ Plain -> Mmap & Indexed payload
         let suggested_to_optimize =
             index_optimizer.check_condition(locked_holder.clone(), &excluded_ids);
         assert!(suggested_to_optimize.contains(&large_segment_id));
         eprintln!("suggested_to_optimize = {suggested_to_optimize:#?}");
+        let permit = budget.try_acquire(0, permit_cpu_count).unwrap();
         index_optimizer
             .optimize(
                 locked_holder.clone(),
@@ -670,6 +674,9 @@             smallest_size + 3,
             "Testing that new data is added to an appendable segment only"
         );
+
+        let permit_cpu_count = num_rayon_threads(0);
+        let budget = ResourceBudget::new(permit_cpu_count, permit_cpu_count);
 
         // ---- New appendable segment should be created if none left
 
@@ -881,7 +888,7 @@                 dir.path().to_owned(),
                 temp_dir.path().to_owned(),
                 collection_params.clone(),
-                hnsw_config.clone(),
+                hnsw_config,
                 Default::default(),
             );
             let config_mismatch_optimizer = ConfigMismatchOptimizer::new(
@@ -889,7 +896,7 @@                 dir.path().to_owned(),
                 temp_dir.path().to_owned(),
                 collection_params.clone(),
-                hnsw_config.clone(),
+                hnsw_config,
                 Default::default(),
             );
 
@@ -945,7 +952,7 @@             dir.path().to_owned(),
             temp_dir.path().to_owned(),
             collection_params.clone(),
-            hnsw_config.clone(),
+            hnsw_config,
             Default::default(),
         );
         let config_mismatch_optimizer = ConfigMismatchOptimizer::new(
@@ -959,9 +966,9 @@ 
         let permit_cpu_count = num_rayon_threads(0);
         let budget = ResourceBudget::new(permit_cpu_count, permit_cpu_count);
+
+        // Use indexing optimizer to build mmap
         let permit = budget.try_acquire(0, permit_cpu_count).unwrap();
-
-        // Use indexing optimizer to build mmap
         let changed = index_optimizer
             .optimize(
                 locked_holder.clone(),
