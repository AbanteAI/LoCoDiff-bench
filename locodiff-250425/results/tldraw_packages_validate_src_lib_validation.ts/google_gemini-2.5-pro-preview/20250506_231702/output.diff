
index 7746ea03..6310c8ea 100644
--- a/tldraw_packages_validate_src_lib_validation.ts_expectedoutput.txt (expected):tmp/tmpzf13ifsj_expected.txt	
+++ b/tldraw_packages_validate_src_lib_validation.ts_extracted.txt (actual):tmp/tmpdgrcn7ge_actual.txt	
@@ -183,7 +183,7 @@ export class Validator<T> implements Validatable<T> {
 			(knownGoodValue, newValue) => {
 				const validated = this.validateUsingKnownGoodVersion(knownGoodValue as any, newValue)
 				if (Object.is(knownGoodValue, validated)) {
-					return knownGoodValue
+					return knownGoodValue as U // if knownGoodValue is T and validated is T, then this should be U
 				}
 				return otherValidationFn(validated)
 			}
@@ -637,401 +637,4 @@ export const bigint = typeofValidator<bigint>('bigint')
  *
  * ```ts
  * const trueValidator = T.literal(true)
- * ```
- *
- * @public
- */
-export function literal<T extends string | number | boolean>(expectedValue: T): Validator<T> {
-	return new Validator((actualValue) => {
-		if (actualValue !== expectedValue) {
-			throw new ValidationError(`Expected ${expectedValue}, got ${JSON.stringify(actualValue)}`)
-		}
-		return expectedValue
-	})
-}
-
-/**
- * Validates that a value is an array. To check the contents of the array, use T.arrayOf.
- *
- * @public
- */
-export const array = new Validator<unknown[]>((value) => {
-	if (!Array.isArray(value)) {
-		throw new ValidationError(`Expected an array, got ${typeToString(value)}`)
-	}
-	return value
-})
-
-/**
- * Validates that a value is an array whose contents matches the passed-in validator.
- *
- * @public
- */
-export function arrayOf<T>(itemValidator: Validatable<T>): ArrayOfValidator<T> {
-	return new ArrayOfValidator(itemValidator)
-}
-
-/** @public */
-export const unknownObject = new Validator<Record<string, unknown>>((value) => {
-	if (typeof value !== 'object' || value === null) {
-		throw new ValidationError(`Expected object, got ${typeToString(value)}`)
-	}
-	return value as Record<string, unknown>
-})
-
-/**
- * Validate an object has a particular shape.
- *
- * @public
- */
-export function object<Shape extends object>(config: {
-	readonly [K in keyof Shape]: Validatable<Shape[K]>
-}): ObjectValidator<MakeUndefinedOptional<Shape>> {
-	return new ObjectValidator(config) as any
-}
-
-function isPlainObject(value: unknown): value is Record<string, unknown> {
-	return (
-		typeof value === 'object' &&
-		value !== null &&
-		(Object.getPrototypeOf(value) === Object.prototype ||
-			Object.getPrototypeOf(value) === null ||
-			Object.getPrototypeOf(value) === STRUCTURED_CLONE_OBJECT_PROTOTYPE)
-	)
-}
-
-function isValidJson(value: any): value is JsonValue {
-	if (
-		value === null ||
-		typeof value === 'number' ||
-		typeof value === 'string' ||
-		typeof value === 'boolean'
-	) {
-		return true
-	}
-
-	if (Array.isArray(value)) {
-		return value.every(isValidJson)
-	}
-
-	if (isPlainObject(value)) {
-		return Object.values(value).every(isValidJson)
-	}
-
-	return false
-}
-
-/**
- * Validate that a value is valid JSON.
- *
- * @public
- */
-export const jsonValue: Validator<JsonValue> = new Validator<JsonValue>(
-	(value): JsonValue => {
-		if (isValidJson(value)) {
-			return value as JsonValue
-		}
-
-		throw new ValidationError(`Expected json serializable value, got ${typeof value}`)
-	},
-	(knownGoodValue, newValue) => {
-		if (Array.isArray(knownGoodValue) && Array.isArray(newValue)) {
-			let isDifferent = knownGoodValue.length !== newValue.length
-			for (let i = 0; i < newValue.length; i++) {
-				if (i >= knownGoodValue.length) {
-					isDifferent = true
-					jsonValue.validate(newValue[i])
-					continue
-				}
-				const prev = knownGoodValue[i]
-				const next = newValue[i]
-				if (Object.is(prev, next)) {
-					continue
-				}
-				const checked = jsonValue.validateUsingKnownGoodVersion!(prev, next)
-				if (!Object.is(checked, prev)) {
-					isDifferent = true
-				}
-			}
-			return isDifferent ? (newValue as JsonValue) : knownGoodValue
-		} else if (isPlainObject(knownGoodValue) && isPlainObject(newValue)) {
-			let isDifferent = false
-			for (const key of Object.keys(newValue)) {
-				if (!hasOwnProperty(knownGoodValue, key)) {
-					isDifferent = true
-					jsonValue.validate(newValue[key])
-					continue
-				}
-				const prev = knownGoodValue[key]
-				const next = newValue[key]
-				if (Object.is(prev, next)) {
-					continue
-				}
-				const checked = jsonValue.validateUsingKnownGoodVersion!(prev!, next)
-				if (!Object.is(checked, prev)) {
-					isDifferent = true
-				}
-			}
-			for (const key of Object.keys(knownGoodValue)) {
-				if (!hasOwnProperty(newValue, key)) {
-					isDifferent = true
-					break
-				}
-			}
-			return isDifferent ? (newValue as JsonValue) : knownGoodValue
-		} else {
-			return jsonValue.validate(newValue)
-		}
-	}
-)
-
-/**
- * Validate an object has a particular shape.
- *
- * @public
- */
-export function jsonDict(): DictValidator<string, JsonValue> {
-	return dict(string, jsonValue)
-}
-
-/**
- * Validation that an option is a dict with particular keys and values.
- *
- * @public
- */
-export function dict<Key extends string, Value>(
-	keyValidator: Validatable<Key>,
-	valueValidator: Validatable<Value>
-): DictValidator<Key, Value> {
-	return new DictValidator(keyValidator, valueValidator)
-}
-
-/**
- * Validate a union of several object types. Each object must have a property matching `key` which
- * should be a unique string.
- *
- * @example
- *
- * ```ts
- * const catValidator = T.object({ kind: T.literal('cat'), meow: T.boolean })
- * const dogValidator = T.object({ kind: T.literal('dog'), bark: T.boolean })
- * const animalValidator = T.union('kind', { cat: catValidator, dog: dogValidator })
- * ```
- *
- * @public
- */
-export function union<Key extends string, Config extends UnionValidatorConfig<Key, Config>>(
-	key: Key,
-	config: Config
-): UnionValidator<Key, Config> {
-	return new UnionValidator(
-		key,
-		config,
-		(_unknownValue, unknownVariant) => {
-			throw new ValidationError(
-				`Expected one of ${Object.keys(config)
-					.map((key) => JSON.stringify(key))
-					.join(' or ')}, got ${JSON.stringify(unknownVariant)}`,
-				[key]
-			)
-		},
-		false
-	)
-}
-
-/**
- * @internal
- */
-export function numberUnion<Key extends string, Config extends UnionValidatorConfig<Key, Config>>(
-	key: Key,
-	config: Config
-): UnionValidator<Key, Config> {
-	return new UnionValidator(
-		key,
-		config,
-		(unknownValue, unknownVariant) => {
-			throw new ValidationError(
-				`Expected one of ${Object.keys(config)
-					.map((key) => JSON.stringify(key))
-					.join(' or ')}, got ${JSON.stringify(unknownVariant)}`,
-				[key]
-			)
-		},
-		true
-	)
-}
-
-/**
- * A named object with an ID. Errors will be reported as being part of the object with the given
- * name.
- *
- * @public
- */
-export function model<T extends { readonly id: string }>(
-	name: string,
-	validator: Validatable<T>
-): Validator<T> {
-	return new Validator(
-		(value) => {
-			return prefixError(name, () => validator.validate(value))
-		},
-		(prevValue, newValue) => {
-			return prefixError(name, () => {
-				if (validator.validateUsingKnownGoodVersion) {
-					return validator.validateUsingKnownGoodVersion(prevValue, newValue)
-				} else {
-					return validator.validate(newValue)
-				}
-			})
-		}
-	)
-}
-
-/** @public */
-export function setEnum<T>(values: ReadonlySet<T>): Validator<T> {
-	return new Validator((value) => {
-		if (!values.has(value as T)) {
-			const valuesString = Array.from(values, (value) => JSON.stringify(value)).join(' or ')
-			throw new ValidationError(`Expected ${valuesString}, got ${value}`)
-		}
-		return value as T
-	})
-}
-
-/** @public */
-export function optional<T>(validator: Validatable<T>): Validator<T | undefined> {
-	return new Validator(
-		(value) => {
-			if (value === undefined) return undefined
-			return validator.validate(value)
-		},
-		(knownGoodValue, newValue) => {
-			if (knownGoodValue === undefined && newValue === undefined) return undefined
-			if (newValue === undefined) return undefined
-			if (validator.validateUsingKnownGoodVersion && knownGoodValue !== undefined) {
-				return validator.validateUsingKnownGoodVersion(knownGoodValue as T, newValue)
-			}
-			return validator.validate(newValue)
-		}
-	)
-}
-
-/** @public */
-export function nullable<T>(validator: Validatable<T>): Validator<T | null> {
-	return new Validator(
-		(value) => {
-			if (value === null) return null
-			return validator.validate(value)
-		},
-		(knownGoodValue, newValue) => {
-			if (newValue === null) return null
-			if (validator.validateUsingKnownGoodVersion && knownGoodValue !== null) {
-				return validator.validateUsingKnownGoodVersion(knownGoodValue as T, newValue)
-			}
-			return validator.validate(newValue)
-		}
-	)
-}
-
-/** @public */
-export function literalEnum<const Values extends readonly unknown[]>(
-	...values: Values
-): Validator<Values[number]> {
-	return setEnum(new Set(values))
-}
-
-function parseUrl(str: string) {
-	try {
-		return new URL(str)
-	} catch {
-		if (str.startsWith('/') || str.startsWith('./')) {
-			try {
-				return new URL(str, 'http://example.com')
-			} catch {
-				throw new ValidationError(`Expected a valid url, got ${JSON.stringify(str)}`)
-			}
-		}
-		throw new ValidationError(`Expected a valid url, got ${JSON.stringify(str)}`)
-	}
-}
-
-const validLinkProtocols = new Set(['http:', 'https:', 'mailto:'])
-
-/**
- * Validates that a value is a url safe to use as a link.
- *
- * @public
- */
-export const linkUrl = string.check((value) => {
-	if (value === '') return
-	const url = parseUrl(value)
-
-	if (!validLinkProtocols.has(url.protocol.toLowerCase())) {
-		throw new ValidationError(
-			`Expected a valid url, got ${JSON.stringify(value)} (invalid protocol)`
-		)
-	}
-})
-
-// N.B. asset: is a reference to the local indexedDB object store.
-const validSrcProtocols = new Set(['http:', 'https:', 'data:', 'asset:'])
-
-/**
- * Validates that a valid is a url safe to load as an asset.
- *
- * @public
- */
-export const srcUrl = string.check((value) => {
-	if (value === '') return
-	const url = parseUrl(value)
-
-	if (!validSrcProtocols.has(url.protocol.toLowerCase())) {
-		throw new ValidationError(
-			`Expected a valid url, got ${JSON.stringify(value)} (invalid protocol)`
-		)
-	}
-})
-
-/**
- * Validates an http(s) url
- *
- * @public
- */
-export const httpUrl = string.check((value) => {
-	if (value === '') return
-	const url = parseUrl(value)
-
-	if (!url.protocol.toLowerCase().match(/^https?:$/)) {
-		throw new ValidationError(
-			`Expected a valid url, got ${JSON.stringify(value)} (invalid protocol)`
-		)
-	}
-})
-
-/**
- * Validates that a value is an IndexKey.
- * @public
- */
-export const indexKey = string.refine<IndexKey>((key) => {
-	try {
-		validateIndexKey(key)
-		return key
-	} catch {
-		throw new ValidationError(`Expected an index key, got ${JSON.stringify(key)}`)
-	}
-})
-
-/**
- * Validate a value against one of two types.
- *
- * @public
- */
-export function or<T1, T2>(v1: Validatable<T1>, v2: Validatable<T2>): Validator<T1 | T2> {
-	return new Validator((value) => {
-		try {
-			return v1.validate(value)
-		} catch {
-			return v2.validate(value)
-		}
-	})
-}
\ No newline at end of file
+ *
\ No newline at end of file
