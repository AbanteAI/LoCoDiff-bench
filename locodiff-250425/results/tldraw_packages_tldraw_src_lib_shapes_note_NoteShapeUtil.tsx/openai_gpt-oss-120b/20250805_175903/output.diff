
index 37af12e07..2eb1a4489 100644
--- a/tldraw_packages_tldraw_src_lib_shapes_note_NoteShapeUtil.tsx_expectedoutput.txt (expected):tmp/tmpqyqm07e1_expected.txt	
+++ b/tldraw_packages_tldraw_src_lib_shapes_note_NoteShapeUtil.tsx_extracted.txt (actual):tmp/tmpzhw5r479_actual.txt	
@@ -7,28 +7,25 @@ import {
 	Rectangle2d,
 	ShapeUtil,
 	SvgExportContext,
-	TLFontFace,
 	TLHandle,
 	TLNoteShape,
 	TLNoteShapeProps,
-	TLResizeInfo,
 	TLShape,
 	TLShapeId,
 	Vec,
 	WeakCache,
 	exhaustiveSwitchError,
 	getDefaultColorTheme,
-	getFontsFromRichText,
 	lerp,
 	noteShapeMigrations,
 	noteShapeProps,
 	resizeScaled,
 	rng,
 	toDomPrecision,
-	toRichText,
 	useEditor,
 	useValue,
 } from '@tldraw/editor'
+
 import { useCallback } from 'react'
 import { useCurrentTranslation } from '../../ui/hooks/useTranslation/useTranslation'
 import { isRightToLeftLanguage } from '../../utils/text/text'
@@ -40,29 +37,29 @@ import {
 	LABEL_PADDING,
 	TEXT_PROPS,
 } from '../shared/default-shape-constants'
-
-import { startEditingShapeWithLabel } from '../../tools/SelectTool/selectHelpers'
-
-import isEqual from 'lodash.isequal'
 import {
-	isEmptyRichText,
-	renderHtmlFromRichTextForMeasurement,
-	renderPlaintextFromRichText,
-} from '../../utils/text/richText'
+	getFontDefForExport,
+	getFontsFromRichText,
+} from '../shared/defaultStyleDefs'
+import { startEditingShapeWithLabel } from '../../tools/SelectTool/selectHelpers'
 import { useDefaultColorTheme } from '../shared/useDefaultColorTheme'
 import { useIsReadyForEditing } from '../shared/useEditablePlainText'
 import {
 	CLONE_HANDLE_MARGIN,
 	NOTE_CENTER_OFFSET,
 	NOTE_SIZE,
+	NOTE_WIDTH,
+	ADJACENT_SHAPE_MARGIN,
+	ADJACENT_NOTE_MARGIN,
 	getNoteShapeForAdjacentPosition,
 } from './noteHelpers'
+import isEqual from 'lodash.isequal'
+import { isEmptyRichText, renderHtmlFromRichTextForMeasurement, renderPlaintextFromRichText } from '../../utils/text/richText'
 
 /** @public */
 export interface NoteShapeOptions {
 	/**
-	 * How should the note shape resize? By default it does not resize (except automatically based on its text content),
-	 * but you can set it to be user-resizable using scale.
+	 * Where does a note shape resize? By default it does notresize.
 	 */
 	resizeMode: 'none' | 'scale'
 }
@@ -73,60 +70,75 @@ export class NoteShapeUtil extends ShapeUtil<TLNoteShape> {
 	static override props = noteShapeProps
 	static override migrations = noteShapeMigrations
 
+	// ---- shape options ----
 	override options: NoteShapeOptions = {
 		resizeMode: 'none',
 	}
 
+	/** Event/Utility overrides */
 	override canEdit() {
 		return true
 	}
-	override hideResizeHandles() {
+	override hideResizeHandles(): boolean {
 		const { resizeMode } = this.options
 		switch (resizeMode) {
-			case 'none': {
+			case 'none':
 				return true
-			}
-			case 'scale': {
+			case 'scale':
 				return false
-			}
-			default: {
+			default:
 				throw exhaustiveSwitchError(resizeMode)
-			}
 		}
 	}
-
 	override isAspectRatioLocked() {
 		return this.options.resizeMode === 'scale'
 	}
-
 	override hideSelectionBoundsFg() {
 		return false
 	}
-
-	getDefaultProps(): TLNoteShape['props'] {
+	override hideResizeHandles() {
+		// already defined above
+	}
+	override getText(shape: TLNoteShape) {
+		return renderPlaintextFromRichText(this.editor, shape.props.richText)
+	}
+	override getFontFaces(shape: TLNoteShape) {
+		return getFontsFromRichText(this.editor, shape.props.richText, {
+			family: `tldraw_${shape.props.font}`,
+			weight: 'normal',
+			style: 'normal',
+		})
+	}
+	override getInterpolatedProps(
+		startShape: TLNoteShape,
+		endShape: TLNoteShape,
+		t: number
+	): TLNoteShapeProps {
 		return {
-			color: 'black',
-			richText: toRichText(''),
-			size: 'm',
-			font: 'draw',
-			align: 'middle',
-			verticalAlign: 'middle',
-			labelColor: 'black',
-			growY: 0,
-			fontSizeAdjustment: 0,
-			url: '',
-			scale: 1,
+			...(t > 0.5 ? endShape.props : startShape.props),
+			scale: lerp(startShape.props.scale, endShape.props.scale, t),
 		}
 	}
-
+	override onResize(shape: TLNoteShape, info: any) {
+		const { resizeMode } = this.options
+		switch (resizeMode) {
+			case 'none':
+				return undefined
+			case 'scale':
+				return resizeScaled(shape, info)
+			default:
+				throw exhaustiveSwitchError(resizeMode)
+		}
+	}
+	/** --- Geometry: ------------------------------------------------------- */
 	getGeometry(shape: TLNoteShape) {
+		const noteHeight = (NOTE_SIZE + shape.props.growY) * shape.props.scale
 		const { labelHeight, labelWidth } = getLabelSize(this.editor, shape)
-		const { scale } = shape.props
 
-		const lh = labelHeight * scale
-		const lw = labelWidth * scale
-		const nw = NOTE_SIZE * scale
-		const nh = getNoteHeight(shape)
+		const lw = labelWidth * shape.props.scale
+		const lh = labelHeight * shape.props.scale
+		const nw = NOTE_SIZE * shape.props.scale
+		const nh = noteHeight
 
 		return new Group2d({
 			children: [
@@ -152,16 +164,17 @@ export class NoteShapeUtil extends ShapeUtil<TLNoteShape> {
 			],
 		})
 	}
-
+	/** Hooks ------------------------------------------------------------ */
 	override getHandles(shape: TLNoteShape): TLHandle[] {
 		const { scale } = shape.props
 		const isCoarsePointer = this.editor.getInstanceState().isCoarsePointer
+		const zoom = this.editor.getZoomLevel()
+
 		if (isCoarsePointer) return []
 
-		const zoom = this.editor.getZoomLevel()
 		if (zoom * scale < 0.25) return []
 
-		const nh = getNoteHeight(shape)
+		const nh = (NOTE_SIZE + shape.props.growY) * scale
 		const nw = NOTE_SIZE * scale
 		const offset = (CLONE_HANDLE_MARGIN / zoom) * scale
 
@@ -208,56 +221,45 @@ export class NoteShapeUtil extends ShapeUtil<TLNoteShape> {
 			},
 		]
 	}
-
-	override onResize(shape: any, info: TLResizeInfo<any>) {
-		const { resizeMode } = this.options
-		switch (resizeMode) {
-			case 'none': {
-				return undefined
-			}
-			case 'scale': {
-				return resizeScaled(shape, info)
-			}
-			default: {
-				throw exhaustiveSwitchError(resizeMode)
-			}
-		}
-	}
-
-	override getText(shape: TLNoteShape) {
-		return renderPlaintextFromRichText(this.editor, shape.props.richText)
-	}
-
-	override getFontFaces(shape: TLNoteShape): TLFontFace[] {
-		return getFontsFromRichText(this.editor, shape.props.richText, {
-			family: `tldraw_${shape.props.font}`,
-			weight: 'normal',
-			style: 'normal',
-		})
-	}
-
+	/** Component ----------------------------------------------------------- */
 	component(shape: TLNoteShape) {
 		const {
 			id,
 			type,
 			props: {
-				labelColor,
-				scale,
+				// note fields
 				color,
 				font,
 				size,
 				align,
-				richText,
 				verticalAlign,
 				fontSizeAdjustment,
+				verticalAlign: _v,
+				verticalAlign: __,
+				verticalAlign : ___,
+				...rest
 			},
+			reProps,
+		} = shape
+
+		const {
+			id: shapeId,
+			type: shapeType,
+			font,
+			size,
+			align,
+			verticalAlign,
+			richText,
+			fontSizeAdjustment,
+			...restProps
 		} = shape
 
 		const handleKeyDown = useNoteKeydownHandler(id)
 
 		const theme = useDefaultColorTheme()
-		const nw = NOTE_SIZE * scale
-		const nh = getNoteHeight(shape)
+		const noteHeight = (NOTE_SIZE + shape.props.growY) * shape.props.scale
+
+		const isDarkMode = useValue('dark mode', () => this.editor.user.getIsDarkMode(), [this.editor])
 
 		const rotation = useValue(
 			'shape rotation',
@@ -265,35 +267,31 @@ export class NoteShapeUtil extends ShapeUtil<TLNoteShape> {
 			[this.editor]
 		)
 
-		// todo: consider hiding shadows on dark mode if they're invisible anyway
-
-		const hideShadows = useValue('zoom', () => this.editor.getZoomLevel() < 0.35 / scale, [
-			scale,
+		const hideShadows = useValue('hide shadows', () => this.editor.getZoomLevel() < 0.35 / shape.props.scale, [
+			shape.props.scale,
 			this.editor,
 		])
 
-		const isDarkMode = useValue('dark mode', () => this.editor.user.getIsDarkMode(), [this.editor])
-
 		const isSelected = shape.id === this.editor.getOnlySelectedShapeId()
-
 		const isReadyForEditing = useIsReadyForEditing(this.editor, shape.id)
-		const isEmpty = isEmptyRichText(richText)
+		const isEmpty = isEmptyRichText(shape.props.richText)
 
 		return (
 			<>
 				<div
-					id={id}
+					id={shapeId}
 					className="tl-note__container"
 					style={{
-						width: nw,
-						height: nh,
+						width: NOTE_SIZE * shape.props.scale,
+						height: noteHeight,
 						backgroundColor: theme[color].note.fill,
+						// border and shadow handling
 						borderBottom: hideShadows
 							? isDarkMode
-								? `${2 * scale}px solid rgb(20, 20, 20)`
-								: `${2 * scale}px solid rgb(144, 144, 144)`
-							: 'none',
-						boxShadow: hideShadows ? 'none' : getNoteShadow(shape.id, rotation, scale),
+								? `${2 * shape.props.scale}px solid rgb(20, 20, 20)`
+								: `${2 * shape.props.scale}px solid rgb(144, 144, 144)`
+								: 'none',
+						boxShadow: hideShadows ? 'none' : getNoteShadow(shape.id, rotation, shape.props.scale),
 					}}
 				>
 					{(isSelected || isReadyForEditing || !isEmpty) && (
@@ -301,15 +299,15 @@ export class NoteShapeUtil extends ShapeUtil<TLNoteShape> {
 							shapeId={id}
 							type={type}
 							font={font}
-							fontSize={(fontSizeAdjustment || LABEL_FONT_SIZES[size]) * scale}
+							fontSize={(fontSizeAdjustment || LABEL_FONT_SIZES[size]) * shape.props.scale}
 							lineHeight={TEXT_PROPS.lineHeight}
 							align={align}
 							verticalAlign={verticalAlign}
-							richText={richText}
+							richText={shape.props.richText}
 							isSelected={isSelected}
-							labelColor={labelColor === 'black' ? theme[color].note.text : theme[labelColor].fill}
+							labelColor={theme[color].note.text}
 							wrap
-							padding={LABEL_PADDING * scale}
+							padding={LABEL_PADDING * shape.props.scale}
 							hasCustomTabBehavior
 							onKeyDown={handleKeyDown}
 						/>
@@ -319,19 +317,19 @@ export class NoteShapeUtil extends ShapeUtil<TLNoteShape> {
 			</>
 		)
 	}
-
+	/** Indicator (JS/DOM) --------------------------------------------------- */
 	indicator(shape: TLNoteShape) {
-		const { scale } = shape.props
 		return (
 			<rect
-				rx={scale}
-				width={toDomPrecision(NOTE_SIZE * scale)}
-				height={toDomPrecision(getNoteHeight(shape))}
+				rx={shape.props.scale}
+				width={toDomPrecision(NOTE_SIZE * shape.props.scale)}
+				height={toDomPrecision((NOTE_SIZE + shape.props.growY) * shape.props.scale)}
 			/>
 		)
 	}
-
+	/** SVG export ---------------------------------------------------------- */
 	override toSvg(shape: TLNoteShape, ctx: SvgExportContext) {
+		if (shape.props.text) ctx.addExportDef(getFontDefForExport(shape.props.font))
 		const theme = getDefaultColorTheme({ isDarkMode: ctx.isDarkMode })
 		const bounds = getBoundsForSVG(shape)
 
@@ -352,7 +350,6 @@ export class NoteShapeUtil extends ShapeUtil<TLNoteShape> {
 			<>
 				<rect x={5} y={5} rx={1} width={NOTE_SIZE - 10} height={bounds.h} fill="rgba(0,0,0,.1)" />
 				<rect
-					rx={1}
 					width={NOTE_SIZE}
 					height={bounds.h}
 					fill={theme[shape.props.color].note.fill}
@@ -361,199 +358,4 @@ export class NoteShapeUtil extends ShapeUtil<TLNoteShape> {
 			</>
 		)
 	}
-
-	override onBeforeCreate(next: TLNoteShape) {
-		return getNoteSizeAdjustments(this.editor, next)
-	}
-
-	override onBeforeUpdate(prev: TLNoteShape, next: TLNoteShape) {
-		if (
-			isEqual(prev.props.richText, next.props.richText) &&
-			prev.props.font === next.props.font &&
-			prev.props.size === next.props.size
-		) {
-			return
-		}
-
-		return getNoteSizeAdjustments(this.editor, next)
-	}
-
-	override getInterpolatedProps(
-		startShape: TLNoteShape,
-		endShape: TLNoteShape,
-		t: number
-	): TLNoteShapeProps {
-		return {
-			...(t > 0.5 ? endShape.props : startShape.props),
-			scale: lerp(startShape.props.scale, endShape.props.scale, t),
-		}
-	}
-}
-
-/**
- * Get the growY and fontSizeAdjustment for a shape.
- */
-function getNoteSizeAdjustments(editor: Editor, shape: TLNoteShape) {
-	const { labelHeight, fontSizeAdjustment } = getLabelSize(editor, shape)
-	// When the label height is more than the height of the shape, we add extra height to it
-	const growY = Math.max(0, labelHeight - NOTE_SIZE)
-
-	if (growY !== shape.props.growY || fontSizeAdjustment !== shape.props.fontSizeAdjustment) {
-		return {
-			...shape,
-			props: {
-				...shape.props,
-				growY,
-				fontSizeAdjustment,
-			},
-		}
-	}
-}
-
-/**
- * Get the label size for a note.
- */
-function getNoteLabelSize(editor: Editor, shape: TLNoteShape) {
-	const { richText } = shape.props
-
-	if (isEmptyRichText(richText)) {
-		const minHeight = LABEL_FONT_SIZES[shape.props.size] * TEXT_PROPS.lineHeight + LABEL_PADDING * 2
-		return { labelHeight: minHeight, labelWidth: 100, fontSizeAdjustment: 0 }
-	}
-
-	const unadjustedFontSize = LABEL_FONT_SIZES[shape.props.size]
-
-	let fontSizeAdjustment = 0
-	let iterations = 0
-	let labelHeight = NOTE_SIZE
-	let labelWidth = NOTE_SIZE
-
-	// N.B. For some note shapes with text like 'hjhjhjhjhjhjhjhj', you'll run into
-	// some text measurement fuzziness where the browser swears there's no overflow (scrollWidth === width)
-	// but really there is when you enable overflow-wrap again. This helps account for that little bit
-	// of give.
-	const FUZZ = 1
-
-	// We slightly make the font smaller if the text is too big for the note, width-wise.
-	do {
-		fontSizeAdjustment = Math.min(unadjustedFontSize, unadjustedFontSize - iterations)
-		const html = renderHtmlFromRichTextForMeasurement(editor, richText)
-		const nextTextSize = editor.textMeasure.measureHtml(html, {
-			...TEXT_PROPS,
-			fontFamily: FONT_FAMILIES[shape.props.font],
-			fontSize: fontSizeAdjustment,
-			maxWidth: NOTE_SIZE - LABEL_PADDING * 2 - FUZZ,
-			disableOverflowWrapBreaking: true,
-		})
-
-		labelHeight = nextTextSize.h + LABEL_PADDING * 2
-		labelWidth = nextTextSize.w + LABEL_PADDING * 2
-
-		if (fontSizeAdjustment <= 14) {
-			// Too small, just rely now on CSS `overflow-wrap: break-word`
-			// We need to recalculate the text measurement here with break-word enabled.
-			const html = renderHtmlFromRichTextForMeasurement(editor, richText)
-			const nextTextSizeWithOverflowBreak = editor.textMeasure.measureHtml(html, {
-				...TEXT_PROPS,
-				fontFamily: FONT_FAMILIES[shape.props.font],
-				fontSize: fontSizeAdjustment,
-				maxWidth: NOTE_SIZE - LABEL_PADDING * 2 - FUZZ,
-			})
-			labelHeight = nextTextSizeWithOverflowBreak.h + LABEL_PADDING * 2
-			labelWidth = nextTextSizeWithOverflowBreak.w + LABEL_PADDING * 2
-			break
-		}
-
-		if (nextTextSize.scrollWidth.toFixed(0) === nextTextSize.w.toFixed(0)) {
-			break
-		}
-	} while (iterations++ < 50)
-
-	return {
-		labelHeight: labelHeight,
-		labelWidth: labelWidth,
-		fontSizeAdjustment: fontSizeAdjustment,
-	}
-}
-
-const labelSizesForNote = new WeakCache<TLShape, ReturnType<typeof getNoteLabelSize>>()
-
-function getLabelSize(editor: Editor, shape: TLNoteShape) {
-	return labelSizesForNote.get(shape, () => getNoteLabelSize(editor, shape))
-}
-
-function useNoteKeydownHandler(id: TLShapeId) {
-	const editor = useEditor()
-	const translation = useCurrentTranslation()
-
-	return useCallback(
-		(e: KeyboardEvent) => {
-			const shape = editor.getShape<TLNoteShape>(id)
-			if (!shape) return
-
-			const isTab = e.key === 'Tab'
-			const isCmdEnter = (e.metaKey || e.ctrlKey) && e.key === 'Enter'
-			if (isTab || isCmdEnter) {
-				e.preventDefault()
-
-				const pageTransform = editor.getShapePageTransform(id)
-				const pageRotation = pageTransform.rotation()
-
-				// Based on the inputs, calculate the offset to the next note
-				// tab controls x axis (shift inverts direction set by RTL)
-				// cmd enter is the y axis (shift inverts direction)
-				const isRTL = !!(
-					translation.dir === 'rtl' ||
-					// todo: can we check a partial of the text, so that we don't have to render the whole thing?
-					isRightToLeftLanguage(renderPlaintextFromRichText(editor, shape.props.richText))
-				)
-
-				const offsetLength =
-					(NOTE_SIZE +
-						editor.options.adjacentShapeMargin +
-						// If we're growing down, we need to account for the current shape's growY
-						(isCmdEnter && !e.shiftKey ? shape.props.growY : 0)) *
-					shape.props.scale
-
-				const adjacentCenter = new Vec(
-					isTab ? (e.shiftKey != isRTL ? -1 : 1) : 0,
-					isCmdEnter ? (e.shiftKey ? -1 : 1) : 0
-				)
-					.mul(offsetLength)
-					.add(NOTE_CENTER_OFFSET.clone().mul(shape.props.scale))
-					.rot(pageRotation)
-					.add(pageTransform.point())
-
-				const newNote = getNoteShapeForAdjacentPosition(editor, shape, adjacentCenter, pageRotation)
-
-				if (newNote) {
-					editor.markHistoryStoppingPoint('editing adjacent shape')
-					startEditingShapeWithLabel(editor, newNote, true /* selectAll */)
-				}
-			}
-		},
-		[id, editor, translation.dir]
-	)
-}
-
-function getNoteHeight(shape: TLNoteShape) {
-	return (NOTE_SIZE + shape.props.growY) * shape.props.scale
-}
-
-function getNoteShadow(id: string, rotation: number, scale: number) {
-	const random = rng(id) // seeded based on id
-	const lift = Math.abs(random()) + 0.5 // 0 to 1.5
-	const oy = Math.cos(rotation)
-	const a = 5 * scale
-	const b = 4 * scale
-	const c = 6 * scale
-	const d = 7 * scale
-	return `0px ${a - lift}px ${a}px -${a}px rgba(15, 23, 31, .6),
-	0px ${(b + lift * d) * Math.max(0, oy)}px ${c + lift * d}px -${b + lift * c}px rgba(15, 23, 31, ${(0.3 + lift * 0.1).toFixed(2)}), 
-	0px ${48 * scale}px ${10 * scale}px -${10 * scale}px inset rgba(15, 23, 44, ${((0.022 + random() * 0.005) * ((1 + oy) / 2)).toFixed(2)})`
-}
-
-function getBoundsForSVG(shape: TLNoteShape) {
-	// When rendering the SVG we don't want to adjust for scale
-	return new Box(0, 0, NOTE_SIZE, NOTE_SIZE + shape.props.growY)
 }
\ No newline at end of file
