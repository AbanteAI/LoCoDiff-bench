
index 5dbd9e9bd..2806583bd 100644
--- a/qdrant_lib_segment_src_segment_constructor_segment_constructor_base.rs_expectedoutput.txt (expected):tmp/tmpl0cy4k47_expected.txt	
+++ b/qdrant_lib_segment_src_segment_constructor_segment_constructor_base.rs_extracted.txt (actual):tmp/tmphh7j5gbi_actual.txt	
@@ -214,12 +214,14 @@ pub(crate) fn open_vector_storage(
         VectorStorageType::ChunkedMmap => {
             if let Some(multi_vec_config) = &vector_config.multivector_config {
                 match storage_element_type {
-                    VectorStorageDatatype::Float32 => open_appendable_memmap_multi_vector_storage(
-                        vector_storage_path,
-                        vector_config.size,
-                        vector_config.distance,
-                        *multi_vec_config,
-                    ),
+                    VectorStorageDatatype::Float32 => {
+                        open_appendable_memmap_multi_vector_storage(
+                            vector_storage_path,
+                            vector_config.size,
+                            vector_config.distance,
+                            *multi_vec_config,
+                        )
+                    }
                     VectorStorageDatatype::Uint8 => {
                         open_appendable_memmap_multi_vector_storage_byte(
                             vector_storage_path,
@@ -360,12 +362,6 @@ pub(crate) fn create_rocksdb_id_tracker(
     SimpleIdTracker::open(database)
 }
 
-pub(crate) fn create_immutable_id_tracker(
-    segment_path: &Path,
-) -> OperationResult<ImmutableIdTracker> {
-    ImmutableIdTracker::open(segment_path)
-}
-
 pub(crate) fn get_payload_index_path(segment_path: &Path) -> PathBuf {
     segment_path.join(PAYLOAD_INDEX_PATH)
 }
@@ -581,7 +577,8 @@ fn create_segment(
         ))
     };
 
-    let mut vector_storages = HashMap::new();
+    let mut vector_storages: HashMap<VectorName, Arc<AtomicRefCell<VectorStorageEnum>>> =
+        HashMap::new();
 
     for (vector_name, vector_config) in &config.vector_data {
         let vector_storage_path = get_vector_storage_path(segment_path, vector_name);
@@ -704,8 +701,8 @@ fn create_segment(
         vector_data.insert(
             vector_name.to_owned(),
             VectorData {
-                vector_storage,
                 vector_index,
+                vector_storage,
                 quantized_vectors: sp(None),
             },
         );
@@ -763,8 +760,9 @@ pub fn load_segment(path: &Path, stopped: &AtomicBool) -> OperationResult<Option
 
         if stored_version > app_version {
             return Err(OperationError::service_error(format!(
-                "Data version {stored_version} is newer than application version {app_version}. \
-                Please upgrade the application. Compatibility is not guaranteed."
+                "Data version {} is newer than application version {}. \
+                Please upgrade the application. Compatibility is not guaranteed.",
+                stored_version, app_version
             )));
         }
 
@@ -792,10 +790,6 @@ pub fn load_segment(path: &Path, stopped: &AtomicBool) -> OperationResult<Option
     Ok(Some(segment))
 }
 
-pub fn new_segment_path(segments_path: &Path) -> PathBuf {
-    segments_path.join(Uuid::new_v4().to_string())
-}
-
 /// Build segment instance using given configuration.
 /// Builder will generate folder for the segment and store all segment information inside it.
 ///
@@ -829,6 +823,10 @@ pub fn build_segment(
     Ok(segment)
 }
 
+pub fn new_segment_path(segments_path: &Path) -> PathBuf {
+    segments_path.join(Uuid::new_v4().to_string())
+}
+
 /// Load v0.3.* segment data and migrate to current version
 #[allow(deprecated)]
 fn load_segment_state_v3(segment_path: &Path) -> OperationResult<SegmentState> {
