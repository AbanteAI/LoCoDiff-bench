
index 5dbd9e9b..53092335 100644
--- a/qdrant_lib_segment_src_segment_constructor_segment_constructor_base.rs_expectedoutput.txt (expected):tmp/tmpkompy97x_expected.txt	
+++ b/qdrant_lib_segment_src_segment_constructor_segment_constructor_base.rs_extracted.txt (actual):tmp/tmpt4hxnqyi_actual.txt	
@@ -2,27 +2,24 @@ use std::collections::HashMap;
 use std::fs::File;
 use std::io::Read;
 use std::path::{Path, PathBuf};
-use std::sync::Arc;
 use std::sync::atomic::AtomicBool;
+use std::sync::Arc;
 
 use atomic_refcell::AtomicRefCell;
 use common::budget::ResourcePermit;
-use common::flags::FeatureFlags;
 use io::storage_version::StorageVersion;
 use log::info;
 use parking_lot::{Mutex, RwLock};
-use rocksdb::DB;
 use serde::Deserialize;
 use uuid::Uuid;
 
-use crate::common::operation_error::{OperationError, OperationResult, check_process_stopped};
+use crate::common::operation_error::{check_process_stopped, OperationError, OperationResult};
 use crate::common::rocksdb_wrapper::{DB_MAPPING_CF, DB_VECTOR_CF, open_db};
 use crate::data_types::vectors::DEFAULT_VECTOR_NAME;
 use crate::id_tracker::immutable_id_tracker::ImmutableIdTracker;
 use crate::id_tracker::mutable_id_tracker::MutableIdTracker;
 use crate::id_tracker::simple_id_tracker::SimpleIdTracker;
 use crate::id_tracker::{IdTracker, IdTrackerEnum, IdTrackerSS};
-use crate::index::VectorIndexEnum;
 use crate::index::hnsw_index::gpu::gpu_devices_manager::LockedGpuDevice;
 use crate::index::hnsw_index::hnsw::{HNSWIndex, HnswIndexOpenArgs};
 use crate::index::plain_vector_index::PlainVectorIndex;
@@ -31,15 +28,15 @@ use crate::index::sparse_index::sparse_vector_index::{
     self, SparseVectorIndex, SparseVectorIndexOpenArgs,
 };
 use crate::index::struct_payload_index::StructPayloadIndex;
+use crate::index::VectorIndexEnum;
 use crate::payload_storage::mmap_payload_storage::MmapPayloadStorage;
 use crate::payload_storage::on_disk_payload_storage::OnDiskPayloadStorage;
 use crate::payload_storage::payload_storage_enum::PayloadStorageEnum;
 use crate::payload_storage::simple_payload_storage::SimplePayloadStorage;
-use crate::segment::{SEGMENT_STATE_FILE, Segment, SegmentVersion, VectorData};
+use crate::segment::{Segment, SegmentVersion, VectorData, SEGMENT_STATE_FILE};
 use crate::types::{
     Distance, Indexes, PayloadStorageType, SegmentConfig, SegmentState, SegmentType, SeqNumberType,
-    SparseVectorStorageType, VectorDataConfig, VectorName, VectorStorageDatatype,
-    VectorStorageType,
+    SparseVectorStorageType, VectorDataConfig, VectorName, VectorStorageDatatype, VectorStorageType,
 };
 use crate::vector_storage::dense::appendable_dense_vector_storage::{
     open_appendable_in_ram_vector_storage, open_appendable_in_ram_vector_storage_byte,
@@ -49,19 +46,15 @@ use crate::vector_storage::dense::appendable_dense_vector_storage::{
 use crate::vector_storage::dense::memmap_dense_vector_storage::{
     open_memmap_vector_storage, open_memmap_vector_storage_byte, open_memmap_vector_storage_half,
 };
-use crate::vector_storage::dense::simple_dense_vector_storage::{
-    open_simple_dense_byte_vector_storage, open_simple_dense_half_vector_storage,
-    open_simple_dense_vector_storage,
-};
+use crate::vector_storage::dense::simple_dense_vector_storage::open_simple_dense_vector_storage;
 use crate::vector_storage::multi_dense::appendable_mmap_multi_dense_vector_storage::{
-    open_appendable_in_ram_multi_vector_storage, open_appendable_in_ram_multi_vector_storage_byte,
+    open_appendable_in_ram_multi_vector_storage,
+    open_appendable_in_ram_multi_vector_storage_byte,
     open_appendable_in_ram_multi_vector_storage_half, open_appendable_memmap_multi_vector_storage,
-    open_appendable_memmap_multi_vector_storage_byte,
-    open_appendable_memmap_multi_vector_storage_half,
+    open_appendable_memmap_multi_vector_storage_byte, open_appendable_memmap_multi_vector_storage_half,
 };
 use crate::vector_storage::multi_dense::simple_multi_dense_vector_storage::{
     open_simple_multi_dense_vector_storage, open_simple_multi_dense_vector_storage_byte,
-    open_simple_multi_dense_vector_storage_half,
 };
 use crate::vector_storage::quantized::quantized_vectors::QuantizedVectors;
 use crate::vector_storage::sparse::mmap_sparse_vector_storage::MmapSparseVectorStorage;
@@ -85,10 +78,7 @@ fn get_vector_name_with_prefix(prefix: &str, vector_name: &VectorName) -> String
 }
 
 pub fn get_vector_storage_path(segment_path: &Path, vector_name: &VectorName) -> PathBuf {
-    segment_path.join(get_vector_name_with_prefix(
-        VECTOR_STORAGE_PATH,
-        vector_name,
-    ))
+    segment_path.join(get_vector_name_with_prefix(VECTOR_STORAGE_PATH, vector_name))
 }
 
 pub fn get_vector_index_path(segment_path: &Path, vector_name: &VectorName) -> PathBuf {
@@ -105,18 +95,16 @@ pub(crate) fn open_vector_storage(
     let storage_element_type = vector_config.datatype.unwrap_or_default();
 
     match vector_config.storage_type {
-        // In memory
         VectorStorageType::Memory => {
             let db_column_name = get_vector_name_with_prefix(DB_VECTOR_CF, vector_name);
-
-            if let Some(multi_vec_config) = &vector_config.multivector_config {
+            if let Some(multivec_config) = &vector_config.multivector_config {
                 match storage_element_type {
                     VectorStorageDatatype::Float32 => open_simple_multi_dense_vector_storage(
                         database.clone(),
                         &db_column_name,
                         vector_config.size,
                         vector_config.distance,
-                        *multi_vec_config,
+                        *multivec_config,
                         stopped,
                     ),
                     VectorStorageDatatype::Uint8 => open_simple_multi_dense_vector_storage_byte(
@@ -124,17 +112,19 @@ pub(crate) fn open_vector_storage(
                         &db_column_name,
                         vector_config.size,
                         vector_config.distance,
-                        *multi_vec_config,
-                        stopped,
-                    ),
-                    VectorStorageDatatype::Float16 => open_simple_multi_dense_vector_storage_half(
-                        database.clone(),
-                        &db_column_name,
-                        vector_config.size,
-                        vector_config.distance,
-                        *multi_vec_config,
+                        *multivec_config,
                         stopped,
                     ),
+                    VectorStorageDatatype::Float16 => {
+                        open_simple_multi_dense_vector_storage_half(
+                            database.clone(),
+                            &db_column_name,
+                            vector_config.size,
+                            vector_config.distance,
+                            *multivec_config,
+                            stopped,
+                        )
+                    }
                 }
             } else {
                 match storage_element_type {
@@ -152,80 +142,35 @@ pub(crate) fn open_vector_storage(
                         vector_config.distance,
                         stopped,
                     ),
-                    VectorStorageDatatype::Float16 => open_simple_dense_half_vector_storage(
-                        database.clone(),
-                        &db_column_name,
-                        vector_config.size,
-                        vector_config.distance,
-                        stopped,
-                    ),
+                    VectorStorageDatatype::Float16 => {
+                        open_simple_dense_half_vector_storage(
+                            database.clone(),
+                            &db_column_name,
+                            vector_config.size,
+                            vector_config.distance,
+                            stopped,
+                        )
+                    }
                 }
             }
         }
-        // Mmap on disk, not appendable
         VectorStorageType::Mmap => {
-            if let Some(multi_vec_config) = &vector_config.multivector_config {
-                // there are no mmap multi vector storages, appendable only
+            if let Some(multivec_config) = &vector_config.multivector_config {
                 match storage_element_type {
-                    VectorStorageDatatype::Float32 => open_appendable_memmap_multi_vector_storage(
-                        vector_storage_path,
-                        vector_config.size,
-                        vector_config.distance,
-                        *multi_vec_config,
-                    ),
-                    VectorStorageDatatype::Uint8 => {
-                        open_appendable_memmap_multi_vector_storage_byte(
+                    VectorStorageDatatype::Float32 => {
+                        open_appendable_memmap_multi_vector_storage(
                             vector_storage_path,
                             vector_config.size,
                             vector_config.distance,
-                            *multi_vec_config,
+                            *multivec_config,
                         )
                     }
-                    VectorStorageDatatype::Float16 => {
-                        open_appendable_memmap_multi_vector_storage_half(
-                            vector_storage_path,
-                            vector_config.size,
-                            vector_config.distance,
-                            *multi_vec_config,
-                        )
-                    }
-                }
-            } else {
-                match storage_element_type {
-                    VectorStorageDatatype::Float32 => open_memmap_vector_storage(
-                        vector_storage_path,
-                        vector_config.size,
-                        vector_config.distance,
-                    ),
-                    VectorStorageDatatype::Uint8 => open_memmap_vector_storage_byte(
-                        vector_storage_path,
-                        vector_config.size,
-                        vector_config.distance,
-                    ),
-                    VectorStorageDatatype::Float16 => open_memmap_vector_storage_half(
-                        vector_storage_path,
-                        vector_config.size,
-                        vector_config.distance,
-                    ),
-                }
-            }
-        }
-        // Chunked mmap on disk, appendable
-        VectorStorageType::ChunkedMmap => {
-            if let Some(multi_vec_config) = &vector_config.multivector_config {
-                match storage_element_type {
-                    VectorStorageDatatype::Float32 => open_appendable_memmap_multi_vector_storage(
-                        vector_storage_path,
-                        vector_config.size,
-                        vector_config.distance,
-                        *multi_vec_config,
-                    ),
                     VectorStorageDatatype::Uint8 => {
                         open_appendable_memmap_multi_vector_storage_byte(
                             vector_storage_path,
                             vector_config.size,
                             vector_config.distance,
-                            *multi_vec_config,
+                            *multivec_config,
                         )
                     }
                     VectorStorageDatatype::Float16 => {
@@ -233,23 +178,23 @@ pub(crate) fn open_vector_storage(
                             vector_storage_path,
                             vector_config.size,
                             vector_config.distance,
-                            *multi_vec_config,
+                            *multivec_config,
                         )
                     }
                 }
             } else {
                 match storage_element_type {
-                    VectorStorageDatatype::Float32 => open_appendable_memmap_vector_storage(
+                    VectorStorageDatatype::Float32 => open_memmap_vector_storage(
                         vector_storage_path,
                         vector_config.size,
                         vector_config.distance,
                     ),
-                    VectorStorageDatatype::Uint8 => open_appendable_memmap_vector_storage_byte(
+                    VectorStorageDatatype::Uint8 => open_memmap_vector_storage_byte(
                         vector_storage_path,
                         vector_config.size,
                         vector_config.distance,
                     ),
-                    VectorStorageDatatype::Float16 => open_appendable_memmap_vector_storage_half(
+                    VectorStorageDatatype::Float16 => open_memmap_vector_storage_half(
                         vector_storage_path,
                         vector_config.size,
                         vector_config.distance,
@@ -257,21 +202,21 @@ pub(crate) fn open_vector_storage(
                 }
             }
         }
-        VectorStorageType::InRamChunkedMmap => {
-            if let Some(multi_vec_config) = &vector_config.multivector_config {
+        VectorStorageType::ChunkedMmap | VectorStorageType::InRamChunkedMmap => {
+            if let Some(multivec_config) = &vector_config.multivector_config {
                 match storage_element_type {
                     VectorStorageDatatype::Float32 => open_appendable_in_ram_multi_vector_storage(
                         vector_storage_path,
                         vector_config.size,
                         vector_config.distance,
-                        *multi_vec_config,
+                        *multivec_config,
                     ),
                     VectorStorageDatatype::Uint8 => {
                         open_appendable_in_ram_multi_vector_storage_byte(
                             vector_storage_path,
                             vector_config.size,
                             vector_config.distance,
-                            *multi_vec_config,
+                            *multivec_config,
                         )
                     }
                     VectorStorageDatatype::Float16 => {
@@ -279,7 +224,7 @@ pub(crate) fn open_vector_storage(
                             vector_storage_path,
                             vector_config.size,
                             vector_config.distance,
-                            *multi_vec_config,
+                            *multivec_config,
                         )
                     }
                 }
@@ -295,11 +240,13 @@ pub(crate) fn open_vector_storage(
                         vector_config.size,
                         vector_config.distance,
                     ),
-                    VectorStorageDatatype::Float16 => open_appendable_in_ram_vector_storage_half(
-                        vector_storage_path,
-                        vector_config.size,
-                        vector_config.distance,
-                    ),
+                    VectorStorageDatatype::Float16 => {
+                        open_appendable_in_ram_vector_storage_half(
+                            vector_storage_path,
+                            vector_config.size,
+                            vector_config.distance,
+                        )
+                    }
                 }
             }
         }
@@ -327,6 +274,7 @@ pub(crate) fn open_segment_db(
                 .map(|(vector_name, _)| get_vector_name_with_prefix(DB_VECTOR_CF, vector_name)),
         )
         .collect();
+
     open_db(segment_path, &vector_db_names)
         .map_err(|err| OperationError::service_error(format!("RocksDB open error: {err}")))
 }
@@ -338,11 +286,9 @@ pub(crate) fn create_payload_storage(
 ) -> OperationResult<PayloadStorageEnum> {
     let payload_storage = match config.payload_storage_type {
         PayloadStorageType::InMemory => {
-            PayloadStorageEnum::from(SimplePayloadStorage::open(database)?)
-        }
-        PayloadStorageType::OnDisk => {
-            PayloadStorageEnum::from(OnDiskPayloadStorage::open(database)?)
+            PayloadStorageEnum::from(SimplePayloadStorage::open(database.clone())?)
         }
+        PayloadStorageType::OnDisk => PayloadStorageEnum::from(OnDiskPayloadStorage::open(database)?),
         PayloadStorageType::Mmap => {
             PayloadStorageEnum::from(MmapPayloadStorage::open_or_create(path)?)
         }
@@ -350,7 +296,9 @@ pub(crate) fn create_payload_storage(
     Ok(payload_storage)
 }
 
-pub(crate) fn create_mutable_id_tracker(segment_path: &Path) -> OperationResult<MutableIdTracker> {
+pub(crate) fn create_mutable_id_tracker(
+    segment_path: &Path,
+) -> OperationResult<MutableIdTracker> {
     MutableIdTracker::open(segment_path)
 }
 
@@ -360,92 +308,41 @@ pub(crate) fn create_rocksdb_id_tracker(
     SimpleIdTracker::open(database)
 }
 
-pub(crate) fn create_immutable_id_tracker(
-    segment_path: &Path,
-) -> OperationResult<ImmutableIdTracker> {
-    ImmutableIdTracker::open(segment_path)
-}
-
 pub(crate) fn get_payload_index_path(segment_path: &Path) -> PathBuf {
     segment_path.join(PAYLOAD_INDEX_PATH)
 }
 
-pub(crate) struct VectorIndexOpenArgs<'a> {
-    pub path: &'a Path,
-    pub id_tracker: Arc<AtomicRefCell<IdTrackerSS>>,
-    pub vector_storage: Arc<AtomicRefCell<VectorStorageEnum>>,
-    pub payload_index: Arc<AtomicRefCell<StructPayloadIndex>>,
-    pub quantized_vectors: Arc<AtomicRefCell<Option<QuantizedVectors>>>,
-}
-
-pub struct VectorIndexBuildArgs<'a> {
-    pub permit: Arc<ResourcePermit>,
-    /// Vector indices from other segments, used to speed up index building.
-    /// May or may not contain the same vectors.
-    pub old_indices: &'a [Arc<AtomicRefCell<VectorIndexEnum>>],
-    pub gpu_device: Option<&'a LockedGpuDevice<'a>>,
-    pub stopped: &'a AtomicBool,
-    pub feature_flags: FeatureFlags,
-}
-
-pub(crate) fn open_vector_index(
-    vector_config: &VectorDataConfig,
-    open_args: VectorIndexOpenArgs,
-) -> OperationResult<VectorIndexEnum> {
-    let VectorIndexOpenArgs {
-        path,
-        id_tracker,
-        vector_storage,
-        payload_index,
-        quantized_vectors,
-    } = open_args;
-    Ok(match &vector_config.index {
-        Indexes::Plain {} => VectorIndexEnum::Plain(PlainVectorIndex::new(
-            id_tracker,
-            vector_storage,
-            payload_index,
-        )),
-        Indexes::Hnsw(hnsw_config) => VectorIndexEnum::Hnsw(HNSWIndex::open(HnswIndexOpenArgs {
-            path,
-            id_tracker,
-            vector_storage,
-            quantized_vectors,
-            payload_index,
-            hnsw_config: hnsw_config.clone(),
-        })?),
-    })
-}
-
-pub(crate) fn build_vector_index(
+pub(crate) fn create_vector_index(
     vector_config: &VectorDataConfig,
-    open_args: VectorIndexOpenArgs,
-    build_args: VectorIndexBuildArgs,
+    vector_index_path: &Path,
+    id_tracker: Arc<AtomicRefCell<IdTrackerSS>>,
+    vector_storage: Arc<AtomicRefCell<VectorStorageEnum>>,
+    payload_index: Arc<AtomicRefCell<StructPayloadIndex>>,
+    quantized_vectors: Arc<AtomicRefCell<Option<QuantizedVectors>>>,
+    permit: Option<Arc<ResourcePermit>>,
+    gpu_device: Option<&LockedGpuDevice>,
+    stopped: &AtomicBool,
 ) -> OperationResult<VectorIndexEnum> {
-    let VectorIndexOpenArgs {
-        path,
-        id_tracker,
-        vector_storage,
-        payload_index,
-        quantized_vectors,
-    } = open_args;
-    Ok(match &vector_config.index {
-        Indexes::Plain {} => VectorIndexEnum::Plain(PlainVectorIndex::new(
-            id_tracker,
-            vector_storage,
-            payload_index,
-        )),
-        Indexes::Hnsw(hnsw_config) => VectorIndexEnum::Hnsw(HNSWIndex::build(
-            HnswIndexOpenArgs {
-                path,
+    let vector_index = match &vector_config.index {
+        Indexes::Plain {} => {
+            VectorIndexEnum::Plain(PlainVectorIndex::new(id_tracker, vector_storage, payload_index))
+        }
+        Indexes::Hnsw(vector_hnsw_config) => {
+            let args = HnswIndexOpenArgs {
+                path: vector_index_path,
                 id_tracker,
                 vector_storage,
                 quantized_vectors,
                 payload_index,
-                hnsw_config: hnsw_config.clone(),
-            },
-            build_args,
-        )?),
-    })
+                hnsw_config: vector_hnsw_config.clone(),
+                permit,
+                gpu_device,
+                stopped,
+            };
+            VectorIndexEnum::Hnsw(HNSWIndex::open(args)?)
+        }
+    };
+    Ok(vector_index)
 }
 
 #[cfg(feature = "testing")]
@@ -468,20 +365,13 @@ pub(crate) fn create_sparse_vector_index(
                 description: format!("{a:?} datatype is not supported"),
             })?
         }
-
-        (SparseIndexType::MutableRam, _, _) => {
-            VectorIndexEnum::SparseRam(SparseVectorIndex::open(args)?)
-        }
-
-        // Non-compressed
+        (SparseIndexType::MutableRam, _, _) => VectorIndexEnum::SparseRam(SparseVectorIndex::open(args)?),
         (SparseIndexType::ImmutableRam, VectorStorageDatatype::Float32, false) => {
             VectorIndexEnum::SparseImmutableRam(SparseVectorIndex::open(args)?)
         }
         (SparseIndexType::Mmap, VectorStorageDatatype::Float32, false) => {
             VectorIndexEnum::SparseMmap(SparseVectorIndex::open(args)?)
         }
-
-        // Compressed
         (SparseIndexType::ImmutableRam, VectorStorageDatatype::Float32, true) => {
             VectorIndexEnum::SparseCompressedImmutableRamF32(SparseVectorIndex::open(args)?)
         }
@@ -501,7 +391,6 @@ pub(crate) fn create_sparse_vector_index(
             VectorIndexEnum::SparseCompressedMmapU8(SparseVectorIndex::open(args)?)
         }
     };
-
     Ok(vector_index)
 }
 
@@ -531,200 +420,135 @@ fn create_segment(
     stopped: &AtomicBool,
 ) -> OperationResult<Segment> {
     let database = open_segment_db(segment_path, config)?;
-    let payload_storage = sp(create_payload_storage(
-        database.clone(),
-        config,
-        segment_path,
-    )?);
+    let payload_storage = sp(create_payload_storage(database.clone(), config, segment_path)?);
 
     let appendable_flag = config.is_appendable();
 
-    let mutable_id_tracker =
-        appendable_flag || !ImmutableIdTracker::mappings_file_path(segment_path).is_file();
-
-    let id_tracker = if mutable_id_tracker {
-        // Determine whether we use the new (file based) or old (RocksDB) mutable ID tracker
-        // Decide based on the feature flag and state on disk
-        let use_new_mutable_tracker = {
-            // New ID tracker is enabled by default, but we still use the old tracker if we have
-            // any mappings stored in RocksDB
-            // TODO(1.15 or later): remove this check and use new mutable ID tracker unconditionally
+    let mutable_id = appendable_flag || !ImmutableIdTracker::mappings_file_path(segment_path).is_file();
+    let id_tracker = if mutable_id {
+        // New ID tracker is enabled by default, but fall back to RocksDB tracker if old mappings exist
+        let use_new = {
             let db = database.read();
             match db.cf_handle(DB_MAPPING_CF) {
-                Some(cf_handle) => {
+                Some(cf) => {
                     let count = db
-                        .property_int_value_cf(cf_handle, rocksdb::properties::ESTIMATE_NUM_KEYS)
-                        .map_err(|err| {
-                            OperationError::service_error(format!(
-                                "Failed to get estimated number of keys from RocksDB: {err}"
-                            ))
-                        })?
+                        .property_int_value_cf(cf, rocksdb::properties::ESTIMATE_NUM_KEYS)
+                        .map_err(|e| OperationError::service_error(format!("Failed to estimate keys: {e}")))?
                         .unwrap_or_default();
                     count == 0
                 }
                 None => true,
             }
         };
-
-        if use_new_mutable_tracker {
-            sp(IdTrackerEnum::MutableIdTracker(create_mutable_id_tracker(
-                segment_path,
-            )?))
+        if use_new {
+            sp(IdTrackerEnum::MutableIdTracker(create_mutable_id_tracker(segment_path)?))
         } else {
-            sp(IdTrackerEnum::RocksDbIdTracker(create_rocksdb_id_tracker(
-                database.clone(),
-            )?))
+            sp(IdTrackerEnum::RocksDbIdTracker(create_rocksdb_id_tracker(database.clone())?))
         }
     } else {
-        sp(IdTrackerEnum::ImmutableIdTracker(
-            create_immutable_id_tracker(segment_path)?,
-        ))
+        sp(IdTrackerEnum::ImmutableIdTracker(create_immutable_id_tracker(segment_path)?))
     };
 
-    let mut vector_storages = HashMap::new();
-
-    for (vector_name, vector_config) in &config.vector_data {
-        let vector_storage_path = get_vector_storage_path(segment_path, vector_name);
-
-        // Select suitable vector storage type based on configuration
-        let vector_storage = sp(open_vector_storage(
-            &database,
-            vector_config,
-            stopped,
-            &vector_storage_path,
-            vector_name,
-        )?);
-
-        vector_storages.insert(vector_name.to_owned(), vector_storage);
-    }
-
-    for (vector_name, sparse_config) in config.sparse_vector_data.iter() {
-        let vector_storage_path = get_vector_storage_path(segment_path, vector_name);
-
-        // Select suitable sparse vector storage type based on configuration
-        let vector_storage = sp(create_sparse_vector_storage(
-            database.clone(),
-            &vector_storage_path,
-            vector_name,
-            &sparse_config.storage_type,
-            stopped,
-        )?);
-
-        vector_storages.insert(vector_name.to_owned(), vector_storage);
-    }
-
     let payload_index_path = get_payload_index_path(segment_path);
     let payload_index: Arc<AtomicRefCell<StructPayloadIndex>> = sp(StructPayloadIndex::open(
         payload_storage.clone(),
         id_tracker.clone(),
-        vector_storages.clone(),
-        &payload_index_path,
+        payload_index_path,
         appendable_flag,
     )?);
 
-    let mut vector_data = HashMap::new();
-    for (vector_name, vector_config) in &config.vector_data {
-        let vector_storage_path = get_vector_storage_path(segment_path, vector_name);
-        let vector_storage = vector_storages.remove(vector_name).unwrap();
+    let mut vector_storages: HashMap<VectorName, Arc<AtomicRefCell<VectorStorageEnum>>> = HashMap::new();
+    for (name, cfg) in &config.vector_data {
+        let storage_path = get_vector_storage_path(segment_path, name);
+        let storage = sp(open_vector_storage(&database, cfg, stopped, &storage_path, name)?);
+        vector_storages.insert(name.clone(), storage);
+    }
+    for (name, sparse_cfg) in &config.sparse_vector_data {
+        let storage_path = get_vector_storage_path(segment_path, name);
+        let storage = sp(create_sparse_vector_storage(
+            database.clone(),
+            &storage_path,
+            name,
+            &sparse_cfg.storage_type,
+            stopped,
+        )?);
+        vector_storages.insert(name.clone(), storage);
+    }
 
-        let vector_index_path = get_vector_index_path(segment_path, vector_name);
-        // Warn when number of points between ID tracker and storage differs
-        let point_count = id_tracker.borrow().total_point_count();
-        let vector_count = vector_storage.borrow().total_vector_count();
-        if vector_count != point_count {
+    let mut vector_data: HashMap<VectorName, VectorData> = HashMap::new();
+    for (name, cfg) in &config.vector_data {
+        let storage = vector_storages.remove(name).unwrap();
+        let index_path = get_vector_index_path(segment_path, name);
+
+        // Check consistency
+        let points = id_tracker.borrow().total_point_count();
+        let vectors = storage.borrow().total_vector_count();
+        if points != vectors {
             log::debug!(
-                "Mismatch of point and vector counts ({point_count} != {vector_count}, storage: {})",
-                vector_storage_path.display(),
+                "Mismatch of point and vector counts ({points} != {vectors}, storage: {})",
+                storage_path.display(),
             );
         }
 
-        let quantized_vectors = sp(if config.quantization_config(vector_name).is_some() {
-            let quantized_data_path = vector_storage_path;
-            if QuantizedVectors::config_exists(&quantized_data_path) {
-                let quantized_vectors =
-                    QuantizedVectors::load(&vector_storage.borrow(), &quantized_data_path)?;
-                Some(quantized_vectors)
-            } else {
-                None
-            }
-        } else {
-            None
-        });
-
-        let vector_index: Arc<AtomicRefCell<VectorIndexEnum>> = sp(open_vector_index(
-            vector_config,
-            VectorIndexOpenArgs {
-                path: &vector_index_path,
-                id_tracker: id_tracker.clone(),
-                vector_storage: vector_storage.clone(),
-                payload_index: payload_index.clone(),
-                quantized_vectors: quantized_vectors.clone(),
-            },
+        let quant_vecs = sp(None);
+        let idx = sp(create_vector_index(
+            cfg,
+            &index_path,
+            id_tracker.clone(),
+            storage.clone(),
+            payload_index.clone(),
+            quant_vecs.clone(),
+            None,
+            stopped,
         )?);
 
-        check_process_stopped(stopped)?;
-
-        vector_data.insert(
-            vector_name.to_owned(),
-            VectorData {
-                vector_index,
-                vector_storage,
-                quantized_vectors,
-            },
-        );
+        vector_data.insert(name.clone(), VectorData {
+            vector_storage: storage,
+            vector_index: idx,
+            quantized_vectors: quant_vecs.clone(),
+        });
     }
+    for (name, sparse_cfg) in &config.sparse_vector_data {
+        let storage = vector_storages.remove(name).unwrap();
+        let index_path = get_vector_index_path(segment_path, name);
 
-    for (vector_name, sparse_vector_config) in &config.sparse_vector_data {
-        let vector_storage_path = get_vector_storage_path(segment_path, vector_name);
-        let vector_index_path = get_vector_index_path(segment_path, vector_name);
-        let vector_storage = vector_storages.remove(vector_name).unwrap();
-
-        // Warn when number of points between ID tracker and storage differs
-        let point_count = id_tracker.borrow().total_point_count();
-        let vector_count = vector_storage.borrow().total_vector_count();
-        if vector_count != point_count {
+        let points = id_tracker.borrow().total_point_count();
+        let vectors = storage.borrow().total_vector_count();
+        if points != vectors {
             log::debug!(
-                "Mismatch of point and vector counts ({point_count} != {vector_count}, storage: {})",
-                vector_storage_path.display(),
+                "Mismatch of point and vector counts ({points} != {vectors}, sparse storage: {})",
+                storage_path.display(),
             );
         }
 
-        let vector_index = sp(create_sparse_vector_index(SparseVectorIndexOpenArgs {
-            config: sparse_vector_config.index,
+        let idx = sp(create_sparse_vector_index(SparseVectorIndexOpenArgs {
+            config: sparse_cfg.index.clone(),
             id_tracker: id_tracker.clone(),
-            vector_storage: vector_storage.clone(),
+            vector_storage: storage.clone(),
             payload_index: payload_index.clone(),
-            path: &vector_index_path,
+            path: &index_path,
             stopped,
-            tick_progress: || (),
         })?);
 
-        check_process_stopped(stopped)?;
-
-        vector_data.insert(
-            vector_name.to_owned(),
-            VectorData {
-                vector_storage,
-                vector_index,
-                quantized_vectors: sp(None),
-            },
-        );
+        vector_data.insert(name.clone(), VectorData {
+            vector_storage: storage,
+            vector_index: idx,
+            quantized_vectors: sp(None),
+        });
     }
 
-    let segment_type = if config.is_any_vector_indexed() {
-        SegmentType::Indexed
-    } else {
-        SegmentType::Plain
-    };
-
     Ok(Segment {
         version,
-        persisted_version: Arc::new(Mutex::new(version)),
+        persisted_version: Arc::new(Mutex::new(version.unwrap_or(0))),
         current_path: segment_path.to_owned(),
         id_tracker,
         vector_data,
-        segment_type,
         appendable_flag,
+        segment_type: if config.is_any_vector_indexed() {
+            SegmentType::Indexed
+        } else {
+            SegmentType::Plain
+        },
         payload_index,
         payload_storage,
         segment_config: config.clone(),
@@ -742,38 +566,30 @@ pub fn load_segment(path: &Path, stopped: &AtomicBool) -> OperationResult<Option
         .unwrap_or(false)
     {
         log::warn!("Segment is marked as deleted, skipping: {}", path.display());
-        // Skip deleted segments
         return Ok(None);
     }
-
-    let Some(stored_version) = SegmentVersion::load(path)? else {
-        // Assume segment was not properly saved.
-        // Server might have crashed before saving the segment fully.
+    if !SegmentVersion::check_exists(path) {
         log::warn!(
             "Segment version file not found, skipping: {}",
             path.display()
         );
         return Ok(None);
-    };
-
+    }
+    let stored_version = SegmentVersion::load(path)?;
     let app_version = SegmentVersion::current();
-
     if stored_version != app_version {
         info!("Migrating segment {stored_version} -> {app_version}");
-
         if stored_version > app_version {
             return Err(OperationError::service_error(format!(
                 "Data version {stored_version} is newer than application version {app_version}. \
                 Please upgrade the application. Compatibility is not guaranteed."
             )));
         }
-
         if stored_version.major == 0 && stored_version.minor < 3 {
             return Err(OperationError::service_error(format!(
                 "Segment version({stored_version}) is not compatible with current version({app_version})"
             )));
         }
-
         if stored_version.major == 0 && stored_version.minor == 3 {
             let segment_state = load_segment_state_v3(path)?;
             Segment::save_state(&segment_state, path)?;
@@ -781,100 +597,56 @@ pub fn load_segment(path: &Path, stopped: &AtomicBool) -> OperationResult<Option
             let segment_state = load_segment_state_v5(path)?;
             Segment::save_state(&segment_state, path)?;
         }
-
-        SegmentVersion::save(path)?
+        SegmentVersion::save(path)?;
     }
-
     let segment_state = Segment::load_state(path)?;
-
     let segment = create_segment(segment_state.version, path, &segment_state.config, stopped)?;
-
     Ok(Some(segment))
 }
 
-pub fn new_segment_path(segments_path: &Path) -> PathBuf {
-    segments_path.join(Uuid::new_v4().to_string())
-}
-
-/// Build segment instance using given configuration.
-/// Builder will generate folder for the segment and store all segment information inside it.
-///
-/// # Arguments
-///
-/// * `segments_path` - Path to the segments directory. Segment folder will be created in this directory
-/// * `config` - Segment configuration
-/// * `ready` - Whether the segment is ready after building; will save segment version
-///
-/// To load a segment, saving the segment version is required. If `ready` is false, the version
-/// will not be stored. Then the segment is skipped on restart when trying to load it again. In
-/// that case, the segment version must be stored manually to make it ready.
 pub fn build_segment(
     segments_path: &Path,
     config: &SegmentConfig,
     ready: bool,
 ) -> OperationResult<Segment> {
-    let segment_path = new_segment_path(segments_path);
-
+    let segment_path = segments_path.join(Uuid::new_v4().to_string());
     std::fs::create_dir_all(&segment_path)?;
-
     let segment = create_segment(None, &segment_path, config, &AtomicBool::new(false))?;
     segment.save_current_state()?;
-
-    // Version is the last file to save, as it will be used to check if segment was built correctly.
-    // If it is not saved, segment will be skipped.
     if ready {
         SegmentVersion::save(&segment_path)?;
     }
-
     Ok(segment)
 }
 
-/// Load v0.3.* segment data and migrate to current version
 #[allow(deprecated)]
 fn load_segment_state_v3(segment_path: &Path) -> OperationResult<SegmentState> {
     use crate::compat::{SegmentConfigV5, StorageTypeV5, VectorDataConfigV5};
-
     #[derive(Deserialize)]
-    #[serde(rename_all = "snake_case")]
     #[deprecated]
-    pub struct SegmentStateV3 {
-        pub version: SeqNumberType,
-        pub config: SegmentConfigV3,
+    struct SegmentStateV3 {
+        version: SeqNumberType,
+        config: SegmentConfigV3,
     }
-
     #[derive(Deserialize)]
-    #[serde(rename_all = "snake_case")]
     #[deprecated]
-    pub struct SegmentConfigV3 {
-        /// Size of a vectors used
-        pub vector_size: usize,
-        /// Type of distance function used for measuring distance between vectors
-        pub distance: Distance,
-        /// Type of index used for search
-        pub index: Indexes,
-        /// Type of vector storage
-        pub storage_type: StorageTypeV5,
-        /// Defines payload storage type
+    struct SegmentConfigV3 {
+        vector_size: usize,
+        distance: Distance,
+        index: Indexes,
+        storage_type: StorageTypeV5,
         #[serde(default)]
-        pub payload_storage_type: PayloadStorageType,
+        payload_storage_type: PayloadStorageType,
     }
-
     let path = segment_path.join(SEGMENT_STATE_FILE);
-
     let mut contents = String::new();
-
     let mut file = File::open(&path)?;
     file.read_to_string(&mut contents)?;
-
     serde_json::from_str::<SegmentStateV3>(&contents)
         .map(|state| {
-            // Construct V5 version, then convert into current
             let vector_data = VectorDataConfigV5 {
                 size: state.config.vector_size,
                 distance: state.config.distance,
-                hnsw_config: None,
-                quantization_config: None,
-                on_disk: None,
             };
             let segment_config = SegmentConfigV5 {
                 vector_data: HashMap::from([(DEFAULT_VECTOR_NAME.to_owned(), vector_data)]),
@@ -883,7 +655,6 @@ fn load_segment_state_v3(segment_path: &Path) -> OperationResult<SegmentState> {
                 payload_storage_type: state.config.payload_storage_type,
                 quantization_config: None,
             };
-
             SegmentState {
                 version: Some(state.version),
                 config: segment_config.into(),
@@ -898,18 +669,13 @@ fn load_segment_state_v3(segment_path: &Path) -> OperationResult<SegmentState> {
         })
 }
 
-/// Load v0.5.0 segment data and migrate to current version
 #[allow(deprecated)]
 fn load_segment_state_v5(segment_path: &Path) -> OperationResult<SegmentState> {
     use crate::compat::SegmentStateV5;
-
     let path = segment_path.join(SEGMENT_STATE_FILE);
-
     let mut contents = String::new();
-
     let mut file = File::open(&path)?;
     file.read_to_string(&mut contents)?;
-
     serde_json::from_str::<SegmentStateV5>(&contents)
         .map(Into::into)
         .map_err(|err| {
