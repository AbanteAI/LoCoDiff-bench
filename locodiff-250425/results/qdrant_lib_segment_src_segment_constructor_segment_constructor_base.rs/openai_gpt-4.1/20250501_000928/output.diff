--- qdrant_lib_segment_src_segment_constructor_segment_constructor_base.rs_expectedoutput.txt (expected)+++ qdrant_lib_segment_src_segment_constructor_segment_constructor_base.rs_extracted.txt (actual)@@ -7,7 +7,6 @@ 
 use atomic_refcell::AtomicRefCell;
 use common::budget::ResourcePermit;
-use common::flags::FeatureFlags;
 use io::storage_version::StorageVersion;
 use log::info;
 use parking_lot::{Mutex, RwLock};
@@ -26,7 +25,7 @@ use crate::index::hnsw_index::gpu::gpu_devices_manager::LockedGpuDevice;
 use crate::index::hnsw_index::hnsw::{HNSWIndex, HnswIndexOpenArgs};
 use crate::index::plain_vector_index::PlainVectorIndex;
-use crate::index::sparse_index::sparse_index_config::SparseIndexType;
+use crate::index::sparse_index::sparse_index_config::{SparseIndexType};
 use crate::index::sparse_index::sparse_vector_index::{
     self, SparseVectorIndex, SparseVectorIndexOpenArgs,
 };
@@ -360,12 +359,6 @@     SimpleIdTracker::open(database)
 }
 
-pub(crate) fn create_immutable_id_tracker(
-    segment_path: &Path,
-) -> OperationResult<ImmutableIdTracker> {
-    ImmutableIdTracker::open(segment_path)
-}
-
 pub(crate) fn get_payload_index_path(segment_path: &Path) -> PathBuf {
     segment_path.join(PAYLOAD_INDEX_PATH)
 }
@@ -530,6 +523,19 @@     config: &SegmentConfig,
     stopped: &AtomicBool,
 ) -> OperationResult<Segment> {
+    if segment_path
+        .extension()
+        .and_then(|ext| ext.to_str())
+        .is_some_and(|ext| ext == "deleted")
+    {
+        log::warn!(
+            "Segment is marked as deleted, skipping: {}",
+            segment_path.display()
+        );
+        // Skip deleted segments
+        return Ok(None);
+    }
+
     let database = open_segment_db(segment_path, config)?;
     let payload_storage = sp(create_payload_storage(
         database.clone(),
@@ -543,8 +549,6 @@         appendable_flag || !ImmutableIdTracker::mappings_file_path(segment_path).is_file();
 
     let id_tracker = if mutable_id_tracker {
-        // Determine whether we use the new (file based) or old (RocksDB) mutable ID tracker
-        // Decide based on the feature flag and state on disk
         let use_new_mutable_tracker = {
             // New ID tracker is enabled by default, but we still use the old tracker if we have
             // any mappings stored in RocksDB
@@ -587,13 +591,13 @@         let vector_storage_path = get_vector_storage_path(segment_path, vector_name);
 
         // Select suitable vector storage type based on configuration
-        let vector_storage = sp(open_vector_storage(
+        let vector_storage = Arc::new(AtomicRefCell::new(open_vector_storage(
             &database,
             vector_config,
             stopped,
             &vector_storage_path,
             vector_name,
-        )?);
+        )?));
 
         vector_storages.insert(vector_name.to_owned(), vector_storage);
     }
@@ -704,8 +708,8 @@         vector_data.insert(
             vector_name.to_owned(),
             VectorData {
+                vector_index,
                 vector_storage,
-                vector_index,
                 quantized_vectors: sp(None),
             },
         );
@@ -730,66 +734,7 @@         segment_config: config.clone(),
         error_status: None,
         database,
-        flush_thread: Mutex::new(None),
     })
-}
-
-pub fn load_segment(path: &Path, stopped: &AtomicBool) -> OperationResult<Option<Segment>> {
-    if path
-        .extension()
-        .and_then(|ext| ext.to_str())
-        .map(|ext| ext == "deleted")
-        .unwrap_or(false)
-    {
-        log::warn!("Segment is marked as deleted, skipping: {}", path.display());
-        // Skip deleted segments
-        return Ok(None);
-    }
-
-    let Some(stored_version) = SegmentVersion::load(path)? else {
-        // Assume segment was not properly saved.
-        // Server might have crashed before saving the segment fully.
-        log::warn!(
-            "Segment version file not found, skipping: {}",
-            path.display()
-        );
-        return Ok(None);
-    };
-
-    let app_version = SegmentVersion::current();
-
-    if stored_version != app_version {
-        info!("Migrating segment {stored_version} -> {app_version}");
-
-        if stored_version > app_version {
-            return Err(OperationError::service_error(format!(
-                "Data version {stored_version} is newer than application version {app_version}. \
-                Please upgrade the application. Compatibility is not guaranteed."
-            )));
-        }
-
-        if stored_version.major == 0 && stored_version.minor < 3 {
-            return Err(OperationError::service_error(format!(
-                "Segment version({stored_version}) is not compatible with current version({app_version})"
-            )));
-        }
-
-        if stored_version.major == 0 && stored_version.minor == 3 {
-            let segment_state = load_segment_state_v3(path)?;
-            Segment::save_state(&segment_state, path)?;
-        } else if stored_version.major == 0 && stored_version.minor <= 5 {
-            let segment_state = load_segment_state_v5(path)?;
-            Segment::save_state(&segment_state, path)?;
-        }
-
-        SegmentVersion::save(path)?
-    }
-
-    let segment_state = Segment::load_state(path)?;
-
-    let segment = create_segment(segment_state.version, path, &segment_state.config, stopped)?;
-
-    Ok(Some(segment))
 }
 
 pub fn new_segment_path(segments_path: &Path) -> PathBuf {
@@ -829,7 +774,63 @@     Ok(segment)
 }
 
-/// Load v0.3.* segment data and migrate to current version
+pub fn load_segment(path: &Path, stopped: &AtomicBool) -> OperationResult<Option<Segment>> {
+    if path
+        .extension()
+        .and_then(|ext| ext.to_str())
+        .is_some_and(|ext| ext == "deleted")
+    {
+        log::warn!("Segment is marked as deleted, skipping: {}", path.display());
+        // Skip deleted segments
+        return Ok(None);
+    }
+
+    let Some(stored_version) = SegmentVersion::load(path)? else {
+        // Assume segment was not properly saved.
+        // Server might have crashed before saving the segment fully.
+        log::warn!(
+            "Segment version file not found, skipping: {}",
+            path.display()
+        );
+        return Ok(None);
+    };
+
+    let app_version = SegmentVersion::current();
+
+    if stored_version != app_version {
+        info!("Migrating segment {stored_version} -> {app_version}");
+
+        if stored_version > app_version {
+            return Err(OperationError::service_error(format!(
+                "Data version {stored_version} is newer than application version {app_version}. \
+                Please upgrade the application. Compatibility is not guaranteed."
+            )));
+        }
+
+        if stored_version.major == 0 && stored_version.minor < 3 {
+            return Err(OperationError::service_error(format!(
+                "Segment version({stored_version}) is not compatible with current version({app_version})"
+            )));
+        }
+
+        if stored_version.major == 0 && stored_version.minor == 3 {
+            let segment_state = load_segment_state_v3(path)?;
+            Segment::save_state(&segment_state, path)?;
+        } else if stored_version.major == 0 && stored_version.minor <= 5 {
+            let segment_state = load_segment_state_v5(path)?;
+            Segment::save_state(&segment_state, path)?;
+        }
+
+        SegmentVersion::save(path)?
+    }
+
+    let segment_state = Segment::load_state(path)?;
+
+    let segment = create_segment(segment_state.version, path, &segment_state.config, stopped)?;
+
+    Ok(Some(segment))
+}
+
 #[allow(deprecated)]
 fn load_segment_state_v3(segment_path: &Path) -> OperationResult<SegmentState> {
     use crate::compat::{SegmentConfigV5, StorageTypeV5, VectorDataConfigV5};
@@ -898,7 +899,6 @@         })
 }
 
-/// Load v0.5.0 segment data and migrate to current version
 #[allow(deprecated)]
 fn load_segment_state_v5(segment_path: &Path) -> OperationResult<SegmentState> {
     use crate::compat::SegmentStateV5;
