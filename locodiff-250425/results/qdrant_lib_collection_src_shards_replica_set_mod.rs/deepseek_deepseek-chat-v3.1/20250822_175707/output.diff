
index 1a8af4043..7716bca18 100644
--- a/qdrant_lib_collection_src_shards_replica_set_mod.rs_expectedoutput.txt (expected):tmp/tmp37s4ou7q_expected.txt	
+++ b/qdrant_lib_collection_src_shards_replica_set_mod.rs_extracted.txt (actual):tmp/tmpbnhtoqgf_actual.txt	
@@ -1,4 +1,4 @@
-pub mod clock_set;
+mod clock_set;
 mod execute_read_operation;
 mod locally_disabled_peers;
 mod read_ops;
@@ -84,7 +84,6 @@ use crate::shards::shard_config::ShardConfig;
 /// Handles operations so that the state is consistent across all the replicas of the shard.
 /// Prefers local shard for read-only operations.
 /// Perform updates on all replicas and report error if there is at least one failure.
-///
 pub struct ShardReplicaSet {
     local: RwLock<Option<Shard>>, // Abstract Shard to be able to use a Proxy during replication
     remotes: RwLock<Vec<RemoteShard>>,
@@ -348,8 +347,8 @@ impl ShardReplicaSet {
             // TODO: move to collection config
             locally_disabled_peers: Default::default(),
             shard_path: shard_path.to_path_buf(),
-            notify_peer_failure_cb: on_peer_failure,
             abort_shard_transfer_cb: abort_shard_transfer,
+            notify_peer_failure_cb: on_peer_failure,
             channel_service,
             collection_id,
             collection_config,
@@ -862,20 +861,6 @@ impl ShardReplicaSet {
         Ok(())
     }
 
-    pub(crate) async fn health_check(&self, peer_id: PeerId) -> CollectionResult<()> {
-        let remotes = self.remotes.read().await;
-
-        let Some(remote) = remotes.iter().find(|remote| remote.peer_id == peer_id) else {
-            return Err(CollectionError::NotFound {
-                what: format!("{}/{}:{} shard", peer_id, self.collection_id, self.shard_id),
-            });
-        };
-
-        remote.health_check().await?;
-
-        Ok(())
-    }
-
     pub async fn delete_local_points(
         &self,
         filter: Filter,
@@ -970,6 +955,20 @@ impl ShardReplicaSet {
             .collect()
     }
 
+    pub(crate) async fn health_check(&self, peer_id: PeerId) -> CollectionResult<()> {
+        let remotes = self.remotes.read().await;
+
+        let Some(remote) = remotes.iter().find(|remote| remote.peer_id == peer_id) else {
+            return Err(CollectionError::NotFound {
+                what: format!("{}/{}:{} shard", peer_id, self.collection_id, self.shard_id),
+            });
+        };
+
+        remote.health_check().await?;
+
+        Ok(())
+    }
+
     /// Check whether a peer is registered as `active`.
     /// Unknown peers are not active.
     fn peer_is_active(&self, peer_id: PeerId) -> bool {
