
index 1724dd1c8..e01fbfd37 100644
--- a/tldraw_apps_dotcom_client_src_tla_app_TldrawApp.ts_expectedoutput.txt (expected):tmp/tmpwgk6qk9v_expected.txt	
+++ b/tldraw_apps_dotcom_client_src_tla_app_TldrawApp.ts_extracted.txt (actual):tmp/tmpa2_9x7jm_actual.txt	
@@ -3,13 +3,12 @@ import { Zero } from '@rocicorp/zero'
 import { captureException } from '@sentry/react'
 import {
 	CreateFilesResponseBody,
-	createMutators,
 	CreateSnapshotRequestBody,
 	LOCAL_FILE_PREFIX,
 	MAX_NUMBER_OF_FILES,
 	TlaFile,
+	TlaFilePartial,
 	TlaFileState,
-	TlaMutators,
 	TlaSchema,
 	TlaUser,
 	UserPreferencesKeys,
@@ -79,36 +78,24 @@ export class TldrawApp {
 
 	readonly id = appId++
 
-	readonly z: ZeroPolyfill | Zero<TlaSchema, TlaMutators>
+	readonly z: ZeroPolyfill | Zero<TlaSchema>
 
 	private readonly user$: Signal<TlaUser | undefined>
+	private readonly files$: Signal<TlaFile[]>
 	private readonly fileStates$: Signal<(TlaFileState & { file: TlaFile })[]>
 
 	private readonly abortController = new AbortController()
-	readonly disposables: (() => void)[] = [() => this.abortController.abort(), () => this.z.close()]
-
-	changes: Map<Atom<any, unknown>, any> = new Map()
-	changesFlushed = null as null | ReturnType<typeof promiseWithResolve>
+	readonly disposables: (() => void)[] = [
+		() => this.abortController.abort(),
+		() => (this.z as any)?.dispose?.(),
+	]
 
 	private signalizeQuery<TReturn>(name: string, query: any): Signal<TReturn> {
 		// fail if closed?
 		const view = query.materialize()
 		const val$ = atom(name, view.data)
 		view.addListener((res: any) => {
-			this.changes.set(val$, structuredClone(res))
-			if (!this.changesFlushed) {
-				this.changesFlushed = promiseWithResolve()
-			}
-			queueMicrotask(() => {
-				transact(() => {
-					this.changes.forEach((value, key) => {
-						key.set(value)
-					})
-					this.changes.clear()
-				})
-				this.changesFlushed?.resolve(undefined)
-				this.changesFlushed = null
-			})
+			val$.set(structuredClone(res) as any)
 		})
 		this.disposables.push(() => {
 			view.destroy()
@@ -120,65 +107,398 @@ export class TldrawApp {
 
 	private constructor(
 		public readonly userId: string,
-		getToken: () => Promise<string | undefined>,
+		getToken: () => Promise<string | null>,
 		onClientTooOld: () => void,
 		trackEvent: TLAppUiContextType
 	) {
 		const sessionId = uniqueId()
-		this.z = useProperZero
-			? new Zero<TlaSchema, TlaMutators>({
-					auth: getToken,
-					userID: userId,
-					schema: zeroSchema,
-					server: ZERO_SERVER,
-					mutators: createMutators(userId),
-					onUpdateNeeded(reason) {
-						console.error('update needed', reason)
-						onClientTooOld()
-					},
-					kvStore: window.navigator.webdriver ? 'mem' : 'idb',
-				})
-			: new ZeroPolyfill({
-					userId,
-					// auth: encodedJWT,
-					getUri: async () => {
-						const params = new URLSearchParams({
-							sessionId,
-							protocolVersion: String(Z_PROTOCOL_VERSION),
-						})
-						const token = await getToken()
-						params.set('accessToken', token || 'no-token-found')
-						return `${MULTIPLAYER_SERVER}/app/${userId}/connect?${params}`
-					},
-					// schema,
-					// This is often easier to develop with if you're frequently changing
-					// the schema. Switch to 'idb' for local-persistence.
-					onMutationRejected: this.showMutationRejectionToast,
-					onClientTooOld: () => onClientTooOld(),
-					trackEvent,
+
+		if (useProperZero) {
+			// NOTE: experimental client; keep options in sync with Zero polyfill behavior where possible
+			this.z = new Zero<TlaSchema>({
+				server: ZERO_SERVER,
+				schema: zeroSchema,
+				userID: this.userId,
+				getAuth: async () => {
+					const token = await getToken()
+					return { accessToken: token || 'no-token-found' }
+				},
+				params: {
+					sessionId,
+					protocolVersion: String(Z_PROTOCOL_VERSION),
+				},
+				onMutationRejected: this.showMutationRejectionToast,
+				onClientTooOld: () => onClientTooOld(),
+				trackEvent,
+			} as any)
+		} else {
+			this.z = new ZeroPolyfill({
+				// userID: userId,
+				// auth: encodedJWT,
+				getUri: async () => {
+					const params = new URLSearchParams({
+						sessionId,
+						protocolVersion: String(Z_PROTOCOL_VERSION),
+					})
+					const token = await getToken()
+					params.set('accessToken', token || 'no-token-found')
+					return `${MULTIPLAYER_SERVER}/app/${this.userId}/connect?${params}`
+				},
+				// schema,
+				// This is often easier to develop with if you're frequently changing
+				// the schema. Switch to 'idb' for local-persistence.
+				onMutationRejected: this.showMutationRejectionToast,
+				onClientTooOld: () => onClientTooOld(),
+				trackEvent,
+			})
+		}
+
+		this.user$ = this.signalizeQuery(
+			'user signal',
+			(this.z as any).query.user.where('id', this.userId).one()
+		)
+		this.files$ = this.signalizeQuery(
+			'files signal',
+			(this.z as any).query.file.where('ownerId', this.userId)
+		)
+		this.fileStates$ = this.signalizeQuery(
+			'file states signal',
+			(this.z as any).query.file_state.where('userId', this.userId).related('file', (q: any) => q.one())
+		)
+	}
+
+	async preload(initialUserData: TlaUser) {
+		let didCreate = false
+		await (this.z as any).query.user.where('id', this.userId).preload().complete
+		if (!this.user$.get()) {
+			didCreate = true
+			;(this.z as any).mutate.user.create(initialUserData)
+			updateLocalSessionState((state) => ({ ...state, shouldShowWelcomeDialog: true }))
+		}
+		await new Promise((resolve) => {
+			let unsub = () => {}
+			unsub = react('wait for user', () => this.user$.get() && resolve(unsub()))
+		})
+		if (!this.user$.get()) {
+			throw Error('could not create user')
+		}
+		await (this.z as any).query.file_state.where('userId', this.userId).preload().complete
+		await (this.z as any).query.file.where('ownerId', this.userId).preload().complete
+		return didCreate
+	}
+
+	messages = defineMessages({
+		// toast title
+		mutation_error_toast_title: { defaultMessage: 'Error' },
+		// toast descriptions
+		publish_failed: {
+			defaultMessage: 'Unable to publish the file.',
+		},
+		unpublish_failed: {
+			defaultMessage: 'Unable to unpublish the file.',
+		},
+		republish_failed: {
+			defaultMessage: 'Unable to publish the changes.',
+		},
+		unknown_error: {
+			defaultMessage: 'An unexpected error occurred.',
+		},
+		forbidden: {
+			defaultMessage: 'You do not have the necessary permissions to perform this action.',
+		},
+		bad_request: {
+			defaultMessage: 'Invalid request.',
+		},
+		rate_limit_exceeded: {
+			defaultMessage: 'Rate limit exceeded, try again later.',
+		},
+		client_too_old: {
+			defaultMessage: 'Please refresh the page to get the latest version of tldraw.',
+		},
+		max_files_title: {
+			defaultMessage: 'File limit reached',
+		},
+		max_files_reached: {
+			defaultMessage:
+				'You have reached the maximum number of files. You need to delete old files before creating new ones.',
+		},
+		uploadingTldrFiles: {
+			defaultMessage:
+				'{total, plural, one {Uploading .tldr file…} other {Uploading {uploaded} of {total} .tldr files…}}',
+		},
+		addingTldrFiles: {
+			// no need for pluralization, if there was only one file we navigated to it
+			// so there's no need to show a toast.
+			defaultMessage: 'Added {total} .tldr files.',
+		},
+	})
+
+	getMessage(id: keyof typeof this.messages) {
+		let msg = this.messages[id]
+		if (!msg) {
+			console.error('Could not find a translation for this error code', id)
+			msg = this.messages.unknown_error
+		}
+		return msg
+	}
+
+	showMutationRejectionToast = throttle((errorCode: ZErrorCode) => {
+		const descriptor = this.getMessage(errorCode)
+		this.toasts?.addToast({
+			title: this.getIntl().formatMessage(this.messages.mutation_error_toast_title),
+			description: this.getIntl().formatMessage(descriptor),
+		})
+	}, 3000)
+
+	dispose() {
+		this.disposables.forEach((d) => d())
+		// this.store.dispose()
+	}
+
+	getUser() {
+		return assertExists(this.user$.get(), 'no user')
+	}
+
+	tlUser = createTLUser({
+		userPreferences: computed('user prefs', () => {
+			const user = this.getUser()
+			return {
+				...(pick(user, UserPreferencesKeys) as TLUserPreferences),
+				id: this.userId,
+			}
+		}),
+		setUserPreferences: ({ id: _, ...others }: Partial<TLUserPreferences>) => {
+			const user = this.getUser()
+
+			const nonNull = Object.fromEntries(
+				Object.entries(others).filter(([_, value]) => value !== null)
+			) as Partial<TLUserPreferences>
+
+			;(this.z as any).mutate((tx: any) => {
+				tx.user.update({
+					id: user.id,
+					...(nonNull as any),
 				})
+			})
+		},
+	})
+
+	// getAll<T extends keyof Schema['tables']>(
+	// 	typeName: T
+	// ): SchemaToRow<Schema['tables'][T]>[] {
+	// 	return this.z.query[typeName].run()
+	// }
+
+	getUserOwnFiles() {
+		return this.files$.get()
+	}
+
+	getUserFileStates() {
+		return this.fileStates$.get()
+	}
+
+	lastRecentFileOrdering = null as null | Array<{
+		fileId: TlaFile['id']
+		isPinned: boolean
+		date: number
+	}>
+
+	@computed
+	getUserRecentFiles() {
+		const myFiles = objectMapFromEntries(this.getUserOwnFiles().map((f) => [f.id, f]))
+		const myStates = objectMapFromEntries(this.getUserFileStates().map((f) => [f.fileId, f]))
+
+		const myFileIds = new Set<string>([...objectMapKeys(myFiles), ...objectMapKeys(myStates)])
+
+		const nextRecentFileOrdering: {
+			fileId: TlaFile['id']
+			isPinned: boolean
+			date: number
+		}[] = []
+
+		for (const fileId of myFileIds) {
+			const file = myFiles[fileId]
+			let state = myStates[fileId]
+			if (!file) continue
+			if (!state && !file.isDeleted && file.ownerId === this.userId) {
+				// create a file state for this file
+				// this allows us to 'undelete' soft-deleted files by manually toggling 'isDeleted' in the backend
+				state = this.getOrCreateFileState(file```ts
+// import { Query, QueryType, Smash, TableSchema, Zero } from '@rocicorp/zero'
+import { Zero } from '@rocicorp/zero'
+import { captureException } from '@sentry/react'
+import {
+	CreateFilesResponseBody,
+	CreateSnapshotRequestBody,
+	LOCAL_FILE_PREFIX,
+	MAX_NUMBER_OF_FILES,
+	TlaFile,
+	TlaFilePartial,
+	TlaFileState,
+	TlaSchema,
+	TlaUser,
+	UserPreferencesKeys,
+	Z_PROTOCOL_VERSION,
+	schema as zeroSchema,
+	ZErrorCode,
+} from '@tldraw/dotcom-shared'
+import {
+	assert,
+	fetch,
+	getFromLocalStorage,
+	promiseWithResolve,
+	Result,
+	setInLocalStorage,
+	structuredClone,
+	throttle,
+	uniqueId,
+} from '@tldraw/utils'
+import pick from 'lodash.pick'
+import {
+	assertExists,
+	Atom,
+	atom,
+	computed,
+	createTLSchema,
+	createTLUser,
+	dataUrlToFile,
+	defaultUserPreferences,
+	getUserPreferences,
+	objectMapFromEntries,
+	objectMapKeys,
+	parseTldrawJsonFile,
+	react,
+	Signal,
+	TLDocument,
+	TLSessionStateSnapshot,
+	TLUiToastsContextType,
+	TLUserPreferences,
+	transact,
+} from 'tldraw'
+import { MULTIPLAYER_SERVER, ZERO_SERVER } from '../../utils/config'
+import { multiplayerAssetStore } from '../../utils/multiplayerAssetStore'
+import { getScratchPersistenceKey } from '../../utils/scratch-persistence-key'
+import { TLAppUiContextType } from '../utils/app-ui-events'
+import { getDateFormat } from '../utils/dates'
+import { createIntl, defineMessages, setupCreateIntl } from '../utils/i18n'
+import { updateLocalSessionState } from '../utils/local-session-state'
+import { Zero as ZeroPolyfill } from './zero-polyfill'
+
+export const TLDR_FILE_ENDPOINT = `/api/app/tldr`
+export const PUBLISH_ENDPOINT = `/api/app/publish`
 
-		this.user$ = this.signalizeQuery('user signal', this.userQuery())
-		this.fileStates$ = this.signalizeQuery('file states signal', this.fileStateQuery())
+let appId = 0
+const useProperZero = getFromLocalStorage('useProperZero') === 'true'
+// eslint-disable-next-line no-console
+console.log('useProperZero', useProperZero)
+// @ts-expect-error
+window.zero = () => {
+	setInLocalStorage('useProperZero', String(!useProperZero))
+	location.reload()
+}
+
+export class TldrawApp {
+	config = {
+		maxNumberOfFiles: MAX_NUMBER_OF_FILES,
 	}
 
-	private userQuery() {
-		return this.z.query.user.where('id', '=', this.userId).one()
+	readonly id = appId++
+
+	readonly z: ZeroPolyfill | Zero<TlaSchema>
+
+	private readonly user$: Signal<TlaUser | undefined>
+	private readonly files$: Signal<TlaFile[]>
+	private readonly fileStates$: Signal<(TlaFileState & { file: TlaFile })[]>
+
+	private readonly abortController = new AbortController()
+	readonly disposables: (() => void)[] = [
+		() => this.abortController.abort(),
+		() => (this.z as any)?.dispose?.(),
+	]
+
+	private signalizeQuery<TReturn>(name: string, query: any): Signal<TReturn> {
+		// fail if closed?
+		const view = query.materialize()
+		const val$ = atom(name, view.data)
+		view.addListener((res: any) => {
+			val$.set(structuredClone(res) as any)
+		})
+		this.disposables.push(() => {
+			view.destroy()
+		})
+		return val$
 	}
 
-	private fileStateQuery() {
-		return this.z.query.file_state
-			.where('userId', '=', this.userId)
-			.related('file', (q: any) => q.one())
+	toasts: TLUiToastsContextType | null = null
+
+	private constructor(
+		public readonly userId: string,
+		getToken: () => Promise<string | null>,
+		onClientTooOld: () => void,
+		trackEvent: TLAppUiContextType
+	) {
+		const sessionId = uniqueId()
+
+		if (useProperZero) {
+			// NOTE: experimental client; keep options in sync with Zero polyfill behavior where possible
+			this.z = new Zero<TlaSchema>({
+				server: ZERO_SERVER,
+				schema: zeroSchema,
+				userID: this.userId,
+				getAuth: async () => {
+					const token = await getToken()
+					return { accessToken: token || 'no-token-found' }
+				},
+				params: {
+					sessionId,
+					protocolVersion: String(Z_PROTOCOL_VERSION),
+				},
+				onMutationRejected: this.showMutationRejectionToast,
+				onClientTooOld: () => onClientTooOld(),
+				trackEvent,
+			} as any)
+		} else {
+			this.z = new ZeroPolyfill({
+				// userID: userId,
+				// auth: encodedJWT,
+				getUri: async () => {
+					const params = new URLSearchParams({
+						sessionId,
+						protocolVersion: String(Z_PROTOCOL_VERSION),
+					})
+					const token = await getToken()
+					params.set('accessToken', token || 'no-token-found')
+					return `${MULTIPLAYER_SERVER}/app/${this.userId}/connect?${params}`
+				},
+				// schema,
+				// This is often easier to develop with if you're frequently changing
+				// the schema. Switch to 'idb' for local-persistence.
+				onMutationRejected: this.showMutationRejectionToast,
+				onClientTooOld: () => onClientTooOld(),
+				trackEvent,
+			})
+		}
+
+		this.user$ = this.signalizeQuery(
+			'user signal',
+			(this.z as any).query.user.where('id', this.userId).one()
+		)
+		this.files$ = this.signalizeQuery(
+			'files signal',
+			(this.z as any).query.file.where('ownerId', this.userId)
+		)
+		this.fileStates$ = this.signalizeQuery(
+			'file states signal',
+			(this.z as any).query.file_state.where('userId', this.userId).related('file', (q: any) => q.one())
+		)
 	}
 
 	async preload(initialUserData: TlaUser) {
 		let didCreate = false
-		await this.userQuery().preload().complete
-		await this.changesFlushed
+		await (this.z as any).query.user.where('id', this.userId).preload().complete
 		if (!this.user$.get()) {
 			didCreate = true
-			this.z.mutate.user.insert(initialUserData)
+			;(this.z as any).mutate.user.create(initialUserData)
 			updateLocalSessionState((state) => ({ ...state, shouldShowWelcomeDialog: true }))
 		}
 		await new Promise((resolve) => {
@@ -188,7 +508,8 @@ export class TldrawApp {
 		if (!this.user$.get()) {
 			throw Error('could not create user')
 		}
-		await this.fileStateQuery().preload().complete
+		await (this.z as any).query.file_state.where('userId', this.userId).preload().complete
+		await (this.z as any).query.file.where('ownerId', this.userId).preload().complete
 		return didCreate
 	}
 
@@ -279,20 +600,17 @@ export class TldrawApp {
 				Object.entries(others).filter(([_, value]) => value !== null)
 			) as Partial<TLUserPreferences>
 
-			this.z.mutate.user.update({
-				id: user.id,
-				...(nonNull as any),
+			;(this.z as any).mutate((tx: any) => {
+				tx.user.update({
+					id: user.id,
+					...(nonNull as any),
+				})
 			})
 		},
 	})
 
 	getUserOwnFiles() {
-		const fileStates = this.getUserFileStates()
-		const files: TlaFile[] = []
-		fileStates.forEach((f) => {
-			if (f.file) files.push(f.file)
-		})
-		return files
+		return this.files$.get()
 	}
 
 	getUserFileStates() {
@@ -320,14 +638,13 @@ export class TldrawApp {
 
 		for (const fileId of myFileIds) {
 			const file = myFiles[fileId]
-			let state: (typeof myStates)[string] | undefined = myStates[fileId]
+			let state = myStates[fileId]
 			if (!file) continue
 			if (!state && !file.isDeleted && file.ownerId === this.userId) {
 				// create a file state for this file
 				// this allows us to 'undelete' soft-deleted files by manually toggling 'isDeleted' in the backend
-				state = this.fileStates$.get().find((fs) => fs.fileId === fileId)
-			}
-			if (!state) {
+				state = this.getOrCreateFileState(fileId)
+			} else if (!state) {
 				// if the file is deleted, we don't want to show it in the recent files
 				continue
 			}
@@ -372,19 +689,15 @@ export class TldrawApp {
 		return numberOfFiles < this.config.maxNumberOfFiles
 	}
 
-	private showMaxFilesToast() {
-		this.toasts?.addToast({
-			title: this.getIntl().formatMessage(this.messages.max_files_title),
-			description: this.getIntl().formatMessage(this.messages.max_files_reached),
-			keepOpen: true,
-		})
-	}
-
-	async createFile(
+	createFile(
 		fileOrId?: string | Partial<TlaFile>
-	): Promise<Result<{ file: TlaFile }, 'max number of files reached'>> {
+	): Result<{ file: TlaFile }, 'max number of files reached'> {
 		if (!this.canCreateNewFile()) {
-			this.showMaxFilesToast()
+			this.toasts?.addToast({
+				title: this.getIntl().formatMessage(this.messages.max_files_title),
+				description: this.getIntl().formatMessage(this.messages.max_files_reached),
+				keepOpen: true,
+			})
 			return Result.err('max number of files reached')
 		}
 
@@ -413,23 +726,19 @@ export class TldrawApp {
 				Object.assign(file, { name: this.getFallbackFileName(file.createdAt) })
 			}
 		}
-		const fileState = {
-			isFileOwner: true,
-			fileId: file.id,
-			userId: this.userId,
-			firstVisitAt: null,
-			isPinned: false,
-			lastEditAt: null,
-			lastSessionState: null,
-			lastVisitAt: null,
-		}
-		await this.z.mutate.file.insertWithFileState({ file, fileState })
-		// todo: add server error handling for real Zero
-		// .server.catch((res: { error: string; details: string }) => {
-		// 	if (res.details === ZErrorCode.max_files_reached) {
-		// 		this.showMaxFilesToast()
-		// 	}
-		// })
+		;(this.z as any).mutate((tx: any) => {
+			tx.file.create(file)
+			tx.file_state.create({
+				isFileOwner: true,
+				fileId: file.id,
+				userId: this.userId,
+				firstVisitAt: null,
+				isPinned: false,
+				lastEditAt: null,
+				lastSessionState: null,
+				lastVisitAt: null,
+			})
+		})
 
 		return Result.ok({ file })
 	}
@@ -468,15 +777,14 @@ export class TldrawApp {
 		return
 	}
 
-	async slurpFile() {
-		return await this.createFile({
-			createSource: `${LOCAL_FILE_PREFIX}/${getScratchPersistenceKey()}`,
-		})
+	claimTemporaryFile(fileId: string) {
+		// removed; replaced by slurpFile
 	}
 
-	getFilePk(fileId: string) {
-		const file = this.getFile(fileId)
-		return { id: fileId, ownerId: file!.ownerId, publishedSlug: file!.publishedSlug }
+	slurpFile() {
+		return this.createFile({
+			createSource: `${LOCAL_FILE_PREFIX}/${getScratchPersistenceKey()}`,
+		})
 	}
 
 	toggleFileShared(fileId: string) {
@@ -485,9 +793,11 @@ export class TldrawApp {
 
 		if (file.ownerId !== this.userId) throw Error('user cannot edit that file')
 
-		this.z.mutate.file.update({
-			id: fileId,
-			shared: !file.shared,
+		;(this.z as any).mutate((tx: any) => {
+			tx.file.update({
+				id: fileId,
+				shared: !file.shared,
+			})
 		})
 	}
 
@@ -506,11 +816,13 @@ export class TldrawApp {
 		const name = this.getFileName(file)
 
 		// Optimistic update
-		this.z.mutate.file.update({
-			id: fileId,
-			name,
-			published: true,
-			lastPublished: Date.now(),
+		;(this.z as any).mutate((tx: any) => {
+			tx.file.update({
+				id: fileId,
+				name,
+				published: true,
+				lastPublished: Date.now(),
+			})
 		})
 	}
 
@@ -528,6 +840,11 @@ export class TldrawApp {
 		return assertExists(this.getFile(fileId), 'no file with id ' + fileId)
 	}
 
+	updateFile(partial: TlaFilePartial) {
+		this.requireFile(partial.id)
+		;(this.z as any).mutate.file.update(partial)
+	}
+
 	/**
 	 * Unpublish a file.
 	 *
@@ -541,9 +858,11 @@ export class TldrawApp {
 		if (!file.published) return Result.ok('success')
 
 		// Optimistic update
-		this.z.mutate.file.update({
-			id: fileId,
-			published: false,
+		;(this.z as any).mutate((tx: any) => {
+			tx.file.update({
+				id: fileId,
+				published: false,
+			})
 		})
 
 		return Result.ok('success')
@@ -556,10 +875,14 @@ export class TldrawApp {
 	 */
 	async deleteOrForgetFile(fileId: string) {
 		const file = this.getFile(fileId)
-		if (!file) return
 
 		// Optimistic update, remove file and file states
-		await this.z.mutate.file.deleteOrForget(file)
+		return (this.z as any).mutate((tx: any) => {
+			tx.file_state.delete({ fileId, userId: this.userId })
+			if (file?.ownerId === this.userId) {
+				tx.file.update({ id: fileId, isDeleted: true })
+			}
+		})
 	}
 
 	/**
@@ -572,7 +895,7 @@ export class TldrawApp {
 
 		if (!fileState) return
 
-		return this.z.mutate.file_state.update({
+		return (this.z as any).mutate.file_state.update({
 			fileId,
 			userId: this.userId,
 			isPinned: !fileState.isPinned,
@@ -587,15 +910,15 @@ export class TldrawApp {
 		}
 
 		if (sharedLinkType === 'no-access') {
-			this.z.mutate.file.update({ id: fileId, shared: false })
+			;(this.z as any).mutate.file.update({ id: fileId, shared: false })
 			return
 		}
-		this.z.mutate.file.update({ id: fileId, shared: true, sharedLinkType })
+		;(this.z as any).mutate.file.update({ id: fileId, shared: true, sharedLinkType })
 	}
 
 	updateUser(partial: Partial<TlaUser>) {
 		const user = this.getUser()
-		return this.z.mutate.user.update({
+		;(this.z as any).mutate.user.update({
 			id: user.id,
 			...partial,
 		})
@@ -607,26 +930,23 @@ export class TldrawApp {
 		>
 	) {
 		this.updateUser(exportPreferences)
-	}
+ 	}
 
-	async createFileStateIfNotExists(fileId: string) {
-		await this.changesFlushed
-		const fileState = this.getFileState(fileId)
+	getOrCreateFileState(fileId: string) {
+		let fileState = this.getFileState(fileId)
 		if (!fileState) {
-			const fs: TlaFileState = {
+			;(this.z as any).mutate.file_state.create({
 				fileId,
 				userId: this.userId,
 				firstVisitAt: Date.now(),
 				lastEditAt: null,
 				lastSessionState: null,
 				lastVisitAt: null,
-				isPinned: false,
-				// doesn't really matter what this is because it is
-				// overwritten by postgres
-				isFileOwner: this.isFileOwner(fileId),
-			}
-			this.z.mutate.file_state.insert(fs)
+			})
 		}
+		fileState = this.getFileState(fileId)
+		if (!fileState) throw Error('could not create file state')
+		return fileState
 	}
 
 	getFileState(fileId: string) {
@@ -636,15 +956,11 @@ export class TldrawApp {
 	updateFileState(fileId: string, partial: Partial<TlaFileState>) {
 		const fileState = this.getFileState(fileId)
 		if (!fileState) return
-		this.z.mutate.file_state.update({ ...partial, fileId, userId: fileState.userId })
-	}
-
-	updateFile(fileId: string, partial: Partial<TlaFile>) {
-		this.z.mutate.file.update({ id: fileId, ...partial })
+		;(this.z as any).mutate.file_state.update({ ...partial, fileId, userId: fileState.userId })
 	}
 
-	async onFileEnter(fileId: string) {
-		await this.createFileStateIfNotExists(fileId)
+	onFileEnter(fileId: string) {
+		this.getOrCreateFileState(fileId)
 		this.updateFileState(fileId, {
 			lastVisitAt: Date.now(),
 		})
@@ -670,7 +986,7 @@ export class TldrawApp {
 		fullName: string
 		email: string
 		avatar: string
-		getToken(): Promise<string | undefined>
+		getToken(): Promise<string | null>
 		onClientTooOld(): void
 		trackEvent: TLAppUiContextType
 	}) {
@@ -754,7 +1070,6 @@ export class TldrawApp {
 					total: totalFiles,
 					uploaded: uploadedFiles,
 				}),
-
 				description: `${getApproxPercentage()}%`,
 				keepOpen: true,
 			})
