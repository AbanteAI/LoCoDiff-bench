
index 1724dd1c8..cdd125c37 100644
--- a/tldraw_apps_dotcom_client_src_tla_app_TldrawApp.ts_expectedoutput.txt (expected):tmp/tmpd_z9dyqe_expected.txt	
+++ b/tldraw_apps_dotcom_client_src_tla_app_TldrawApp.ts_extracted.txt (actual):tmp/tmpfu36oin__actual.txt	
@@ -9,13 +9,11 @@ import {
 	MAX_NUMBER_OF_FILES,
 	TlaFile,
 	TlaFileState,
-	TlaMutators,
 	TlaSchema,
 	TlaUser,
 	UserPreferencesKeys,
-	Z_PROTOCOL_VERSION,
-	schema as zeroSchema,
 	ZErrorCode,
+	Z_PROTOCOL_VERSION,
 } from '@tldraw/dotcom-shared'
 import {
 	assert,
@@ -30,24 +28,21 @@ import {
 } from '@tldraw/utils'
 import pick from 'lodash.pick'
 import {
-	assertExists,
+	Signal,
+	TLDocument,
+	TLSessionStateSnapshot,
+	TLUiToastsContextType,
+	TLUserPreferences,
 	Atom,
 	atom,
 	computed,
 	createTLSchema,
-	createTLUser,
-	dataUrlToFile,
 	defaultUserPreferences,
 	getUserPreferences,
 	objectMapFromEntries,
 	objectMapKeys,
 	parseTldrawJsonFile,
 	react,
-	Signal,
-	TLDocument,
-	TLSessionStateSnapshot,
-	TLUiToastsContextType,
-	TLUserPreferences,
 	transact,
 } from 'tldraw'
 import { MULTIPLAYER_SERVER, ZERO_SERVER } from '../../utils/config'
@@ -57,7 +52,7 @@ import { TLAppUiContextType } from '../utils/app-ui-events'
 import { getDateFormat } from '../utils/dates'
 import { createIntl, defineMessages, setupCreateIntl } from '../utils/i18n'
 import { updateLocalSessionState } from '../utils/local-session-state'
-import { Zero as ZeroPolyfill } from './zero-polyfill'
+// import { Zero as ZeroPolyfill } from './zero-polyfill'
 
 export const TLDR_FILE_ENDPOINT = `/api/app/tldr`
 export const PUBLISH_ENDPOINT = `/api/app/publish`
@@ -79,7 +74,7 @@ export class TldrawApp {
 
 	readonly id = appId++
 
-	readonly z: ZeroPolyfill | Zero<TlaSchema, TlaMutators>
+	readonly z: Zero | Zero<TlaSchema, any>
 
 	private readonly user$: Signal<TlaUser | undefined>
 	private readonly fileStates$: Signal<(TlaFileState & { file: TlaFile })[]>
@@ -116,8 +111,6 @@ export class TldrawApp {
 		return val$
 	}
 
-	toasts: TLUiToastsContextType | null = null
-
 	private constructor(
 		public readonly userId: string,
 		getToken: () => Promise<string | undefined>,
@@ -126,10 +119,10 @@ export class TldrawApp {
 	) {
 		const sessionId = uniqueId()
 		this.z = useProperZero
-			? new Zero<TlaSchema, TlaMutators>({
+			? new Zero<TlaSchema, any>({
 					auth: getToken,
 					userID: userId,
-					schema: zeroSchema,
+					schema: createTLSchema(),
 					server: ZERO_SERVER,
 					mutators: createMutators(userId),
 					onUpdateNeeded(reason) {
@@ -138,8 +131,8 @@ export class TldrawApp {
 					},
 					kvStore: window.navigator.webdriver ? 'mem' : 'idb',
 				})
-			: new ZeroPolyfill({
-					userId,
+			: new Zero({
+					// userID: userId,
 					// auth: encodedJWT,
 					getUri: async () => {
 						const params = new URLSearchParams({
@@ -193,36 +186,7 @@ export class TldrawApp {
 	}
 
 	messages = defineMessages({
-		// toast title
-		mutation_error_toast_title: { defaultMessage: 'Error' },
-		// toast descriptions
-		publish_failed: {
-			defaultMessage: 'Unable to publish the file.',
-		},
-		unpublish_failed: {
-			defaultMessage: 'Unable to unpublish the file.',
-		},
-		republish_failed: {
-			defaultMessage: 'Unable to publish the changes.',
-		},
-		unknown_error: {
-			defaultMessage: 'An unexpected error occurred.',
-		},
-		forbidden: {
-			defaultMessage: 'You do not have the necessary permissions to perform this action.',
-		},
-		bad_request: {
-			defaultMessage: 'Invalid request.',
-		},
-		rate_limit_exceeded: {
-			defaultMessage: 'Rate limit exceeded, try again later.',
-		},
-		client_too_old: {
-			defaultMessage: 'Please refresh the page to get the latest version of tldraw.',
-		},
-		max_files_title: {
-			defaultMessage: 'File limit reached',
-		},
+		max_files_title: { defaultMessage: 'File limit reached' },
 		max_files_reached: {
 			defaultMessage:
 				'You have reached the maximum number of files. You need to delete old files before creating new ones.',
@@ -232,19 +196,34 @@ export class TldrawApp {
 				'{total, plural, one {Uploading .tldr file…} other {Uploading {uploaded} of {total} .tldr files…}}',
 		},
 		addingTldrFiles: {
-			// no need for pluralization, if there was only one file we navigated to it
-			// so there's no need to show a toast.
 			defaultMessage: 'Added {total} .tldr files.',
 		},
+		publish_failed: { defaultMessage: 'Unable to publish the file.' },
+		unpublish_failed: { defaultMessage: 'Unable to unpublish the file.' },
+		republish_failed: { defaultMessage: 'Unable to publish the changes.' },
+		unknown_error: { defaultMessage: 'An unexpected error occurred.' },
+		forbidden: {
+			defaultMessage:
+				'You do not have the necessary permissions to perform this action.',
+		},
+		bad_request: { defaultMessage: 'Invalid request.' },
+		rate_limit_exceeded: {
+			defaultMessage: 'Rate limit exceeded, try again later.',
+		},
+		mutation_error_toast_title: { defaultMessage: 'Error' },
+		client_too_old: {
+			defaultMessage: 'Please refresh the page to get the latest version of tldraw.',
+		},
 	})
 
 	getMessage(id: keyof typeof this.messages) {
-		let msg = this.messages[id]
-		if (!msg) {
+		const descriptor = this.messages[id]
+		if (!descriptor) {
+			// eslint-disable-next-line no-console
 			console.error('Could not find a translation for this error code', id)
-			msg = this.messages.unknown_error
+			return this.messages.unknown_error
 		}
-		return msg
+		return descriptor
 	}
 
 	showMutationRejectionToast = throttle((errorCode: ZErrorCode) => {
@@ -257,11 +236,20 @@ export class TldrawApp {
 
 	dispose() {
 		this.disposables.forEach((d) => d())
-		// this.store.dispose()
 	}
 
-	getUser() {
-		return assertExists(this.user$.get(), 'no user')
+	toasts: TLUiToastsContextType | null = null
+	intl: IntlShape | null = null
+
+	private getIntl() {
+		const intl = createIntl()
+		if (intl) return intl
+		setupCreateIntl({
+			defaultLocale: 'en',
+			locale: this.user$.get()?.locale ?? 'en',
+			messages: {},
+		})
+		return createIntl()!
 	}
 
 	tlUser = createTLUser({
@@ -274,11 +262,9 @@ export class TldrawApp {
 		}),
 		setUserPreferences: ({ id: _, ...others }: Partial<TLUserPreferences>) => {
 			const user = this.getUser()
-
 			const nonNull = Object.fromEntries(
 				Object.entries(others).filter(([_, value]) => value !== null)
 			) as Partial<TLUserPreferences>
-
 			this.z.mutate.user.update({
 				id: user.id,
 				...(nonNull as any),
@@ -286,6 +272,10 @@ export class TldrawApp {
 		},
 	})
 
+	// getAll<T extends keyof Schema['tables']>(typeName: T): SchemaToRow<Schema['tables'][T]>[] {
+	// 	return this.z.query[typeName].run()
+	// }
+
 	getUserOwnFiles() {
 		const fileStates = this.getUserFileStates()
 		const files: TlaFile[] = []
@@ -320,14 +310,13 @@ export class TldrawApp {
 
 		for (const fileId of myFileIds) {
 			const file = myFiles[fileId]
-			let state: (typeof myStates)[string] | undefined = myStates[fileId]
+			let state = myStates[fileId]
 			if (!file) continue
 			if (!state && !file.isDeleted && file.ownerId === this.userId) {
 				// create a file state for this file
 				// this allows us to 'undelete' soft-deleted files by manually toggling 'isDeleted' in the backend
 				state = this.fileStates$.get().find((fs) => fs.fileId === fileId)
-			}
-			if (!state) {
+			} else if (!state) {
 				// if the file is deleted, we don't want to show it in the recent files
 				continue
 			}
@@ -336,17 +325,20 @@ export class TldrawApp {
 				nextRecentFileOrdering.push(existing)
 				continue
 			}
-
 			nextRecentFileOrdering.push({
 				fileId,
 				isPinned: state.isPinned ?? false,
 				date: state.lastEditAt ?? state.firstVisitAt ?? file.createdAt ?? 0,
 			})
 		}
-
 		// sort by date with most recent first
 		nextRecentFileOrdering.sort((a, b) => b.date - a.date)
-
+		// move pinned files to the top, stable sort
+		nextRecentFileOrdering.sort((a, b) => {
+			if (a.isPinned && !b.isPinned) return -1
+			if (!a.isPinned && b.isPinned) return 1
+			return 0
+		})
 		// stash the ordering for next time
 		this.lastRecentFileOrdering = nextRecentFileOrdering
 
@@ -357,22 +349,19 @@ export class TldrawApp {
 		return Array.from(
 			new Set(
 				this.getUserFileStates()
-					.map((s) => {
-						// skip files where the owner is the current user
-						if (s.file!.ownerId === this.userId) return
-						return s.file
-					})
+					.filter((r) => r.file.ownerId !== this.userId)
+					.map((s) => s.file)
 					.filter(Boolean) as TlaFile[]
 			)
 		)
 	}
 
-	private canCreateNewFile() {
+	canCreateNewFile() {
 		const numberOfFiles = this.getUserOwnFiles().length
 		return numberOfFiles < this.config.maxNumberOfFiles
 	}
 
-	private showMaxFilesToast() {
+	private async showMaxFilesToast() {
 		this.toasts?.addToast({
 			title: this.getIntl().formatMessage(this.messages.max_files_title),
 			description: this.getIntl().formatMessage(this.messages.max_files_reached),
@@ -384,20 +373,19 @@ export class TldrawApp {
 		fileOrId?: string | Partial<TlaFile>
 	): Promise<Result<{ file: TlaFile }, 'max number of files reached'>> {
 		if (!this.canCreateNewFile()) {
-			this.showMaxFilesToast()
+			await this.showMaxFilesToast()
 			return Result.err('max number of files reached')
 		}
 
 		const file: TlaFile = {
 			id: typeof fileOrId === 'string' ? fileOrId : uniqueId(),
 			ownerId: this.userId,
-			// these two owner properties are overridden by postgres triggers
 			ownerAvatar: this.getUser().avatar,
 			ownerName: this.getUser().name,
 			isEmpty: true,
 			createdAt: Date.now(),
 			lastPublished: 0,
-			name: this.getFallbackFileName(Date.now()),
+			name: '',
 			published: false,
 			publishedSlug: uniqueId(),
 			shared: true,
@@ -452,33 +440,32 @@ export class TldrawApp {
 		}
 		assert(typeof file !== 'string', 'ok')
 
-		if (typeof file.name === 'undefined') {
-			captureException(new Error('file name is undefined somehow: ' + JSON.stringify(file)))
-		}
-		// need a ? here because we were seeing issues on sentry where file.name was undefined
-		const name = file.name?.trim()
+		const name = file.name.trim()
 		if (name) {
 			return name
 		}
 
 		if (useDateFallback) {
-			return this.getFallbackFileName(file.createdAt)
+			const createdAt = new Date(file.createdAt)
+			const format = getDateFormat(createdAt)
+			return this.getIntl().formatDate(createdAt, format)
 		}
 
 		return
 	}
 
+	claimTemporaryFile(fileId: string) {
+		// TODO(david): check that you can't claim someone else's file (the db insert should fail)
+		// TODO(zero stuff): add table constraint
+		this.createFile(fileId)
+	}
+
 	async slurpFile() {
 		return await this.createFile({
 			createSource: `${LOCAL_FILE_PREFIX}/${getScratchPersistenceKey()}`,
 		})
 	}
 
-	getFilePk(fileId: string) {
-		const file = this.getFile(fileId)
-		return { id: fileId, ownerId: file!.ownerId, publishedSlug: file!.publishedSlug }
-	}
-
 	toggleFileShared(fileId: string) {
 		const file = this.getUserOwnFiles().find((f) => f.id === fileId)
 		if (!file) throw Error('no file with id ' + fileId)
@@ -491,18 +478,11 @@ export class TldrawApp {
 		})
 	}
 
-	/**
-	 * Publish a file or re-publish changes.
-	 *
-	 * @param fileId - The file id to unpublish.
-	 * @returns A result indicating success or failure.
-	 */
 	publishFile(fileId: string) {
 		const file = this.getUserOwnFiles().find((f) => f.id === fileId)
 		if (!file) throw Error(`No file with that id`)
 		if (file.ownerId !== this.userId) throw Error('user cannot publish that file')
 
-		// We're going to bake the name of the file, if it's undefined
 		const name = this.getFileName(file)
 
 		// Optimistic update
@@ -514,18 +494,12 @@ export class TldrawApp {
 		})
 	}
 
-	getFile(fileId?: string): TlaFile | null {
-		if (!fileId) return null
-		return this.getUserOwnFiles().find((f) => f.id === fileId) ?? null
-	}
-
-	isFileOwner(fileId: string) {
-		const file = this.getFile(fileId)
-		return file && file.ownerId === this.userId
-	}
-
-	requireFile(fileId: string): TlaFile {
-		return assertExists(this.getFile(fileId), 'no file with id ' + fileId)
+	updateFile(partial: Partial<TlaFile>) {
+		this.requireFile(partial.id)
+		this.z.mutate.file.update({
+			...this.getFilePk(partial.id),
+			...partial,
+		})
 	}
 
 	/**
@@ -536,6 +510,7 @@ export class TldrawApp {
 	 */
 	unpublishFile(fileId: string) {
 		const file = this.requireFile(fileId)
+
 		if (file.ownerId !== this.userId) throw Error('user cannot edit that file')
 
 		if (!file.published) return Result.ok('success')
@@ -579,6 +554,12 @@ export class TldrawApp {
 		})
 	}
 
+	/**
+	 * Set the link type for a file.
+	 *
+	 * @param fileId - The file id.
+	 * @param sharedLinkType - The link type.
+	 */
 	setFileSharedLinkType(fileId: string, sharedLinkType: TlaFile['sharedLinkType'] | 'no-access') {
 		const file = this.requireFile(fileId)
 
@@ -593,6 +574,12 @@ export class TldrawApp {
 		this.z.mutate.file.update({ id: fileId, shared: true, sharedLinkType })
 	}
 
+	isFileOwner(fileId: string) {
+		const file = this.getFile(fileId)
+		if (!file) return false
+		return file.ownerId === this.userId
+	}
+
 	updateUser(partial: Partial<TlaUser>) {
 		const user = this.getUser()
 		return this.z.mutate.user.update({
@@ -609,7 +596,7 @@ export class TldrawApp {
 		this.updateUser(exportPreferences)
 	}
 
-	async createFileStateIfNotExists(fileId: string) {
+	async getOrCreateFileState(fileId: string) {
 		await this.changesFlushed
 		const fileState = this.getFileState(fileId)
 		if (!fileState) {
@@ -617,15 +604,12 @@ export class TldrawApp {
 				fileId,
 				userId: this.userId,
 				firstVisitAt: Date.now(),
+				isPinned: false,
 				lastEditAt: null,
 				lastSessionState: null,
 				lastVisitAt: null,
-				isPinned: false,
-				// doesn't really matter what this is because it is
-				// overwritten by postgres
-				isFileOwner: this.isFileOwner(fileId),
 			}
-			this.z.mutate.file_state.insert(fs)
+			this.z.mutate.file_state.upsert(fs)
 		}
 	}
 
@@ -639,12 +623,8 @@ export class TldrawApp {
 		this.z.mutate.file_state.update({ ...partial, fileId, userId: fileState.userId })
 	}
 
-	updateFile(fileId: string, partial: Partial<TlaFile>) {
-		this.z.mutate.file.update({ id: fileId, ...partial })
-	}
-
 	async onFileEnter(fileId: string) {
-		await this.createFileStateIfNotExists(fileId)
+		await this.getOrCreateFileState(fileId)
 		this.updateFileState(fileId, {
 			lastVisitAt: Date.now(),
 		})
@@ -673,16 +653,22 @@ export class TldrawApp {
 		getToken(): Promise<string | undefined>
 		onClientTooOld(): void
 		trackEvent: TLAppUiContextType
+		intl: IntlShape
 	}) {
 		// This is an issue: we may have a user record but not in the store.
 		// Could be just old accounts since before the server had a version
 		// of the store... but we should probably identify that better.
 
-		const { id: _id, name: _name, color, ...restOfPreferences } = getUserPreferences()
+		const {
+			id: _id,
+			name: _name,
+			color,
+			...restOfPreferences
+		} = getUserPreferences()
 		const app = new TldrawApp(opts.userId, opts.getToken, opts.onClientTooOld, opts.trackEvent)
 		// @ts-expect-error
 		window.app = app
-		const didCreate = await app.preload({
+		await app.preload({
 			id: opts.userId,
 			name: opts.fullName,
 			email: opts.email,
@@ -695,7 +681,6 @@ export class TldrawApp {
 			createdAt: Date.now(),
 			updatedAt: Date.now(),
 			flags: '',
-			allowAnalyticsCookie: null,
 			...restOfPreferences,
 			locale: restOfPreferences.locale ?? null,
 			animationSpeed: restOfPreferences.animationSpeed ?? null,
@@ -705,188 +690,9 @@ export class TldrawApp {
 			isWrapMode: restOfPreferences.isWrapMode ?? null,
 			isDynamicSizeMode: restOfPreferences.isDynamicSizeMode ?? null,
 			isPasteAtCursorMode: restOfPreferences.isPasteAtCursorMode ?? null,
+			allowAnalyticsCookie: null,
 		})
-		if (didCreate) {
-			opts.trackEvent('create-user', { source: 'app' })
-		}
 		return { app, userId: opts.userId }
 	}
-
-	getIntl() {
-		const intl = createIntl()
-		if (intl) return intl
-		// intl should exists since IntlWrapper should create it before we get here, but let's use this just in case
-		setupCreateIntl({
-			defaultLocale: 'en',
-			locale: this.user$.get()?.locale ?? 'en',
-			messages: {},
-		})
-		return createIntl()!
-	}
-
-	async uploadTldrFiles(files: File[], onFirstFileUploaded?: (file: TlaFile) => void) {
-		const totalFiles = files.length
-		let uploadedFiles = 0
-		if (totalFiles === 0) return
-
-		// this is only approx since we upload the files in pieces and they are base64 encoded
-		// in the json blob, so this will usually be a big overestimate. But that's fine because
-		// if the upload finishes before the number hits 100% people are pleasantly surprised.
-		const approxTotalBytes = files.reduce((acc, f) => acc + f.size, 0)
-		let bytesUploaded = 0
-		const getApproxPercentage = () =>
-			Math.min(Math.round((bytesUploaded / approxTotalBytes) * 100), 100)
-		const updateProgress = () => updateToast({ description: `${getApproxPercentage()}%` })
-
-		// only bother showing the percentage if it's going to take a while
-
-		let uploadingToastId = undefined as undefined | string
-		let didFinishUploading = false
-
-		// give it a second before we show the toast, in case the upload is fast
-		setTimeout(() => {
-			if (didFinishUploading || this.abortController.signal.aborted) return
-			// if it's close to the end, don't show the progress toast
-			if (getApproxPercentage() > 50) return
-			uploadingToastId = this.toasts?.addToast({
-				severity: 'info',
-				title: this.getIntl().formatMessage(this.messages.uploadingTldrFiles, {
-					total: totalFiles,
-					uploaded: uploadedFiles,
-				}),
-
-				description: `${getApproxPercentage()}%`,
-				keepOpen: true,
-			})
-		}, 800)
-
-		const updateToast = (args: { title?: string; description?: string }) => {
-			if (!uploadingToastId) return
-			this.toasts?.toasts.update((toasts) =>
-				toasts.map((t) =>
-					t.id === uploadingToastId
-						? {
-								...t,
-								...args,
-							}
-						: t
-				)
-			)
-		}
-
-		for (const f of files) {
-			const res = await this.uploadTldrFile(f, (bytes) => {
-				bytesUploaded += bytes
-				updateProgress()
-			}).catch((e) => Result.err(e))
-			if (!res.ok) {
-				if (uploadingToastId) this.toasts?.removeToast(uploadingToastId)
-				this.toasts?.addToast({
-					severity: 'error',
-					title: this.getIntl().formatMessage(this.messages.unknown_error),
-					keepOpen: true,
-				})
-				console.error(res.error)
-				return
-			}
-
-			updateToast({
-				title: this.getIntl().formatMessage(this.messages.uploadingTldrFiles, {
-					total: totalFiles,
-					uploaded: ++uploadedFiles + 1,
-				}),
-			})
-
-			if (onFirstFileUploaded) {
-				onFirstFileUploaded(res.value.file)
-				onFirstFileUploaded = undefined
-			}
-		}
-		didFinishUploading = true
-
-		if (uploadingToastId) this.toasts?.removeToast(uploadingToastId)
-
-		if (totalFiles > 1) {
-			this.toasts?.addToast({
-				severity: 'success',
-				title: this.getIntl().formatMessage(this.messages.addingTldrFiles, {
-					total: files.length,
-				}),
-				keepOpen: true,
-			})
-		}
-	}
-
-	private async uploadTldrFile(
-		file: File,
-		onProgress?: (bytesUploadedSinceLastProgressUpdate: number) => void
-	) {
-		const json = await file.text()
-		const parseFileResult = parseTldrawJsonFile({
-			schema: createTLSchema(),
-			json,
-		})
-
-		if (!parseFileResult.ok) {
-			return Result.err('could not parse file')
-		}
-
-		const snapshot = parseFileResult.value.getStoreSnapshot()
-
-		for (const record of Object.values(snapshot.store)) {
-			if (
-				record.typeName !== 'asset' ||
-				record.type === 'bookmark' ||
-				!record.props.src?.startsWith('data:')
-			) {
-				snapshot.store[record.id] = record
-				continue
-			}
-			const src = record.props.src
-			const file = await dataUrlToFile(
-				src,
-				record.props.name,
-				record.props.mimeType ?? 'application/octet-stream'
-			)
-			// TODO: this creates duplicate versions of the assets because we'll re-upload them when the user opens
-			// the file to associate them with the file id. To avoid this we'd need a way to create the file row
-			// in postgres so we can do the association while uploading the first time. Or just tolerate foreign key
-			// constraints being violated for a moment.
-			const assetsStore = multiplayerAssetStore()
-			const { src: newSrc } = await assetsStore.upload(record, file, this.abortController.signal)
-			onProgress?.(file.size)
-			snapshot.store[record.id] = {
-				...record,
-				props: {
-					...record.props,
-					src: newSrc,
-				},
-			}
-		}
-		const body = JSON.stringify({
-			snapshots: [
-				{
-					schema: snapshot.schema,
-					snapshot: snapshot.store,
-				} satisfies CreateSnapshotRequestBody,
-			],
-		})
-
-		const res = await fetch(TLDR_FILE_ENDPOINT, { method: 'POST', body })
-		onProgress?.(body.length)
-		if (!res.ok) {
-			throw Error('could not upload file ' + (await res.text()))
-		}
-		const response = (await res.json()) as CreateFilesResponseBody
-		if (response.error) {
-			throw Error(response.message)
-		}
-		const id = response.slugs[0]
-		const name =
-			file.name?.replace(/\.tldr$/, '') ??
-			Object.values(snapshot.store).find((d): d is TLDocument => d.typeName === 'document')?.name ??
-			''
-
-		return this.createFile({ id, name })
-	}
-}
\ No newline at end of file
+}
+```
\ No newline at end of file
