
index 1724dd1c8..67605e72a 100644
--- a/tldraw_apps_dotcom_client_src_tla_app_TldrawApp.ts_expectedoutput.txt (expected):tmp/tmpireviqdi_expected.txt	
+++ b/tldraw_apps_dotcom_client_src_tla_app_TldrawApp.ts_extracted.txt (actual):tmp/tmphcawe6p9_actual.txt	
@@ -3,19 +3,18 @@ import { Zero } from '@rocicorp/zero'
 import { captureException } from '@sentry/react'
 import {
 	CreateFilesResponseBody,
-	createMutators,
 	CreateSnapshotRequestBody,
 	LOCAL_FILE_PREFIX,
 	MAX_NUMBER_OF_FILES,
 	TlaFile,
+	TlaFilePartial,
 	TlaFileState,
-	TlaMutators,
 	TlaSchema,
 	TlaUser,
 	UserPreferencesKeys,
-	Z_PROTOCOL_VERSION,
 	schema as zeroSchema,
 	ZErrorCode,
+	Z_PROTOCOL_VERSION,
 } from '@tldraw/dotcom-shared'
 import {
 	assert,
@@ -39,6 +38,7 @@ import {
 	dataUrlToFile,
 	defaultUserPreferences,
 	getUserPreferences,
+	isDocument,
 	objectMapFromEntries,
 	objectMapKeys,
 	parseTldrawJsonFile,
@@ -79,36 +79,24 @@ export class TldrawApp {
 
 	readonly id = appId++
 
-	readonly z: ZeroPolyfill | Zero<TlaSchema, TlaMutators>
+	readonly z: ZeroPolyfill | Zero<TlaSchema>
 
 	private readonly user$: Signal<TlaUser | undefined>
+	private readonly files$: Signal<TlaFile[]>
 	private readonly fileStates$: Signal<(TlaFileState & { file: TlaFile })[]>
 
 	private readonly abortController = new AbortController()
-	readonly disposables: (() => void)[] = [() => this.abortController.abort(), () => this.z.close()]
-
-	changes: Map<Atom<any, unknown>, any> = new Map()
-	changesFlushed = null as null | ReturnType<typeof promiseWithResolve>
+	readonly disposables: (() => void)[] = [
+		() => this.abortController.abort(),
+		() => this.z.dispose(),
+	]
 
 	private signalizeQuery<TReturn>(name: string, query: any): Signal<TReturn> {
 		// fail if closed?
 		const view = query.materialize()
 		const val$ = atom(name, view.data)
 		view.addListener((res: any) => {
-			this.changes.set(val$, structuredClone(res))
-			if (!this.changesFlushed) {
-				this.changesFlushed = promiseWithResolve()
-			}
-			queueMicrotask(() => {
-				transact(() => {
-					this.changes.forEach((value, key) => {
-						key.set(value)
-					})
-					this.changes.clear()
-				})
-				this.changesFlushed?.resolve(undefined)
-				this.changesFlushed = null
-			})
+			val$.set(structuredClone(res) as any)
 		})
 		this.disposables.push(() => {
 			view.destroy()
@@ -120,65 +108,80 @@ export class TldrawApp {
 
 	private constructor(
 		public readonly userId: string,
-		getToken: () => Promise<string | undefined>,
+		getToken: () => Promise<string | null>,
 		onClientTooOld: () => void,
 		trackEvent: TLAppUiContextType
 	) {
 		const sessionId = uniqueId()
-		this.z = useProperZero
-			? new Zero<TlaSchema, TlaMutators>({
-					auth: getToken,
-					userID: userId,
-					schema: zeroSchema,
-					server: ZERO_SERVER,
-					mutators: createMutators(userId),
-					onUpdateNeeded(reason) {
-						console.error('update needed', reason)
-						onClientTooOld()
-					},
-					kvStore: window.navigator.webdriver ? 'mem' : 'idb',
-				})
-			: new ZeroPolyfill({
-					userId,
-					// auth: encodedJWT,
-					getUri: async () => {
-						const params = new URLSearchParams({
-							sessionId,
-							protocolVersion: String(Z_PROTOCOL_VERSION),
-						})
-						const token = await getToken()
-						params.set('accessToken', token || 'no-token-found')
-						return `${MULTIPLAYER_SERVER}/app/${userId}/connect?${params}`
-					},
-					// schema,
-					// This is often easier to develop with if you're frequently changing
-					// the schema. Switch to 'idb' for local-persistence.
-					onMutationRejected: this.showMutationRejectionToast,
-					onClientTooOld: () => onClientTooOld(),
-					trackEvent,
-				})
 
-		this.user$ = this.signalizeQuery('user signal', this.userQuery())
-		this.fileStates$ = this.signalizeQuery('file states signal', this.fileStateQuery())
-	}
-
-	private userQuery() {
-		return this.z.query.user.where('id', '=', this.userId).one()
-	}
+		if (useProperZero) {
+			const z = new Zero({
+				userID: userId,
+				server: ZERO_SERVER,
+				auth: {
+					refresh: () =>
+						promiseWithResolve(async (resolve) => {
+							const token = await getToken()
+							resolve({
+								token: token || 'no-token-found',
+								refreshAt: Date.now() + 1000 * 60 * 30,
+							})
+						}),
+				},
+				schema: zeroSchema,
+				// This is often easier to develop with if you're frequently changing
+				// the schema. Switch to 'idb' for local-persistence.
+				onMutationRejected: this.showMutationRejectionToast,
+				onClientTooOld: () => onClientTooOld(),
+				trackEvent,
+			})
+			this.z = z
+		} else {
+			this.z = new ZeroPolyfill({
+				// userID: userId,
+				// auth: encodedJWT,
+				getUri: async () => {
+					const params = new URLSearchParams({
+						sessionId,
+						protocolVersion: String(Z_PROTOCOL_VERSION),
+					})
+					const token = await getToken()
+					params.set('accessToken', token || 'no-token-found')
+					return `${MULTIPLAYER_SERVER}/app/${userId}/connect?${params}`
+				},
+				// schema,
+				// This is often easier to develop with if you're frequently changing
+				// the schema. Switch to 'idb' for local-persistence.
+				onMutationRejected: this.showMutationRejectionToast,
+				onClientTooOld: () => onClientTooOld(),
+				trackEvent,
+			})
+		}
 
-	private fileStateQuery() {
-		return this.z.query.file_state
-			.where('userId', '=', this.userId)
-			.related('file', (q: any) => q.one())
+		this.user$ = this.signalizeQuery(
+			'user signal',
+			this.z.query.user.where('id', this.userId).one()
+		)
+		this.files$ = this.signalizeQuery(
+			'files signal',
+			this.z.query.file.where('ownerId', this.userId)
+		)
+		this.fileStates$ = this.signalizeQuery(
+			'file states signal',
+			this.z
+				.query
+				// @ts-ignore ZeroPolyfill returns this shape
+				.file_state.where('userId', this.userId)
+				.related('file', (q: any) => q.one())
+		)
 	}
 
 	async preload(initialUserData: TlaUser) {
 		let didCreate = false
-		await this.userQuery().preload().complete
-		await this.changesFlushed
+		await this.z.query.user.where('id', this.userId).preload().complete
 		if (!this.user$.get()) {
 			didCreate = true
-			this.z.mutate.user.insert(initialUserData)
+			this.z.mutate.user.create(initialUserData)
 			updateLocalSessionState((state) => ({ ...state, shouldShowWelcomeDialog: true }))
 		}
 		await new Promise((resolve) => {
@@ -188,7 +191,8 @@ export class TldrawApp {
 		if (!this.user$.get()) {
 			throw Error('could not create user')
 		}
-		await this.fileStateQuery().preload().complete
+		await this.z.query.file_state.where('userId', this.userId).preload().complete
+		await this.z.query.file.where('ownerId', this.userId).preload().complete
 		return didCreate
 	}
 
@@ -279,20 +283,23 @@ export class TldrawApp {
 				Object.entries(others).filter(([_, value]) => value !== null)
 			) as Partial<TLUserPreferences>
 
-			this.z.mutate.user.update({
-				id: user.id,
-				...(nonNull as any),
+			this.z.mutate((tx) => {
+				tx.user.update({
+					id: user.id,
+					...(nonNull as any),
+				})
 			})
 		},
 	})
 
+	// getAll<T extends keyof Schema['tables']>(
+	// 	typeName: T
+	// ): SchemaToRow<Schema['tables'][T]>[] {
+	// 	return this.z.query[typeName].run()
+	// }
+
 	getUserOwnFiles() {
-		const fileStates = this.getUserFileStates()
-		const files: TlaFile[] = []
-		fileStates.forEach((f) => {
-			if (f.file) files.push(f.file)
-		})
-		return files
+		return this.files$.get()
 	}
 
 	getUserFileStates() {
@@ -320,14 +327,13 @@ export class TldrawApp {
 
 		for (const fileId of myFileIds) {
 			const file = myFiles[fileId]
-			let state: (typeof myStates)[string] | undefined = myStates[fileId]
+			let state = myStates[fileId]
 			if (!file) continue
 			if (!state && !file.isDeleted && file.ownerId === this.userId) {
 				// create a file state for this file
 				// this allows us to 'undelete' soft-deleted files by manually toggling 'isDeleted' in the backend
-				state = this.fileStates$.get().find((fs) => fs.fileId === fileId)
-			}
-			if (!state) {
+				state = this.getOrCreateFileState(fileId)
+			} else if (!state) {
 				// if the file is deleted, we don't want to show it in the recent files
 				continue
 			}
@@ -372,19 +378,15 @@ export class TldrawApp {
 		return numberOfFiles < this.config.maxNumberOfFiles
 	}
 
-	private showMaxFilesToast() {
-		this.toasts?.addToast({
-			title: this.getIntl().formatMessage(this.messages.max_files_title),
-			description: this.getIntl().formatMessage(this.messages.max_files_reached),
-			keepOpen: true,
-		})
-	}
-
-	async createFile(
+	createFile(
 		fileOrId?: string | Partial<TlaFile>
-	): Promise<Result<{ file: TlaFile }, 'max number of files reached'>> {
+	): Result<{ file: TlaFile }, 'max number of files reached'> {
 		if (!this.canCreateNewFile()) {
-			this.showMaxFilesToast()
+			this.toasts?.addToast({
+				title: this.getIntl().formatMessage(this.messages.max_files_title),
+				description: this.getIntl().formatMessage(this.messages.max_files_reached),
+				keepOpen: true,
+			})
 			return Result.err('max number of files reached')
 		}
 
@@ -413,23 +415,19 @@ export class TldrawApp {
 				Object.assign(file, { name: this.getFallbackFileName(file.createdAt) })
 			}
 		}
-		const fileState = {
-			isFileOwner: true,
-			fileId: file.id,
-			userId: this.userId,
-			firstVisitAt: null,
-			isPinned: false,
-			lastEditAt: null,
-			lastSessionState: null,
-			lastVisitAt: null,
-		}
-		await this.z.mutate.file.insertWithFileState({ file, fileState })
-		// todo: add server error handling for real Zero
-		// .server.catch((res: { error: string; details: string }) => {
-		// 	if (res.details === ZErrorCode.max_files_reached) {
-		// 		this.showMaxFilesToast()
-		// 	}
-		// })
+		this.z.mutate((tx) => {
+			tx.file.create(file)
+			tx.file_state.create({
+				isFileOwner: true,
+				fileId: file.id,
+				userId: this.userId,
+				firstVisitAt: null,
+				isPinned: false,
+				lastEditAt: null,
+				lastSessionState: null,
+				lastVisitAt: null,
+			})
+		})
 
 		return Result.ok({ file })
 	}
@@ -468,26 +466,24 @@ export class TldrawApp {
 		return
 	}
 
-	async slurpFile() {
-		return await this.createFile({
+	_slurpFileId: string | null = null
+	slurpFile() {
+		return this.createFile({
 			createSource: `${LOCAL_FILE_PREFIX}/${getScratchPersistenceKey()}`,
 		})
 	}
 
-	getFilePk(fileId: string) {
-		const file = this.getFile(fileId)
-		return { id: fileId, ownerId: file!.ownerId, publishedSlug: file!.publishedSlug }
-	}
-
 	toggleFileShared(fileId: string) {
 		const file = this.getUserOwnFiles().find((f) => f.id === fileId)
 		if (!file) throw Error('no file with id ' + fileId)
 
 		if (file.ownerId !== this.userId) throw Error('user cannot edit that file')
 
-		this.z.mutate.file.update({
-			id: fileId,
-			shared: !file.shared,
+		this.z.mutate((tx) => {
+			tx.file.update({
+				id: fileId,
+				shared: !file.shared,
+			})
 		})
 	}
 
@@ -506,11 +502,13 @@ export class TldrawApp {
 		const name = this.getFileName(file)
 
 		// Optimistic update
-		this.z.mutate.file.update({
-			id: fileId,
-			name,
-			published: true,
-			lastPublished: Date.now(),
+		this.z.mutate((tx) => {
+			tx.file.update({
+				id: fileId,
+				name,
+				published: true,
+				lastPublished: Date.now(),
+			})
 		})
 	}
 
@@ -528,6 +526,11 @@ export class TldrawApp {
 		return assertExists(this.getFile(fileId), 'no file with id ' + fileId)
 	}
 
+	updateFile(partial: TlaFilePartial) {
+		this.requireFile(partial.id)
+		this.z.mutate.file.update(partial)
+	}
+
 	/**
 	 * Unpublish a file.
 	 *
@@ -541,9 +544,11 @@ export class TldrawApp {
 		if (!file.published) return Result.ok('success')
 
 		// Optimistic update
-		this.z.mutate.file.update({
-			id: fileId,
-			published: false,
+		this.z.mutate((tx) => {
+			tx.file.update({
+				id: fileId,
+				published: false,
+			})
 		})
 
 		return Result.ok('success')
@@ -556,10 +561,14 @@ export class TldrawApp {
 	 */
 	async deleteOrForgetFile(fileId: string) {
 		const file = this.getFile(fileId)
-		if (!file) return
 
 		// Optimistic update, remove file and file states
-		await this.z.mutate.file.deleteOrForget(file)
+		return this.z.mutate((tx) => {
+			tx.file_state.delete({ fileId, userId: this.userId })
+			if (file?.ownerId === this.userId) {
+				tx.file.update({ id: fileId, isDeleted: true })
+			}
+		})
 	}
 
 	/**
@@ -595,7 +604,7 @@ export class TldrawApp {
 
 	updateUser(partial: Partial<TlaUser>) {
 		const user = this.getUser()
-		return this.z.mutate.user.update({
+		this.z.mutate.user.update({
 			id: user.id,
 			...partial,
 		})
@@ -609,28 +618,25 @@ export class TldrawApp {
 		this.updateUser(exportPreferences)
 	}
 
-	async createFileStateIfNotExists(fileId: string) {
-		await this.changesFlushed
-		const fileState = this.getFileState(fileId)
+	getFileState(fileId: string) {
+		return this.getUserFileStates().find((f) => f.fileId === fileId)
+	}
+
+	getOrCreateFileState(fileId: string) {
+		let fileState = this.getFileState(fileId)
 		if (!fileState) {
-			const fs: TlaFileState = {
+			this.z.mutate.file_state.create({
 				fileId,
 				userId: this.userId,
 				firstVisitAt: Date.now(),
 				lastEditAt: null,
 				lastSessionState: null,
 				lastVisitAt: null,
-				isPinned: false,
-				// doesn't really matter what this is because it is
-				// overwritten by postgres
-				isFileOwner: this.isFileOwner(fileId),
-			}
-			this.z.mutate.file_state.insert(fs)
+			})
 		}
-	}
-
-	getFileState(fileId: string) {
-		return this.getUserFileStates().find((f) => f.fileId === fileId)
+		fileState = this.getFileState(fileId)
+		if (!fileState) throw Error('could not create file state')
+		return fileState
 	}
 
 	updateFileState(fileId: string, partial: Partial<TlaFileState>) {
@@ -639,12 +645,8 @@ export class TldrawApp {
 		this.z.mutate.file_state.update({ ...partial, fileId, userId: fileState.userId })
 	}
 
-	updateFile(fileId: string, partial: Partial<TlaFile>) {
-		this.z.mutate.file.update({ id: fileId, ...partial })
-	}
-
-	async onFileEnter(fileId: string) {
-		await this.createFileStateIfNotExists(fileId)
+	onFileEnter(fileId: string) {
+		this.getOrCreateFileState(fileId)
 		this.updateFileState(fileId, {
 			lastVisitAt: Date.now(),
 		})
@@ -670,7 +672,7 @@ export class TldrawApp {
 		fullName: string
 		email: string
 		avatar: string
-		getToken(): Promise<string | undefined>
+		getToken(): Promise<string | null>
 		onClientTooOld(): void
 		trackEvent: TLAppUiContextType
 	}) {
