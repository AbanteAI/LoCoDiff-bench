
index 489e95479..24048b2f6 100644
--- a/tldraw_packages_store_src_lib_Store.ts_expectedoutput.txt (expected):tmp/tmptcspptgy_expected.txt	
+++ b/tldraw_packages_store_src_lib_Store.ts_extracted.txt (actual):tmp/tmpi589j8gv_actual.txt	
@@ -24,11 +24,7 @@ import { devFreeze } from './devFreeze'
 export type RecordFromId<K extends RecordId<UnknownRecord>> =
 	K extends RecordId<infer R> ? R : never
 
-/**
- * A diff describing the changes to a collection.
- *
- * @public
- */
+/** @public */
 export interface CollectionDiff<T> {
 	added?: Set<T>
 	removed?: Set<T>
@@ -43,43 +39,21 @@ export interface StoreListenerFilters {
 	scope: RecordScope | 'all'
 }
 
-/**
- * An entry containing changes that originated either by user actions or remote changes.
- *
- * @public
- */
+/** @public */
 export interface HistoryEntry<R extends UnknownRecord = UnknownRecord> {
 	changes: RecordsDiff<R>
 	source: ChangeSource
 }
 
-/**
- * A function that will be called when the history changes.
- *
- * @public
- */
+/** @public */
 export type StoreListener<R extends UnknownRecord> = (entry: HistoryEntry<R>) => void
 
-/**
- * A record store is a collection of records of different types.
- *
- * @public
- */
+/** @public */
 export interface ComputedCache<Data, R extends UnknownRecord> {
 	get(id: IdOf<R>): Data | undefined
 }
 
 /** @public */
-export interface CreateComputedCacheOpts<Data, R extends UnknownRecord> {
-	areRecordsEqual?(a: R, b: R): boolean
-	areResultsEqual?(a: Data, b: Data): boolean
-}
-
-/**
- * A serialized snapshot of the record store's values.
- *
- * @public
- */
 export type SerializedStore<R extends UnknownRecord> = Record<IdOf<R>, R>
 
 /** @public */
@@ -94,11 +68,6 @@ export interface StoreValidator<R extends UnknownRecord> {
 	validateUsingKnownGoodVersion?(knownGoodVersion: R, record: unknown): R
 }
 
-/** @public */
-export type StoreValidators<R extends UnknownRecord> = {
-	[K in R['typeName']]: StoreValidator<Extract<R, { typeName: K }>>
-}
-
 /** @public */
 export interface StoreError {
 	error: Error
@@ -111,6 +80,12 @@ export interface StoreError {
 /** @internal */
 export type StoreRecord<S extends Store<any>> = S extends Store<infer R> ? R : never
 
+/** @public */
+export interface CreateComputedCacheOpts<Data, R extends UnknownRecord> {
+	areRecordsEqual?(a: R, b: R): boolean
+	areResultsEqual?(a: Data, b: Data): boolean
+}
+
 /**
  * A store of records.
  *
@@ -121,8 +96,9 @@ export class Store<R extends UnknownRecord = UnknownRecord, Props = unknown> {
 	 * The random id of the store.
 	 */
 	public readonly id: string
+
 	/**
-	 * An AtomMap containing the stores records.
+	 * An AtomMap containing the store's records.
 	 *
 	 * @internal
 	 * @readonly
@@ -170,7 +146,7 @@ export class Store<R extends UnknownRecord = UnknownRecord, Props = unknown> {
 	private historyReactor: Reactor
 
 	/**
-	 * Function to dispose of any in-flight timeouts.
+	 * Function to dispose of any in‑flight timeouts.
 	 *
 	 * @internal
 	 */
@@ -186,6 +162,8 @@ export class Store<R extends UnknownRecord = UnknownRecord, Props = unknown> {
 
 	public readonly sideEffects = new StoreSideEffects<R>(this)
 
+	private isMergingRemoteChanges = false
+
 	constructor(config: {
 		id?: string
 		/** The store's initial data. */
@@ -246,8 +224,12 @@ export class Store<R extends UnknownRecord = UnknownRecord, Props = unknown> {
 		}
 	}
 
-	public _flushHistory() {
-		// If we have accumulated history, flush it and update listeners
+	dispose() {
+		this.cancelHistoryReactor()
+	}
+
+	/** @internal */
+	_flushHistory() {
 		if (this.historyAccumulator.hasChanges()) {
 			const entries = this.historyAccumulator.flush()
 			for (const { changes, source } of entries) {
@@ -280,15 +262,10 @@ export class Store<R extends UnknownRecord = UnknownRecord, Props = unknown> {
 		}
 	}
 
-	dispose() {
-		this.cancelHistoryReactor()
-	}
-
 	/**
-	 * Filters out non-document changes from a diff. Returns null if there are no changes left.
+	 * Filters out non‑document changes from a diff. Returns null if there are no changes left.
 	 * @param change - the records diff
 	 * @param scope - the records scope
-	 * @returns
 	 */
 	filterChangesByScope(change: RecordsDiff<R>, scope: RecordScope) {
 		const result = {
@@ -306,11 +283,6 @@ export class Store<R extends UnknownRecord = UnknownRecord, Props = unknown> {
 		return result
 	}
 
-	/**
-	 * Update the history with a diff of changes.
-	 *
-	 * @param changes - The changes to add to the history.
-	 */
 	private updateHistory(changes: RecordsDiff<R>): void {
 		this.historyAccumulator.add({
 			changes,
@@ -326,11 +298,101 @@ export class Store<R extends UnknownRecord = UnknownRecord, Props = unknown> {
 		this.allRecords().forEach((record) => this.schema.validateRecord(this, record, phase, null))
 	}
 
+	/** @internal */
+	addDiffForAfterEvent(before: R | null, after: R | null) {
+		assert(this.pendingAfterEvents, 'must be in event operation')
+		if (before === after) return
+		if (before && after) assert(before.id === after.id)
+		const id = (before || after)!.id
+		const existing = this.pendingAfterEvents.get(id)
+		if (existing) {
+			existing.after = after
+		} else {
+			this.pendingAfterEvents.set(id, { before, after })
+		}
+	}
+
+	private pendingAfterEvents: Map<IdOf<R>, { before: R | null; after: R | null }> | null = null
+
+	private flushAtomicCallbacks(isMergingRemoteChanges: boolean) {
+		let updateDepth = 0
+		let source: ChangeSource = isMergingRemoteChanges ? 'remote' : 'user'
+		while (this.pendingAfterEvents) {
+			const events = this.pendingAfterEvents
+			this.pendingAfterEvents = null
+
+			if (!this.sideEffects.isEnabled()) continue
+
+			updateDepth++
+			if (updateDepth > 100) {
+				throw new Error('Maximum store update depth exceeded, bailing out')
+			}
+
+			for (const { before, after } of events.values()) {
+				if (before && after && before !== after && !isEqual(before, after)) {
+					this.sideEffects.handleAfterChange(before, after, source)
+				} else if (before && !after) {
+					this.sideEffects.handleAfterDelete(before, source)
+				} else if (!before && after) {
+					this.sideEffects.handleAfterCreate(after, source)
+				}
+			}
+
+			if (!this.pendingAfterEvents) {
+				this.sideEffects.handleOperationComplete(source)
+			} else {
+				source = 'user'
+			}
+		}
+	}
+
+	private _isInAtomicOp = false
+	/** @internal */
+	atomic<T>(fn: () => T, runCallbacks = true, isMergingRemoteChanges = false): T {
+		return transact(() => {
+			if (this._isInAtomicOp) {
+				if (!this.pendingAfterEvents) this.pendingAfterEvents = new Map()
+				const prevSideEffectsEnabled = this.sideEffects.isEnabled()
+				assert(!isMergingRemoteChanges, 'cannot call mergeRemoteChanges while in atomic operation')
+				try {
+					if (prevSideEffectsEnabled && !runCallbacks) {
+						this.sideEffects.setIsEnabled(false)
+					}
+					return fn()
+				} finally {
+					this.sideEffects.setIsEnabled(prevSideEffectsEnabled)
+				}
+			}
+
+			this.pendingAfterEvents = new Map()
+			const prevSideEffectsEnabled = this.sideEffects.isEnabled()
+			this.sideEffects.setIsEnabled(runCallbacks ?? prevSideEffectsEnabled)
+			this._isInAtomicOp = true
+
+			if (isMergingRemoteChanges) {
+				this.isMergingRemoteChanges = true
+			}
+
+			try {
+				const result = fn()
+				this.isMergingRemoteChanges = false
+
+				this.flushAtomicCallbacks(isMergingRemoteChanges)
+
+				return result
+			} finally {
+				this.pendingAfterEvents = null
+				this.sideEffects.setIsEnabled(prevSideEffectsEnabled)
+				this._isInAtomicOp = false
+				this.isMergingRemoteChanges = false
+			}
+		})
+	}
+
 	/**
 	 * Add some records to the store. It's an error if they already exist.
 	 *
 	 * @param records - The records to add.
-	 * @param phaseOverride - The phase override.
 	 * @public
 	 */
 	put(records: R[], phaseOverride?: 'initialize'): void {
@@ -338,69 +400,55 @@ export class Store<R extends UnknownRecord = UnknownRecord, Props = unknown> {
 			const updates: Record<IdOf<UnknownRecord>, [from: R, to: R]> = {}
 			const additions: Record<IdOf<UnknownRecord>, R> = {}
 
-			// Iterate through all records, creating, updating or removing as needed
-			let record: R
-
-			// There's a chance that, despite having records, all of the values are
-			// identical to what they were before; and so we'd end up with an "empty"
-			// history entry. Let's keep track of whether we've actually made any
-			// changes (e.g. additions, deletions, or updates that produce a new value).
 			let didChange = false
 
 			const source = this.isMergingRemoteChanges ? 'remote' : 'user'
 
 			for (let i = 0, n = records.length; i < n; i++) {
-				record = records[i]
+				const record = records[i]
 
 				const initialValue = this.records.__unsafe__getWithoutCapture(record.id)
-				// If we already have an atom for this record, update its value.
+
 				if (initialValue) {
-					// If we have a beforeUpdate callback, run it against the initial and next records
-					record = this.sideEffects.handleBeforeChange(initialValue, record, source)
+					const updatedRecord = this.sideEffects.handleBeforeChange
+						? this.sideEffects.handleBeforeChange(initialValue, record, source)
+						: record
 
-					// Validate the record
 					const validated = this.schema.validateRecord(
 						this,
-						record,
+						updatedRecord,
 						phaseOverride ?? 'updateRecord',
 						initialValue
 					)
 
 					if (validated === initialValue) continue
 
-					record = devFreeze(record)
-					this.records.set(record.id, record)
+					const finalRecord = devFreeze(validated)
+					this.records.set(record.id, finalRecord)
 
 					didChange = true
-					updates[record.id] = [initialValue, record]
-					this.addDiffForAfterEvent(initialValue, record)
+					updates[record.id] = [initialValue, finalRecord]
+					this.addDiffForAfterEvent(initialValue, finalRecord)
 				} else {
-					record = this.sideEffects.handleBeforeCreate(record, source)
-
-					didChange = true
-
-					// If we don't have an atom, create one.
+					const createdRecord = this.sideEffects.handleBeforeCreate
+						? this.sideEffects.handleBeforeCreate(record, source)
+						: record
 
-					// Validate the record
-					record = this.schema.validateRecord(
+					const validated = this.schema.validateRecord(
 						this,
-						record as R,
+						createdRecord,
 						phaseOverride ?? 'createRecord',
 						null
 					)
 
-					// freeze it
-					record = devFreeze(record)
-
-					// Mark the change as a new addition.
-					additions[record.id] = record
-					this.addDiffForAfterEvent(null, record)
+					const finalRecord = devFreeze(validated)
+					additions[record.id] = finalRecord
+					this.addDiffForAfterEvent(null, finalRecord)
 
-					this.records.set(record.id, record)
+					this.records.set(record.id, finalRecord)
 				}
 			}
 
-			// If we did change, update the history
 			if (!didChange) return
 			this.updateHistory({
 				added: additions,
@@ -441,7 +489,6 @@ export class Store<R extends UnknownRecord = UnknownRecord, Props = unknown> {
 				this.addDiffForAfterEvent(record, null)
 			}
 
-			// Update the history with the removed records.
 			this.updateHistory({ added: {}, updated: {}, removed } as RecordsDiff<R>)
 		})
 	}
@@ -453,7 +500,7 @@ export class Store<R extends UnknownRecord = UnknownRecord, Props = unknown> {
 	 * @public
 	 */
 	get<K extends IdOf<R>>(id: K): RecordFromId<K> | undefined {
-		return this.records.get(id) as RecordFromId<K> | undefined
+		return this.records.get(id) as any
 	}
 
 	/**
@@ -463,7 +510,7 @@ export class Store<R extends UnknownRecord = UnknownRecord, Props = unknown> {
 	 * @public
 	 */
 	unsafeGetWithoutCapture<K extends IdOf<R>>(id: K): RecordFromId<K> | undefined {
-		return this.records.__unsafe__getWithoutCapture(id) as RecordFromId<K> | undefined
+		return this.records.__unsafe__getWithoutCapture(id) as any
 	}
 
 	/**
@@ -485,11 +532,6 @@ export class Store<R extends UnknownRecord = UnknownRecord, Props = unknown> {
 	/**
 	 * Get a serialized snapshot of the store and its schema.
 	 *
-	 * ```ts
-	 * const snapshot = store.getStoreSnapshot()
-	 * store.loadStoreSnapshot(snapshot)
-	 * ```
-	 *
 	 * @param scope - The scope of records to serialize. Defaults to 'document'.
 	 *
 	 * @public
@@ -514,35 +556,6 @@ export class Store<R extends UnknownRecord = UnknownRecord, Props = unknown> {
 	/**
 	 * Migrate a serialized snapshot of the store and its schema.
 	 *
-	 * ```ts
-	 * const snapshot = store.getSnapshot()
-	 * store.migrateSnapshot(snapshot)
-	 * ```
-	 *
-	 * @param snapshot - The snapshot to load.
-	 * @public
-	 */
-	migrateSnapshot(snapshot: StoreSnapshot<R>): StoreSnapshot<R> {
-		const migrationResult = this.schema.migrateStoreSnapshot(snapshot)
-
-		if (migrationResult.type === 'error') {
-			throw new Error(`Failed to migrate snapshot: ${migrationResult.reason}`)
-		}
-
-		return {
-			store: migrationResult.value,
-			schema: this.schema.serialize(),
-		}
-	}
-
-	/**
-	 * Load a serialized snapshot.
-	 *
-	 * ```ts
-	 * const snapshot = store.getStoreSnapshot()
-	 * store.loadStoreSnapshot(snapshot)
-	 * ```
-	 *
 	 * @param snapshot - The snapshot to load.
 	 * @public
 	 */
@@ -580,7 +593,6 @@ export class Store<R extends UnknownRecord = UnknownRecord, Props = unknown> {
 	/**
 	 * Get an array of all values in the store.
 	 *
-	 * @returns An array of all values in the store.
 	 * @public
 	 */
 	allRecords(): R[] {
@@ -604,13 +616,12 @@ export class Store<R extends UnknownRecord = UnknownRecord, Props = unknown> {
 	 * @param updater - A function that updates the record.
 	 */
 	update<K extends IdOf<R>>(id: K, updater: (record: RecordFromId<K>) => RecordFromId<K>) {
-		const existing = this.unsafeGetWithoutCapture(id)
-		if (!existing) {
+		const atom = this.records.getAtom(id)
+		if (!atom) {
 			console.error(`Record ${id} not found. This is probably an error`)
 			return
 		}
-
-		this.put([updater(existing) as any])
+		this.put([updater(atom.__unsafe__getWithoutCapture() as any as RecordFromId<K>) as any])
 	}
 
 	/**
@@ -642,13 +653,13 @@ export class Store<R extends UnknownRecord = UnknownRecord, Props = unknown> {
 			},
 		}
 
+		this.listeners.add(listener)
+
 		if (!this.historyReactor.scheduler.isActivelyListening) {
 			this.historyReactor.start()
 			this.historyReactor.scheduler.execute()
 		}
 
-		this.listeners.add(listener)
-
 		return () => {
 			this.listeners.delete(listener)
 
@@ -658,8 +669,6 @@ export class Store<R extends UnknownRecord = UnknownRecord, Props = unknown> {
 		}
 	}
 
-	private isMergingRemoteChanges = false
-
 	/**
 	 * Merge changes from a remote source
 	 *
@@ -671,10 +680,6 @@ export class Store<R extends UnknownRecord = UnknownRecord, Props = unknown> {
 			return fn()
 		}
 
-		if (this._isInAtomicOp) {
-			throw new Error('Cannot merge remote changes while in atomic operation')
-		}
-
 		try {
 			this.atomic(fn, true, true)
 		} finally {
@@ -682,63 +687,6 @@ export class Store<R extends UnknownRecord = UnknownRecord, Props = unknown> {
 		}
 	}
 
-	/**
-	 * Run `fn` and return a {@link RecordsDiff} of the changes that occurred as a result.
-	 */
-	extractingChanges(fn: () => void): RecordsDiff<R> {
-		const changes: Array<RecordsDiff<R>> = []
-		const dispose = this.historyAccumulator.addInterceptor((entry) => changes.push(entry.changes))
-		try {
-			transact(fn)
-			return squashRecordDiffs(changes)
-		} finally {
-			dispose()
-		}
-	}
-
-	applyDiff(
-		diff: RecordsDiff<R>,
-		{
-			runCallbacks = true,
-			ignoreEphemeralKeys = false,
-		}: { runCallbacks?: boolean; ignoreEphemeralKeys?: boolean } = {}
-	) {
-		this.atomic(() => {
-			const toPut = objectMapValues(diff.added)
-
-			for (const [_from, to] of objectMapValues(diff.updated)) {
-				const type = this.schema.getType(to.typeName)
-				if (ignoreEphemeralKeys && type.ephemeralKeySet.size) {
-					const existing = this.get(to.id)
-					if (!existing) {
-						toPut.push(to)
-						continue
-					}
-					let changed: R | null = null
-					for (const [key, value] of Object.entries(to)) {
-						if (type.ephemeralKeySet.has(key) || Object.is(value, getOwnProperty(existing, key))) {
-							continue
-						}
-
-						if (!changed) changed = { ...existing } as R
-						;(changed as any)[key] = value
-					}
-					if (changed) toPut.push(changed)
-				} else {
-					toPut.push(to)
-				}
-			}
-
-			const toRemove = objectMapKeys(diff.removed)
-			if (toPut.length) {
-				this.put(toPut)
-			}
-			if (toRemove.length) {
-				this.remove(toRemove)
-			}
-		}, runCallbacks)
-	}
-
 	/**
 	 * Create a cache based on values in the store. Pass in a function that takes and ID and a
 	 * signal for the underlying record. Return a signal (usually a computed) for the cached value.
@@ -807,105 +755,61 @@ export class Store<R extends UnknownRecord = UnknownRecord, Props = unknown> {
 	isPossiblyCorrupted() {
 		return this._isPossiblyCorrupted
 	}
+}
 
-	private pendingAfterEvents: Map<IdOf<R>, { before: R | null; after: R | null }> | null = null
-	private addDiffForAfterEvent(before: R | null, after: R | null) {
-		assert(this.pendingAfterEvents, 'must be in event operation')
-		if (before === after) return
-		if (before && after) assert(before.id === after.id)
-		if (!before && !after) return
-		const id = (before || after)!.id
-		const existing = this.pendingAfterEvents.get(id)
-		if (existing) {
-			existing.after = after
-		} else {
-			this.pendingAfterEvents.set(id, { before, after })
-		}
-	}
-	private flushAtomicCallbacks(isMergingRemoteChanges: boolean) {
-		let updateDepth = 0
-		let source: ChangeSource = isMergingRemoteChanges ? 'remote' : 'user'
-		while (this.pendingAfterEvents) {
-			const events = this.pendingAfterEvents
-			this.pendingAfterEvents = null
-
-			if (!this.sideEffects.isEnabled()) continue
-
-			updateDepth++
-			if (updateDepth > 100) {
-				throw new Error('Maximum store update depth exceeded, bailing out')
-			}
-
-			for (const { before, after } of events.values()) {
-				if (before && after && before !== after && !isEqual(before, after)) {
-					this.sideEffects.handleAfterChange(before, after, source)
-				} else if (before && !after) {
-					this.sideEffects.handleAfterDelete(before, source)
-				} else if (!before && after) {
-					this.sideEffects.handleAfterCreate(after, source)
+/**
+ * Squash a collection of diffs into a single diff.
+ *
+ * @param diffs - An array of diffs to squash.
+ * @returns A single diff that represents the squashed diffs.
+ * @public
+ */
+export function squashRecordDiffs<T extends UnknownRecord>(diffs: RecordsDiff<T>[]): RecordsDiff<T> {
+	const result = { added: {}, removed: {}, updated: {} } as RecordsDiff<T>
+
+	for (const diff of diffs) {
+		for (const [id, value] of objectMapEntries(diff.added)) {
+			if (result.removed[id]) {
+				const original = result.removed[id]
+				delete result.removed[id]
+				if (original !== value) {
+					result.updated[id] = [original, value]
 				}
-			}
-
-			if (!this.pendingAfterEvents) {
-				this.sideEffects.handleOperationComplete(source)
 			} else {
-				// if the side effects triggered by a remote operation resulted in more effects,
-				// those extra effects should not be marked as originating remotely.
-				source = 'user'
+				result.added[id] = value
 			}
 		}
-	}
-	private _isInAtomicOp = false
-	/** @internal */
-	atomic<T>(fn: () => T, runCallbacks = true, isMergingRemoteChanges = false): T {
-		return transact(() => {
-			if (this._isInAtomicOp) {
-				if (!this.pendingAfterEvents) this.pendingAfterEvents = new Map()
-				const prevSideEffectsEnabled = this.sideEffects.isEnabled()
-				assert(!isMergingRemoteChanges, 'cannot call mergeRemoteChanges while in atomic operation')
-				try {
-					// if we are in an atomic context with side effects ON allow switching before* callbacks OFF.
-					// but don't allow switching them ON if they had been marked OFF before.
-					if (prevSideEffectsEnabled && !runCallbacks) {
-						this.sideEffects.setIsEnabled(false)
-					}
-					return fn()
-				} finally {
-					this.sideEffects.setIsEnabled(prevSideEffectsEnabled)
-				}
-			}
 
-			this.pendingAfterEvents = new Map()
-			const prevSideEffectsEnabled = this.sideEffects.isEnabled()
-			this.sideEffects.setIsEnabled(runCallbacks ?? prevSideEffectsEnabled)
-			this._isInAtomicOp = true
-
-			if (isMergingRemoteChanges) {
-				this.isMergingRemoteChanges = true
+		for (const [id, [_from, to]] of objectMapEntries(diff.updated)) {
+			if (result.added[id]) {
+				result.added[id] = to
+				delete result.updated[id]
+				delete result.removed[id]
+				continue
+			}
+			if (result.updated[id]) {
+				result.updated[id] = [result.updated[id][0], to]
+				delete result.removed[id]
+				continue
 			}
 
-			try {
-				const result = fn()
-				this.isMergingRemoteChanges = false
-
-				this.flushAtomicCallbacks(isMergingRemoteChanges)
+			result.updated[id] = diff.updated[id]
+			delete result.removed[id]
+		}
 
-				return result
-			} finally {
-				this.pendingAfterEvents = null
-				this.sideEffects.setIsEnabled(prevSideEffectsEnabled)
-				this._isInAtomicOp = false
-				this.isMergingRemoteChanges = false
+		for (const [id, value] of objectMapEntries(diff.removed)) {
+			if (result.added[id]) {
+				delete result.added[id]
+			} else if (result.updated[id]) {
+				result.removed[id] = result.updated[id][0]
+				delete result.updated[id]
+			} else {
+				result.removed[id] = value
 			}
-		})
+		}
 	}
 
-	/** @internal */
-	addHistoryInterceptor(fn: (entry: HistoryEntry<R>, source: ChangeSource) => void) {
-		return this.historyAccumulator.addInterceptor((entry) =>
-			fn(entry, this.isMergingRemoteChanges ? 'remote' : 'user')
-		)
-	}
+	return devFreeze(result)
 }
 
 /**
@@ -917,9 +821,7 @@ export class Store<R extends UnknownRecord = UnknownRecord, Props = unknown> {
  * @returns A map of history entries by their sources.
  * @public
  */
-function squashHistoryEntries<T extends UnknownRecord>(
-	entries: HistoryEntry<T>[]
-): HistoryEntry<T>[] {
+function squashHistoryEntries<T extends UnknownRecord>(entries: HistoryEntry<T>[]): HistoryEntry<T>[] {
 	if (entries.length === 0) return []
 
 	const chunked: HistoryEntry<T>[][] = []
@@ -928,6 +830,7 @@ function squashHistoryEntries<T extends UnknownRecord>(
 
 	for (let i = 1, n = entries.length; i < n; i++) {
 		entry = entries[i]
+
 		if (chunk[0].source !== entry.source) {
 			chunked.push(chunk)
 			chunk = []
@@ -945,6 +848,15 @@ function squashHistoryEntries<T extends UnknownRecord>(
 	)
 }
 
+/** @public */
+export function reverseRecordsDiff(diff: RecordsDiff<any>) {
+	const result: RecordsDiff<any> = { added: diff.removed, removed: diff.added, updated: {} }
+	for (const [from, to] of Object.values(diff.updated)) {
+		result.updated[from.id] = [to, from]
+	}
+	return result
+}
+
 class HistoryAccumulator<T extends UnknownRecord> {
 	private _history: HistoryEntry<T>[] = []
 
@@ -979,12 +891,6 @@ class HistoryAccumulator<T extends UnknownRecord> {
 	}
 }
 
-/** @public */
-export type StoreObject<R extends UnknownRecord> = Store<R> | { store: Store<R> }
-/** @public */
-export type StoreObjectRecordType<Context extends StoreObject<any>> =
-	Context extends Store<infer R> ? R : Context extends { store: Store<infer R> } ? R : never
-
 /**
  * Free version of {@link Store.createComputedCache}.
  *
@@ -1012,7 +918,7 @@ export function createComputedCache<
 	return {
 		get(context: Context, id: IdOf<Record>) {
 			const computedCache = cache.get(context, () => {
-				const store = (context instanceof Store ? context : context.store) as Store<Record>
+				const store = context instanceof Store ? context : (context as any).store
 				return store.createComputedCache(name, (record) => derive(context, record), opts)
 			})
 			return computedCache.get(id)
