--- tldraw_packages_store_src_lib_Store.ts_expectedoutput.txt (expected)+++ tldraw_packages_store_src_lib_Store.ts_extracted.txt (actual)@@ -76,7 +76,7 @@ }
 
 /**
- * A serialized snapshot of the record store's values.
+ * A serialized snapshot of the store's values.
  *
  * @public
  */
@@ -280,32 +280,6 @@ 		}
 	}
 
-	dispose() {
-		this.cancelHistoryReactor()
-	}
-
-	/**
-	 * Filters out non-document changes from a diff. Returns null if there are no changes left.
-	 * @param change - the records diff
-	 * @param scope - the records scope
-	 * @returns
-	 */
-	filterChangesByScope(change: RecordsDiff<R>, scope: RecordScope) {
-		const result = {
-			added: filterEntries(change.added, (_, r) => this.scopedTypes[scope].has(r.typeName)),
-			updated: filterEntries(change.updated, (_, r) => this.scopedTypes[scope].has(r[1].typeName)),
-			removed: filterEntries(change.removed, (_, r) => this.scopedTypes[scope].has(r.typeName)),
-		}
-		if (
-			Object.keys(result.added).length === 0 &&
-			Object.keys(result.updated).length === 0 &&
-			Object.keys(result.removed).length === 0
-		) {
-			return null
-		}
-		return result
-	}
-
 	/**
 	 * Update the history with a diff of changes.
 	 *
@@ -322,6 +296,32 @@ 		this.history.set(this.history.get() + 1, changes)
 	}
 
+	dispose() {
+		this.cancelHistoryReactor()
+	}
+
+	/**
+	 * Filters out non-document changes from a diff. Returns null if there are no changes left.
+	 * @param change - the records diff
+	 * @param scope - the records scope
+	 * @returns
+	 */
+	filterChangesByScope(change: RecordsDiff<R>, scope: RecordScope) {
+		const result = {
+			added: filterEntries(change.added, (_, r) => this.scopedTypes[scope].has(r.typeName)),
+			updated: filterEntries(change.updated, (_, r) => this.scopedTypes[scope].has(r[1].typeName)),
+			removed: filterEntries(change.removed, (_, r) => this.scopedTypes[scope].has(r.typeName)),
+		}
+		if (
+			Object.keys(result.added).length === 0 &&
+			Object.keys(result.updated).length === 0 &&
+			Object.keys(result.removed).length === 0
+		) {
+			return null
+		}
+		return result
+	}
+
 	validate(phase: 'initialize' | 'createRecord' | 'updateRecord' | 'tests') {
 		this.allRecords().forEach((record) => this.schema.validateRecord(this, record, phase, null))
 	}
@@ -337,27 +337,21 @@ 		this.atomic(() => {
 			const updates: Record<IdOf<UnknownRecord>, [from: R, to: R]> = {}
 			const additions: Record<IdOf<UnknownRecord>, R> = {}
-
 			// Iterate through all records, creating, updating or removing as needed
 			let record: R
-
 			// There's a chance that, despite having records, all of the values are
 			// identical to what they were before; and so we'd end up with an "empty"
 			// history entry. Let's keep track of whether we've actually made any
 			// changes (e.g. additions, deletions, or updates that produce a new value).
 			let didChange = false
-
 			const source = this.isMergingRemoteChanges ? 'remote' : 'user'
-
 			for (let i = 0, n = records.length; i < n; i++) {
 				record = records[i]
-
 				const initialValue = this.records.__unsafe__getWithoutCapture(record.id)
 				// If we already have an atom for this record, update its value.
 				if (initialValue) {
 					// If we have a beforeUpdate callback, run it against the initial and next records
 					record = this.sideEffects.handleBeforeChange(initialValue, record, source)
-
 					// Validate the record
 					const validated = this.schema.validateRecord(
 						this,
@@ -365,22 +359,16 @@ 						phaseOverride ?? 'updateRecord',
 						initialValue
 					)
-
 					if (validated === initialValue) continue
-
 					record = devFreeze(record)
 					this.records.set(record.id, record)
-
 					didChange = true
 					updates[record.id] = [initialValue, record]
 					this.addDiffForAfterEvent(initialValue, record)
 				} else {
 					record = this.sideEffects.handleBeforeCreate(record, source)
-
 					didChange = true
-
 					// If we don't have an atom, create one.
-
 					// Validate the record
 					record = this.schema.validateRecord(
 						this,
@@ -388,18 +376,14 @@ 						phaseOverride ?? 'createRecord',
 						null
 					)
-
 					// freeze it
 					record = devFreeze(record)
-
 					// Mark the change as a new addition.
 					additions[record.id] = record
 					this.addDiffForAfterEvent(null, record)
-
 					this.records.set(record.id, record)
 				}
 			}
-
 			// If we did change, update the history
 			if (!didChange) return
 			this.updateHistory({
@@ -420,27 +404,22 @@ 		this.atomic(() => {
 			const toDelete = new Set<IdOf<R>>(ids)
 			const source = this.isMergingRemoteChanges ? 'remote' : 'user'
-
 			if (this.sideEffects.isEnabled()) {
 				for (const id of ids) {
 					const record = this.records.__unsafe__getWithoutCapture(id)
 					if (!record) continue
-
 					if (this.sideEffects.handleBeforeDelete(record, source) === false) {
 						toDelete.delete(id)
 					}
 				}
 			}
-
 			const actuallyDeleted = this.records.deleteMany(toDelete)
 			if (actuallyDeleted.length === 0) return
-
 			const removed = {} as RecordsDiff<R>['removed']
 			for (const [id, record] of actuallyDeleted) {
 				removed[id] = record
 				this.addDiffForAfterEvent(record, null)
 			}
-
 			// Update the history with the removed records.
 			this.updateHistory({ added: {}, updated: {}, removed } as RecordsDiff<R>)
 		})
@@ -515,7 +494,7 @@ 	 * Migrate a serialized snapshot of the store and its schema.
 	 *
 	 * ```ts
-	 * const snapshot = store.getSnapshot()
+	 * const snapshot = store.getStoreSnapshot()
 	 * store.migrateSnapshot(snapshot)
 	 * ```
 	 *
