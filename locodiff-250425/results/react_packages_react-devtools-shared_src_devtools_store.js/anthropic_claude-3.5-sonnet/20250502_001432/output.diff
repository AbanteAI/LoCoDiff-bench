--- react_packages_react-devtools-shared_src_devtools_store.js_expectedoutput.txt (expected)+++ react_packages_react-devtools-shared_src_devtools_store.js_extracted.txt (actual)@@ -49,8 +49,8 @@   FrontendBridge,
   BridgeProtocol,
 } from 'react-devtools-shared/src/bridge';
+import type {DevToolsHookSettings} from '../backend/types';
 import UnsupportedBridgeOperationError from 'react-devtools-shared/src/UnsupportedBridgeOperationError';
-import type {DevToolsHookSettings} from '../backend/types';
 
 const debug = (methodName: string, ...args: Array<string>) => {
   if (__DEBUG__) {
@@ -264,13 +264,13 @@       this.onBridgeUnsupportedRendererVersion,
     );
 
-    this._profilerStore = new ProfilerStore(bridge, this, isProfiling);
-
     bridge.addListener('backendVersion', this.onBridgeBackendVersion);
     bridge.addListener('saveToClipboard', this.onSaveToClipboard);
     bridge.addListener('hookSettings', this.onHookSettings);
     bridge.addListener('backendInitialized', this.onBackendInitialized);
     bridge.addListener('selectElement', this.onHostInstanceSelected);
+
+    this._profilerStore = new ProfilerStore(bridge, this, isProfiling);
   }
 
   // This is only used in tests to avoid memory leaks.
@@ -880,698 +880,4 @@     }
   }
 
-  _adjustParentTreeWeight: (
-    parentElement: ?Element,
-    weightDelta: number,
-  ) => void = (parentElement, weightDelta) => {
-    let isInsideCollapsedSubTree = false;
-
-    while (parentElement != null) {
-      parentElement.weight += weightDelta;
-
-      // Additions and deletions within a collapsed subtree should not bubble beyond the collapsed parent.
-      // Their weight will bubble up when the parent is expanded.
-      if (parentElement.isCollapsed) {
-        isInsideCollapsedSubTree = true;
-        break;
-      }
-
-      parentElement = this._idToElement.get(parentElement.parentID);
-    }
-
-    // Additions and deletions within a collapsed subtree should not affect the overall number of elements.
-    if (!isInsideCollapsedSubTree) {
-      this._weightAcrossRoots += weightDelta;
-    }
-  };
-
-  _recursivelyUpdateSubtree(
-    id: number,
-    callback: (element: Element) => void,
-  ): void {
-    const element = this._idToElement.get(id);
-    if (element) {
-      callback(element);
-
-      element.children.forEach(child =>
-        this._recursivelyUpdateSubtree(child, callback),
-      );
-    }
-  }
-
-  onBridgeNativeStyleEditorSupported: ({
-    isSupported: boolean,
-    validAttributes: ?$ReadOnlyArray<string>,
-  }) => void = ({isSupported, validAttributes}) => {
-    this._isNativeStyleEditorSupported = isSupported;
-    this._nativeStyleEditorValidAttributes = validAttributes || null;
-
-    this.emit('supportsNativeStyleEditor');
-  };
-
-  onBridgeOperations: (operations: Array<number>) => void = operations => {
-    if (__DEBUG__) {
-      console.groupCollapsed('onBridgeOperations');
-      debug('onBridgeOperations', operations.join(','));
-    }
-
-    let haveRootsChanged = false;
-    let haveErrorsOrWarningsChanged = false;
-
-    // The first two values are always rendererID and rootID
-    const rendererID = operations[0];
-
-    const addedElementIDs: Array<number> = [];
-    // This is a mapping of removed ID -> parent ID:
-    const removedElementIDs: Map<number, number> = new Map();
-    // We'll use the parent ID to adjust selection if it gets deleted.
-
-    let i = 2;
-
-    // Reassemble the string table.
-    const stringTable: Array<string | null> = [
-      null, // ID = 0 corresponds to the null string.
-    ];
-    const stringTableSize = operations[i];
-    i++;
-
-    const stringTableEnd = i + stringTableSize;
-
-    while (i < stringTableEnd) {
-      const nextLength = operations[i];
-      i++;
-
-      const nextString = utfDecodeStringWithRanges(
-        operations,
-        i,
-        i + nextLength - 1,
-      );
-      stringTable.push(nextString);
-      i += nextLength;
-    }
-
-    while (i < operations.length) {
-      const operation = operations[i];
-      switch (operation) {
-        case TREE_OPERATION_ADD: {
-          const id = operations[i + 1];
-          const type = ((operations[i + 2]: any): ElementType);
-
-          i += 3;
-
-          if (this._idToElement.has(id)) {
-            this._throwAndEmitError(
-              Error(
-                `Cannot add node "${id}" because a node with that id is already in the Store.`,
-              ),
-            );
-          }
-
-          if (type === ElementTypeRoot) {
-            if (__DEBUG__) {
-              debug('Add', `new root node ${id}`);
-            }
-
-            const isStrictModeCompliant = operations[i] > 0;
-            i++;
-
-            const supportsBasicProfiling =
-              (operations[i] & PROFILING_FLAG_BASIC_SUPPORT) !== 0;
-            const supportsTimeline =
-              (operations[i] & PROFILING_FLAG_TIMELINE_SUPPORT) !== 0;
-            i++;
-
-            let supportsStrictMode = false;
-            let hasOwnerMetadata = false;
-
-            // If we don't know the bridge protocol, guess that we're dealing with the latest.
-            // If we do know it, we can take it into consideration when parsing operations.
-            if (
-              this._bridgeProtocol === null ||
-              this._bridgeProtocol.version >= 2
-            ) {
-              supportsStrictMode = operations[i] > 0;
-              i++;
-
-              hasOwnerMetadata = operations[i] > 0;
-              i++;
-            }
-
-            this._roots = this._roots.concat(id);
-            this._rootIDToRendererID.set(id, rendererID);
-            this._rootIDToCapabilities.set(id, {
-              supportsBasicProfiling,
-              hasOwnerMetadata,
-              supportsStrictMode,
-              supportsTimeline,
-            });
-
-            // Not all roots support StrictMode;
-            // don't flag a root as non-compliant unless it also supports StrictMode.
-            const isStrictModeNonCompliant =
-              !isStrictModeCompliant && supportsStrictMode;
-
-            this._idToElement.set(id, {
-              children: [],
-              depth: -1,
-              displayName: null,
-              hocDisplayNames: null,
-              id,
-              isCollapsed: false, // Never collapse roots; it would hide the entire tree.
-              isStrictModeNonCompliant,
-              key: null,
-              ownerID: 0,
-              parentID: 0,
-              type,
-              weight: 0,
-              compiledWithForget: false,
-            });
-
-            haveRootsChanged = true;
-          } else {
-            const parentID = operations[i];
-            i++;
-
-            const ownerID = operations[i];
-            i++;
-
-            const displayNameStringID = operations[i];
-            const displayName = stringTable[displayNameStringID];
-            i++;
-
-            const keyStringID = operations[i];
-            const key = stringTable[keyStringID];
-            i++;
-
-            if (__DEBUG__) {
-              debug(
-                'Add',
-                `node ${id} (${displayName || 'null'}) as child of ${parentID}`,
-              );
-            }
-
-            const parentElement = this._idToElement.get(parentID);
-            if (parentElement === undefined) {
-              this._throwAndEmitError(
-                Error(
-                  `Cannot add child "${id}" to parent "${parentID}" because parent node was not found in the Store.`,
-                ),
-              );
-
-              break;
-            }
-
-            parentElement.children.push(id);
-
-            const {
-              formattedDisplayName: displayNameWithoutHOCs,
-              hocDisplayNames,
-              compiledWithForget,
-            } = parseElementDisplayNameFromBackend(displayName, type);
-
-            const element: Element = {
-              children: [],
-              depth: parentElement.depth + 1,
-              displayName: displayNameWithoutHOCs,
-              hocDisplayNames,
-              id,
-              isCollapsed: this._collapseNodesByDefault,
-              isStrictModeNonCompliant: parentElement.isStrictModeNonCompliant,
-              key,
-              ownerID,
-              parentID,
-              type,
-              weight: 1,
-              compiledWithForget,
-            };
-
-            this._idToElement.set(id, element);
-            addedElementIDs.push(id);
-            this._adjustParentTreeWeight(parentElement, 1);
-
-            if (ownerID > 0) {
-              let set = this._ownersMap.get(ownerID);
-              if (set === undefined) {
-                set = new Set();
-                this._ownersMap.set(ownerID, set);
-              }
-              set.add(id);
-            }
-          }
-          break;
-        }
-        case TREE_OPERATION_REMOVE: {
-          const removeLength = operations[i + 1];
-          i += 2;
-
-          for (let removeIndex = 0; removeIndex < removeLength; removeIndex++) {
-            const id = operations[i];
-            const element = this._idToElement.get(id);
-
-            if (element === undefined) {
-              this._throwAndEmitError(
-                Error(
-                  `Cannot remove node "${id}" because no matching node was found in the Store.`,
-                ),
-              );
-
-              break;
-            }
-
-            i += 1;
-
-            const {children, ownerID, parentID, weight} = element;
-            if (children.length > 0) {
-              this._throwAndEmitError(
-                Error(`Node "${id}" was removed before its children.`),
-              );
-            }
-
-            this._idToElement.delete(id);
-
-            let parentElement: ?Element = null;
-            if (parentID === 0) {
-              if (__DEBUG__) {
-                debug('Remove', `node ${id} root`);
-              }
-
-              this._roots = this._roots.filter(rootID => rootID !== id);
-              this._rootIDToRendererID.delete(id);
-              this._rootIDToCapabilities.delete(id);
-
-              haveRootsChanged = true;
-            } else {
-              if (__DEBUG__) {
-                debug('Remove', `node ${id} from parent ${parentID}`);
-              }
-
-              parentElement = this._idToElement.get(parentID);
-              if (parentElement === undefined) {
-                this._throwAndEmitError(
-                  Error(
-                    `Cannot remove node "${id}" from parent "${parentID}" because no matching node was found in the Store.`,
-                  ),
-                );
-
-                break;
-              }
-
-              const index = parentElement.children.indexOf(id);
-              parentElement.children.splice(index, 1);
-            }
-
-            this._adjustParentTreeWeight(parentElement, -weight);
-            removedElementIDs.set(id, parentID);
-
-            this._ownersMap.delete(id);
-            if (ownerID > 0) {
-              const set = this._ownersMap.get(ownerID);
-              if (set !== undefined) {
-                set.delete(id);
-              }
-            }
-
-            if (this._errorsAndWarnings.has(id)) {
-              this._errorsAndWarnings.delete(id);
-              haveErrorsOrWarningsChanged = true;
-            }
-          }
-
-          break;
-        }
-        case TREE_OPERATION_REMOVE_ROOT: {
-          i += 1;
-
-          const id = operations[1];
-
-          if (__DEBUG__) {
-            debug(`Remove root ${id}`);
-          }
-
-          const recursivelyDeleteElements = (elementID: number) => {
-            const element = this._idToElement.get(elementID);
-            this._idToElement.delete(elementID);
-            if (element) {
-              // Mostly for Flow's sake
-              for (let index = 0; index < element.children.length; index++) {
-                recursivelyDeleteElements(element.children[index]);
-              }
-            }
-          };
-
-          const root = this._idToElement.get(id);
-          if (root === undefined) {
-            this._throwAndEmitError(
-              Error(
-                `Cannot remove root "${id}": no matching node was found in the Store.`,
-              ),
-            );
-
-            break;
-          }
-
-          recursivelyDeleteElements(id);
-
-          this._rootIDToCapabilities.delete(id);
-          this._rootIDToRendererID.delete(id);
-          this._roots = this._roots.filter(rootID => rootID !== id);
-          this._weightAcrossRoots -= root.weight;
-          break;
-        }
-        case TREE_OPERATION_REORDER_CHILDREN: {
-          const id = operations[i + 1];
-          const numChildren = operations[i + 2];
-          i += 3;
-
-          const element = this._idToElement.get(id);
-          if (element === undefined) {
-            this._throwAndEmitError(
-              Error(
-                `Cannot reorder children for node "${id}" because no matching node was found in the Store.`,
-              ),
-            );
-
-            break;
-          }
-
-          const children = element.children;
-          if (children.length !== numChildren) {
-            this._throwAndEmitError(
-              Error(
-                `Children cannot be added or removed during a reorder operation.`,
-              ),
-            );
-          }
-
-          for (let j = 0; j < numChildren; j++) {
-            const childID = operations[i + j];
-            children[j] = childID;
-            if (__DEV__) {
-              // This check is more expensive so it's gated by __DEV__.
-              const childElement = this._idToElement.get(childID);
-              if (childElement == null || childElement.parentID !== id) {
-                console.error(
-                  `Children cannot be added or removed during a reorder operation.`,
-                );
-              }
-            }
-          }
-          i += numChildren;
-
-          if (__DEBUG__) {
-            debug('Re-order', `Node ${id} children ${children.join(',')}`);
-          }
-          break;
-        }
-        case TREE_OPERATION_SET_SUBTREE_MODE: {
-          const id = operations[i + 1];
-          const mode = operations[i + 2];
-
-          i += 3;
-
-          // If elements have already been mounted in this subtree, update them.
-          // (In practice, this likely only applies to the root element.)
-          if (mode === StrictMode) {
-            this._recursivelyUpdateSubtree(id, element => {
-              element.isStrictModeNonCompliant = false;
-            });
-          }
-
-          if (__DEBUG__) {
-            debug(
-              'Subtree mode',
-              `Subtree with root ${id} set to mode ${mode}`,
-            );
-          }
-          break;
-        }
-        case TREE_OPERATION_UPDATE_TREE_BASE_DURATION:
-          // Base duration updates are only sent while profiling is in progress.
-          // We can ignore them at this point.
-          // The profiler UI uses them lazily in order to generate the tree.
-          i += 3;
-          break;
-        case TREE_OPERATION_UPDATE_ERRORS_OR_WARNINGS:
-          const id = operations[i + 1];
-          const errorCount = operations[i + 2];
-          const warningCount = operations[i + 3];
-
-          i += 4;
-
-          if (errorCount > 0 || warningCount > 0) {
-            this._errorsAndWarnings.set(id, {errorCount, warningCount});
-          } else if (this._errorsAndWarnings.has(id)) {
-            this._errorsAndWarnings.delete(id);
-          }
-          haveErrorsOrWarningsChanged = true;
-          break;
-        default:
-          this._throwAndEmitError(
-            new UnsupportedBridgeOperationError(
-              `Unsupported Bridge operation "${operation}"`,
-            ),
-          );
-      }
-    }
-
-    this._revision++;
-
-    // Any time the tree changes (e.g. elements added, removed, or reordered) cached indices may be invalid.
-    this._cachedErrorAndWarningTuples = null;
-
-    if (haveErrorsOrWarningsChanged) {
-      let componentWithErrorCount = 0;
-      let componentWithWarningCount = 0;
-
-      this._errorsAndWarnings.forEach(entry => {
-        if (entry.errorCount > 0) {
-          componentWithErrorCount++;
-        }
-
-        if (entry.warningCount > 0) {
-          componentWithWarningCount++;
-        }
-      });
-
-      this._cachedComponentWithErrorCount = componentWithErrorCount;
-      this._cachedComponentWithWarningCount = componentWithWarningCount;
-    }
-
-    if (haveRootsChanged) {
-      const prevRootSupportsProfiling = this._rootSupportsBasicProfiling;
-      const prevRootSupportsTimelineProfiling =
-        this._rootSupportsTimelineProfiling;
-
-      this._hasOwnerMetadata = false;
-      this._rootSupportsBasicProfiling = false;
-      this._rootSupportsTimelineProfiling = false;
-      this._rootIDToCapabilities.forEach(
-        ({supportsBasicProfiling, hasOwnerMetadata, supportsTimeline}) => {
-          if (supportsBasicProfiling) {
-            this._rootSupportsBasicProfiling = true;
-          }
-          if (hasOwnerMetadata) {
-            this._hasOwnerMetadata = true;
-          }
-          if (supportsTimeline) {
-            this._rootSupportsTimelineProfiling = true;
-          }
-        },
-      );
-
-      this.emit('roots');
-
-      if (this._rootSupportsBasicProfiling !== prevRootSupportsProfiling) {
-        this.emit('rootSupportsBasicProfiling');
-      }
-
-      if (
-        this._rootSupportsTimelineProfiling !==
-        prevRootSupportsTimelineProfiling
-      ) {
-        this.emit('rootSupportsTimelineProfiling');
-      }
-    }
-
-    if (__DEBUG__) {
-      console.log(printStore(this, true));
-      console.groupEnd();
-    }
-
-    this.emit('mutated', [addedElementIDs, removedElementIDs]);
-  };
-
-  // Certain backends save filters on a per-domain basis.
-  // In order to prevent filter preferences and applied filters from being out of sync,
-  // this message enables the backend to override the frontend's current ("saved") filters.
-  // This action should also override the saved filters too,
-  // else reloading the frontend without reloading the backend would leave things out of sync.
-  onBridgeOverrideComponentFilters: (
-    componentFilters: Array<ComponentFilter>,
-  ) => void = componentFilters => {
-    this._componentFilters = componentFilters;
-
-    setSavedComponentFilters(componentFilters);
-  };
-
-  onBridgeShutdown: () => void = () => {
-    if (__DEBUG__) {
-      debug('onBridgeShutdown', 'unsubscribing from Bridge');
-    }
-
-    const bridge = this._bridge;
-    bridge.removeListener('operations', this.onBridgeOperations);
-    bridge.removeListener(
-      'overrideComponentFilters',
-      this.onBridgeOverrideComponentFilters,
-    );
-    bridge.removeListener('shutdown', this.onBridgeShutdown);
-    bridge.removeListener(
-      'isReloadAndProfileSupportedByBackend',
-      this.onBackendReloadAndProfileSupported,
-    );
-    bridge.removeListener(
-      'isNativeStyleEditorSupported',
-      this.onBridgeNativeStyleEditorSupported,
-    );
-    bridge.removeListener(
-      'unsupportedRendererVersion',
-      this.onBridgeUnsupportedRendererVersion,
-    );
-    bridge.removeListener('backendVersion', this.onBridgeBackendVersion);
-    bridge.removeListener('bridgeProtocol', this.onBridgeProtocol);
-    bridge.removeListener('saveToClipboard', this.onSaveToClipboard);
-    bridge.removeListener('selectElement', this.onHostInstanceSelected);
-
-    if (this._onBridgeProtocolTimeoutID !== null) {
-      clearTimeout(this._onBridgeProtocolTimeoutID);
-      this._onBridgeProtocolTimeoutID = null;
-    }
-  };
-
-  onBackendReloadAndProfileSupported: (
-    isReloadAndProfileSupported: boolean,
-  ) => void = isReloadAndProfileSupported => {
-    this._isReloadAndProfileBackendSupported = isReloadAndProfileSupported;
-
-    this.emit('supportsReloadAndProfile');
-  };
-
-  onBridgeUnsupportedRendererVersion: () => void = () => {
-    this._unsupportedRendererVersionDetected = true;
-
-    this.emit('unsupportedRendererVersionDetected');
-  };
-
-  onBridgeBackendVersion: (backendVersion: string) => void = backendVersion => {
-    this._backendVersion = backendVersion;
-    this.emit('backendVersion');
-  };
-
-  onBridgeProtocol: (bridgeProtocol: BridgeProtocol) => void =
-    bridgeProtocol => {
-      if (this._onBridgeProtocolTimeoutID !== null) {
-        clearTimeout(this._onBridgeProtocolTimeoutID);
-        this._onBridgeProtocolTimeoutID = null;
-      }
-
-      this._bridgeProtocol = bridgeProtocol;
-
-      if (bridgeProtocol.version !== currentBridgeProtocol.version) {
-        // Technically newer versions of the frontend can, at least for now,
-        // gracefully handle older versions of the backend protocol.
-        // So for now we don't need to display the unsupported dialog.
-      }
-    };
-
-  onBridgeProtocolTimeout: () => void = () => {
-    this._onBridgeProtocolTimeoutID = null;
-
-    // If we timed out, that indicates the backend predates the bridge protocol,
-    // so we can set a fake version (0) to trigger the downgrade message.
-    this._bridgeProtocol = BRIDGE_PROTOCOL[0];
-
-    this.emit('unsupportedBridgeProtocolDetected');
-  };
-
-  onSaveToClipboard: (text: string) => void = text => {
-    withPermissionsCheck({permissions: ['clipboardWrite']}, () => copy(text))();
-  };
-
-  onBackendInitialized: () => void = () => {
-    // Verify that the frontend version is compatible with the connected backend.
-    // See github.com/facebook/react/issues/21326
-    if (this._shouldCheckBridgeProtocolCompatibility) {
-      // Older backends don't support an explicit bridge protocol,
-      // so we should timeout eventually and show a downgrade message.
-      this._onBridgeProtocolTimeoutID = setTimeout(
-        this.onBridgeProtocolTimeout,
-        10000,
-      );
-
-      this._bridge.addListener('bridgeProtocol', this.onBridgeProtocol);
-      this._bridge.send('getBridgeProtocol');
-    }
-
-    this._bridge.send('getBackendVersion');
-    this._bridge.send('getIfHasUnsupportedRendererVersion');
-    this._bridge.send('getHookSettings'); // Warm up cached hook settings
-  };
-
-  onHostInstanceSelected: (elementId: number) => void = elementId => {
-    if (this._lastSelectedHostInstanceElementId === elementId) {
-      return;
-    }
-
-    this._lastSelectedHostInstanceElementId = elementId;
-    // By the time we emit this, there is no guarantee that TreeContext is rendered.
-    this.emit('hostInstanceSelected', elementId);
-  };
-
-  getHookSettings: () => void = () => {
-    if (this._hookSettings != null) {
-      this.emit('hookSettings', this._hookSettings);
-    } else {
-      this._bridge.send('getHookSettings');
-    }
-  };
-
-  updateHookSettings: (settings: $ReadOnly<DevToolsHookSettings>) => void =
-    settings => {
-      this._hookSettings = settings;
-
-      this._bridge.send('updateHookSettings', settings);
-      this.emit('settingsUpdated', settings);
-    };
-
-  onHookSettings: (settings: $ReadOnly<DevToolsHookSettings>) => void =
-    settings => {
-      this._hookSettings = settings;
-
-      this.setShouldShowWarningsAndErrors(settings.showInlineWarningsAndErrors);
-      this.emit('hookSettings', settings);
-    };
-
-  setShouldShowWarningsAndErrors(status: boolean): void {
-    const previousStatus = this._shouldShowWarningsAndErrors;
-    this._shouldShowWarningsAndErrors = status;
-
-    if (previousStatus !== status) {
-      // Propagate to subscribers, although tree state has not changed
-      this.emit('mutated', [[], new Map()]);
-    }
-  }
-
-  // The Store should never throw an Error without also emitting an event.
-  // Otherwise Store errors will be invisible to users,
-  // but the downstream errors they cause will be reported as bugs.
-  // For example, https://github.com/facebook/react/issues/21402
-  // Emitting an error event allows the ErrorBoundary to show the original error.
-  _throwAndEmitError(error: Error): empty {
-    this.emit('error', error);
-
-    // Throwing is still valuable for local development
-    // and for unit testing the Store itself.
-    throw error;
-  }
-}+  _adjustParentTreeWeight: (