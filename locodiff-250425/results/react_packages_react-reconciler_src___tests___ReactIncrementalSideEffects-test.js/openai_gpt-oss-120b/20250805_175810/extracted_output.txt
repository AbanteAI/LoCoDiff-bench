/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @emails react-core
 * @jest-environment node
 */

'use strict';

let React;
let ReactNoop;
let Scheduler;
let waitForAll;
let waitFor;
let waitForPaint;

describe('ReactIncrementalSideEffects', () => {
  beforeEach(() => {
    jest.resetModules();

    React = require('react');
    ReactNoop = require('react-noop-renderer');
    Scheduler = require('scheduler');

    const InternalTestUtils = require('internal-test-utils');
    waitForAll = InternalTestUtils.waitForAll;
    waitFor = InternalTestUtils.waitFor;
    waitForPaint = InternalTestUtils.waitForPaint;
  });

  // NOTE: This is based on a similar component we use in www.
  // We can delete this once the extra div wrapper is no longer
  // necessary.
  function LegacyHiddenDiv({children, mode}) {
    return (
      <div hidden={mode === 'hidden'}>
        <React.unstable_LegacyHidden
          mode={mode === 'hidden' ? 'unstable-defer-without-hiding' : mode}>
          {children}
        </React.unstable_LegacyHidden>
      </div>
    );
  }

  // ----------------------------------------------------------------------
  // Basic children tests
  // ----------------------------------------------------------------------

  it('can update child nodes of a host instance', async () => {
    function Bar({text}) {
      return <span>{text}</span>;
    }

    function Foo({text}) {
      return (
        <div>
          <Bar text={text} />
          {text === 'World' ? <Bar text={text} /> : null}
        </div>
      );
    }

    ReactNoop.render(<Foo text="Hello" />);
    await waitForAll([]);
    expect(ReactNoop).toMatchRenderedOutput(
      <div>
        <span>Hello</span>
      </div>,
    );

    ReactNoop.render(<Foo text="World" />);
    await waitForAll([]);
    expect(ReactNoop).toMatchRenderedOutput(
      <div>
        <span>World</span>
        <span>World</span>
      </div>,
    );
  });

  it('can update child nodes of a fragment', async function () {
    function Bar({text}) {
      return <span>{text}</span>;
    }

    function Foo({text}) {
      return (
        <div>
          <Bar text={text} />
          {text === 'World'
            ? [<Bar key="a" text={text} />, <div key="b" />]
            : text === 'Hi'
              ? [<div key="b" />, <Bar key="a" text={text} />]
              : null}
          <span prop="test" />
        </div>
      );
    }

    ReactNoop.render(<Foo text="Hello" />);
    await waitForAll([]);
    expect(ReactNoop).toMatchRenderedOutput(
      <div>
        <span>Hello</span>
        <span prop="test" />
      </div>,
    );

    ReactNoop.render(<Foo text="World" />);
    await waitForAll([]);
    expect(ReactNoop).toMatchRenderedOutput(
      <div>
        <span>World</span>
        <span>World</span>
        <div />
        <span prop="test" />
      </div>,
    );

    ReactNoop.render(<Foo text="Hi" />);
    await waitForAll([]);
    expect(ReactNoop).toMatchRenderedOutput(
      <div>
        <span>Hi</span>
        <div />
        <span>Hi</span>
        <span prop="test" />
      </div>,
    );
  });

  it('can update child nodes rendering into text nodes', function () {
    function Bar({text}) {
      return text;
    }

    function Foo({text}) {
      return (
        <div>
          <Bar text={text} />
          {text === 'World' ? [<Bar key="a" text={text} />, '!'] : null}
        </div>
      );
    }

    ReactNoop.render(<Foo text="Hello" />);
    await waitForAll([]);
    expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);

    ReactNoop.render(<Foo text="World" />);
    await waitForAll([]);
    expect(ReactNoop).toMatchRenderedOutput(<div>WorldWorld!</div>);
  });

  // ----------------------------------------------------------------------
  // Deletion tests
  // ----------------------------------------------------------------------

  it('deletes children either components, host or text', function () {
    function Bar({children}) {
      return <span prop={children} />;
    }

    function Foo({show}) {
      return (
        <div>
          {show
            ? [<div key="a" />, <Bar key="b">Hello</Bar>, 'World']
            : []}
        </div>
      );
    }

    ReactNoop.render(<Foo show={true} />);
    await waitForAll([]);
    expect(ReactNoop).toMatchRenderedOutput(
      <div>
        <div />
        <span prop="Hello" />
        World
      </div>,
    );

    ReactNoop.render(<Foo show={false} />);
    await waitForAll([]);
    expect(ReactNoop).toMatchRenderedOutput(<div />);
  });

  it('delete a child that changes type - implicit keys', async () => {
    let unmounted = false;

    class ClassComponent extends React.Component {
      componentWillUnmount() {
        unmounted = true;
      }
      render() {
        return <span prop="Class" />;
      }
    }

    function FunctionComponent() {
      return <span prop="Function" />;
    }

    function Foo({useClass, useFunction, useText}) {
      return (
        <div>
          {useClass ? (
            <ClassComponent />
          ) : useFunction ? (
            <FunctionComponent />
          ) : useText ? (
            'Text'
          ) : null}
          Trail
        </div>
      );
    }

    ReactNoop.render(<Foo useClass={true} />);
    await waitForAll([]);
    expect(ReactNoop).toMatchRenderedOutput(
      <div>
        <span prop="Class" />
        Trail
      </div>,
    );
    expect(unmounted).toBe(false);

    ReactNoop.render(<Foo useFunction={true} />);
    await waitForAll([]);
    expect(ReactNoop).toMatchRenderedOutput(
      <div>
        <span prop="Function" />
        Trail
      </div>,
    );
    expect(unmounted).toBe(true);

    ReactNoop.render(<Foo useText={true} />);
    await waitForAll([]);
    expect(ReactNoop).toMatchRenderedOutput(<div>Text</div>);

    ReactNoop.render(<Foo />);
    await waitForAll([]);
    expect(ReactNoop).toMatchRenderedOutput(<div>Trail</div>);
  });

  it('delete a child when it changes type - explicit keys', async () => {
    let unmounted = false;

    class ClassComponent extends React.Component {
      componentWillUnmount() {
        unmounted = true;
      }
      render() {
        return <span prop="Class" />;
      }
    }

    function FunctionComponent() {
      return <span prop="Function" />;
    }

    function Foo({useClass, useFunction}) {
      return (
        <div>
          {useClass ? (
            <ClassComponent key="a" />
          ) : useFunction ? (
            <FunctionComponent key="a" />
          ) : null}
          Trail
        </div>
      );
    }

    ReactNoop.render(<Foo useClass={true} />);
    await waitForAll([]);
    expect(ReactNoop).toMatchRenderedOutput(
      <div>
        <span prop="Class" />
        Trail
      </div>,
    );
    expect(unmounted).toBe(false);

    ReactNoop.render(<Foo useFunction={true} />);
    await waitForAll([]);
    expect(ReactNoop).toMatchRenderedOutput(
      <div>
        <span prop="Function" />
        Trail
      </div>,
    );
    expect(unmounted).toBe(true);

    ReactNoop.render(<Foo />);
    await waitForAll([]);
    expect(ReactNoop).toMatchRenderedOutput(<div>Trail</div>);
  });

  // ----------------------------------------------------------------------
  // Portal tests
  // ----------------------------------------------------------------------

  it('deletes a child inside a portal', async () => {
    function Bar({children}) {
      return <span prop={children} />;
    }

    const portalContainer = ReactNoop.getOrCreateRootContainer('portalContainer');

    function Foo({show}) {
      return ReactNoop.createPortal(
        show ? [<div key="a" />, <Bar key="b">Hello</Bar>, 'World'] : [],
        portalContainer,
        null,
      );
    }

    ReactNoop.render(
      <div>
        <Foo show={true} />
      </div>,
    );
    await waitForAll([]);
    expect(ReactNoop).toMatchRenderedOutput(<div />);
    expect(ReactNoop.getChildren('portalContainer')).toEqual([
      <div />,
      <span prop="Hello" />,
      'World',
    ]);

    ReactNoop.render(
      <div>
        <Foo show={false} />
      </div>,
    );
    await waitForAll([]);
    expect(ReactNoop).toMatchRenderedOutput(<div />);
    expect(ReactNoop.getChildren('portalContainer')).toBe(null);

    ReactNoop.render(
      <div>
        <Foo show={true} />
      </div>,
    );
    await waitForAll([]);
    expect(ReactNoop).toMatchRenderedOutput(<div />);
    expect(ReactNoop.getChildren('portalContainer')).toEqual([
      <div />,
      <span prop="Hello" />,
      'World',
    ]);

    ReactNoop.render(null);
    await waitForAll([]);
    expect(ReactNoop).toMatchRenderedOutput(null);
    expect(ReactNoop.getChildren('portalContainer')).toBe(null);

    ReactNoop.render(<Foo show={false} />);
    await waitForAll([]);
    expect(ReactNoop).toMatchRenderedOutput(null);
    expect(ReactNoop.getChildren('portalContainer')).toBe(null);

    ReactNoop.render(<Foo show={true} />);
    await waitForAll([]);
    expect(ReactNoop).toMatchRenderedOutput(null);
    expect(ReactNoop.getChildren('portalContainer')).toEqual([
      <div />,
      <span prop="Hello" />,
      'World',
    ]);

    ReactNoop.render(null);
    await waitForAll([]);
    expect(ReactNoop).toMatchRenderedOutput(null);
    expect(ReactNoop.getChildren('portalContainer')).toBe(null);
  });

  it('deletes a child when it unmounts with a portal', async () => {
    function Bar({children}) {
      return <span prop={children} />;
    }

    const portalContainer = ReactNoop.getOrCreateRootContainer('portalContainer');

    function Foo() {
      return ReactNoop.createPortal(
        [<div key="a" />, <Bar key="b">Hello</Bar>, 'World'],
        portalContainer,
        null,
      );
    }

    ReactNoop.render(
      <div>
        <Foo />
      </div>,
    );
    await waitForAll([]);
    expect(ReactNoop).toMatchRenderedOutput(<div />);
    expect(ReactNoop.getChildren('portalContainer')).toEqual([
      <div />,
      <span prop="Hello" />,
      'World',
    ]);

    ReactNoop.render(null);
    await waitForAll([]);
    expect(ReactNoop).toMatchRenderedOutput(null);
    expect(ReactNoop.getChildren('portalContainer')).toBe(null);

    ReactNoop.render(<Foo />);
    await waitForAll([]);
    expect(ReactNoop).toMatchRenderedOutput(null);
    expect(ReactNoop.getChildren('portalContainer')).toEqual([
      <div />,
      <span prop="Hello" />,
      'World',
    ]);

    ReactNoop.render(null);
    await waitForAll([]);
    expect(ReactNoop).toMatchRenderedOutput(null);
    expect(ReactNoop.getChildren('portalContainer')).toBe(null);
  });

  // ----------------------------------------------------------------------
  // Abort behavior
  // ----------------------------------------------------------------------

  it('does not update child nodes if a flush is aborted', async () => {
    function Bar({text}) {
      Scheduler.log('Bar');
      return <span prop={text} />;
    }

    function Foo({text}) {
      Scheduler.log('Foo');
      return (
        <div>
          <div>
            <Bar text={text} />
            {text === 'Hello' ? <Bar text={text} /> : null}
          </div>
          <Bar text="Yo" />
        </div>
      );
    }

    ReactNoop.render(<Foo text="Hello" />);
    await waitFor(['Foo', 'Bar', 'Bar', 'Bar']);
    expect(ReactNoop).toMatchRenderedOutput(
      <div>
        <div>
          <span prop="Hello" />
          <span prop="Hello" />
        </div>
        <span prop="Yo" />
      </div>,
    );

    ReactNoop.render(<Foo text="World" />);
    // Flush some of the work without committing.
    await waitFor(['Foo', 'Bar']);
    expect(ReactNoop).toMatchRenderedOutput(
      <div>
        <div>
          <span prop="Hello" />
          <span prop="Hello" />
        </div>
        <span prop="Yo" />
      </div>,
    );
  });

  // ----------------------------------------------------------------------
  // Legacy hidden tests
  // ----------------------------------------------------------------------

  // @gate enableLegacyHidden
  it('preserves a previously rendered node when deprioritized', async () => {
    function Middle({children}) {
      Scheduler.log('Middle');
      return <span prop={children} />;
    }

    function Foo({text}) {
      Scheduler.log('Foo');
      return (
        <div>
          <LegacyHiddenDiv mode="hidden">
            <Middle>{text}</Middle>
          </LegacyHiddenDiv>
        </div>
      );
    }

    ReactNoop.render(<Foo text="foo" />);
    await waitFor(['Foo', 'Middle']);
    expect(ReactNoop.getChildrenAsJSX()).toEqual(
      <div>
        <div hidden={true}>
          <span prop="foo" />
        </div>
      </div>,
    );

    // Update with a commit that happens after the suspend
    ReactNoop.render(<Foo text="bar" />, () => Scheduler.log('commit'));
    await waitFor(['Foo', 'commit']);
    expect(ReactNoop.getChildrenAsJSX()).toEqual(
      <div>
        <div hidden={true}>
          <span prop="foo" />
        </div>
      </div>,
    );

    await waitFor(['Middle']);
    expect(ReactNoop.getChildrenAsJSX()).toEqual(
      <div>
        <div hidden={true}>
          <span prop="bar" />
        </div>
      </div>,
    );
  });

  // @gate enableLegacyHidden
  it('can reuse side-effects after being preempted', async () => {
    function Bar({children}) {
      Scheduler.log('Bar');
      return <span prop={children} />;
    }

    const middleContent = (
      <div>
        <Bar>Hello</Bar>
        <Bar>World</Bar>
      </div>
    );

    function Foo({text, step}) {
      Scheduler.log('Foo');
      return (
        <LegacyHiddenDiv mode="hidden">
          {step === 0 ? (
            <div>
              <Bar>Hi</Bar>
              <Bar>{text}</Bar>
            </div>
          ) : (
            middleContent
          )}
        </LegacyHiddenDiv>
      );
    }

    // Init
    ReactNoop.render(<Foo text="foo" step={0} />);
    await waitFor(['Foo', 'Bar', 'Bar']);
    expect(ReactNoop.getChildrenAsJSX()).toEqual(
      <div hidden={true}>
        <div>
          <span prop="Hi" />
          <span prop="foo" />
        </div>
      </div>,
    );

    // Make a quick update which will schedule low priority work to
    // update the middle content.
    ReactNoop.render(<Foo text="bar" step={1} />, () => Scheduler.log('commit'));
    await waitFor(['Foo', 'commit', 'Bar']);

    // The tree remains unchanged.
    expect(ReactNoop.getChildrenAsJSX()).toEqual(
      <div hidden={true}>
        <div>
          <span prop="Hi" />
          <span prop="foo" />
        </div>
      </div>,
    );

    // Interrupt with higher priority work.
    ReactNoop.render(<Foo text="foo" step={1} />);
    await waitFor(['Foo', 'Bar', 'Bar']);

    // Since we did nothing to the middle subtree during the interruption,
    // we should be able to reuse the work.
    expect(ReactNoop.getChildrenAsJSX()).toEqual(
      <div hidden={true}>
        <div>
          <span prop="Hello" />
          <span prop="World" />
        </div>
      </div>,
    );
  });

  // @gate enableLegacyHidden
  it('can reuse side-effects after being preempted, if shouldComponentUpdate is false', async () => {
    class Bar extends React.Component {
      shouldComponentUpdate(next) {
        return this.props.children !== next.children;
      }
      render() {
        Scheduler.log('Bar');
        return <span prop={this.props.children} />;
      }
    }

    class Content extends React.Component {
      shouldComponentUpdate(next) {
        return this.props.step !== next.step;
      }
      render() {
        Scheduler.log('Content');
        return (
          <div>
            <Bar>{this.props.step === 0 ? 'Hi' : 'Hello'}</Bar>
            <Bar>{this.props.step === 0 ? this.props.text : 'World'}</Bar>
          </div>
        );
      }
    }

    function Foo({step, text}) {
      Scheduler.log('Foo');
      return (
        <LegacyHiddenDiv mode="hidden">
          <Content step={step} text={text} />
        </LegacyDiv>
      );
    }

    // Init
    ReactNoop.render(<Foo step={0} text="foo" />);
    await waitFor(['Foo', 'Content', 'Bar', 'Bar']);
    expect(ReactNoop.getChildrenAsJSX()).toEqual(
      <div hidden={true}>
        <div>
          <span prop="Hi" />
          <span prop="foo" />
        </div>
      </div>,
    );

    // Update which will schedule low priority work.
    ReactNoop.render(<Foo step={1} text="bar" />);
    await waitFor(['Foo', 'Content', 'Bar']);

    // tree unchanged
    expect(ReactNoop.getChildrenAsJSX()).toEqual(
      <div hidden={true}>
        <div>
          <span prop="Hi" />
          <span prop="foo" />
        </div>
      </div>,
    );

    // Interrupt with higher priority work.
    ReactNoop.render(<Foo step={1} text="foo" />);
    await waitFor(['Foo', 'Content', 'Bar', 'Bar']);

    // Ensure reuse
    expect(ReactNoop.getChildrenAsJSX()).toEqual(
      <div hidden={true}>
        <div>
          <span prop="Hello" />
          <span prop="World" />
        </div>
      </div>,
    );
  });

  // ----------------------------------------------------------------------
  // Completion tests
  // ---------------------------------------------------------------------- 

  it('can update a completed tree before it has a chance to commit', async () => {
    function Foo({step}) {
      Scheduler.log('Foo ' + step);
      return <span prop={step} />;
    }
    // Initial render
    React.startTransition(() => {
      ReactNoop.render(<Foo step={1} />);
    });
    // Complete but do not commit
    await waitFor(['Foo 1']);
    expect(ReactNoop.getChildrenAsJSX()).toBe(null);
    await waitForPaint([]);
    expect(ReactNoop.getChildrenAsJSX()).toEqual(<span prop={1} />);

    // Render second step, not committed
    React.startTransition(() => {
      ReactNoop.render(<Foo step={2} />);
    });
    await waitFor(['Foo 2']);
    expect(ReactNoop.getChildrenAsJSX()).toEqual(<span prop={1} />);

    // Update before commit
    React.startTransition(() => {
      ReactNoop.render(<Foo step={3} />);
    });
    expect(ReactNoop.getChildrenAsJSX()).toEqual(<span prop={1} />);

    // Commit pending
    await waitForPaint([]);
    expect(ReactNoop.getChildrenAsJSX()).toEqual(<span prop={2} />);

    // Flush rest
    await waitForAll(['Foo 3']);
    expect(ReactNoop.getChildrenAsJSX()).toEqual(<span prop={3} />);
  });

  // @enableLegacyHidden
  it('updates a child even though the old props is empty', async () => {
    function Foo() {
      return (
        <LegacyDiv mode="hidden">
          <span prop={1} />
        </LegacyDiv>
      );
    }

    ReactNoop.render(<Foo />);
    await waitForAll([]);
    expect(ReactNoop.getChildrenAsJSX()).toEqual(
      <div hidden={true}>
        <span prop={1} />
      </div>,
    );
  });

  it('calls callback after update is flushed', async () => {
    let instance;
    class Foo extends React.Component {
      constructor() {
        super();
        instance = this;
        this.state = {text: 'foo'};
      }
      render() {
        return <span prop={this.state.text} />;
      }
    }

    ReactNoop.render(<Foo />);
    await waitForAll([]);
    expect(ReactNoop).toMatchRenderedOutput(<span prop="foo" />);
    let called = false;
    instance.setState({text: 'bar'}, () => {
      expect(ReactNoop).toMatchRenderedOutput(<span prop="bar" />);
      called = true;
    });
    await waitForAll([]);
    expect(called).toBe(true);
  });

  it('calls setState callback even if component bails out', async () => {
    let instance;
    class Foo extends React.Component {
      constructor() {
        super();
        instance = this;
        this.state = {text: 'foo'};
      }
      shouldComponentUpdate(_, next) {
        return this.state.text !== next.text;
      }
      render() {
        return <span prop={this.state.text} />;
      }
    }

    ReactNoop.render(<Foo />);
    await waitAll([]);
    expect(ReactNoop).toMatchRenderedOutput(<span prop="foo" />);
    let called = false;
    instance.setState({}, () => {
      called = true;
    });
    await waitAll([]);
    expect(called).toBe(true);
  });

  // ----------------------------------------------------------------------
  // Unmount tests
  // ---------------------------------------------------------------------- 

  it('calls componentWillUnmount after a deletion, even if nested', async () => {
    const ops = [];

    class Bar extends React.Component {
      componentWillUnmount() {
        ops.push(this.props.name);
      }
      render() {
        return <span />;
      }
    }

    class Wrapper extends React.Component {
      componentWillUnmount() {
        ops.push('Wrapper');
      }
      render() {
        return <Bar name={this.props.name} />;
      }
    }

    function Foo({show}) {
      return (
        <div>
          {show
            ? [
                <Bar key="a" name="A" />,
                <Wrapper key="b" name="B" />,
                <div key="cd">
                  <Bar name="C" />
                  <Wrapper name="D" />,
                </div>,
                [<Bar key="e" name="E" />, <Bar key="f" name="F" />],
              ]
            : []}
          <div>{show ? <Bar key="g" name="G" /> : null}</div>
          <Bar name="this should not unmount" />
        </div>
      );
    }

    ReactNoop.render(<Foo show={true} />);
    await waitForAll([]);
    expect(ops).toEqual([]);

    ReactNoop.render(<Foo show={false} />);
    await waitForAll([]);
    expect(ops).toEqual([
      'A',
      'Wrapper',
      'B',
      'C',
      'Wrapper',
      'D',
      'E',
      'F',
      'G',
    ]);
  });

  it('calls componentDidMount/Update after insertion/update', async () => {
    const ops = [];

    class Bar extends React.Component {
      componentDidMount() {
        ops.push(`mount:${this.props.name}`);
      }
      componentDidUpdate() {
        ops.push(`update:${this.props.name}`);
      }
      render() {
        return <span />;
      }
    }

    class Wrapper extends React.Component {
      componentDidMount() {
        ops.push(`mount:wrapper-${this.props.name}`);
      }
      componentDidUpdate() {
        ops.push(`update:wrapper-${this.props.name}`);
      }
      render() {
        return <Bar name={this.props.name} />;
      }
    }

    function Foo() {
      return (
        <div>
          <Bar key="a" name="A" />
          <Wrapper key="b" name="B" />
          <div key="cd">
            <Bar name="C" />
            <Wrapper name="D" />
          </div>
          {[<Bar key="e" name="E" />, <Bar key="f" name="F" />]}
          <div>
            <Bar key="g" name="G" />
          </div>
        </div>
      );
    }

    ReactNoop.render(<Foo />);
    await waitForAll([]);
    expect(ops).toEqual([
      'mount:A',
      'mount:B',
      'mount:wrapper-B',
      'mount:C',
      'mount:D',
      'mount:wrapper-D',
      'mount:E',
      'mount:F',
      'mount:G',
    ]);

    ops.splice(0);
    ReactNoop.render(<Foo />);
    await waitForAll([]);
    expect(ops).toEqual([
      'update:A',
      'update:B',
      'update:wrapper-B',
      'update:C',
      'update:D',
      'update:wrapper-D',
      'update:E',
      'update:F',
      'update:G',
    ]);
  });

  it('invokes ref callbacks after insertion/update/unmount', async () => {
    let classInstance = null;
    const ops = [];

    class ClassComponent extends React.Component {
      render() {
        classInstance = this;
        return <span />;
      }
    }

    function FunctionComponent() {
      return <span />;
    }

    function Foo({show}) {
      return show ? (
        <div>
          <ClassComponent ref={n => ops.push(n)} />
          <FunctionComponent ref={n => ops.push(n)} />
          <div ref={n => ops.push(n)} />
        </div>
      ) : null;
    }

    ReactNoop.render(<Foo show={true} />);
    await expectAsync(async () => await waitForAll([])).toErrorDev(
      'Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()? ',
    );

    expect(ops).toEqual([classInstance, {type: 'div', children: [], prop: undefined, hidden: false}]);

    ops.splice(0);
    // Reinscribe refs
    ReactNoop.render(<Foo show={true} />);
    await waitForAll([]);
    expect(ops).toEqual([
      null,
      null,
      classInstance,
      {type: 'div', children: [], prop: undefined, hidden: false},
    ]);

    ops.splice(0);
    ReactNoop.render(<Foo show={false} />);
    await waitForAll([]);
    expect(ops).toEqual([null, null]);
  });

  // TODO: Test that mounts, updates, refs, unmounts and deletions happen in the
  // expected way for aborted and resumed render life-cycles.
});
```

(Note: The code above captures the final state of the test file after all changes, including the removal of string‑ref handling behind a flag, the updated `waitFor*`‑based testing pattern, and the LegacyHidden gating.)