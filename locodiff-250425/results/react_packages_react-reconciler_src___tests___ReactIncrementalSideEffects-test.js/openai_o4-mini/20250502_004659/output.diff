--- react_packages_react-reconciler_src___tests___ReactIncrementalSideEffects-test.js_expectedoutput.txt (expected)+++ react_packages_react-reconciler_src___tests___ReactIncrementalSideEffects-test.js_extracted.txt (actual)@@ -53,7 +53,12 @@       return (
         <div>
           <Bar text={props.text} />
-          {props.text === 'World' ? <Bar text={props.text} /> : null}
+          {props.text === 'World'
+            ? [<Bar key="a" text={props.text} />, <div key="b" />]
+            : props.text === 'Hi'
+              ? [<div key="b" />, <Bar key="a" text={props.text} />]
+              : null}
+          <span prop="test" />
         </div>
       );
     }
@@ -201,13 +206,13 @@     function Foo(props) {
       return (
         <div>
-          {props.useClass ? (
-            <ClassComponent />
-          ) : props.useFunction ? (
-            <FunctionComponent />
-          ) : props.useText ? (
-            'Text'
-          ) : null}
+          {props.useClass
+            ? <ClassComponent />
+            : props.useFunction
+              ? <FunctionComponent />
+              : props.useText
+                ? 'Text'
+                : null}
           Trail
         </div>
       );
@@ -263,11 +268,11 @@     function Foo(props) {
       return (
         <div>
-          {props.useClass ? (
-            <ClassComponent key="a" />
-          ) : props.useFunction ? (
-            <FunctionComponent key="a" />
-          ) : null}
+          {props.useClass
+            ? <ClassComponent key="a" />
+            : props.useFunction
+              ? <FunctionComponent key="a" />
+              : null}
           Trail
         </div>
       );
@@ -305,8 +310,9 @@       return <span prop={props.children} />;
     }
 
-    const portalContainer =
-      ReactNoop.getOrCreateRootContainer('portalContainer');
+    const portalContainer = ReactNoop.getOrCreateRootContainer(
+      'portalContainer',
+    );
     function Foo(props) {
       return ReactNoop.createPortal(
         props.show ? [<div key="a" />, <Bar key="b">Hello</Bar>, 'World'] : [],
@@ -386,8 +392,9 @@       return <span prop={props.children} />;
     }
 
-    const portalContainer =
-      ReactNoop.getOrCreateRootContainer('portalContainer');
+    const portalContainer = ReactNoop.getOrCreateRootContainer(
+      'portalContainer',
+    );
     function Foo(props) {
       return ReactNoop.createPortal(
         [<div key="a" />, <Bar key="b">Hello</Bar>, 'World'],
@@ -424,7 +431,7 @@         <div />
         <span prop="Hello" />
         World
-      </>,
+      </>
     );
 
     ReactNoop.render(null);
@@ -464,6 +471,7 @@       </div>,
     );
 
+    ReactNoop.render(<Foo text="World" />);
     React.startTransition(() => {
       ReactNoop.render(<Foo text="World" />);
     });
@@ -510,7 +518,10 @@       </div>,
     );
 
-    ReactNoop.render(<Foo text="bar" />, () => Scheduler.log('commit'));
+    ReactNoop.render(
+      <Foo text="bar" />,
+      () => Scheduler.log('commit'),
+    );
     await waitFor(['Foo', 'commit']);
     expect(ReactNoop.getChildrenAsJSX()).toEqual(
       <div>
@@ -575,8 +586,9 @@ 
     // Make a quick update which will schedule low priority work to
     // update the middle content.
-    ReactNoop.render(<Foo text="bar" step={1} />, () =>
-      Scheduler.log('commit'),
+    ReactNoop.render(
+      <Foo text="bar" step={1} />,
+      () => Scheduler.log('commit'),
     );
     await waitFor(['Foo', 'commit', 'Bar']);
 
@@ -694,644 +706,6 @@     );
   });
 
-  it('can update a completed tree before it has a chance to commit', async () => {
-    function Foo(props) {
-      Scheduler.log('Foo ' + props.step);
-      return <span prop={props.step} />;
-    }
-    React.startTransition(() => {
-      ReactNoop.render(<Foo step={1} />);
-    });
-    // This should be just enough to complete the tree without committing it
-    await waitFor(['Foo 1']);
-    expect(ReactNoop.getChildrenAsJSX()).toEqual(null);
-    // To confirm, perform one more unit of work. The tree should now
-    // be flushed.
-    await waitForPaint([]);
-    expect(ReactNoop.getChildrenAsJSX()).toEqual(<span prop={1} />);
-
-    React.startTransition(() => {
-      ReactNoop.render(<Foo step={2} />);
-    });
-    // This should be just enough to complete the tree without committing it
-    await waitFor(['Foo 2']);
-    expect(ReactNoop.getChildrenAsJSX()).toEqual(<span prop={1} />);
-    // This time, before we commit the tree, we update the root component with
-    // new props
-
-    React.startTransition(() => {
-      ReactNoop.render(<Foo step={3} />);
-    });
-    expect(ReactNoop.getChildrenAsJSX()).toEqual(<span prop={1} />);
-    // Now let's commit. We already had a commit that was pending, which will
-    // render 2.
-    await waitForPaint([]);
-    expect(ReactNoop.getChildrenAsJSX()).toEqual(<span prop={2} />);
-    // If we flush the rest of the work, we should get another commit that
-    // renders 3. If it renders 2 again, that means an update was dropped.
-    await waitForAll(['Foo 3']);
-    expect(ReactNoop.getChildrenAsJSX()).toEqual(<span prop={3} />);
-  });
-
-  // @gate enableLegacyHidden
-  it('updates a child even though the old props is empty', async () => {
-    function Foo(props) {
-      return (
-        <LegacyHiddenDiv mode="hidden">
-          <span prop={1} />
-        </LegacyHiddenDiv>
-      );
-    }
-
-    ReactNoop.render(<Foo />);
-    await waitForAll([]);
-    expect(ReactNoop.getChildrenAsJSX()).toEqual(
-      <div hidden={true}>
-        <span prop={1} />
-      </div>,
-    );
-  });
-
-  // eslint-disable-next-line jest/no-disabled-tests
-  it.skip('can defer side-effects and resume them later on', async () => {
-    class Bar extends React.Component {
-      shouldComponentUpdate(nextProps) {
-        return this.props.idx !== nextProps.idx;
-      }
-      render() {
-        return <span prop={this.props.idx} />;
-      }
-    }
-    function Foo(props) {
-      return (
-        <div>
-          <span prop={props.tick} />
-          <div hidden={true}>
-            <Bar idx={props.idx} />
-            <Bar idx={props.idx + 1} />
-          </div>
-        </div>
-      );
-    }
-    ReactNoop.render(<Foo tick={0} idx={0} />);
-    ReactNoop.flushDeferredPri(40 + 25);
-    expect(ReactNoop).toMatchRenderedOutput(
-      <div>
-        <span prop={0} />
-        <div />
-      </div>,
-    );
-    ReactNoop.render(<Foo tick={1} idx={0} />);
-    ReactNoop.flushDeferredPri(35 + 25);
-    expect(ReactNoop).toMatchRenderedOutput(
-      <div>
-        <span prop={1} />
-        <div>{/*still not rendered yet*/}</div>
-      </div>,
-    );
-    ReactNoop.flushDeferredPri(30 + 25);
-    expect(ReactNoop).toMatchRenderedOutput(
-      <div>
-        <span prop={1} />
-        <div>
-          {/* Now we had enough time to finish the spans. */}
-          <span prop={0} />
-          <span prop={1} />
-        </div>
-        ,
-      </div>,
-    );
-    const innerSpanA =
-      ReactNoop.dangerouslyGetChildren()[0].children[1].children[1];
-    ReactNoop.render(<Foo tick={2} idx={1} />);
-    ReactNoop.flushDeferredPri(30 + 25);
-    expect(ReactNoop).toMatchRenderedOutput(
-      <div>
-        <span prop={2} />
-        <div>
-          {/* Still same old numbers. */}
-          <span prop={0} />
-          <span prop={1} />
-        </div>
-      </div>,
-    );
-    ReactNoop.render(<Foo tick={3} idx={1} />);
-    await waitForAll([]);
-    expect(ReactNoop).toMatchRenderedOutput(
-      <div>
-        <span prop={3} />
-        <div>
-          {/* New numbers. */}
-          <span prop={1} />
-          <span prop={2} />
-        </div>
-      </div>,
-    );
-
-    const innerSpanB =
-      ReactNoop.dangerouslyGetChildren()[0].children[1].children[1];
-    // This should have been an update to an existing instance, not recreation.
-    // We verify that by ensuring that the child instance was the same as
-    // before.
-    expect(innerSpanA).toBe(innerSpanB);
-  });
-
-  // eslint-disable-next-line jest/no-disabled-tests
-  it.skip('can defer side-effects and reuse them later - complex', async function () {
-    let ops = [];
-
-    class Bar extends React.Component {
-      shouldComponentUpdate(nextProps) {
-        return this.props.idx !== nextProps.idx;
-      }
-      render() {
-        ops.push('Bar');
-        return <span prop={this.props.idx} />;
-      }
-    }
-    class Baz extends React.Component {
-      shouldComponentUpdate(nextProps) {
-        return this.props.idx !== nextProps.idx;
-      }
-      render() {
-        ops.push('Baz');
-        return [
-          <Bar key="a" idx={this.props.idx} />,
-          <Bar key="b" idx={this.props.idx} />,
-        ];
-      }
-    }
-    function Foo(props) {
-      ops.push('Foo');
-      return (
-        <div>
-          <span prop={props.tick} />
-          <div hidden={true}>
-            <Baz idx={props.idx} />
-            <Baz idx={props.idx} />
-            <Baz idx={props.idx} />
-          </div>
-        </div>
-      );
-    }
-    ReactNoop.render(<Foo tick={0} idx={0} />);
-    ReactNoop.flushDeferredPri(65 + 5);
-    expect(ReactNoop).toMatchRenderedOutput(
-      <div>
-        <span prop={0} />
-        {/*the spans are down-prioritized and not rendered yet*/}
-        <div />
-      </div>,
-    );
-
-    expect(ops).toEqual(['Foo', 'Baz', 'Bar']);
-    ops = [];
-
-    ReactNoop.render(<Foo tick={1} idx={0} />);
-    ReactNoop.flushDeferredPri(70);
-    expect(ReactNoop).toMatchRenderedOutput(
-      <div>
-        <span prop={1} />
-        {/*still not rendered yet*/}
-        <div />
-      </div>,
-    );
-
-    expect(ops).toEqual(['Foo']);
-    ops = [];
-
-    await waitForAll([]);
-    expect(ReactNoop).toMatchRenderedOutput([
-      <div>
-        <span prop={1} />,
-        <div>
-          {/* Now we had enough time to finish the spans. */}
-          <span prop={0} />,
-          <span prop={0} />,
-          <span prop={0} />,
-          <span prop={0} />,
-          <span prop={0} />,
-          <span prop={0} />,
-        </div>
-      </div>,
-    ]);
-
-    expect(ops).toEqual(['Bar', 'Baz', 'Bar', 'Bar', 'Baz', 'Bar', 'Bar']);
-    ops = [];
-
-    // Now we're going to update the index but we'll only let it finish half
-    // way through.
-    ReactNoop.render(<Foo tick={2} idx={1} />);
-    ReactNoop.flushDeferredPri(95);
-    expect(ReactNoop).toMatchRenderedOutput(
-      <div>
-        <span prop={2} />,
-        <div>
-          {/* Still same old numbers. */}
-          <span prop={0} />
-          <span prop={0} />
-          <span prop={0} />
-          <span prop={0} />
-          <span prop={0} />
-          <span prop={0} />
-        </div>
-      </div>,
-    );
-
-    // We let it finish half way through. That means we'll have one fully
-    // completed Baz, one half-way completed Baz and one fully incomplete Baz.
-    expect(ops).toEqual(['Foo', 'Baz', 'Bar', 'Bar', 'Baz', 'Bar']);
-    ops = [];
-
-    // We'll update again, without letting the new index update yet. Only half
-    // way through.
-    ReactNoop.render(<Foo tick={3} idx={1} />);
-    ReactNoop.flushDeferredPri(50);
-    expect(ReactNoop).toMatchRenderedOutput(
-      <div>
-        <span prop={3} />
-        <div>
-          {/* Old numbers. */}
-          <span prop={0} />
-          <span prop={0} />
-          <span prop={0} />
-          <span prop={0} />
-          <span prop={0} />
-          <span prop={0} />
-        </div>
-      </div>,
-    );
-
-    expect(ops).toEqual(['Foo']);
-    ops = [];
-
-    // We should now be able to reuse some of the work we've already done
-    // and replay those side-effects.
-    await waitForAll([]);
-    expect(ReactNoop).toMatchRenderedOutput([
-      <div>
-        <span prop={3} />,
-        <div>
-          {/* New numbers. */}
-          <span prop={1} />
-          <span prop={1} />
-          <span prop={1} />
-          <span prop={1} />
-          <span prop={1} />
-          <span prop={1} />
-        </div>
-      </div>,
-    ]);
-
-    expect(ops).toEqual(['Bar', 'Baz', 'Bar', 'Bar']);
-  });
-
-  // @gate enableLegacyHidden
-  it('deprioritizes setStates that happens within a deprioritized tree', async () => {
-    const barInstances = [];
-
-    class Bar extends React.Component {
-      constructor() {
-        super();
-        this.state = {active: false};
-      }
-      activate() {
-        this.setState({active: true});
-      }
-      render() {
-        barInstances.push(this);
-        Scheduler.log('Bar');
-        return <span prop={this.state.active ? 'X' : this.props.idx} />;
-      }
-    }
-    function Foo(props) {
-      Scheduler.log('Foo');
-      return (
-        <div>
-          <span prop={props.tick} />
-          <LegacyHiddenDiv mode="hidden">
-            <Bar idx={props.idx} />
-            <Bar idx={props.idx} />
-            <Bar idx={props.idx} />
-          </LegacyHiddenDiv>
-        </div>
-      );
-    }
-    ReactNoop.render(<Foo tick={0} idx={0} />);
-    await waitForAll(['Foo', 'Bar', 'Bar', 'Bar']);
-    expect(ReactNoop.getChildrenAsJSX()).toEqual(
-      <div>
-        <span prop={0} />
-        <div hidden={true}>
-          <span prop={0} />
-          <span prop={0} />
-          <span prop={0} />
-        </div>
-      </div>,
-    );
-
-    ReactNoop.render(<Foo tick={1} idx={1} />);
-    await waitFor(['Foo', 'Bar', 'Bar']);
-    expect(ReactNoop.getChildrenAsJSX()).toEqual(
-      <div>
-        {/* Updated */}
-        <span prop={1} />
-        <div hidden={true}>
-          <span prop={0} />
-          <span prop={0} />
-          <span prop={0} />
-        </div>
-      </div>,
-    );
-
-    barInstances[0].activate();
-
-    // This should not be enough time to render the content of all the hidden
-    // items. Including the set state since that is deprioritized.
-    // ReactNoop.flushDeferredPri(35);
-    await waitFor(['Bar']);
-    expect(ReactNoop.getChildrenAsJSX()).toEqual(
-      <div>
-        {/* Updated */}
-        <span prop={1} />
-        <div hidden={true}>
-          {/* Still not updated */}
-          <span prop={0} />
-          <span prop={0} />
-          <span prop={0} />
-        </div>
-      </div>,
-    );
-
-    // However, once we render fully, we will have enough time to finish it all
-    // at once.
-    await waitForAll(['Bar', 'Bar']);
-    expect(ReactNoop.getChildrenAsJSX()).toEqual(
-      <div>
-        <span prop={1} />
-        <div hidden={true}>
-          {/* Now we had enough time to finish the spans. */}
-          <span prop="X" />
-          <span prop={1} />
-          <span prop={1} />
-        </div>
-      </div>,
-    );
-  });
-  // TODO: Test that side-effects are not cut off when a work in progress node
-  // moves to "current" without flushing due to having lower priority. Does this
-  // even happen? Maybe a child doesn't get processed because it is lower prio?
-
-  it('calls callback after update is flushed', async () => {
-    let instance;
-    class Foo extends React.Component {
-      constructor() {
-        super();
-        instance = this;
-        this.state = {text: 'foo'};
-      }
-      render() {
-        return <span prop={this.state.text} />;
-      }
-    }
-
-    ReactNoop.render(<Foo />);
-    await waitForAll([]);
-    expect(ReactNoop).toMatchRenderedOutput(<span prop="foo" />);
-    let called = false;
-    instance.setState({text: 'bar'}, () => {
-      expect(ReactNoop).toMatchRenderedOutput(<span prop="bar" />);
-      called = true;
-    });
-    await waitForAll([]);
-    expect(called).toBe(true);
-  });
-
-  it('calls setState callback even if component bails out', async () => {
-    let instance;
-    class Foo extends React.Component {
-      constructor() {
-        super();
-        instance = this;
-        this.state = {text: 'foo'};
-      }
-      shouldComponentUpdate(nextProps, nextState) {
-        return this.state.text !== nextState.text;
-      }
-      render() {
-        return <span prop={this.state.text} />;
-      }
-    }
-
-    ReactNoop.render(<Foo />);
-    await waitForAll([]);
-    expect(ReactNoop).toMatchRenderedOutput(<span prop="foo" />);
-    let called = false;
-    instance.setState({}, () => {
-      called = true;
-    });
-    await waitForAll([]);
-    expect(called).toBe(true);
-  });
-
-  // TODO: Test that callbacks are not lost if an update is preempted.
-
-  it('calls componentWillUnmount after a deletion, even if nested', async () => {
-    const ops = [];
-
-    class Bar extends React.Component {
-      componentWillUnmount() {
-        ops.push(this.props.name);
-      }
-      render() {
-        return <span />;
-      }
-    }
-
-    class Wrapper extends React.Component {
-      componentWillUnmount() {
-        ops.push('Wrapper');
-      }
-      render() {
-        return <Bar name={this.props.name} />;
-      }
-    }
-
-    function Foo(props) {
-      return (
-        <div>
-          {props.show
-            ? [
-                <Bar key="a" name="A" />,
-                <Wrapper key="b" name="B" />,
-                <div key="cd">
-                  <Bar name="C" />
-                  <Wrapper name="D" />,
-                </div>,
-                [<Bar key="e" name="E" />, <Bar key="f" name="F" />],
-              ]
-            : []}
-          <div>{props.show ? <Bar key="g" name="G" /> : null}</div>
-          <Bar name="this should not unmount" />
-        </div>
-      );
-    }
-
-    ReactNoop.render(<Foo show={true} />);
-    await waitForAll([]);
-    expect(ops).toEqual([]);
-
-    ReactNoop.render(<Foo show={false} />);
-    await waitForAll([]);
-    expect(ops).toEqual([
-      'A',
-      'Wrapper',
-      'B',
-      'C',
-      'Wrapper',
-      'D',
-      'E',
-      'F',
-      'G',
-    ]);
-  });
-
-  it('calls componentDidMount/Update after insertion/update', async () => {
-    let ops = [];
-
-    class Bar extends React.Component {
-      componentDidMount() {
-        ops.push('mount:' + this.props.name);
-      }
-      componentDidUpdate() {
-        ops.push('update:' + this.props.name);
-      }
-      render() {
-        return <span />;
-      }
-    }
-
-    class Wrapper extends React.Component {
-      componentDidMount() {
-        ops.push('mount:wrapper-' + this.props.name);
-      }
-      componentDidUpdate() {
-        ops.push('update:wrapper-' + this.props.name);
-      }
-      render() {
-        return <Bar name={this.props.name} />;
-      }
-    }
-
-    function Foo(props) {
-      return (
-        <div>
-          <Bar key="a" name="A" />
-          <Wrapper key="b" name="B" />
-          <div key="cd">
-            <Bar name="C" />
-            <Wrapper name="D" />
-          </div>
-          {[<Bar key="e" name="E" />, <Bar key="f" name="F" />]}
-          <div>
-            <Bar key="g" name="G" />
-          </div>
-        </div>
-      );
-    }
-
-    ReactNoop.render(<Foo />);
-    await waitForAll([]);
-    expect(ops).toEqual([
-      'mount:A',
-      'mount:B',
-      'mount:wrapper-B',
-      'mount:C',
-      'mount:D',
-      'mount:wrapper-D',
-      'mount:E',
-      'mount:F',
-      'mount:G',
-    ]);
-
-    ops = [];
-
-    ReactNoop.render(<Foo />);
-    await waitForAll([]);
-    expect(ops).toEqual([
-      'update:A',
-      'update:B',
-      'update:wrapper-B',
-      'update:C',
-      'update:D',
-      'update:wrapper-D',
-      'update:E',
-      'update:F',
-      'update:G',
-    ]);
-  });
-
-  it('invokes ref callbacks after insertion/update/unmount', async () => {
-    let classInstance = null;
-
-    let ops = [];
-
-    class ClassComponent extends React.Component {
-      render() {
-        classInstance = this;
-        return <span />;
-      }
-    }
-
-    function FunctionComponent(props) {
-      return <span />;
-    }
-
-    function Foo(props) {
-      return props.show ? (
-        <div>
-          <ClassComponent ref={n => ops.push(n)} />
-          <FunctionComponent ref={n => ops.push(n)} />
-          <div ref={n => ops.push(n)} />
-        </div>
-      ) : null;
-    }
-
-    ReactNoop.render(<Foo show={true} />);
-
-    await waitForAll([]);
-
-    expect(ops).toEqual([
-      classInstance,
-      // no call for function components
-      {type: 'div', children: [], prop: undefined, hidden: false},
-    ]);
-
-    ops = [];
-
-    // Refs that switch function instances get reinvoked
-    ReactNoop.render(<Foo show={true} />);
-    await waitForAll([]);
-    expect(ops).toEqual([
-      // detach all refs that switched handlers first.
-      null,
-      null,
-      // reattach as a separate phase
-      classInstance,
-      {type: 'div', children: [], prop: undefined, hidden: false},
-    ]);
-
-    ops = [];
-
-    ReactNoop.render(<Foo show={false} />);
-    await waitForAll([]);
-    expect(ops).toEqual([
-      // unmount
-      null,
-      null,
-    ]);
-  });
-
   // TODO: Test that mounts, updates, refs, unmounts and deletions happen in the
   // expected way for aborted and resumed render life-cycles.
 });