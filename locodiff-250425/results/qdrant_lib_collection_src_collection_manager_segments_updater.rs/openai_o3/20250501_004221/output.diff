--- qdrant_lib_collection_src_collection_manager_segments_updater.rs_expectedoutput.txt (expected)+++ qdrant_lib_collection_src_collection_manager_segments_updater.rs_extracted.txt (actual)@@ -1,5 +1,6 @@ //! A collection of functions for updating points and payloads stored in segments
 
+use std::collections::HashMap;
 use std::sync::atomic::AtomicBool;
 
 use ahash::{AHashMap, AHashSet};
@@ -17,13 +18,13 @@ };
 
 use crate::collection_manager::holders::segment_holder::SegmentHolder;
-use crate::operations::FieldIndexOperations;
 use crate::operations::payload_ops::PayloadOps;
 use crate::operations::point_ops::{
     PointInsertOperationsInternal, PointOperations, PointStructPersisted,
 };
 use crate::operations::types::{CollectionError, CollectionResult};
 use crate::operations::vector_ops::{PointVectorsPersisted, VectorOperations};
+use crate::operations::FieldIndexOperations;
 
 pub(crate) fn check_unprocessed_points(
     points: &[PointIdType],
@@ -36,6 +37,8 @@         Some(missed_point_id) => Err(CollectionError::PointNotFound { missed_point_id }),
     }
 }
+
+const VECTOR_OP_BATCH_SIZE: usize = 512;
 
 /// Tries to delete points from all segments, returns number of actually deleted points
 pub(crate) fn delete_points(
@@ -101,8 +104,6 @@ 
     Ok(total_updated_points)
 }
-
-const VECTOR_OP_BATCH_SIZE: usize = 512;
 
 /// Delete the given named vectors for the given points, keeping other vectors intact.
 pub(crate) fn delete_vectors(
@@ -333,6 +334,7 @@     hw_counter: &HardwareCounterCell,
 ) -> CollectionResult<usize> {
     let points_to_clear = points_by_filter(segments, filter, hw_counter)?;
+
     clear_payload(segments, op_num, &points_to_clear, hw_counter)
 }
 
@@ -520,9 +522,10 @@     let new_point_ids = ids.iter().copied().filter(|x| !updated_points.contains(x));
 
     {
-        let default_write_segment = segments.smallest_appendable_segment().ok_or_else(|| {
-            CollectionError::service_error("No appendable segments exists, expected at least one")
-        })?;
+        let default_write_segment =
+            segments.smallest_appendable_segment().ok_or_else(|| {
+                CollectionError::service_error("No appendable segments exists, expected at least one")
+            })?;
 
         let segment_arc = default_write_segment.get();
         let mut write_segment = segment_arc.write();
@@ -754,6 +757,5 @@ 
         Ok(true)
     })?;
-
     Ok(total_deleted)
 }