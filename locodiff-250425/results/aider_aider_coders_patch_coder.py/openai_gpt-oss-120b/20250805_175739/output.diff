
index 1992834ec..1218b7545 100644
--- a/aider_aider_coders_patch_coder.py_expectedoutput.txt (expected):tmp/tmpgogph9no_expected.txt	
+++ b/aider_aider_coders_patch_coder.py_extracted.txt (actual):tmp/tmpt_jopwsr_actual.txt	
@@ -83,7 +83,9 @@ def find_context(lines: List[str], context: List[str], start: int, eof: bool) ->
     if eof:
         # If EOF marker, first try matching at the very end
         if len(lines) >= len(context):
-            new_index, fuzz = find_context_core(lines, context, len(lines) - len(context))
+            new_index, fuzz = find_context_core(
+                lines, context, len(lines) - len(context)
+            )
             if new_index != -1:
                 return new_index, fuzz
         # If not found at end, search from `start` as fallback
@@ -93,7 +95,9 @@ def find_context(lines: List[str], context: List[str], start: int, eof: bool) ->
     return find_context_core(lines, context, start)
 
 
-def peek_next_section(lines: List[str], index: int) -> Tuple[List[str], List[Chunk], int, bool]:
+def peek_next_section(
+    lines: List[str], index: int
+) -> Tuple[List[str], List[Chunk], int, bool]:
     """
     Parses one section (context, -, + lines) of an Update block.
     Returns: (context_lines, chunks_in_section, next_index, is_eof)
@@ -306,14 +310,12 @@ class PatchCoder(Coder):
                 index += 1
                 break  # Successfully reached end
 
-            # ---------- UPDATE ---------- #
+            # ---------- UPDATE ----------
             if norm_line.startswith("*** Update File: "):
                 path = norm_line[len("*** Update File: ") :].strip()
                 index += 1
                 if not path:
                     raise DiffError("Update File action missing path.")
-
-                # Optional move target
                 move_to = None
                 if index < len(lines) and _norm(lines[index]).startswith("*** Move to: "):
                     move_to = _norm(lines[index])[len("*** Move to: ") :].strip()
@@ -338,8 +340,13 @@ class PatchCoder(Coder):
                     existing_action.chunks.extend(new_action.chunks)
 
                     if move_to:
-                        if existing_action.move_path and existing_action.move_path != move_to:
-                            raise DiffError(f"Conflicting move targets for file: {path}")
+                        if (
+                            existing_action.move_path
+                            and existing_action.move_path != move_to
+                        ):
+                            raise DiffError(
+                                f"Conflicting move targets for file: {path}"
+                            )
                         existing_action.move_path = move_to
                     fuzz_accumulator += fuzz
                 else:
@@ -353,7 +360,7 @@ class PatchCoder(Coder):
                     fuzz_accumulator += fuzz
                 continue
 
-            # ---------- DELETE ---------- #
+            # ---------- DELETE ----------
             elif norm_line.startswith("*** Delete File: "):
                 path = norm_line[len("*** Delete File: ") :].strip()
                 index += 1
@@ -363,7 +370,9 @@ class PatchCoder(Coder):
                 if existing_action:
                     if existing_action.type == ActionType.DELETE:
                         # Duplicate delete – ignore the extra block
-                        self.io.tool_warning(f"Duplicate delete action for file: {path} ignored.")
+                        self.io.tool_warning(
+                            f"Duplicate delete action for file: {path} ignored."
+                        )
                         continue
                     else:
                         raise DiffError(f"Conflicting actions for file: {path}")
@@ -375,7 +384,7 @@ class PatchCoder(Coder):
                 patch.actions[path] = PatchAction(type=ActionType.DELETE, path=path)
                 continue
 
-            # ---------- ADD ---------- #
+            # ---------- ADD ----------
             elif norm_line.startswith("*** Add File: "):
                 path = norm_line[len("*** Add File: ") :].strip()
                 index += 1
@@ -393,19 +402,11 @@ class PatchCoder(Coder):
                 patch.actions[path] = action
                 continue
 
-            # If we are here, the line is unexpected
-            # Allow blank lines between actions
-            if not norm_line.strip():
+            else:
+                # Unexpected line – skip or raise
                 index += 1
                 continue
 
-            raise DiffError(f"Unknown or misplaced line while parsing patch: {line}")
-
-        # Check if we consumed the whole input or stopped early
-        # Tolerate missing "*** End Patch" if we processed actions
-        # if index < len(lines) and _norm(lines[index-1]) != "*** End Patch":
-        #    raise DiffError("Patch parsing finished unexpectedly before end of input.")
-
         patch.fuzz = fuzz_accumulator
         return patch
 
@@ -419,8 +420,8 @@ class PatchCoder(Coder):
         total_fuzz = 0
 
         while index < len(lines):
-            norm_line = _norm(lines[index])
-            # Check for terminators for *this* file update
+            line = lines[index]
+            norm_line = _norm(line)
             if norm_line.startswith(
                 (
                     "*** End Patch",
@@ -432,17 +433,14 @@ class PatchCoder(Coder):
                 break  # End of this file's update section
 
             # Handle @@ scope lines (optional)
-            scope_lines = []
+            scope_lines: List[str] = []
             while index < len(lines) and _norm(lines[index]).startswith("@@"):
                 scope_line_content = lines[index][len("@@") :].strip()
                 if scope_line_content:  # Ignore empty @@ lines?
                     scope_lines.append(scope_line_content)
                 index += 1
 
-            # Find the scope in the original file if specified
             if scope_lines:
-                # Simple scope finding: search from current position
-                # A more robust finder could handle nested scopes like the reference @@ @@
                 found_scope = False
                 temp_index = current_file_index
                 while temp_index < len(orig_lines):
@@ -469,7 +467,8 @@ class PatchCoder(Coder):
                         for i, scope in enumerate(scope_lines):
                             if (
                                 temp_index + i >= len(orig_lines)
-                                or _norm(orig_lines[temp_index + i]).strip() != scope.strip()
+                                or _norm(orig_lines[temp_index + i]).strip()
+                                != scope.strip()
                             ):
                                 match = False
                                 break
@@ -485,10 +484,14 @@ class PatchCoder(Coder):
                     raise DiffError(f"Could not find scope context:\n{scope_txt}")
 
             # Peek and parse the next context/change section
-            context_block, chunks_in_section, next_index, is_eof = peek_next_section(lines, index)
+            context_block, chunks_in_section, next_index, is_eof = peek_next_section(
+                lines, index
+            )
 
             # Find where this context block appears in the original file
-            found_index, fuzz = find_context(orig_lines, context_block, current_file_index, is_eof)
+            found_index, fuzz = find_context(
+                orig_lines, context_block, current_file_index, is_eof
+            )
             total_fuzz += fuzz
 
             if found_index == -1:
@@ -513,7 +516,9 @@ class PatchCoder(Coder):
 
         return action, index, total_fuzz
 
-    def _parse_add_file_content(self, lines: List[str], index: int) -> Tuple[PatchAction, int]:
+    def _parse_add_file_content(
+        self, lines: List[str], index: int
+    ) -> Tuple[PatchAction, int]:
         """Parses the content (+) lines for an Add File action."""
         added_lines: List[str] = []
         while index < len(lines):
@@ -546,15 +551,13 @@ class PatchCoder(Coder):
         action = PatchAction(type=ActionType.ADD, path="", new_content="\n".join(added_lines))
         return action, index
 
-    def apply_edits(self, edits: List[PatchAction]):
+    def apply_edits(self, edits: List[EditResult]):
         """
         Applies the parsed PatchActions to the corresponding files.
         """
         if not edits:
             return
 
-        # Group edits by original path? Not strictly needed if processed sequentially.
-
         # Edits are now List[Tuple[str, PatchAction]]
         for _path_tuple_element, action in edits:
             # action is the PatchAction object
@@ -568,10 +571,9 @@ class PatchCoder(Coder):
                     if path_obj.exists():
                         raise DiffError(f"ADD Error: File already exists: {action.path}")
                     if action.new_content is None:
-                        # Parser should ensure this doesn't happen
                         raise DiffError(f"ADD change for {action.path} has no content")
-
                     self.io.tool_output(f"Adding {action.path}")
+                    # Ensure parent directory exists
                     path_obj.parent.mkdir(parents=True, exist_ok=True)
                     # Ensure single trailing newline, matching reference behavior
                     content_to_write = action.new_content
@@ -601,7 +603,9 @@ class PatchCoder(Coder):
                     new_content = self._apply_update(current_content, action, action.path)
 
                     target_full_path = (
-                        self.abs_root_path(action.move_path) if action.move_path else full_path
+                        self.abs_root_path(action.move_path)
+                        if action.move_path
+                        else full_path
                     )
                     target_path_obj = pathlib.Path(target_full_path)
 
@@ -622,7 +626,7 @@ class PatchCoder(Coder):
                     target_path_obj.parent.mkdir(parents=True, exist_ok=True)
                     self.io.write_text(target_full_path, new_content)
 
-                    # Remove original file *after* successful write to new location if moved
+                    # Remove original file after successful write to new location if moved
                     if action.move_path and full_path != target_full_path:
                         path_obj.unlink()
 
@@ -641,7 +645,6 @@ class PatchCoder(Coder):
 
     def _apply_update(self, text: str, action: PatchAction, path: str) -> str:
         """
-        Applies UPDATE chunks to the given text content.
         Adapted from _get_updated_file in apply_patch.py.
         """
         if action.type is not ActionType.UPDATE:
@@ -656,8 +659,6 @@ class PatchCoder(Coder):
         sorted_chunks = sorted(action.chunks, key=lambda c: c.orig_index)
 
         for chunk in sorted_chunks:
-            # chunk.orig_index is the absolute line number where the change starts
-            # (where the first deleted line was, or where inserted lines go if no deletes)
             chunk_start_index = chunk.orig_index
 
             if chunk_start_index < current_orig_line_idx:
