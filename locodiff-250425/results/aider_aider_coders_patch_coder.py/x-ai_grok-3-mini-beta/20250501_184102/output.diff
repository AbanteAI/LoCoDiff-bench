--- aider_aider_coders_patch_coder.py_expectedoutput.txt (expected)+++ aider_aider_coders_patch_coder.py_extracted.txt (actual)@@ -7,9 +7,9 @@ from .patch_prompts import PatchPrompts
 
 
-# --------------------------------------------------------------------------- #
+# ---------------------------------------------------------------------------
 #  Domain objects & Exceptions (Adapted from apply_patch.py)
-# --------------------------------------------------------------------------- #
+# ---------------------------------------------------------------------------
 class DiffError(ValueError):
     """Any problem detected while parsing or applying a patch."""
 
@@ -48,9 +48,9 @@     fuzz: int = 0  # Track fuzziness used during parsing
 
 
-# --------------------------------------------------------------------------- #
+# ---------------------------------------------------------------------------
 #  Helper functions (Adapted from apply_patch.py)
-# --------------------------------------------------------------------------- #
+# ---------------------------------------------------------------------------
 def _norm(line: str) -> str:
     """Strip CR so comparisons work for both LF and CRLF input."""
     return line.rstrip("\r")
@@ -152,7 +152,6 @@             if del_lines or ins_lines:
                 chunks.append(
                     Chunk(
-                        # orig_index is relative to the start of the *context* block found
                         orig_index=len(context_lines) - len(del_lines),
                         del_lines=del_lines,
                         ins_lines=ins_lines,
@@ -204,9 +203,9 @@     return list(paths)
 
 
-# --------------------------------------------------------------------------- #
+# ---------------------------------------------------------------------------
 #  PatchCoder Class Implementation
-# --------------------------------------------------------------------------- #
+# ---------------------------------------------------------------------------
 class PatchCoder(Coder):
     """
     A coder that uses a custom patch format for code modifications,
@@ -381,8 +380,6 @@                 index += 1
                 if not path:
                     raise DiffError("Add File action missing path.")
-                if path in patch.actions:
-                    raise DiffError(f"Duplicate action for file: {path}")
                 # Check if file exists in the context provided (should not for Add).
                 # Note: We only have needed files, a full check requires FS access.
                 # if path in current_files:
@@ -400,11 +397,6 @@                 continue
 
             raise DiffError(f"Unknown or misplaced line while parsing patch: {line}")
-
-        # Check if we consumed the whole input or stopped early
-        # Tolerate missing "*** End Patch" if we processed actions
-        # if index < len(lines) and _norm(lines[index-1]) != "*** End Patch":
-        #    raise DiffError("Patch parsing finished unexpectedly before end of input.")
 
         patch.fuzz = fuzz_accumulator
         return patch
@@ -439,10 +431,8 @@                     scope_lines.append(scope_line_content)
                 index += 1
 
-            # Find the scope in the original file if specified
             if scope_lines:
                 # Simple scope finding: search from current position
-                # A more robust finder could handle nested scopes like the reference @@ @@
                 found_scope = False
                 temp_index = current_file_index
                 while temp_index < len(orig_lines):
@@ -465,7 +455,8 @@                     # Try fuzzy scope matching (strip whitespace)
                     temp_index = current_file_index
                     while temp_index < len(orig_lines):
-                        match = True
+
+match = True
                         for i, scope in enumerate(scope_lines):
                             if (
                                 temp_index + i >= len(orig_lines)
@@ -530,7 +521,6 @@             ):
                 break
 
-            # Expect lines to start with '+'
             if not line.startswith("+"):
                 # Tolerate blank lines? Or require '+'? Reference implies '+' required.
                 if norm_line.strip() == "":
@@ -546,16 +536,16 @@         action = PatchAction(type=ActionType.ADD, path="", new_content="\n".join(added_lines))
         return action, index
 
-    def apply_edits(self, edits: List[PatchAction]):
-        """
-        Applies the parsed PatchActions to the corresponding files.
+    def apply_edits(self, edits: List[EditResult]):
+        """
+        Applies the parsed edits to the corresponding files.
+        Edits is a list of tuples: (path, PatchAction)
         """
         if not edits:
             return
 
         # Group edits by original path? Not strictly needed if processed sequentially.
 
-        # Edits are now List[Tuple[str, PatchAction]]
         for _path_tuple_element, action in edits:
             # action is the PatchAction object
             # action.path is the canonical path within the action logic
