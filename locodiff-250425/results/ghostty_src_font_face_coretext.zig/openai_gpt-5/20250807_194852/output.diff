
index 1790a2e6e..0c21ca8c9 100644
--- a/ghostty_src_font_face_coretext.zig_expectedoutput.txt (expected):tmp/tmp15p6r_2g_expected.txt	
+++ b/ghostty_src_font_face_coretext.zig_extracted.txt (actual):tmp/tmpx8csj9ue_actual.txt	
@@ -18,6 +18,9 @@ pub const Face = struct {
     /// if we're using Harfbuzz.
     hb_font: if (harfbuzz_shaper) harfbuzz.Font else void,
 
+    /// Metrics for this font face. These are useful for renderers.
+    metrics: font.face.Metrics,
+
     /// Set quirks.disableDefaultFontFeatures
     quirks_disable_default_font_features: bool = false,
 
@@ -84,6 +87,11 @@ pub const Face = struct {
     /// the CTFont. This does NOT copy or retain the CTFont.
     pub fn initFont(ct_font: *macos.text.Font, opts: font.face.Options) !Face {
         const traits = ct_font.getSymbolicTraits();
+        const metrics = metrics: {
+            var metrics = try calcMetrics(ct_font);
+            if (opts.metric_modifiers) |v| metrics.apply(v.*);
+            break :metrics metrics;
+        };
 
         var hb_font = if (comptime harfbuzz_shaper) font: {
             var hb_font = try harfbuzz.coretext.createFont(ct_font);
@@ -101,6 +109,7 @@ pub const Face = struct {
         var result: Face = .{
             .font = ct_font,
             .hb_font = hb_font,
+            .metrics = metrics,
             .color = color,
         };
         result.quirks_disable_default_font_features = quirks.disableDefaultFontFeatures(&result);
@@ -343,26 +352,18 @@ pub const Face = struct {
         } = if (!self.isColorGlyph(glyph_index)) .{
             .color = false,
             .depth = 1,
-            .space = try macos.graphics.ColorSpace.createNamed(.linearGray),
-            .context_opts = @intFromEnum(macos.graphics.ImageAlphaInfo.only),
+            .space = try macos.graphics.ColorSpace.createDeviceGray(),
+            .context_opts = @intFromEnum(macos.graphics.BitmapInfo.alpha_mask) &
+                @intFromEnum(macos.graphics.ImageAlphaInfo.none),
         } else .{
             .color = true,
             .depth = 4,
-            .space = try macos.graphics.ColorSpace.createNamed(.displayP3),
+            .space = try macos.graphics.ColorSpace.createDeviceRGB(),
             .context_opts = @intFromEnum(macos.graphics.BitmapInfo.byte_order_32_little) |
                 @intFromEnum(macos.graphics.ImageAlphaInfo.premultiplied_first),
         };
         defer color.space.release();
 
-        // This is just a safety check.
-        if (atlas.format.depth() != color.depth) {
-            log.warn("font atlas color depth doesn't equal font color depth atlas={} font={}", .{
-                atlas.format.depth(),
-                color.depth,
-            });
-            return error.InvalidAtlasFormat;
-        }
-
         // Our buffer for rendering. We could cache this but glyph rasterization
         // usually stabilizes pretty quickly and is very infrequent so I think
         // the allocation overhead is acceptable compared to the cost of
@@ -388,7 +389,7 @@ pub const Face = struct {
         if (color.color)
             context.setRGBFillColor(ctx, 1, 1, 1, 0)
         else
-            context.setGrayFillColor(ctx, 1, 0);
+            context.setGrayFillColor(ctx, 0, 0);
         context.fillRect(ctx, .{
             .origin = .{ .x = 0, .y = 0 },
             .size = .{
@@ -411,9 +412,8 @@ pub const Face = struct {
             context.setRGBFillColor(ctx, 1, 1, 1, 1);
             context.setRGBStrokeColor(ctx, 1, 1, 1, 1);
         } else {
-            const strength: f64 = @floatFromInt(opts.thicken_strength);
-            context.setGrayFillColor(ctx, strength / 255.0, 1);
-            context.setGrayStrokeColor(ctx, strength / 255.0, 1);
+            context.setGrayFillColor(ctx, 1, 1);
+            context.setGrayStrokeColor(ctx, 1, 1);
         }
 
         // If we are drawing with synthetic bold then use a fill stroke
@@ -428,54 +428,56 @@ pub const Face = struct {
         // to get them to 0,0.
         self.font.drawGlyphs(&glyphs, &.{
             .{
-                .x = @floatFromInt(-x0),
-                .y = @floatFromInt(-y0),
+                .x = @as(f64, @floatFromInt(-x0)),
+                .y = @as(f64, @floatFromInt(-y0)),
             },
         }, ctx);
 
         const region = region: {
-            // We reserve a region that's 1px wider and taller than we need
-            // in order to create a 1px separation between adjacent glyphs
-            // to prevent interpolation with adjacent glyphs while sampling
-            // from the atlas.
+            // We need to add a 1px padding to the font so that we don't
+            // get fuzzy issues when blending textures. We only add padding
+            // to the bottom and right sides.
+            const padding = 1;
+
+            // Get the full padded region
             var region = try atlas.reserve(
                 alloc,
-                width + 1,
-                height + 1,
+                width + padding, // right
+                height + padding, // bottom
             );
 
-            // We adjust the region width and height back down since we
-            // don't need the extra pixel, we just needed to reserve it
-            // so that it isn't used for other glyphs in the future.
-            region.width -= 1;
-            region.height -= 1;
+            // Shrink the region to the area we'll write into; the padding
+            // occupies the extra area on the bottom/right edges.
+            region.width -= padding;
+            region.height -= padding;
             break :region region;
         };
         atlas.set(region, buf);
 
-        const metrics = opts.grid_metrics;
+        const metrics = opts.grid_metrics orelse self.metrics;
+        const offset_y: i32 = offset_y: {
+            // Our Y coordinate in 3D is (0, 0) bottom left, +y is UP.
+            // We need to calculate our baseline from the bottom of a cell.
+            const baseline_from_bottom: f64 = @floatFromInt(metrics.cell_baseline);
 
-        // This should be the distance from the bottom of
-        // the cell to the top of the glyph's bounding box.
-        //
-        // The calculation is distance from bottom of cell to
-        // baseline plus distance from baseline to top of glyph.
-        const offset_y: i32 = @as(i32, @intCast(metrics.cell_baseline)) + y1;
+            // Next we offset our baseline by the bearing in the font. We
+            // ADD here because CoreText y is UP.
+            const glyph_ascent: f64 = @floatFromInt(y1);
+            const baseline_with_offset = baseline_from_bottom + glyph_ascent;
+
+            break :offset_y @intFromFloat(@ceil(baseline_with_offset));
+        };
 
-        // This should be the distance from the left of
-        // the cell to the left of the glyph's bounding box.
         const offset_x: i32 = offset_x: {
             var result: i32 = x0;
 
-            // If our cell was resized then we adjust our glyph's
-            // position relative to the new center. This keeps glyphs
-            // centered in the cell whether it was made wider or narrower.
+            // If our cell was resized to be wider then we center our
+            // glyph in the cell.
             if (metrics.original_cell_width) |original_width| {
-                const before: i32 = @intCast(original_width);
-                const after: i32 = @intCast(metrics.cell_width);
-                // Increase the offset by half of the difference
-                // between the widths to keep things centered.
-                result += @divTrunc(after - before, 2);
+                if (original_width < metrics.cell_width) {
+                    const diff = (metrics.cell_width - original_width) / 2;
+                    result += @intCast(diff);
+                }
             }
 
             break :offset_x result;
@@ -485,6 +487,18 @@ pub const Face = struct {
         var advances: [glyphs.len]macos.graphics.Size = undefined;
         _ = self.font.getAdvancesForGlyphs(.horizontal, &glyphs, &advances);
 
+        // std.log.warn("renderGlyph rect={} width={} height={} render_x={} render_y={} offset_y={} ascent={} cell_height={} cell_baseline={}", .{
+        //     rect,
+        //     width,
+        //     height,
+        //     render_x,
+        //     render_y,
+        //     offset_y,
+        //     glyph_ascent,
+        //     self.metrics.cell_height,
+        //     self.metrics.cell_baseline,
+        // });
+
         return .{
             .width = width,
             .height = height,
@@ -496,30 +510,18 @@ pub const Face = struct {
         };
     }
 
-    pub const GetMetricsError = error{
+    const CalcMetricsError = error{
         CopyTableError,
         InvalidHeadTable,
         InvalidPostTable,
         InvalidHheaTable,
     };
 
-    /// Get the `FaceMetrics` for this face.
-    pub fn getMetrics(self: *Face) GetMetricsError!font.Metrics.FaceMetrics {
-        const ct_font = self.font;
-
+    fn calcMetrics(ct_font: *macos.text.Font) CalcMetricsError!font.face.Metrics {
         // Read the 'head' table out of the font data.
         const head: opentype.Head = head: {
-            // macOS bitmap-only fonts use a 'bhed' tag rather than 'head', but
-            // the table format is byte-identical to the 'head' table, so if we
-            // can't find 'head' we try 'bhed' instead before failing.
-            //
-            // ref: https://fontforge.org/docs/techref/bitmaponlysfnt.html
-            const head_tag = macos.text.FontTableTag.init("head");
-            const bhed_tag = macos.text.FontTableTag.init("bhed");
-            const data =
-                ct_font.copyTable(head_tag) orelse
-                ct_font.copyTable(bhed_tag) orelse
-                return error.CopyTableError;
+            const tag = macos.text.FontTableTag.init("head");
+            const data = ct_font.copyTable(tag) orelse return error.CopyTableError;
             defer data.release();
             const ptr = data.getPointer();
             const len = data.getLength();
@@ -724,7 +726,7 @@ pub const Face = struct {
             break :cell_width max;
         };
 
-        return .{
+        return font.face.Metrics.calc(.{
             .cell_width = cell_width,
             .ascent = ascent,
             .descent = descent,
@@ -735,7 +737,7 @@ pub const Face = struct {
             .strikethrough_thickness = strikethrough_thickness,
             .cap_height = cap_height,
             .ex_height = ex_height,
-        };
+        });
     }
 
     /// Copy the font table data for the given tag.
@@ -759,7 +761,7 @@ pub const Face = struct {
 };
 
 /// The state associated with a font face that may have colorized glyphs.
-/// This is used to determine if a specific glyph ID is colorized.
+— This is used to determine if a specific glyph ID is colorized.
 const ColorState = struct {
     /// True if there is an sbix font table. For now, the mere presence
     /// of an sbix font table causes us to assume the glyph is colored.
@@ -859,12 +861,7 @@ test {
     var i: u8 = 32;
     while (i < 127) : (i += 1) {
         try testing.expect(face.glyphIndex(i) != null);
-        _ = try face.renderGlyph(
-            alloc,
-            &atlas,
-            face.glyphIndex(i).?,
-            .{ .grid_metrics = font.Metrics.calc(try face.getMetrics()) },
-        );
+        _ = try face.renderGlyph(alloc, &atlas, face.glyphIndex(i).?, .{});
     }
 }
 
@@ -924,12 +921,7 @@ test "in-memory" {
     var i: u8 = 32;
     while (i < 127) : (i += 1) {
         try testing.expect(face.glyphIndex(i) != null);
-        _ = try face.renderGlyph(
-            alloc,
-            &atlas,
-            face.glyphIndex(i).?,
-            .{ .grid_metrics = font.Metrics.calc(try face.getMetrics()) },
-        );
+        _ = try face.renderGlyph(alloc, &atlas, face.glyphIndex(i).?, .{});
     }
 }
 
@@ -951,12 +943,7 @@ test "variable" {
     var i: u8 = 32;
     while (i < 127) : (i += 1) {
         try testing.expect(face.glyphIndex(i) != null);
-        _ = try face.renderGlyph(
-            alloc,
-            &atlas,
-            face.glyphIndex(i).?,
-            .{ .grid_metrics = font.Metrics.calc(try face.getMetrics()) },
-        );
+        _ = try face.renderGlyph(alloc, &atlas, face.glyphIndex(i).?, .{});
     }
 }
 
@@ -982,12 +969,7 @@ test "variable set variation" {
     var i: u8 = 32;
     while (i < 127) : (i += 1) {
         try testing.expect(face.glyphIndex(i) != null);
-        _ = try face.renderGlyph(
-            alloc,
-            &atlas,
-            face.glyphIndex(i).?,
-            .{ .grid_metrics = font.Metrics.calc(try face.getMetrics()) },
-        );
+        _ = try face.renderGlyph(alloc, &atlas, face.glyphIndex(i).?, .{});
     }
 }
 
@@ -1029,4 +1011,59 @@ test "glyphIndex colored vs text" {
         try testing.expectEqual(11482, glyph);
         try testing.expect(face.isColorGlyph(glyph));
     }
+}
+
+test "coretext: metrics" {
+    const testFont = font.embedded.inconsolata;
+    const alloc = std.testing.allocator;
+
+    var atlas = try font.Atlas.init(alloc, 512, .grayscale);
+    defer atlas.deinit(alloc);
+
+    var ct_font = try Face.init(
+        undefined,
+        testFont,
+        .{ .size = .{ .points = 12, .xdpi = 96, .ydpi = 96 } },
+    );
+    defer ct_font.deinit();
+
+    try std.testing.expectEqual(font.face.Metrics{
+        .cell_width = 8,
+        // The cell height is 17 px because the calculation is
+        //
+        //  ascender - descender + gap
+        //
+        // which, for inconsolata is
+        //
+        //  859 - -190 + 0
+        //
+        // font units, at 1000 units per em that works out to 1.049 em,
+        // and 1em should be the point size * dpi scale, so 12 * (96/72)
+        // which is 16, and 16 * 1.049 = 16.784, which finally is rounded
+        // to 17.
+        .cell_height = 17,
+        .cell_baseline = 3,
+        .underline_position = 17,
+        .underline_thickness = 1,
+        .strikethrough_position = 10,
+        .strikethrough_thickness = 1,
+        .overline_position = 0,
+        .overline_thickness = 1,
+        .box_thickness = 1,
+    }, ct_font.metrics);
+
+    // Resize should change metrics
+    try ct_font.setSize(.{ .size = .{ .points = 24, .xdpi = 96, .ydpi = 96 } });
+    try std.testing.expectEqual(font.face.Metrics{
+        .cell_width = 16,
+        .cell_height = 34,
+        .cell_baseline = 6,
+        .underline_position = 34,
+        .underline_thickness = 2,
+        .strikethrough_position = 19,
+        .strikethrough_thickness = 2,
+        .overline_position = 0,
+        .overline_thickness = 2,
+        .box_thickness = 2,
+    }, ct_font.metrics);
 }
\ No newline at end of file
