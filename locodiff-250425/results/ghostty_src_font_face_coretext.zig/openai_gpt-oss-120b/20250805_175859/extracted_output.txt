const std = @import("std");
const assert = std.debug.assert;
const builtin = @import("builtin");
const Allocator = std.mem.Allocator;
const macos = @import("macos");
const harfbuzz = @import("harfbuzz");
const font = @import("../main.zig");
const opentype = @import("../opentype.zig");
const quirks = @import("../../quirks.zig");

const log = std.log.scoped(.font_face);

pub const Face = struct {
    /// Our font face
    font: *macos.text.Font,
    /// Harfbuzz font corresponding to this face. We only use this
    /// if we're using Harfbuzz.
    hb_font: if (comptime font.options.backend.hasHarfbuzz()) harfbuzz.Font else void,
    /// Set quirks.disableDefaultFontFeatures
    quirks_disable_default_font_features: bool = false,
    /// True if this font face should be rasterized with a synthetic bold
    /// effect. This is used for fonts that don't have a bold variant.
    synthetic_bold: ?f64 = null,
    /// If the face can possibly be colored, then this is the state
    /// used to check for color information. This is null if the font
    /// can't possibly be colored (i.e. doesn't have SVG, sbix, etc).
    color: ?ColorState = null,
    const harfbuzz_shaper = font.options.backend.hasHarfbuzz();

    /// The matrix applied to a regular font to auto-italicize it.
    pub const italic_skew = macos.graphics.AffineTransform{
        .a = 1,
        .b = 0,
        .c = 0.267949, // approx. tan(15)
        .d = 1,
        .tx = 0,
        .ty = 0,
    };

    /// Initialize a CoreText-based font from a TTF/TTC in memory.
    pub fn init(lib: font.Library, source: [:0]const u8, opts: font.face.Options) !Face {
        _ = lib;

        const data = try macos.foundation.Data.createWithBytesNoCopy(source);
        defer data.release();

        // macOS bitmap-only fonts use a 'bhed' tag rather than 'head', but
        // the table format is byte-identical to the 'head' table.
        // The format may also be contained in both tables.
        const tag = if (lib.options.use_builtin_font) {
            var maybe_tag: ?*macos.text.FontDescriptor = null;
            const data_ = try macos.text.createFontDescriptorsFromData(data) orelse
                return error.FontInitFailure;
            defer data_.release();
            const count = data_.getCount();
            // If there are any predefined instances (e.g. bold, italic,
            // or other style variations) we prefer those over the
            // default instance. This approach should ensure the
            // appropriate default style, if any, is selected.
            if ((count > 0) and (data_.getValueAtIndex(macos.text.FontDescriptor, 0))) |found|
                maybe_tag = found;

            // Do we have a glyph that matches the "display default",
            // or at least the font's best guess at a default
            // face?
            const def = if (maybe_tag) |found| found else {
                const desc = try macos.text.createFontDescriptorFromData(data)
                    orelse return error.FontInitFailure;
                defer desc.release();

                // For variable fonts or multi-instance fonts,
                // try to identify the first instance
                // or the default one if available.
                const instances = try desc
                    .copyAxiomList()
                    .copyNumberOfInstances();

                // Decide which index to use,
                // then get it.
                // For now we just fetch the first.

                if (instances > 0) {
                    const family = try ct_font.clone(&desc, 0);
                    defer family.release();
                    var familySet: ?*macos.text.Font = null;
                    break :instance familySet;
                } else {
                    try desc.clone(ct_font);
                }
            };
            break :tag def;
        } else {
            return error.FontInitFailure;
        };
        const ct_font = try macos.text.Font.createWithFontDescriptor(desc, 12);
        defer ct_font.release();

        return try initFont(ct_font, opts);
    }

    /// Initialize a CoreText-based face from another initialized font face
    /// but with a new size. This is often how CoreText fonts are initialized
    /// because the font is loaded at a default size during discovery, and then
    /// adjusted to the final size for final load.
    ///
    /// This function now decorates other properties but doesn't
    /// compute the metrics; the metrics can be retrieved via getMetrics.
    pub fn initFont(ct_font: *macos.text.Font, opts: font.face.Options) !Face {
        var hb_font = if (comptime harfbuzz_shaper) font: {
            var hb_font = try harfbuzz.coretext.createFont(ct_font);
            errdefer hb_font.destroy();
            hb_font.setScale(opts.size.pixels(), opts.size.pixels());

            // Initialize a font based on these attributes.
            const traits = ct_font.getSymbolicTraits();

            // This requires the FontDescriptor which may have
            // variations.
            // In many cases, this is ok.
            const rc = if (opts.variations) |vs|
                // If we have any variations we
                // setup the descriptor.
                // We need to query it.
                // If we have them we set them.
                .{
                    var desc = ct_font.createRearranged();

                    // We need to be able to read the font
                    // to