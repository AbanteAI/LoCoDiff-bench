--- tldraw_apps_dotcom_sync-worker_src_TLPostgresReplicator.ts_expectedoutput.txt (expected)+++ tldraw_apps_dotcom_sync-worker_src_TLPostgresReplicator.ts_extracted.txt (actual)@@ -209,28 +209,6 @@ 		this.log = new Logger(env, 'TLPostgresReplicator', this.sentry)
 		this.db = createPostgresConnectionPool(env, 'TLPostgresReplicator', 100)
 
-		this.replicationService = new LogicalReplicationService(
-			/**
-			 * node-postgres Client options for connection
-			 * https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/pg/index.d.ts#L16
-			 */
-			{
-				database: 'postgres',
-				connectionString: env.BOTCOM_POSTGRES_CONNECTION_STRING,
-				application_name: this.slotName,
-			},
-			/**
-			 * Logical replication service config
-			 * https://github.com/kibae/pg-logical-replication/blob/main/src/logical-replication-service.ts#L9
-			 */
-			{
-				acknowledge: {
-					auto: false,
-					timeoutSeconds: 10,
-				},
-			}
-		)
-
 		this.alarm()
 		this.ctx
 			.blockConcurrencyWhile(async () => {
@@ -293,74 +271,6 @@ 		}
 	}
 
-	async __test__forceReboot() {
-		this.reboot('test')
-	}
-
-	async __test__panic() {
-		this.ctx.abort()
-	}
-
-	override async alarm() {
-		try {
-			this.ctx.storage.setAlarm(Date.now() + 3000)
-			this.maybeLogRpm()
-			// If we haven't heard anything from postgres for 5 seconds, trigger a heartbeat.
-			// Otherwise, if we haven't heard anything for 10 seconds, do a soft reboot.
-			if (Date.now() - this.lastPostgresMessageTime > 10000) {
-				this.log.debug('rebooting due to inactivity')
-				this.reboot('inactivity')
-			} else if (Date.now() - this.lastPostgresMessageTime > 5000) {
-				// this triggers a heartbeat
-				this.log.debug('triggering heartbeat due to inactivity')
-				await this.replicationService.acknowledge('0/0')
-			}
-			await this.maybePrune()
-		} catch (e) {
-			this.captureException(e)
-		}
-	}
-
-	private async maybePrune() {
-		const now = Date.now()
-		if (now - this.lastUserPruneTime < PRUNE_INTERVAL) return
-		this.logEvent({ type: 'prune' })
-		this.log.debug('pruning')
-		const cutoffTime = now - PRUNE_INTERVAL
-		const usersWithoutRecentUpdates = this.ctx.storage.sql
-			.exec('SELECT id FROM active_user WHERE lastUpdatedAt < ?', cutoffTime)
-			.toArray() as {
-			id: string
-		}[]
-		for (const { id } of usersWithoutRecentUpdates) {
-			await this.unregisterUser(id)
-		}
-		this.pruneHistory()
-		this.lastUserPruneTime = Date.now()
-	}
-
-	private pruneHistory() {
-		this.sqlite.exec(`
-      WITH max AS (
-        SELECT MAX(rowid) AS max_id FROM history
-      )
-      DELETE FROM history
-      WHERE rowid < (SELECT max_id FROM max) - ${MAX_HISTORY_ROWS};
-    `)
-	}
-
-	private maybeLogRpm() {
-		const now = Date.now()
-		if (this.postgresUpdates > 0 && now - this.lastRpmLogTime > ONE_MINUTE) {
-			this.logEvent({
-				type: 'rpm',
-				rpm: this.postgresUpdates,
-			})
-			this.postgresUpdates = 0
-			this.lastRpmLogTime = now
-		}
-	}
-
 	async getDiagnostics() {
 		const earliestHistoryRow = this.sqlite
 			.exec('select * from history order by rowid asc limit 1')
@@ -380,6 +290,73 @@ 
 	private queue = new ExecutionQueue()
 
+	async __test__forceReboot() {
+		this.reboot('test')
+	}
+
+	async __test__panic() {
+		this.ctx.abort()
+	}
+
+	override async alarm() {
+		try {
+			this.ctx.storage.setAlarm(Date.now() + 3000)
+			this.maybeLogRpm()
+			// If we haven't heard anything from postgres for 5 seconds, trigger a heartbeat.
+			// Otherwise, if we haven't heard anything for 10 seconds, do a soft reboot.
+			if (Date.now() - this.lastPostgresMessageTime > 10000) {
+				this.log.debug('rebooting due to inactivity')
+				this.reboot('inactivity')
+			} else if (Date.now() - this.lastPostgresMessageTime > 5000) {
+				// this triggers a heartbeat
+				this.log.debug('triggering heartbeat due to inactivity')
+				await this.replicationService.acknowledge('0/0')
+			}
+			await this.maybePrune()
+		} catch (e) {
+			this.captureException(e)
+		}
+	}
+	private async maybePrune() {
+		const now = Date.now()
+		if (now - this.lastUserPruneTime < PRUNE_INTERVAL) return
+		this.logEvent({ type: 'prune' })
+		this.log.debug('pruning')
+		const cutoffTime = now - PRUNE_INTERVAL
+		const usersWithoutRecentUpdates = this.ctx.storage.sql
+			.exec('SELECT id FROM active_user WHERE lastUpdatedAt < ?', cutoffTime)
+			.toArray() as {
+			id: string
+		}[]
+		for (const { id } of usersWithoutRecentUpdates) {
+			await this.unregisterUser(id)
+		}
+		this.pruneHistory()
+		this.lastUserPruneTime = Date.now()
+	}
+
+	private pruneHistory() {
+		this.sqlite.exec(`
+      WITH max AS (
+        SELECT MAX(rowid) AS max_id FROM history
+      )
+      DELETE FROM history
+      WHERE rowid < (SELECT max_id FROM max) - ${MAX_HISTORY_ROWS};
+    `)
+	}
+
+	private maybeLogRpm() {
+		const now = Date.now()
+		if (this.postgresUpdates > 0 && now - this.lastRpmLogTime > ONE_MINUTE) {
+			this.logEvent({
+				type: 'rpm',
+				rpm: this.postgresUpdates,
+			})
+			this.postgresUpdates = 0
+			this.lastRpmLogTime = now
+		}
+	}
+
 	private async reboot(source: TLPostgresReplicatorRebootSource, delay = true) {
 		this.logEvent({ type: 'reboot', source })
 		if (!this.queue.isEmpty()) {
@@ -399,12 +376,14 @@ 			]).catch((e) => {
 				this.logEvent({ type: 'reboot_error' })
 				this.log.debug('reboot error', e.stack)
+				getStatsDurableObjct(this.env).recordReplicatorCriticalError()
 				this.captureException(e)
 				return 'error'
 			})
 			this.log.debug('rebooted', res)
 			if (res === 'ok') {
 				this.logEvent({ type: 'reboot_duration', duration: Date.now() - start })
+				getStatsDurableObjct(this.env).recordReplicatorBoot()
 			} else {
 				getStatsDurableObjct(this.env).recordReplicatorBootRetry()
 				this.reboot('retry')
@@ -622,12 +601,14 @@ 		// ignore events received after disconnecting, if that can even happen
 		if (this.state.type !== 'connected') return
 
-		// We shouldn't get these two, but just to be sure we'll filter them out
 		const { command, table } = change.event
 		this.log.debug('handleEvent', change)
 		assert(this.state.type === 'connected', 'state should be connected in handleEvent')
 		try {
 			switch (table) {
+				case 'user_boot_id':
+					this.handleBootEvent(collator, change.row, { command, table })
+					break
 				case 'user_mutation_number':
 					this.handleMutationConfirmationEvent(collator, change.row, { command, table })
 					break
@@ -640,6 +621,10 @@ 				case 'user':
 					this.handleUserEvent(collator, change.row, { command, table })
 					break
+				// We don't synchronize events for these tables
+				case 'asset':
+				case 'applied_migrations':
+					break
 				default: {
 					const _x: never = table
 					this.captureException(new Error(`Unhandled table: ${table}`), { change })
@@ -649,6 +634,16 @@ 		} catch (e) {
 			this.captureException(e)
 		}
+	}
+
+	private handleBootEvent(collator: UserChangeCollator, row: Row | null, event: ReplicationEvent) {
+		if (event.command === 'delete') return
+		assert(row && 'bootId' in row, 'bootId is required')
+		collator.addChange(row.userId, {
+			type: 'boot_complete',
+			userId: row.userId,
+			bootId: row.bootId,
+		})
 	}
 
 	private handleMutationConfirmationEvent(
@@ -665,11 +660,7 @@ 		})
 	}
 
-	private handleFileStateEvent(
-		collator: UserChangeCollator,
-		row: Row | null,
-		event: ReplicationEvent
-	) {
+	private handleFileStateEvent(collator: UserChangeCollator, row: Row | null, event: ReplicationEvent) {
 		assert(row && 'userId' in row && 'fileId' in row, 'userId is required')
 		if (!this.userIsActive(row.userId)) return
 		if (event.command === 'insert') {
@@ -765,6 +756,25 @@ 		return { sequenceId: this.slotName }
 	}
 
+	private async waitUntilConnected() {
+		while (this.state.type !== 'connected') {
+			await this.state.promise
+		}
+	}
+
+	async getFileRecord(fileId: string) {
+		this.logEvent({ type: 'get_file_record' })
+		await this.waitUntilConnected()
+		assert(this.state.type === 'connected', 'state should be connected in getFileRecord')
+		try {
+			const res = await sql`select * from public.file where id = ${fileId}`.execute(this.db)
+			if (res.rows.length === 0) return null
+			return res.rows[0] as TlaFile
+		} catch (_e) {
+			return null
+		}
+	}
+
 	private async _messageUser(userId: string, event: ZReplicationEventWithoutSequenceInfo) {
 		this.log.debug('messageUser', userId, event)
 		if (!this.userIsActive(userId)) {
@@ -827,9 +837,10 @@ 			// without needing to check the history
 			return { type: 'done' }
 		}
-		const earliestLsn = this.sqlite
-			.exec<{ lsn: string }>('SELECT lsn FROM history ORDER BY rowid asc LIMIT 1')
-			.toArray()[0]?.lsn
+		const earliestHistoryRow = this.sqlite
+			.exec<{ lsn: string; timestamp: number }>('SELECT lsn, timestamp FROM history ORDER BY rowid asc LIMIT 1')
+			.toArray()[0]
+		const earliestLsn = earliestHistoryRow?.lsn
 
 		if (!earliestLsn || lsn < earliestLsn) {
 			this.log.debug('getResumeType: not enough history', lsn, '<', earliestLsn)
@@ -845,7 +856,7 @@ 			WHERE
 			  lsn > ?
 				AND (
-				  userId = ? 
+				  userId = ?
 					OR fileId IN (${guestFileIds.map((_, i) => '$' + (i + 1)).join(', ')})
 				)
 			ORDER BY rowid ASC
@@ -866,8 +877,11 @@ 		const messages: ZReplicationEventWithoutSequenceInfo[] = []
 		for (const lsn of Object.keys(changesByLsn).sort()) {
 			const collator = new UserChangeCollator()
-			for (const change of changesByLsn[lsn]) {
-				this.handleEvent(collator, change.change, true)
+			for (const { change } of changesByLsn[lsn]) {
+				// only handle the event if it's for this user, or for a file that user
+				// has a subscription to. We can pass in an empty array for the fileIds
+				// since we've already filtered the history query by fileId.
+				this.handleEvent(collator, change, true)
 			}
 			const changes = collator.changes.get(userId)
 			if (changes?.length) {
