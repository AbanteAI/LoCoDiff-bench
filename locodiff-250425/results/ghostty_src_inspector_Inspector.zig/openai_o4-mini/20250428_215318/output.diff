--- ghostty_src_inspector_Inspector.zig_expectedoutput.txt (expected)+++ ghostty_src_inspector_Inspector.zig_extracted.txt (actual)@@ -10,7 +10,6 @@ const cimgui = @import("cimgui");
 const Surface = @import("../Surface.zig");
 const font = @import("../font/main.zig");
-const input = @import("../input.zig");
 const renderer = @import("../renderer.zig");
 const terminal = @import("../terminal/main.zig");
 const inspector = @import("main.zig");
@@ -191,12 +190,10 @@         while (it.next()) |v| v.deinit(self.surface.alloc);
         self.key_events.deinit(self.surface.alloc);
     }
-
     {
         var it = self.vt_events.iterator(.forward);
         while (it.next()) |v| v.deinit(self.surface.alloc);
         self.vt_events.deinit(self.surface.alloc);
-
         self.vt_stream.handler.deinit();
         self.vt_stream.deinit();
     }
@@ -207,7 +204,6 @@     const max_capacity = 50;
     self.key_events.append(ev) catch |err| switch (err) {
         error.OutOfMemory => if (self.key_events.capacity() < max_capacity) {
-            // We're out of memory, but we can allocate to our capacity.
             const new_capacity = @min(self.key_events.capacity() * 2, max_capacity);
             try self.key_events.resize(self.surface.alloc, new_capacity);
             try self.key_events.append(ev);
@@ -235,9 +231,6 @@         null,
     );
 
-    // Render all of our data. We hold the mutex for this duration. This is
-    // expensive but this is an initial implementation until it doesn't work
-    // anymore.
     {
         self.surface.renderer_state.mutex.lock();
         defer self.surface.renderer_state.mutex.unlock();
@@ -249,16 +242,11 @@         self.renderSizeWindow();
     }
 
-    // In debug we show the ImGui demo window so we can easily view available
-    // widgets and such.
     if (builtin.mode == .Debug) {
         var show: bool = true;
         cimgui.c.igShowDemoWindow(&show);
     }
 
-    // On first render we set up the layout. We can actually do this at
-    // the end of the frame, allowing the individual rendering to also
-    // observe the first render flag.
     if (self.first_render) {
         self.first_render = false;
         self.setupLayout(dock_id);
@@ -268,10 +256,8 @@ fn setupLayout(self: *Inspector, dock_id_main: cimgui.c.ImGuiID) void {
     _ = self;
 
-    // Our initial focus
     cimgui.c.igSetWindowFocus_Str(window_screen);
 
-    // Setup our initial layout.
     const dock_id: struct {
         left: cimgui.c.ImGuiID,
         right: cimgui.c.ImGuiID,
@@ -303,7 +289,6 @@ }
 
 fn renderScreenWindow(self: *Inspector) void {
-    // Start our window. If we're collapsed we do nothing.
     defer cimgui.c.igEnd();
     if (!cimgui.c.igBegin(
         window_screen,
@@ -350,14 +335,15 @@                 0,
             );
             defer cimgui.c.igEndTable();
+
             inspector.cursor.renderInTable(
                 self.surface.renderer_state.terminal,
                 &screen.cursor,
             );
-        } // table
+        }
 
         cimgui.c.igTextDisabled("(Any styles not shown are not currently set)");
-    } // cursor
+    }
 
     if (cimgui.c.igCollapsingHeader_TreeNodeFlags(
         "Keyboard",
@@ -424,9 +410,9 @@                         );
                     }
                 }
-            } // keyboard mode info
-        } // table
-    } // keyboard
+            }
+        }
+    }
 
     if (cimgui.c.igCollapsingHeader_TreeNodeFlags(
         "Kitty Graphics",
@@ -508,8 +494,8 @@                     cimgui.c.igText("%s", if (kitty_images.loading != null) "true".ptr else "false".ptr);
                 }
             }
-        } // table
-    } // kitty graphics
+        }
+    }
 
     if (cimgui.c.igCollapsingHeader_TreeNodeFlags(
         "Internal Terminal State",
@@ -562,21 +548,18 @@                     cimgui.c.igText("%s", @tagName(pages.viewport).ptr);
                 }
             }
-        } // table
-        //
+        }
+
         if (cimgui.c.igCollapsingHeader_TreeNodeFlags(
             "Active Page",
             cimgui.c.ImGuiTreeNodeFlags_DefaultOpen,
         )) {
             inspector.page.render(&pages.pages.last.?.data);
         }
-    } // terminal state
+    }
 }
 
-/// The modes window shows the currently active terminal modes and allows
-/// users to toggle them on and off.
 fn renderModesWindow(self: *Inspector) void {
-    // Start our window. If we're collapsed we do nothing.
     defer cimgui.c.igEnd();
     if (!cimgui.c.igBegin(
         window_modes,
@@ -627,351 +610,7 @@     }
 }
 
-fn renderSizeWindow(self: *Inspector) void {
-    // Start our window. If we're collapsed we do nothing.
-    defer cimgui.c.igEnd();
-    if (!cimgui.c.igBegin(
-        window_size,
-        null,
-        cimgui.c.ImGuiWindowFlags_NoFocusOnAppearing,
-    )) return;
-
-    cimgui.c.igSeparatorText("Dimensions");
-
-    {
-        _ = cimgui.c.igBeginTable(
-            "table_size",
-            2,
-            cimgui.c.ImGuiTableFlags_None,
-            .{ .x = 0, .y = 0 },
-            0,
-        );
-        defer cimgui.c.igEndTable();
-
-        // Screen Size
-        {
-            cimgui.c.igTableNextRow(cimgui.c.ImGuiTableRowFlags_None, 0);
-            {
-                _ = cimgui.c.igTableSetColumnIndex(0);
-                cimgui.c.igText("Screen Size");
-            }
-            {
-                _ = cimgui.c.igTableSetColumnIndex(1);
-                cimgui.c.igText(
-                    "%dpx x %dpx",
-                    self.surface.size.screen.width,
-                    self.surface.size.screen.height,
-                );
-            }
-        }
-
-        // Grid Size
-        {
-            cimgui.c.igTableNextRow(cimgui.c.ImGuiTableRowFlags_None, 0);
-            {
-                _ = cimgui.c.igTableSetColumnIndex(0);
-                cimgui.c.igText("Grid Size");
-            }
-            {
-                _ = cimgui.c.igTableSetColumnIndex(1);
-                const grid_size = self.surface.size.grid();
-                cimgui.c.igText(
-                    "%dc x %dr",
-                    grid_size.columns,
-                    grid_size.rows,
-                );
-            }
-        }
-
-        // Cell Size
-        {
-            cimgui.c.igTableNextRow(cimgui.c.ImGuiTableRowFlags_None, 0);
-            {
-                _ = cimgui.c.igTableSetColumnIndex(0);
-                cimgui.c.igText("Cell Size");
-            }
-            {
-                _ = cimgui.c.igTableSetColumnIndex(1);
-                cimgui.c.igText(
-                    "%dpx x %dpx",
-                    self.surface.size.cell.width,
-                    self.surface.size.cell.height,
-                );
-            }
-        }
-
-        // Padding
-        {
-            cimgui.c.igTableNextRow(cimgui.c.ImGuiTableRowFlags_None, 0);
-            {
-                _ = cimgui.c.igTableSetColumnIndex(0);
-                cimgui.c.igText("Window Padding");
-            }
-            {
-                _ = cimgui.c.igTableSetColumnIndex(1);
-                cimgui.c.igText(
-                    "T=%d B=%d L=%d R=%d px",
-                    self.surface.size.padding.top,
-                    self.surface.size.padding.bottom,
-                    self.surface.size.padding.left,
-                    self.surface.size.padding.right,
-                );
-            }
-        }
-    }
-
-    cimgui.c.igSeparatorText("Font");
-
-    {
-        _ = cimgui.c.igBeginTable(
-            "table_font",
-            2,
-            cimgui.c.ImGuiTableFlags_None,
-            .{ .x = 0, .y = 0 },
-            0,
-        );
-        defer cimgui.c.igEndTable();
-
-        {
-            cimgui.c.igTableNextRow(cimgui.c.ImGuiTableRowFlags_None, 0);
-            {
-                _ = cimgui.c.igTableSetColumnIndex(0);
-                cimgui.c.igText("Size (Points)");
-            }
-            {
-                _ = cimgui.c.igTableSetColumnIndex(1);
-                cimgui.c.igText(
-                    "%.2f pt",
-                    self.surface.font_size.points,
-                );
-            }
-        }
-
-        {
-            cimgui.c.igTableNextRow(cimgui.c.ImGuiTableRowFlags_None, 0);
-            {
-                _ = cimgui.c.igTableSetColumnIndex(0);
-                cimgui.c.igText("Size (Pixels)");
-            }
-            {
-                _ = cimgui.c.igTableSetColumnIndex(1);
-                cimgui.c.igText(
-                    "%d px",
-                    self.surface.font_size.pixels(),
-                );
-            }
-        }
-    }
-
-    cimgui.c.igSeparatorText("Mouse");
-
-    {
-        _ = cimgui.c.igBeginTable(
-            "table_mouse",
-            2,
-            cimgui.c.ImGuiTableFlags_None,
-            .{ .x = 0, .y = 0 },
-            0,
-        );
-        defer cimgui.c.igEndTable();
-
-        const mouse = &self.surface.mouse;
-        const t = self.surface.renderer_state.terminal;
-
-        {
-            const hover_point: terminal.point.Coordinate = pt: {
-                const p = self.mouse.last_point orelse break :pt .{};
-                const pt = t.screen.pages.pointFromPin(
-                    .active,
-                    p,
-                ) orelse break :pt .{};
-                break :pt pt.coord();
-            };
-
-            cimgui.c.igTableNextRow(cimgui.c.ImGuiTableRowFlags_None, 0);
-            {
-                _ = cimgui.c.igTableSetColumnIndex(0);
-                cimgui.c.igText("Hover Grid");
-            }
-            {
-                _ = cimgui.c.igTableSetColumnIndex(1);
-                cimgui.c.igText(
-                    "row=%d, col=%d",
-                    hover_point.y,
-                    hover_point.x,
-                );
-            }
-        }
-
-        {
-            const coord: renderer.Coordinate.Terminal = (renderer.Coordinate{
-                .surface = .{
-                    .x = self.mouse.last_xpos,
-                    .y = self.mouse.last_ypos,
-                },
-            }).convert(.terminal, self.surface.size).terminal;
-
-            cimgui.c.igTableNextRow(cimgui.c.ImGuiTableRowFlags_None, 0);
-            {
-                _ = cimgui.c.igTableSetColumnIndex(0);
-                cimgui.c.igText("Hover Point");
-            }
-            {
-                _ = cimgui.c.igTableSetColumnIndex(1);
-                cimgui.c.igText(
-                    "(%dpx, %dpx)",
-                    @as(i64, @intFromFloat(coord.x)),
-                    @as(i64, @intFromFloat(coord.y)),
-                );
-            }
-        }
-
-        const any_click = for (mouse.click_state) |state| {
-            if (state == .press) break true;
-        } else false;
-
-        click: {
-            cimgui.c.igTableNextRow(cimgui.c.ImGuiTableRowFlags_None, 0);
-            {
-                _ = cimgui.c.igTableSetColumnIndex(0);
-                cimgui.c.igText("Click State");
-            }
-            {
-                _ = cimgui.c.igTableSetColumnIndex(1);
-                if (!any_click) {
-                    cimgui.c.igText("none");
-                    break :click;
-                }
-
-                for (mouse.click_state, 0..) |state, i| {
-                    if (state != .press) continue;
-                    const button: input.MouseButton = @enumFromInt(i);
-                    cimgui.c.igSameLine(0, 0);
-                    cimgui.c.igText("%s", (switch (button) {
-                        .unknown => "?",
-                        .left => "L",
-                        .middle => "M",
-                        .right => "R",
-                        .four => "{4}",
-                        .five => "{5}",
-                        .six => "{6}",
-                        .seven => "{7}",
-                        .eight => "{8}",
-                        .nine => "{9}",
-                        .ten => "{10}",
-                        .eleven => "{11}",
-                    }).ptr);
-                }
-            }
-        }
-
-        {
-            const left_click_point: terminal.point.Coordinate = pt: {
-                const p = mouse.left_click_pin orelse break :pt .{};
-                const pt = t.screen.pages.pointFromPin(
-                    .active,
-                    p.*,
-                ) orelse break :pt .{};
-                break :pt pt.coord();
-            };
-
-            cimgui.c.igTableNextRow(cimgui.c.ImGuiTableRowFlags_None, 0);
-            {
-                _ = cimgui.c.igTableSetColumnIndex(0);
-                cimgui.c.igText("Click Grid");
-            }
-            {
-                _ = cimgui.c.igTableSetColumnIndex(1);
-                cimgui.c.igText(
-                    "row=%d, col=%d",
-                    left_click_point.y,
-                    left_click_point.x,
-                );
-            }
-        }
-
-        {
-            cimgui.c.igTableNextRow(cimgui.c.ImGuiTableRowFlags_None, 0);
-            {
-                _ = cimgui.c.igTableSetColumnIndex(0);
-                cimgui.c.igText("Click Point");
-            }
-            {
-                _ = cimgui.c.igTableSetColumnIndex(1);
-                cimgui.c.igText(
-                    "(%dpx, %dpx)",
-                    @as(u32, @intFromFloat(mouse.left_click_xpos)),
-                    @as(u32, @intFromFloat(mouse.left_click_ypos)),
-                );
-            }
-        }
-    }
-}
-
-fn renderCellWindow(self: *Inspector) void {
-    // Start our window. If we're collapsed we do nothing.
-    defer cimgui.c.igEnd();
-    if (!cimgui.c.igBegin(
-        window_cell,
-        null,
-        cimgui.c.ImGuiWindowFlags_NoFocusOnAppearing,
-    )) return;
-
-    // Our popup for the picker
-    const popup_picker = "Cell Picker";
-
-    if (cimgui.c.igButton("Picker", .{ .x = 0, .y = 0 })) {
-        // Request a cell
-        self.cell.request();
-
-        cimgui.c.igOpenPopup_Str(
-            popup_picker,
-            cimgui.c.ImGuiPopupFlags_None,
-        );
-    }
-
-    if (cimgui.c.igBeginPopupModal(
-        popup_picker,
-        null,
-        cimgui.c.ImGuiWindowFlags_AlwaysAutoResize,
-    )) popup: {
-        defer cimgui.c.igEndPopup();
-
-        // Once we select a cell, close this popup.
-        if (self.cell == .selected) {
-            cimgui.c.igCloseCurrentPopup();
-            break :popup;
-        }
-
-        cimgui.c.igText(
-            "Click on a cell in the terminal to inspect it.\n" ++
-                "The click will be intercepted by the picker, \n" ++
-                "so it won't be sent to the terminal.",
-        );
-        cimgui.c.igSeparator();
-
-        if (cimgui.c.igButton("Cancel", .{ .x = 0, .y = 0 })) {
-            cimgui.c.igCloseCurrentPopup();
-        }
-    } // cell pick popup
-
-    cimgui.c.igSeparator();
-
-    if (self.cell != .selected) {
-        cimgui.c.igText("No cell selected.");
-        return;
-    }
-
-    const selected = self.cell.selected;
-    selected.cell.renderTable(
-        self.surface.renderer_state.terminal,
-        selected.col,
-        selected.row,
-    );
-}
-
 fn renderKeyboardWindow(self: *Inspector) void {
-    // Start our window. If we're collapsed we do nothing.
     defer cimgui.c.igEnd();
     if (!cimgui.c.igBegin(
         window_keyboard,
@@ -981,8 +620,7 @@ 
     list: {
         if (self.key_events.empty()) {
-            cimgui.c.igText("No recorded key events. Press a key with the " ++
-                "terminal focused to record it.");
+            cimgui.c.igText("No recorded key events. Press a key with the terminal focused to record it.");
             break :list;
         }
 
@@ -990,7 +628,6 @@             var it = self.key_events.iterator(.forward);
             while (it.next()) |v| v.deinit(self.surface.alloc);
             self.key_events.clear();
-            self.vt_stream.handler.current_seq = 1;
         }
 
         cimgui.c.igSeparator();
@@ -998,7 +635,6 @@         _ = cimgui.c.igBeginTable(
             "table_key_events",
             1,
-            //cimgui.c.ImGuiTableFlags_ScrollY |
             cimgui.c.ImGuiTableFlags_RowBg |
                 cimgui.c.ImGuiTableFlags_Borders,
             .{ .x = 0, .y = 0 },
@@ -1008,7 +644,6 @@ 
         var it = self.key_events.iterator(.reverse);
         while (it.next()) |ev| {
-            // Need to push an ID so that our selectable is unique.
             cimgui.c.igPushID_Ptr(ev);
             defer cimgui.c.igPopID();
 
@@ -1025,12 +660,12 @@             );
 
             if (!ev.imgui_state.selected) continue;
+
             ev.render();
         }
-    } // table
+    }
 }
 
-/// Helper function to check keyboard state and determine navigation action.
 fn getKeyAction(self: *Inspector) KeyAction {
     _ = self;
     const keys = .{
@@ -1049,7 +684,6 @@ }
 
 fn renderTermioWindow(self: *Inspector) void {
-    // Start our window. If we're collapsed we do nothing.
     defer cimgui.c.igEnd();
     if (!cimgui.c.igBegin(
         window_termio,
@@ -1057,9 +691,8 @@         cimgui.c.ImGuiWindowFlags_NoFocusOnAppearing,
     )) return;
 
-    const popup_filter = "Filter";
-
     list: {
+        const popup_filter = "Filter";
         const pause_play: [:0]const u8 = if (self.vt_stream.handler.active)
             "Pause##pause_play"
         else
@@ -1082,18 +715,72 @@                 var it = self.vt_events.iterator(.forward);
                 while (it.next()) |v| v.deinit(self.surface.alloc);
                 self.vt_events.clear();
-
-                // We also reset the sequence number.
                 self.vt_stream.handler.current_seq = 1;
             }
         }
 
-        cimgui.c.igSeparator();
+        if (cimgui.c.igBeginPopupModal(
+            popup_filter,
+            null,
+            cimgui.c.ImGuiWindowFlags_AlwaysAutoResize,
+        )) {
+            defer cimgui.c.igEndPopup();
+
+            cimgui.c.igText("Changed filter settings will only affect future events.");
+
+            cimgui.c.igSeparator();
+
+            {
+                _ = cimgui.c.igBeginTable(
+                    "table_filter_kind",
+                    3,
+                    cimgui.c.ImGuiTableFlags_None,
+                    .{ .x = 0, .y = 0 },
+                    0,
+                );
+                defer cimgui.c.igEndTable();
+
+                inline for (@typeInfo(terminal.Parser.Action.Tag).@"enum".fields) |field| {
+                    const tag = @field(terminal.Parser.Action.Tag, field.name);
+                    if (tag == .apc_put or tag == .dcs_put) continue;
+
+                    _ = cimgui.c.igTableNextColumn();
+                    var value = !self.vt_stream.handler.filter_exclude.contains(tag);
+                    if (cimgui.c.igCheckbox(@tagName(tag).ptr, &value)) {
+                        if (value) {
+                            self.vt_stream.handler.filter_exclude.insert(tag);
+                        } else {
+                            self.vt_stream.handler.filter_exclude.remove(tag);
+                        }
+                    }
+                }
+            }
+
+            cimgui.c.igSeparator();
+
+            cimgui.c.igText(
+                "Filter by string. Empty displays all, \"abc\" finds lines\n" ++
+                    "containing \"abc\", \"abc,xyz\" finds lines containing \"abc\"\n" ++
+                    "or \"xyz\", \"-abc\" excludes lines containing \"abc\".",
+            );
+            _ = cimgui.c.ImGuiTextFilter_Draw(
+                self.vt_stream.handler.filter_text,
+                "##filter_text",
+                0,
+            );
+
+            cimgui.c.igSeparator();
+            if (cimgui.c.igButton("Close", .{ .x = 0, .y = 0 })) {
+                cimgui.c.igCloseCurrentPopup();
+            }
+        }
 
         if (self.vt_events.empty()) {
             cimgui.c.igText("Waiting for events...");
             break :list;
         }
+
+        cimgui.c.igSeparator();
 
         _ = cimgui.c.igBeginTable(
             "table_vt_events",
@@ -1131,7 +818,6 @@             switch (key_pressed) {
                 .none => {},
                 .up, .down => {
-                    // If no event is selected, select the first/last event based on direction
                     if (self.selected_event_seq == null) {
                         if (!self.vt_events.empty()) {
                             var it = self.vt_events.iterator(if (key_pressed == .up) .forward else .reverse);
@@ -1140,7 +826,6 @@                             }
                         }
                     } else {
-                        // Find next/previous event based on current selection
                         var it = self.vt_events.iterator(.reverse);
                         switch (key_pressed) {
                             .down => {
@@ -1171,7 +856,6 @@                         }
                     }
 
-                    // Mark that we need to scroll to the newly selected item
                     self.need_scroll_to_selected = true;
                     self.is_keyboard_selection = true;
                 },
@@ -1180,29 +864,23 @@ 
         var it = self.vt_events.iterator(.reverse);
         while (it.next()) |ev| {
-            // Need to push an ID so that our selectable is unique.
             cimgui.c.igPushID_Ptr(ev);
             defer cimgui.c.igPopID();
 
             cimgui.c.igTableNextRow(cimgui.c.ImGuiTableRowFlags_None, 0);
             _ = cimgui.c.igTableNextColumn();
 
-            // Store the previous selection state to detect changes
             const was_selected = ev.imgui_selected;
-
-            // Update selection state based on keyboard navigation
             if (self.selected_event_seq) |seq| {
                 ev.imgui_selected = (@as(u32, @intCast(ev.seq)) == seq);
             }
 
-            // Handle selectable widget
             if (cimgui.c.igSelectable_BoolPtr(
                 "##select",
                 &ev.imgui_selected,
                 cimgui.c.ImGuiSelectableFlags_SpanAllColumns,
                 .{ .x = 0, .y = 0 },
             )) {
-                // If selection state changed, update keyboard navigation state
                 if (ev.imgui_selected != was_selected) {
                     self.selected_event_seq = if (ev.imgui_selected)
                         @as(u32, @intCast(ev.seq))
@@ -1219,117 +897,371 @@             _ = cimgui.c.igTableNextColumn();
             cimgui.c.igText("%s", ev.str.ptr);
 
-            // If the event is selected, we render info about it. For now
-            // we put this in the last column because thats the widest and
-            // imgui has no way to make a column span.
             if (ev.imgui_selected) {
-                {
-                    _ = cimgui.c.igBeginTable(
-                        "details",
-                        2,
-                        cimgui.c.ImGuiTableFlags_None,
-                        .{ .x = 0, .y = 0 },
-                        0,
-                    );
-                    defer cimgui.c.igEndTable();
-                    inspector.cursor.renderInTable(
-                        self.surface.renderer_state.terminal,
-                        &ev.cursor,
-                    );
-
+                _ = cimgui.c.igBeginTable(
+                    "details",
+                    2,
+                    cimgui.c.ImGuiTableFlags_None,
+                    .{ .x = 0, .y = 0 },
+                    0,
+                );
+                defer cimgui.c.igEndTable();
+
+                inspector.cursor.renderInTable(
+                    self.surface.renderer_state.terminal,
+                    &ev.cursor,
+                );
+
+                {
+                    cimgui.c.igTableNextRow(cimgui.c.ImGuiTableRowFlags_None, 0);
                     {
-                        cimgui.c.igTableNextRow(cimgui.c.ImGuiTableRowFlags_None, 0);
-                        {
-                            _ = cimgui.c.igTableSetColumnIndex(0);
-                            cimgui.c.igText("Scroll Region");
-                        }
-                        {
-                            _ = cimgui.c.igTableSetColumnIndex(1);
-                            cimgui.c.igText(
-                                "T=%d B=%d L=%d R=%d",
-                                ev.scrolling_region.top,
-                                ev.scrolling_region.bottom,
-                                ev.scrolling_region.left,
-                                ev.scrolling_region.right,
-                            );
-                        }
+                        _ = cimgui.c.igTableSetColumnIndex(0);
+                        cimgui.c.igText("Scroll Region");
                     }
-
-                    var md_it = ev.metadata.iterator();
-                    while (md_it.next()) |entry| {
-                        var buf: [256]u8 = undefined;
-                        const key = std.fmt.bufPrintZ(&buf, "{s}", .{entry.key_ptr.*}) catch
-                            "<internal error>";
-                        cimgui.c.igTableNextRow(cimgui.c.ImGuiTableRowFlags_None, 0);
-                        _ = cimgui.c.igTableNextColumn();
-                        cimgui.c.igText("%s", key.ptr);
-                        _ = cimgui.c.igTableNextColumn();
-                        cimgui.c.igText("%s", entry.value_ptr.ptr);
+                    {
+                        _ = cimgui.c.igTableSetColumnIndex(1);
+                        cimgui.c.igText(
+                            "T=%d B=%d L=%d R=%d",
+                            ev.scrolling_region.top,
+                            ev.scrolling_region.bottom,
+                            ev.scrolling_region.left,
+                            ev.scrolling_region.right,
+                        );
                     }
                 }
 
-                // If this is the selected event and scrolling is needed, scroll to it
+                var md_it = ev.metadata.iterator();
+                while (md_it.next()) |entry| {
+                    var buf: [256]u8 = undefined;
+                    const key = std.fmt.bufPrintZ(&buf, "{s}", .{entry.key_ptr.*}) catch
+                        "<internal error>";
+                    cimgui.c.igTableNextRow(cimgui.c.ImGuiTableRowFlags_None, 0);
+                    _ = cimgui.c.igTableNextColumn();
+                    cimgui.c.igText("%s", key.ptr);
+                    _ = cimgui.c.igTableNextColumn();
+                    cimgui.c.igText("%s", entry.value_ptr.ptr);
+                }
+
                 if (self.need_scroll_to_selected and self.is_keyboard_selection) {
                     cimgui.c.igSetScrollHereY(0.5);
                     self.need_scroll_to_selected = false;
                 }
             }
         }
-    } // table
+    }
+}
+
+fn renderCellWindow(self: *Inspector) void {
+    defer cimgui.c.igEnd();
+    if (!cimgui.c.igBegin(
+        window_cell,
+        null,
+        cimgui.c.ImGuiWindowFlags_NoFocusOnAppearing,
+    )) return;
+
+    const popup_picker = "Cell Picker";
+
+    if (cimgui.c.igButton("Picker", .{ .x = 0, .y = 0 })) {
+        self.cell.request();
+
+        cimgui.c.igOpenPopup_Str(
+            popup_picker,
+            cimgui.c.ImGuiPopupFlags_None,
+        );
+    }
 
     if (cimgui.c.igBeginPopupModal(
-        popup_filter,
+        popup_picker,
         null,
         cimgui.c.ImGuiWindowFlags_AlwaysAutoResize,
-    )) {
+    )) popup: {
         defer cimgui.c.igEndPopup();
 
-        cimgui.c.igText("Changed filter settings will only affect future events.");
-
+        if (self.cell == .selected) {
+            cimgui.c.igCloseCurrentPopup();
+            break :popup;
+        }
+
+        cimgui.c.igText(
+            "Click on a cell in the terminal to inspect it.\n" ++
+                "The click will be intercepted by the picker, \n" ++
+                "so it won't be sent to the terminal.",
+        );
         cimgui.c.igSeparator();
 
-        {
-            _ = cimgui.c.igBeginTable(
-                "table_filter_kind",
-                3,
-                cimgui.c.ImGuiTableFlags_None,
-                .{ .x = 0, .y = 0 },
-                0,
-            );
-            defer cimgui.c.igEndTable();
-
-            inline for (@typeInfo(terminal.Parser.Action.Tag).@"enum".fields) |field| {
-                const tag = @field(terminal.Parser.Action.Tag, field.name);
-                if (tag == .apc_put or tag == .dcs_put) continue;
-
-                _ = cimgui.c.igTableNextColumn();
-                var value = !self.vt_stream.handler.filter_exclude.contains(tag);
-                if (cimgui.c.igCheckbox(@tagName(tag).ptr, &value)) {
-                    if (value) {
-                        self.vt_stream.handler.filter_exclude.remove(tag);
-                    } else {
-                        self.vt_stream.handler.filter_exclude.insert(tag);
-                    }
-                }
-            }
-        } // Filter kind table
-
-        cimgui.c.igSeparator();
-
-        cimgui.c.igText(
-            "Filter by string. Empty displays all, \"abc\" finds lines\n" ++
-                "containing \"abc\", \"abc,xyz\" finds lines containing \"abc\"\n" ++
-                "or \"xyz\", \"-abc\" excludes lines containing \"abc\".",
-        );
-        _ = cimgui.c.ImGuiTextFilter_Draw(
-            self.vt_stream.handler.filter_text,
-            "##filter_text",
+        if (cimgui.c.igButton("Cancel", .{ .x = 0, .y = 0 })) {
+            cimgui.c.igCloseCurrentPopup();
+        }
+    }
+
+    cimgui.c.igSeparator();
+
+    if (self.cell != .selected) {
+        cimgui.c.igText("No cell selected.");
+        return;
+    }
+
+    const selected = self.cell.selected;
+    selected.cell.renderTable(
+        self.surface.renderer_state.terminal,
+        selected.col,
+        selected.row,
+    );
+}
+
+fn renderSizeWindow(self: *Inspector) void {
+    defer cimgui.c.igEnd();
+    if (!cimgui.c.igBegin(
+        window_size,
+        null,
+        cimgui.c.ImGuiWindowFlags_NoFocusOnAppearing,
+    )) return;
+
+    cimgui.c.igSeparatorText("Dimensions");
+
+    {
+        _ = cimgui.c.igBeginTable(
+            "table_size",
+            2,
+            cimgui.c.ImGuiTableFlags_None,
+            .{ .x = 0, .y = 0 },
             0,
         );
-
-        cimgui.c.igSeparator();
-        if (cimgui.c.igButton("Close", .{ .x = 0, .y = 0 })) {
-            cimgui.c.igCloseCurrentPopup();
-        }
-    } // filter popup
+        defer cimgui.c.igEndTable();
+
+        {
+            cimgui.c.igTableNextRow(cimgui.c.ImGuiTableRowFlags_None, 0);
+            {
+                _ = cimgui.c.igTableSetColumnIndex(0);
+                cimgui.c.igText("Screen Size");
+            }
+            {
+                _ = cimgui.c.igTableSetColumnIndex(1);
+                cimgui.c.igText(
+                    "%dpx x %dpx",
+                    self.surface.size.screen.width,
+                    self.surface.size.screen.height,
+                );
+            }
+        }
+
+        {
+            cimgui.c.igTableNextRow(cimgui.c.ImGuiTableRowFlags_None, 0);
+            {
+                _ = cimgui.c.igTableSetColumnIndex(0);
+                cimgui.c.igText("Grid Size");
+            }
+            {
+                _ = cimgui.c.igTableSetColumnIndex(1);
+                const grid_size = self.surface.size.grid();
+                cimgui.c.igText(
+                    "%dc x %dr",
+                    grid_size.columns,
+                    grid_size.rows,
+                );
+            }
+        }
+
+        {
+            cimgui.c.igTableNextRow(cimgui.c.ImGuiTableRowFlags_None, 0);
+            {
+                _ = cimgui.c.igTableSetColumnIndex(0);
+                cimgui.c.igText("Cell Size");
+            }
+            {
+                _ = cimgui.c.igTableSetColumnIndex(1);
+                cimgui.c.igText(
+                    "%dpx x %dpx",
+                    self.surface.size.cell.width,
+                    self.surface.size.cell.height,
+                );
+            }
+        }
+
+        {
+            cimgui.c.igTableNextRow(cimgui.c.ImGuiTableRowFlags_None, 0);
+            {
+                _ = cimgui.c.igTableSetColumnIndex(0);
+                cimgui.c.igText("Window Padding");
+            }
+            {
+                _ = cimgui.c.igTableSetColumnIndex(1);
+                cimgui.c.igText(
+                    "T=%d B=%d L=%d R=%d px",
+                    self.surface.size.padding.top,
+                    self.surface.size.padding.bottom,
+                    self.surface.size.padding.left,
+                    self.surface.size.padding.right,
+                );
+            }
+        }
+    }
+
+    cimgui.c.igSeparatorText("Font");
+
+    {
+        _ = cimgui.c.igBeginTable(
+            "table_font",
+            2,
+            cimgui.c.ImGuiTableFlags_None,
+            .{ .x = 0, .y = 0 },
+            0,
+        );
+        defer cimgui.c.igEndTable();
+
+        {
+            cimgui.c.igTableNextRow(cimgui.c.ImGuiTableRowFlags_None, 0);
+            {
+                _ = cimgui.c.igTableSetColumnIndex(0);
+                cimgui.c.igText("Size (Points)");
+            }
+            {
+                _ = cimgui.c.igTableSetColumnIndex(1);
+                cimgui.c.igText(
+                    "%.2f pt",
+                    self.surface.font_size.points,
+                );
+            }
+        }
+
+        {
+            cimgui.c.igTableNextRow(cimgui.c.ImGuiTableRowFlags_None, 0);
+            {
+                _ = cimgui.c.igTableSetColumnIndex(0);
+                cimgui.c.igText("Size (Pixels)");
+            }
+            {
+                _ = cimgui.c.igTableSetColumnIndex(1);
+                cimgui.c.igText(
+                    "%d px",
+                    self.surface.font_size.pixels(),
+                );
+            }
+        }
+    }
+
+    cimgui.c.igSeparatorText("Mouse");
+
+    {
+        _ = cimgui.c.igBeginTable(
+            "table_mouse",
+            2,
+            cimgui.c.ImGuiTableFlags_None,
+            .{ .x = 0, .y = 0 },
+            0,
+        );
+        defer cimgui.c.igEndTable();
+
+        const mouse = &self.surface.mouse;
+        const t = self.surface.renderer_state.terminal;
+
+        {
+            const hover_point: terminal.point.Coordinate = pt: {
+                const p = self.mouse.last_point orelse break :pt .{};
+                const pt = t.screen.pages.pointFromPin(
+                    .active,
+                    p,
+                ) orelse break :pt .{};
+                break :pt pt.coord();
+            };
+
+            cimgui.c.igTableNextRow(cimgui.c.ImGuiTableRowFlags_None, 0);
+            {
+                _ = cimgui.c.igTableSetColumnIndex(0);
+                cimgui.c.igText("Hover Grid");
+            }
+            {
+                _ = cimgui.c.igTableSetColumnIndex(1);
+                cimgui.c.igText(
+                    "row=%d, col=%d",
+                    hover_point.y,
+                    hover_point.x,
+                );
+            }
+        }
+
+        {
+            const left_click_point: terminal.point.Coordinate = pt: {
+                const p = mouse.left_click_pin orelse break :pt .{};
+                const pt = t.screen.pages.pointFromPin(
+                    .active,
+                    p.*,
+                ) orelse break :pt .{};
+                break :pt pt.coord();
+            };
+
+            cimgui.c.igTableNextRow(cimgui.c.ImGuiTableRowFlags_None, 0);
+            {
+                _ = cimgui.c.igTableSetColumnIndex(0);
+                cimgui.c.igText("Click Grid");
+            }
+            {
+                _ = cimgui.c.igTableSetColumnIndex(1);
+                cimgui.c.igText(
+                    "row=%d, col=%d",
+                    left_click_point.y,
+                    left_click_point.x,
+                );
+            }
+        }
+
+        {
+            const adjusted = (renderer.Coordinate{
+                .surface = .{ .x = self.mouse.last_xpos, .y = self.mouse.last_ypos },
+            }).convert(.terminal, self.surface.size).terminal;
+
+            cimgui.c.igTableNextRow(cimgui.c.ImGuiTableRowFlags_None, 0);
+            {
+                _ = cimgui.c.igTableSetColumnIndex(0);
+                cimgui.c.igText("Hover Point");
+            }
+            {
+                _ = cimgui.c.igTableSetColumnIndex(1);
+                cimgui.c.igText(
+                    "(%dpx, %dpx)",
+                    @as(i64, @intFromFloat(adjusted.x)),
+                    @as(i64, @intFromFloat(adjusted.y)),
+                );
+            }
+        }
+
+        const any_click = for (mouse.click_state) |state| {
+            if (state == .press) break true;
+        } else false;
+
+        click: {
+            cimgui.c.igTableNextRow(cimgui.c.ImGuiTableRowFlags_None, 0);
+            {
+                _ = cimgui.c.igTableSetColumnIndex(0);
+                cimgui.c.igText("Click State");
+            }
+            {
+                _ = cimgui.c.igTableSetColumnIndex(1);
+                if (!any_click) {
+                    cimgui.c.igText("none");
+                    break :click;
+                }
+
+                for (mouse.click_state, 0..) |state, i| {
+                    if (state != .press) continue;
+                    const button: input.MouseButton = @enumFromInt(i);
+                    cimgui.c.igSameLine(0, 0);
+                    cimgui.c.igText("%s", (switch (button) {
+                        .unknown => "?",
+                        .left => "L",
+                        .middle => "M",
+                        .right => "R",
+                        .four => "{4}",
+                        .five => "{5}",
+                        .six => "{6}",
+                        .seven => "{7}",
+                        .eight => "{8}",
+                        .nine => "{9}",
+                        .ten => "{10}",
+                        .eleven => "{11}",
+                    }).ptr);
+                }
+            }
+        }
+    }
 }