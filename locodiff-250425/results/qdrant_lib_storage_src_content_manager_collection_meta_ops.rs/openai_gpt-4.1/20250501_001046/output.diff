--- qdrant_lib_storage_src_content_manager_collection_meta_ops.rs_expectedoutput.txt (expected)+++ qdrant_lib_storage_src_content_manager_collection_meta_ops.rs_extracted.txt (actual)@@ -107,82 +107,7 @@ }
 
 /// Operation for creating new collection and (optionally) specify index params
-#[derive(Debug, Deserialize, Serialize, JsonSchema, Validate, PartialEq, Eq, Hash, Clone)]
-#[serde(rename_all = "snake_case")]
-pub struct CreateCollection {
-    /// Vector data config.
-    /// It is possible to provide one config for single vector mode and list of configs for multiple vectors mode.
-    #[serde(default)]
-    #[validate(nested)]
-    pub vectors: VectorsConfig,
-    /// For auto sharding:
-    /// Number of shards in collection.
-    ///  - Default is 1 for standalone, otherwise equal to the number of nodes
-    ///  - Minimum is 1
-    ///
-    /// For custom sharding:
-    /// Number of shards in collection per shard group.
-    ///  - Default is 1, meaning that each shard key will be mapped to a single shard
-    ///  - Minimum is 1
-    #[serde(default)]
-    #[validate(range(min = 1))]
-    pub shard_number: Option<u32>,
-    /// Sharding method
-    /// Default is Auto - points are distributed across all available shards
-    /// Custom - points are distributed across shards according to shard key
-    #[serde(default)]
-    pub sharding_method: Option<ShardingMethod>,
-    /// Number of shards replicas.
-    /// Default is 1
-    /// Minimum is 1
-    #[serde(default)]
-    #[validate(range(min = 1))]
-    pub replication_factor: Option<u32>,
-    /// Defines how many replicas should apply the operation for us to consider it successful.
-    /// Increasing this number will make the collection more resilient to inconsistencies, but will
-    /// also make it fail if not enough replicas are available.
-    /// Does not have any performance impact.
-    #[serde(default)]
-    #[validate(range(min = 1))]
-    pub write_consistency_factor: Option<u32>,
-    /// If true - point's payload will not be stored in memory.
-    /// It will be read from the disk every time it is requested.
-    /// This setting saves RAM by (slightly) increasing the response time.
-    /// Note: those payload values that are involved in filtering and are indexed - remain in RAM.
-    ///
-    /// Default: true
-    #[serde(default)]
-    pub on_disk_payload: Option<bool>,
-    /// Custom params for HNSW index. If none - values from service configuration file are used.
-    #[validate(nested)]
-    pub hnsw_config: Option<HnswConfigDiff>,
-    /// Custom params for WAL. If none - values from service configuration file are used.
-    #[validate(nested)]
-    pub wal_config: Option<WalConfigDiff>,
-    /// Custom params for Optimizers.  If none - values from service configuration file are used.
-    #[serde(alias = "optimizer_config")]
-    #[validate(nested)]
-    pub optimizers_config: Option<OptimizersConfigDiff>,
-    /// Specify other collection to copy data from.
-    #[serde(default)]
-    pub init_from: Option<InitFrom>,
-    /// Quantization parameters. If none - quantization is disabled.
-    #[serde(default, alias = "quantization")]
-    #[validate(nested)]
-    pub quantization_config: Option<QuantizationConfig>,
-    /// Sparse vector data config.
-    #[validate(nested)]
-    pub sparse_vectors: Option<BTreeMap<VectorNameBuf, SparseVectorParams>>,
-    /// Strict-mode config.
-    #[validate(nested)]
-    pub strict_mode_config: Option<StrictModeConfig>,
-    #[serde(default)]
-    #[schemars(skip)]
-    pub uuid: Option<Uuid>,
-}
-
-/// Operation for creating new collection and (optionally) specify index params
-#[derive(Debug, Deserialize, Serialize, PartialEq, Eq, Hash, Clone)]
+#[derive(Debug, Deserialize, Serialize, JsonSchema, PartialEq, Eq, Hash, Clone)]
 #[serde(rename_all = "snake_case")]
 pub struct CreateCollectionOperation {
     pub collection_name: String,
@@ -226,6 +151,81 @@     }
 }
 
+/// Operation for creating new collection and (optionally) specify index params
+#[derive(Debug, Deserialize, Serialize, JsonSchema, Validate, PartialEq, Eq, Hash, Clone)]
+#[serde(rename_all = "snake_case")]
+pub struct CreateCollection {
+    /// Vector data config.
+    /// It is possible to provide one config for single vector mode and list of configs for multiple vectors mode.
+    #[serde(default)]
+    #[validate(nested)]
+    pub vectors: VectorsConfig,
+    /// For auto sharding:
+    /// Number of shards in collection.
+    ///  - Default is 1 for standalone, otherwise equal to the number of nodes
+    ///  - Minimum is 1
+    ///
+    /// For custom sharding:
+    /// Number of shards in collection per shard group.
+    ///  - Default is 1, meaning that each shard key will be mapped to a single shard
+    ///  - Minimum is 1
+    #[serde(default)]
+    #[validate(range(min = 1))]
+    pub shard_number: Option<u32>,
+    /// Sharding method
+    /// Default is Auto - points are distributed across all available shards
+    /// Custom - points are distributed across shards according to shard key
+    #[serde(default)]
+    pub sharding_method: Option<ShardingMethod>,
+    /// Number of shards replicas.
+    /// Default is 1
+    /// Minimum is 1
+    #[serde(default)]
+    #[validate(range(min = 1))]
+    pub replication_factor: Option<u32>,
+    /// Defines how many replicas should apply the operation for us to consider it successful.
+    /// Increasing this number will make the collection more resilient to inconsistencies, but will
+    /// also make it fail if not enough replicas are available.
+    /// Does not have any performance impact.
+    #[serde(default)]
+    #[validate(range(min = 1))]
+    pub write_consistency_factor: Option<u32>,
+    /// If true - point's payload will not be stored in memory.
+    /// It will be read from the disk every time it is requested.
+    /// This setting saves RAM by (slightly) increasing the response time.
+    /// Note: those payload values that are involved in filtering and are indexed - remain in RAM.
+    ///
+    /// Default: true
+    #[serde(default)]
+    pub on_disk_payload: Option<bool>,
+    /// Custom params for HNSW index. If none - values from service configuration file are used.
+    #[validate(nested)]
+    pub hnsw_config: Option<HnswConfigDiff>,
+    /// Custom params for WAL. If none - values from service configuration file are used.
+    #[validate(nested)]
+    pub wal_config: Option<WalConfigDiff>,
+    /// Custom params for Optimizers.  If none - values from service configuration file are used.
+    #[serde(alias = "optimizer_config")]
+    #[validate(nested)]
+    pub optimizers_config: Option<OptimizersConfigDiff>,
+    /// Specify other collection to copy data from.
+    #[serde(default)]
+    pub init_from: Option<InitFrom>,
+    /// Quantization parameters. If none - quantization is disabled.
+    #[serde(default, alias = "quantization")]
+    #[validate(nested)]
+    pub quantization_config: Option<QuantizationConfig>,
+    /// Sparse vector data config.
+    #[validate(nested)]
+    pub sparse_vectors: Option<BTreeMap<VectorNameBuf, SparseVectorParams>>,
+    /// Strict-mode config.
+    #[validate(nested)]
+    pub strict_mode_config: Option<StrictModeConfig>,
+    #[serde(default)]
+    #[schemars(skip)]
+    pub uuid: Option<Uuid>,
+}
+
 /// Operation for updating parameters of the existing collection
 #[derive(Debug, Deserialize, Serialize, JsonSchema, Validate, PartialEq, Eq, Hash, Clone)]
 #[serde(rename_all = "snake_case")]
@@ -237,7 +237,7 @@     /// Custom params for Optimizers.  If none - it is left unchanged.
     /// This operation is blocking, it will only proceed once all current optimizations are complete
     #[serde(alias = "optimizer_config")]
-    pub optimizers_config: Option<OptimizersConfigDiff>, // TODO: Allow updates for other configuration params as well
+    pub optimizers_config: Option<OptimizersConfigDiff>,
     /// Collection base params. If none - it is left unchanged.
     pub params: Option<CollectionParamsDiff>,
     /// HNSW parameters to update for the collection index. If none - it is left unchanged.
