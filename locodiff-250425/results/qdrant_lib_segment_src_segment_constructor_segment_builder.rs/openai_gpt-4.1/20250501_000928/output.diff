--- qdrant_lib_segment_src_segment_constructor_segment_builder.rs_expectedoutput.txt (expected)+++ qdrant_lib_segment_src_segment_constructor_segment_builder.rs_extracted.txt (actual)@@ -15,7 +15,6 @@ use common::small_uint::U24;
 use common::types::PointOffsetType;
 use io::storage_version::StorageVersion;
-use itertools::Itertools;
 use tempfile::TempDir;
 use uuid::Uuid;
 
@@ -235,7 +234,7 @@                 }
                 FieldIndex::UuidIndex(index) => {
                     if let Some(ids) = index.get_values(internal_id) {
-                        uuid_hash(&mut ordering, ids);
+                        uuid_hash(&mut ordering, ids.copied());
                     }
                     break;
                 }
@@ -277,7 +276,7 @@         }
 
         let mut points_to_insert = Vec::new();
-        let locked_id_trackers = segments.iter().map(|s| s.id_tracker.borrow()).collect_vec();
+        let locked_id_trackers = segments.iter().map(|s| s.id_tracker.borrow()).collect::<Vec<_>>();
         for_each_unique_point(locked_id_trackers.iter().map(|i| i.deref()), |item| {
             points_to_insert.push(PointData {
                 external_id: CompactExtendedPointId::from(item.external_id),
@@ -427,7 +426,7 @@                     self.payload_storage.set(
                         new_internal_id,
                         &other_payload,
-                        &HardwareCounterCell::disposable(),
+                        &hw_counter,
                     )?;
                 }
             }
@@ -485,14 +484,6 @@             id_tracker.versions_flusher()()?;
             let id_tracker_arc = Arc::new(AtomicRefCell::new(id_tracker));
 
-            let mut quantized_vectors = Self::update_quantization(
-                &segment_config,
-                &vector_data,
-                temp_dir.path(),
-                &permit,
-                stopped,
-            )?;
-
             let mut vector_storages_arc = HashMap::new();
             let mut old_indices = HashMap::new();
 
@@ -542,6 +533,17 @@ 
             payload_index.flusher()()?;
             let payload_index_arc = Arc::new(AtomicRefCell::new(payload_index));
+
+            let mut quantized_vectors = Self::update_quantization(
+                &segment_config,
+                &vector_data,
+                temp_dir.path(),
+                &permit,
+                stopped,
+            )?;
+
+            // Arc permit to share it with each vector store
+            let permit = Arc::new(permit);
 
             // Try to lock GPU device.
             #[cfg(feature = "gpu")]
@@ -554,9 +556,6 @@                 .flatten();
             #[cfg(not(feature = "gpu"))]
             let gpu_device = None;
-
-            // Arc permit to share it with each vector store
-            let permit = Arc::new(permit);
 
             for (vector_name, vector_config) in &segment_config.vector_data {
                 let vector_storage = vector_storages_arc.remove(vector_name).unwrap();
