
index 70dd22b46..0849095e3 100644
--- a/qdrant_lib_segment_src_segment_constructor_segment_builder.rs_expectedoutput.txt (expected):tmp/tmpzhz32gke_expected.txt	
+++ b/qdrant_lib_segment_src_segment_constructor_segment_builder.rs_extracted.txt (actual):tmp/tmptxao6wd3_actual.txt	
@@ -353,7 +353,7 @@ impl SegmentBuilder {
                     if new_internal_range != &internal_range {
                         return Err(OperationError::service_error(format!(
                             "Internal ids range mismatch between self segment vectors and other segment vectors\n\
-                                vector_name: {vector_name}, self range: {new_internal_range:?}, other range: {internal_range:?}"
+                            vector_name: {vector_name}, self range: {new_internal_range:?}, other range: {internal_range:?}"
                         )));
                     }
                 }
@@ -439,6 +439,9 @@ impl SegmentBuilder {
             }
         }
 
+        self.id_tracker.mapping_flusher()()?;
+        self.id_tracker.versions_flusher()()?;
+
         Ok(true)
     }
 
@@ -466,6 +469,9 @@ impl SegmentBuilder {
             payload_storage.flusher()()?;
             let payload_storage_arc = Arc::new(AtomicRefCell::new(payload_storage));
 
+            id_tracker.mapping_flusher()()?;
+            id_tracker.versions_flusher()()?;
+
             let id_tracker = match id_tracker {
                 IdTrackerEnum::InMemoryIdTracker(in_memory_id_tracker) => {
                     let (versions, mappings) = in_memory_id_tracker.into_internal();
@@ -485,6 +491,26 @@ impl SegmentBuilder {
             id_tracker.versions_flusher()()?;
             let id_tracker_arc = Arc::new(AtomicRefCell::new(id_tracker));
 
+            let payload_index_path = get_payload_index_path(temp_dir.path());
+
+            let mut payload_index = StructPayloadIndex::open(
+                payload_storage_arc.clone(),
+                id_tracker_arc.clone(),
+                vector_storages_arc.clone(),
+                &payload_index_path,
+                appendable_flag,
+            )?;
+            for (field, payload_schema) in indexed_fields {
+                payload_index.set_indexed(&field, payload_schema, hw_counter)?;
+                check_process_stopped(stopped)?;
+            }
+
+            payload_index.flusher()()?;
+            let payload_index_arc = Arc::new(AtomicRefCell::new(payload_index));
+
+            // Arc permit to share it with each vector store
+            let permit = Arc::new(permit);
+
             let mut quantized_vectors = Self::update_quantization(
                 &segment_config,
                 &vector_data,
@@ -526,23 +552,6 @@ impl SegmentBuilder {
                 vector_storages_arc.insert(vector_name.to_owned(), vector_storage_arc);
             }
 
-            let payload_index_path = get_payload_index_path(temp_dir.path());
-
-            let mut payload_index = StructPayloadIndex::open(
-                payload_storage_arc.clone(),
-                id_tracker_arc.clone(),
-                vector_storages_arc.clone(),
-                &payload_index_path,
-                appendable_flag,
-            )?;
-            for (field, payload_schema) in indexed_fields {
-                payload_index.set_indexed(&field, payload_schema, hw_counter)?;
-                check_process_stopped(stopped)?;
-            }
-
-            payload_index.flusher()()?;
-            let payload_index_arc = Arc::new(AtomicRefCell::new(payload_index));
-
             // Try to lock GPU device.
             #[cfg(feature = "gpu")]
             let gpu_devices_manager = crate::index::hnsw_index::gpu::GPU_DEVICES_MANAGER.read();
