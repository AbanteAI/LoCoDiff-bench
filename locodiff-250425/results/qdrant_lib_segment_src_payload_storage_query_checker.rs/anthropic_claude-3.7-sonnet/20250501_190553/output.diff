
index 4e5c39ca..8b2e0310 100644
--- a/qdrant_lib_segment_src_payload_storage_query_checker.rs_expectedoutput.txt (expected):tmp/tmpwh336db4_expected.txt	
+++ b/qdrant_lib_segment_src_payload_storage_query_checker.rs_extracted.txt (actual):tmp/tmppezqsz0m_actual.txt	
@@ -1,5 +1,3 @@
-#![cfg_attr(not(feature = "testing"), allow(unused_imports))]
-
 use std::cell::RefCell;
 use std::collections::HashMap;
 use std::ops::Deref;
@@ -319,348 +317,4 @@ impl ConditionChecker for SimpleConditionChecker {
             &HardwareCounterCell::new(),
         )
     }
-}
-
-#[cfg(test)]
-mod tests {
-    use std::str::FromStr;
-
-    use ahash::AHashSet;
-    use tempfile::Builder;
-
-    use super::*;
-    use crate::common::rocksdb_wrapper::{DB_VECTOR_CF, open_db};
-    use crate::id_tracker::IdTracker;
-    use crate::id_tracker::simple_id_tracker::SimpleIdTracker;
-    use crate::json_path::JsonPath;
-    use crate::payload_json;
-    use crate::payload_storage::PayloadStorage;
-    use crate::payload_storage::simple_payload_storage::SimplePayloadStorage;
-    use crate::types::{
-        DateTimeWrapper, FieldCondition, GeoBoundingBox, GeoPoint, PayloadField, Range, ValuesCount,
-    };
-
-    #[test]
-    fn test_condition_checker() {
-        let dir = Builder::new().prefix("db_dir").tempdir().unwrap();
-        let db = open_db(dir.path(), &[DB_VECTOR_CF]).unwrap();
-
-        let payload = payload_json! {
-            "location": {
-                "lon": 13.404954,
-                "lat": 52.520008,
-            },
-            "price": 499.90,
-            "amount": 10,
-            "rating": vec![3, 7, 9, 9],
-            "color": "red",
-            "has_delivery": true,
-            "shipped_at": "2020-02-15T00:00:00Z",
-            "parts": [],
-            "packaging": null,
-            "not_null": [null],
-        };
-
-        let hw_counter = HardwareCounterCell::new();
-
-        let mut payload_storage: PayloadStorageEnum =
-            SimplePayloadStorage::open(db.clone()).unwrap().into();
-        let mut id_tracker = SimpleIdTracker::open(db).unwrap();
-
-        id_tracker.set_link(0.into(), 0).unwrap();
-        id_tracker.set_link(1.into(), 1).unwrap();
-        id_tracker.set_link(2.into(), 2).unwrap();
-        id_tracker.set_link(10.into(), 10).unwrap();
-        payload_storage.overwrite(0, &payload, &hw_counter).unwrap();
-
-        let payload_checker = SimpleConditionChecker::new(
-            Arc::new(AtomicRefCell::new(payload_storage)),
-            Arc::new(AtomicRefCell::new(id_tracker)),
-            HashMap::new(),
-        );
-
-        let is_empty_condition = Filter::new_must(Condition::IsEmpty(IsEmptyCondition {
-            is_empty: PayloadField {
-                key: JsonPath::new("price"),
-            },
-        }));
-        assert!(!payload_checker.check(0, &is_empty_condition));
-
-        let is_empty_condition = Filter::new_must(Condition::IsEmpty(IsEmptyCondition {
-            is_empty: PayloadField {
-                key: JsonPath::new("something_new"),
-            },
-        }));
-        assert!(payload_checker.check(0, &is_empty_condition));
-
-        let is_empty_condition = Filter::new_must(Condition::IsEmpty(IsEmptyCondition {
-            is_empty: PayloadField {
-                key: JsonPath::new("parts"),
-            },
-        }));
-        assert!(payload_checker.check(0, &is_empty_condition));
-
-        let is_empty_condition = Filter::new_must(Condition::IsEmpty(IsEmptyCondition {
-            is_empty: PayloadField {
-                key: JsonPath::new("not_null"),
-            },
-        }));
-        assert!(!payload_checker.check(0, &is_empty_condition));
-
-        let is_null_condition = Filter::new_must(Condition::IsNull(IsNullCondition {
-            is_null: PayloadField {
-                key: JsonPath::new("amount"),
-            },
-        }));
-        assert!(!payload_checker.check(0, &is_null_condition));
-
-        let is_null_condition = Filter::new_must(Condition::IsNull(IsNullCondition {
-            is_null: PayloadField {
-                key: JsonPath::new("parts"),
-            },
-        }));
-        assert!(!payload_checker.check(0, &is_null_condition));
-
-        let is_null_condition = Filter::new_must(Condition::IsNull(IsNullCondition {
-            is_null: PayloadField {
-                key: JsonPath::new("something_else"),
-            },
-        }));
-        assert!(!payload_checker.check(0, &is_null_condition));
-
-        let is_null_condition = Filter::new_must(Condition::IsNull(IsNullCondition {
-            is_null: PayloadField {
-                key: JsonPath::new("packaging"),
-            },
-        }));
-        assert!(payload_checker.check(0, &is_null_condition));
-
-        let is_null_condition = Filter::new_must(Condition::IsNull(IsNullCondition {
-            is_null: PayloadField {
-                key: JsonPath::new("not_null"),
-            },
-        }));
-        assert!(!payload_checker.check(0, &is_null_condition));
-
-        let match_red = Condition::Field(FieldCondition::new_match(
-            JsonPath::new("color"),
-            "red".to_owned().into(),
-        ));
-        let match_blue = Condition::Field(FieldCondition::new_match(
-            JsonPath::new("color"),
-            "blue".to_owned().into(),
-        ));
-        let shipped_in_february = Condition::Field(FieldCondition::new_datetime_range(
-            JsonPath::new("shipped_at"),
-            Range {
-                lt: Some(DateTimeWrapper::from_str("2020-03-01T00:00:00Z").unwrap()),
-                gt: None,
-                gte: Some(DateTimeWrapper::from_str("2020-02-01T00:00:00Z").unwrap()),
-                lte: None,
-            },
-        ));
-        let shipped_in_march = Condition::Field(FieldCondition::new_datetime_range(
-            JsonPath::new("shipped_at"),
-            Range {
-                lt: Some(DateTimeWrapper::from_str("2020-04-01T00:00:00Z").unwrap()),
-                gt: None,
-                gte: Some(DateTimeWrapper::from_str("2020-03-01T00:00:00Z").unwrap()),
-                lte: None,
-            },
-        ));
-        let with_delivery = Condition::Field(FieldCondition::new_match(
-            JsonPath::new("has_delivery"),
-            true.into(),
-        ));
-
-        let many_value_count_condition =
-            Filter::new_must(Condition::Field(FieldCondition::new_values_count(
-                JsonPath::new("rating"),
-                ValuesCount {
-                    lt: None,
-                    gt: None,
-                    gte: Some(10),
-                    lte: None,
-                },
-            )));
-        assert!(!payload_checker.check(0, &many_value_count_condition));
-
-        let few_value_count_condition =
-            Filter::new_must(Condition::Field(FieldCondition::new_values_count(
-                JsonPath::new("rating"),
-                ValuesCount {
-                    lt: Some(5),
-                    gt: None,
-                    gte: None,
-                    lte: None,
-                },
-            )));
-        assert!(payload_checker.check(0, &few_value_count_condition));
-
-        let in_berlin = Condition::Field(FieldCondition::new_geo_bounding_box(
-            JsonPath::new("location"),
-            GeoBoundingBox {
-                top_left: GeoPoint {
-                    lon: 13.08835,
-                    lat: 52.67551,
-                },
-                bottom_right: GeoPoint {
-                    lon: 13.76116,
-                    lat: 52.33826,
-                },
-            },
-        ));
-
-        let in_moscow = Condition::Field(FieldCondition::new_geo_bounding_box(
-            JsonPath::new("location"),
-            GeoBoundingBox {
-                top_left: GeoPoint {
-                    lon: 37.0366,
-                    lat: 56.1859,
-                },
-                bottom_right: GeoPoint {
-                    lon: 38.2532,
-                    lat: 55.317,
-                },
-            },
-        ));
-
-        let with_bad_rating = Condition::Field(FieldCondition::new_range(
-            JsonPath::new("rating"),
-            Range {
-                lt: None,
-                gt: None,
-                gte: None,
-                lte: Some(5.),
-            },
-        ));
-
-        let query = Filter::new_must(match_red.clone());
-        assert!(payload_checker.check(0, &query));
-
-        let query = Filter::new_must(match_blue.clone());
-        assert!(!payload_checker.check(0, &query));
-
-        let query = Filter::new_must_not(match_blue.clone());
-        assert!(payload_checker.check(0, &query));
-
-        let query = Filter::new_must_not(match_red.clone());
-        assert!(!payload_checker.check(0, &query));
-
-        let query = Filter {
-            should: Some(vec![match_red.clone(), match_blue.clone()]),
-            min_should: None,
-            must: Some(vec![with_delivery.clone(), in_berlin.clone()]),
-            must_not: None,
-        };
-        assert!(payload_checker.check(0, &query));
-
-        let query = Filter {
-            should: Some(vec![match_red.clone(), match_blue.clone()]),
-            min_should: None,
-            must: Some(vec![with_delivery, in_moscow.clone()]),
-            must_not: None,
-        };
-        assert!(!payload_checker.check(0, &query));
-
-        let query = Filter {
-            should: Some(vec![
-                Condition::Filter(Filter {
-                    should: None,
-                    min_should: None,
-                    must: Some(vec![match_red.clone(), in_moscow.clone()]),
-                    must_not: None,
-                }),
-                Condition::Filter(Filter {
-                    should: None,
-                    min_should: None,
-                    must: Some(vec![match_blue.clone(), in_berlin.clone()]),
-                    must_not: None,
-                }),
-            ]),
-            min_should: None,
-            must: None,
-            must_not: None,
-        };
-        assert!(!payload_checker.check(0, &query));
-
-        let query = Filter {
-            should: Some(vec![
-                Condition::Filter(Filter {
-                    should: None,
-                    min_should: None,
-                    must: Some(vec![match_blue.clone(), in_moscow.clone()]),
-                    must_not: None,
-                }),
-                Condition::Filter(Filter {
-                    should: None,
-                    min_should: None,
-                    must: Some(vec![match_red.clone(), in_berlin.clone()]),
-                    must_not: None,
-                }),
-            ]),
-            min_should: None,
-            must: None,
-            must_not: None,
-        };
-        assert!(payload_checker.check(0, &query));
-
-        let query = Filter::new_must_not(with_bad_rating);
-        assert!(!payload_checker.check(0, &query));
-
-        // min_should
-        let query = Filter::new_min_should(MinShould {
-            conditions: vec![match_blue.clone(), in_moscow.clone()],
-            min_count: 1,
-        });
-        assert!(!payload_checker.check(0, &query));
-
-        let query = Filter::new_min_should(MinShould {
-            conditions: vec![match_red.clone(), in_berlin.clone(), in_moscow.clone()],
-            min_count: 2,
-        });
-        assert!(payload_checker.check(0, &query));
-
-        let query = Filter::new_min_should(MinShould {
-            conditions: vec![
-                Condition::Filter(Filter {
-                    should: None,
-                    min_should: None,
-                    must: Some(vec![match_blue, in_moscow]),
-                    must_not: None,
-                }),
-                Condition::Filter(Filter {
-                    should: None,
-                    min_should: None,
-                    must: Some(vec![match_red, in_berlin]),
-                    must_not: None,
-                }),
-            ],
-            min_count: 1,
-        });
-        assert!(payload_checker.check(0, &query));
-
-        // DateTime payload index
-        let query = Filter::new_must(shipped_in_february);
-        assert!(payload_checker.check(0, &query));
-
-        let query = Filter::new_must(shipped_in_march);
-        assert!(!payload_checker.check(0, &query));
-
-        // id Filter
-        let ids: AHashSet<_> = vec![1, 2, 3].into_iter().map(|x| x.into()).collect();
-
-        let query = Filter::new_must_not(Condition::HasId(ids.into()));
-        assert!(!payload_checker.check(2, &query));
-
-        let ids: AHashSet<_> = vec![1, 2, 3].into_iter().map(|x| x.into()).collect();
-
-        let query = Filter::new_must_not(Condition::HasId(ids.into()));
-        assert!(payload_checker.check(10, &query));
-
-        let ids: AHashSet<_> = vec![1, 2, 3].into_iter().map(|x| x.into()).collect();
-
-        let query = Filter::new_must(Condition::HasId(ids.into()));
-        assert!(payload_checker.check(2, &query));
-    }
 }
\ No newline at end of file
