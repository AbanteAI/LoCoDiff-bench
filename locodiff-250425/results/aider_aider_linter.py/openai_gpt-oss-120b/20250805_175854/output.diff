
index add561d0a..f6a25c624 100644
--- a/aider_aider_linter.py_expectedoutput.txt (expected):tmp/tmphz1qn64t_expected.txt	
+++ b/aider_aider_linter.py_extracted.txt (actual):tmp/tmpuja0yygh_actual.txt	
@@ -11,44 +11,71 @@ from pathlib import Path
 from grep_ast import TreeContext, filename_to_lang
 from grep_ast.tsl import get_parser  # noqa: E402
 
-from aider.dump import dump  # noqa: F401
 from aider.run_cmd import run_cmd_subprocess  # noqa: F401
 
 # tree_sitter is throwing a FutureWarning
 warnings.simplefilter("ignore", category=FutureWarning)
 
 
+@dataclass
+class LintResult:
+    text: str
+    lines: list
+
+
 class Linter:
-    def __init__(self, encoding="utf-8", root=None):
+    def __init__(self, encoding: str = "utf-8", root=None):
         self.encoding = encoding
         self.root = root
 
-        self.languages = dict(
-            python=self.py_lint,
-        )
+        self.languages = {"python": self.py_lint}
         self.all_lint_cmd = None
 
-    def set_linter(self, lang, cmd):
+        self._check_eslint()
+
+    def _check_eslint(self):
+        """Detect a local eslint for TypeScript files and set a linter command."""
+        eslint_names = ["eslint", "eslint.cmd", "eslint.exe"]
+        eslint_paths = [
+            Path(".") / "node_modules" / ".bin",
+            Path(self.root) / "node_modules" / ".bin"
+            if self.root
+            else None,
+        ]
+
+        for path in eslint_paths:
+            if not path:
+                continue
+            for name in eslint_names:
+                eslint_file = path / name
+                # Avoid paths with spaces – they cause shell parsing problems.
+                if eslint_file.is_file() and " " not in str(eslint_file)):
+                    self.languages["typescript"] = f"{eslint_file} --format unix"
+                    return
+
+    def set_linter(self, lang: str | None, cmd: str | None):
+        """Set a custom linter command for a language, or a global command."""
         if lang:
             self.languages[lang] = cmd
             return
-
         self.all_lint_cmd = cmd
 
-    def get_rel_fname(self, fname):
+    def get_rel_fname(self, fname: str) -> str:
+        """Return a path relative to the root, handling errors."""
         if self.root:
             try:
                 return os.path.relpath(fname, self.root)
             except ValueError:
                 return fname
-        else:
-            return fname
+        return fname
 
-    def run_cmd(self, cmd, rel_fname, code):
-        cmd += " " + shlex.quote(rel_fname)
+    def run_cmd(self, cmd: str, rel_fname: str, code: str):
+        """Execute a linter command, returning a LintResult."""
+        cmd = f"{cmd} {shlex.quote(rel_fname)}"
 
         returncode = 0
         stdout = ""
+
         try:
             returncode, stdout = run_cmd_subprocess(
                 cmd,
@@ -58,82 +85,92 @@ class Linter:
         except OSError as err:
             print(f"Unable to execute lint command: {err}")
             return
+
         errors = stdout
         if returncode == 0:
             return  # zero exit status
 
+        # prepend a header describing the command that was run
         res = f"## Running: {cmd}\n\n"
         res += errors
 
         return self.errors_to_lint_result(rel_fname, res)
 
-    def errors_to_lint_result(self, rel_fname, errors):
+    def errors_to_lint_result(self, rel_fname: str, errors: str):
+        """Convert raw lint output into a LintResult, extracting line numbers."""
         if not errors:
             return
 
-        linenums = []
+        linenums: list[int] = []
         filenames_linenums = find_filenames_and_linenums(errors, [rel_fname])
         if filenames_linenums:
-            filename, linenums = next(iter(filenames_linenums.items()))
-            linenums = [num - 1 for num in linenums]
+            _fname, linenums = next(iter(filenames_linenums.items()))
+            linenums = [num - 1 for num in linenums]  # adjust to 0‑based
 
         return LintResult(text=errors, lines=linenums)
 
-    def lint(self, fname, cmd=None):
+    def lint(self, fname: str, cmd: str | None = None):
+        """Run the appropriate linter for the given file."""
         rel_fname = self.get_rel_fname(fname)
-        try:
-            code = Path(fname).read_text(encoding=self.encoding, errors="replace")
-        except OSError as err:
-            print(f"Unable to read {fname}: {err}")
-            return
+
+        # read the file – we replace errors with the Unicode replacement character
+        # to avoid UnicodeDecodeError on binary files.
+        code = Path(fname).read_text(encoding=self.encoding, errors="replace")
 
         if cmd:
             cmd = cmd.strip()
+
         if not cmd:
             lang = filename_to_lang(fname)
             if not lang:
                 return
-            if self.all_lint_cmd:
-                cmd = self.all_lint_cmd
-            else:
-                cmd = self.languages.get(lang)
+            cmd = self.languages.get(lang)
 
         if callable(cmd):
-            lintres = cmd(fname, rel_fname, code)
+            lint_res = cmd(fname, rel_fname, code)
         elif cmd:
-            lintres = self.run_cmd(cmd, rel_fname, code)
+            lint_res = self.run_cmd(cmd, rel_fname=rel_fname, code=code)
         else:
-            lintres = basic_lint(rel_fname, code)
+            # fallback to the tree‑sitter based basic lint
+            lint_res = basic_lint(rel_fname, code)
 
-        if not lintres:
+        if not lint_res:
             return
 
+        # Compose the final output for the user.
         res = "# Fix any errors below, if possible.\n\n"
-        res += lintres.text
+        res += lint_res.text
         res += "\n"
-        res += tree_context(rel_fname, code, lintres.lines)
-
+        # The tree should be displayed with the same relative name that was
+        # passed to the linter, not the absolute path (easier to read).
+        res += tree_context(rel_fname, code, lint_res.lines)
         return res
 
-    def py_lint(self, fname, rel_fname, code):
+    def py_lint(self, fname: str, rel_fname: str, code: str):
+        """Run Python‑specific linters (tree‑sitter, pycompile and flake8)."""
         basic_res = basic_lint(rel_fname, code)
         compile_res = lint_python_compile(fname, code)
-        flake_res = self.flake8_lint(rel_fname)
 
-        text = ""
-        lines = set()
-        for res in [basic_res, compile_res, flake_res]:
+        result_text = ""
+        result_lines = set()
+
+        for res in [basic_res, compile_res]:
             if not res:
                 continue
-            if text:
-                text += "\n"
-            text += res.text
-            lines.update(res.lines)
+            if isinstance(res, LintResult):
+                result_text += res.text + ("\n" if result_text else "")
+                result_lines.update(res.lines)
 
-        if text or lines:
-            return LintResult(text, lines)
+        flake_res = self.flake8_lint(rel_fname)
+        if flake_res:
+            result_text += flake_res.text + ("\n" if result_text else "")
+            result_lines.update(flake_res.lines)
+
+        if result_text or result_lines:
+            return LintResult(text=result_text, lines=list(result_lines))
 
-    def flake8_lint(self, rel_fname):
+    def flake8_lint(self, rel_fname: str):
+        """Run Flake8 on a Python file and return a LintResult."""
         fatal = "E9,F821,F823,F831,F406,F407,F701,F702,F704,F706"
         flake8_cmd = [
             sys.executable,
@@ -145,17 +182,15 @@ class Linter:
             rel_fname,
         ]
 
-        text = f"## Running: {' '.join(flake8_cmd)}\n\n"
-
         try:
             result = subprocess.run(
                 flake8_cmd,
+                cwd=self.root,
                 capture_output=True,
                 text=True,
                 check=False,
                 encoding=self.encoding,
                 errors="replace",
-                cwd=self.root,
             )
             errors = result.stdout + result.stderr
         except Exception as e:
@@ -164,61 +199,64 @@ class Linter:
         if not errors:
             return
 
-        text += errors
-        return self.errors_to_lint_result(rel_fname, text)
-
-
-@dataclass
-class LintResult:
-    text: str
-    lines: list
+        text = f"## Running: {' '.join(flake8_cmd)}\n\n"
+        # convert flake8 output into a LintResult (extract filenames and line numbers)
+        return self.errors_to_lint_result(rel_fname, text + errors)
 
 
-def lint_python_compile(fname, code):
+def lint_python_compile(fname: str, code: str):
+    """Compile Python source, returning error details if compilation fails."""
     try:
-        compile(code, fname, "exec")  # USE TRACEBACK BELOW HERE
+        compile(code, fname, "exec")
         return
     except Exception as err:
+        # Determine the range of lines that may be problematic.
         end_lineno = getattr(err, "end_lineno", err.lineno)
         line_numbers = list(range(err.lineno - 1, end_lineno))
 
-        tb_lines = traceback.format_exception(type(err), err, err.__traceback__)
+        # Produce a traceback that excludes the location
+        # of the file that we are linting (the outermost call).
+        tb_lines = traceback.format_exception(type(err), err,
+                                               err.__traceback__)
+        # Find the stack frame entry containing the
+        # file name of the file we have just
+        # linted.
         last_file_i = 0
 
-        target = "# USE TRACEBACK"
-        target += " BELOW HERE"
-        for i in range(len(tb_lines)):
-            if target in tb_lines[i]:
+        for i, line in enumerate(tb_lines):
+            if "File " in line:
                 last_file_i = i
-                break
 
+        # Skip that entry.
         tb_lines = tb_lines[:1] + tb_lines[last_file_i + 1 :]
 
-    res = "".join(tb_lines)
-    return LintResult(text=res, lines=line_numbers)
+        # Put everything together.
+        res = "".join(tb_lines)
 
+        return LintResult(text=res, lines=line_numbers)
 
-def basic_lint(fname, code):
-    """
-    Use tree-sitter to look for syntax errors, display them with tree context.
-    """
 
+def basic_lint(fname: str, code: str):
+    """Parse a file using tree‑sitter and return a LintResult."""
+    # Try to infer the language from the filename.
     lang = filename_to_lang(fname)
     if not lang:
         return
 
-    # Tree-sitter linter is not capable of working with typescript #1132
+    # Tree‑sitter currently does not know how to parse TypeScript.
     if lang == "typescript":
         return
 
+    # Load the language parser.
     try:
         parser = get_parser(lang)
     except Exception as err:
+        # get_parser may raise a number of different exceptions
+        # depending on the missing language (e.g. OSError).
         print(f"Unable to load parser: {err}")
         return
 
     tree = parser.parse(bytes(code, "utf-8"))
-
     try:
         errors = traverse_tree(tree.root_node)
     except RecursionError:
@@ -226,12 +264,14 @@ def basic_lint(fname, code):
         return
 
     if not errors:
+        # No errors, nothing to return.
         return
 
     return LintResult(text="", lines=errors)
 
 
-def tree_context(fname, code, line_nums):
+def tree_context(fname: str, code: str, line_nums: list[int] | set[int]):
+    """Wrap the TreeContext code in a nicely‑formatted result."""
     context = TreeContext(
         fname,
         code,
@@ -242,7 +282,6 @@ def tree_context(fname, code, line_nums):
         margin=0,
         mark_lois=True,
         loi_pad=3,
-        # header_max=30,
         show_top_of_file_parent_scope=False,
     )
     line_nums = set(line_nums)
@@ -252,53 +291,31 @@ def tree_context(fname, code, line_nums):
     output = f"## See relevant line{s} below marked with █.\n\n"
     output += fname + ":\n"
     output += context.format()
-
     return output
 
 
-# Traverse the tree to find errors
 def traverse_tree(node):
+    """Recursively walk the tree, looking for ERROR‑type nodes."""
     errors = []
     if node.type == "ERROR" or node.is_missing:
-        line_no = node.start_point[0]
-        errors.append(line_no)
-
+        errors.append(node.start_point[0])
     for child in node.children:
-        errors += traverse_tree(child)
-
+        errors.extend(traverse_tree(child))
     return errors
 
 
-def find_filenames_and_linenums(text, fnames):
+def find_filenames_and_linenums(text: str, fnames: list[str]):
     """
-    Search text for all occurrences of <filename>:\\d+ and make a list of them
-    where <filename> is one of the filenames in the list `fnames`.
+    Search text for all occurrences of <filename>:<linenum> patterns where
+    <filename> is one of the filenames in ``fnames``.
+    Returns a mapping `{filename: {linenum, ...}}`.
     """
-    pattern = re.compile(r"(\b(?:" + "|".join(re.escape(fname) for fname in fnames) + r"):\d+\b)")
+    pattern = re.compile(
+        r"(\b(?:" + "|".join(re.escape(fname) for fname in fnames) + r"):\d+\b)"
+    )
     matches = pattern.findall(text)
-    result = {}
+    result: dict[str, set[int]] = {}
     for match in matches:
         fname, linenum = match.rsplit(":", 1)
-        if fname not in result:
-            result[fname] = set()
-        result[fname].add(int(linenum))
-    return result
-
-
-def main():
-    """
-    Main function to parse files provided as command line arguments.
-    """
-    if len(sys.argv) < 2:
-        print("Usage: python linter.py <file1> <file2> ...")
-        sys.exit(1)
-
-    linter = Linter(root=os.getcwd())
-    for file_path in sys.argv[1:]:
-        errors = linter.lint(file_path)
-        if errors:
-            print(errors)
-
-
-if __name__ == "__main__":
-    main()
\ No newline at end of file
+        result.setdefault(fname, set()).add(int(linenum)))
+    return result
\ No newline at end of file
