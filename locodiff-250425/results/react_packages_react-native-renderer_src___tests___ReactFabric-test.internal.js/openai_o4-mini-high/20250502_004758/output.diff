--- react_packages_react-native-renderer_src___tests___ReactFabric-test.internal.js_expectedoutput.txt (expected)+++ react_packages_react-native-renderer_src___tests___ReactFabric-test.internal.js_extracted.txt (actual)@@ -30,6 +30,7 @@   beforeEach(() => {
     jest.resetModules();
 
+    // Initialize the Fabric UI Manager global for tests.
     require('react-native/Libraries/ReactPrivate/InitializeNativeFabricUIManager');
 
     React = require('react');
@@ -37,8 +38,7 @@     ReactFabric = require('react-native-renderer/fabric');
     ReactNativePrivateInterface = require('react-native/Libraries/ReactPrivate/ReactNativePrivateInterface');
     createReactNativeComponentClass =
-      require('react-native/Libraries/ReactPrivate/ReactNativePrivateInterface')
-        .ReactNativeViewConfigRegistry.register;
+      ReactNativePrivateInterface.ReactNativeViewConfigRegistry.register;
     ({act, assertConsoleErrorDev} = require('internal-test-utils'));
   });
 
@@ -69,23 +69,17 @@     await act(() => {
       ReactFabric.render(<View foo="foo" />, 11, null, true);
     });
-
     expect(nativeFabricUIManager.createNode).toHaveBeenCalledTimes(1);
 
     await act(() => {
       ReactFabric.render(<View foo="bar" />, 11, null, true);
     });
-
     expect(nativeFabricUIManager.createNode).toHaveBeenCalledTimes(1);
-    expect(nativeFabricUIManager.cloneNodeWithNewProps).toHaveBeenCalledTimes(
-      1,
-    );
+    expect(nativeFabricUIManager.cloneNodeWithNewProps).toHaveBeenCalledTimes(1);
     expect(nativeFabricUIManager.cloneNodeWithNewProps.mock.calls[0][0]).toBe(
       firstNode,
     );
-    expect(
-      nativeFabricUIManager.cloneNodeWithNewProps.mock.calls[0][1],
-    ).toEqual({
+    expect(nativeFabricUIManager.cloneNodeWithNewProps.mock.calls[0][1]).toEqual({
       foo: 'bar',
     });
   });
@@ -106,7 +100,6 @@       nativeFabricUIManager.cloneNodeWithNewChildrenAndProps,
     ).not.toBeCalled();
 
-    // If no properties have changed, we shouldn't call cloneNode.
     await act(() => {
       ReactFabric.render(<Text foo="a">1</Text>, 11, null, true);
     });
@@ -117,7 +110,6 @@       nativeFabricUIManager.cloneNodeWithNewChildrenAndProps,
     ).not.toBeCalled();
 
-    // Only call cloneNode for the changed property (and not for text).
     await act(() => {
       ReactFabric.render(<Text foo="b">1</Text>, 11, null, true);
     });
@@ -130,7 +122,6 @@       nativeFabricUIManager.cloneNodeWithNewChildrenAndProps,
     ).not.toBeCalled();
 
-    // Only call cloneNode for the changed text (and no other properties).
     await act(() => {
       ReactFabric.render(<Text foo="b">2</Text>, 11, null, true);
     });
@@ -145,7 +136,6 @@       nativeFabricUIManager.cloneNodeWithNewChildrenAndProps,
     ).not.toBeCalled();
 
-    // Call cloneNode for both changed text and properties.
     await act(() => {
       ReactFabric.render(<Text foo="c">3</Text>, 11, null, true);
     });
@@ -199,7 +189,9 @@     ).toEqual({
       bar: 'b',
     });
-    expect(nativeFabricUIManager.__dumpHierarchyForJestTestsOnly()).toBe(`11
+    expect(
+      nativeFabricUIManager.__dumpHierarchyForJestTestsOnly(),
+    ).toBe(`11
  RCTText {"foo":"a","bar":"b"}
    RCTRawText {"text":"1"}`);
 
@@ -223,61 +215,11 @@     ).toEqual({
       foo: 'b',
     });
-    expect(nativeFabricUIManager.__dumpHierarchyForJestTestsOnly()).toBe(`11
+    expect(
+      nativeFabricUIManager.__dumpHierarchyForJestTestsOnly(),
+    ).toBe(`11
  RCTText {"foo":"b","bar":"b"}
    RCTRawText {"text":"2"}`);
-  });
-
-  it('should not clone nodes without children when updating props', async () => {
-    const View = createReactNativeComponentClass('RCTView', () => ({
-      validAttributes: {foo: true},
-      uiViewClassName: 'RCTView',
-    }));
-
-    const Component = ({foo}) => (
-      <View>
-        <View foo={foo} />
-      </View>
-    );
-
-    await act(() =>
-      ReactFabric.render(<Component foo={true} />, 11, null, true),
-    );
-    expect(nativeFabricUIManager.completeRoot).toBeCalled();
-    jest.clearAllMocks();
-
-    await act(() =>
-      ReactFabric.render(<Component foo={false} />, 11, null, true),
-    );
-    expect(nativeFabricUIManager.cloneNode).not.toBeCalled();
-    expect(nativeFabricUIManager.cloneNodeWithNewProps).toHaveBeenCalledTimes(
-      1,
-    );
-    expect(nativeFabricUIManager.cloneNodeWithNewProps).toHaveBeenCalledWith(
-      expect.anything(),
-      {foo: false},
-    );
-
-    expect(
-      nativeFabricUIManager.cloneNodeWithNewChildren,
-    ).toHaveBeenCalledTimes(1);
-    if (gate(flags => flags.passChildrenWhenCloningPersistedNodes)) {
-      expect(
-        nativeFabricUIManager.cloneNodeWithNewChildren,
-      ).toHaveBeenCalledWith(expect.anything(), [
-        expect.objectContaining({props: {foo: false}}),
-      ]);
-      expect(nativeFabricUIManager.appendChild).not.toBeCalled();
-    } else {
-      expect(
-        nativeFabricUIManager.cloneNodeWithNewChildren,
-      ).toHaveBeenCalledWith(expect.anything());
-      expect(nativeFabricUIManager.appendChild).toHaveBeenCalledTimes(1);
-    }
-    expect(
-      nativeFabricUIManager.cloneNodeWithNewChildrenAndProps,
-    ).not.toBeCalled();
-    expect(nativeFabricUIManager.completeRoot).toBeCalled();
   });
 
   // @gate enablePersistedModeClonedFlag
@@ -298,6 +240,8 @@           <ComponentWithEffect />
         </View>,
         11,
+        null,
+        true,
       ),
     );
     expect(nativeFabricUIManager.completeRoot).toBeCalled();
@@ -309,6 +253,8 @@           <ComponentWithEffect />
         </View>,
         11,
+        null,
+        true,
       ),
     );
     expect(nativeFabricUIManager.cloneNode).not.toBeCalled();
@@ -338,6 +284,8 @@           <ComponentWithRef />
         </View>,
         11,
+        null,
+        true,
       ),
     );
     expect(nativeFabricUIManager.completeRoot).toBeCalled();
@@ -349,6 +297,8 @@           <ComponentWithRef />
         </View>,
         11,
+        null,
+        true,
       ),
     );
     expect(nativeFabricUIManager.cloneNode).not.toBeCalled();
@@ -380,6 +330,8 @@           <ComponentWithImperativeHandle ref={ref} />
         </View>,
         11,
+        null,
+        true,
       ),
     );
     expect(nativeFabricUIManager.completeRoot).toBeCalled();
@@ -392,6 +344,8 @@           <ComponentWithImperativeHandle ref={ref} />
         </View>,
         11,
+        null,
+        true,
       ),
     );
     expect(nativeFabricUIManager.cloneNode).not.toBeCalled();
@@ -464,7 +418,6 @@     assertConsoleErrorDev([DISPATCH_COMMAND_REQUIRES_HOST_COMPONENT], {
       withoutStack: true,
     });
-
     expect(nativeFabricUIManager.dispatchCommand).not.toBeCalled();
   });
 
@@ -529,60 +482,7 @@     assertConsoleErrorDev([SEND_ACCESSIBILITY_EVENT_REQUIRES_HOST_COMPONENT], {
       withoutStack: true,
     });
-
     expect(nativeFabricUIManager.sendAccessibilityEvent).not.toBeCalled();
-  });
-
-  it('calls the callback with the correct instance and returns null', async () => {
-    const View = createReactNativeComponentClass('RCTView', () => ({
-      validAttributes: {foo: true},
-      uiViewClassName: 'RCTView',
-    }));
-
-    let a;
-    let b;
-    let c;
-    await act(() => {
-      c = ReactFabric.render(
-        <View foo="foo" ref={v => (a = v)} />,
-        11,
-        function () {
-          b = this;
-        },
-        true,
-      );
-    });
-
-    expect(a).toBeTruthy();
-    expect(a).toBe(b);
-    expect(c).toBe(null);
-  });
-
-  // @gate !disableLegacyMode
-  it('returns the instance in legacy mode and calls the callback with it', () => {
-    const View = createReactNativeComponentClass('RCTView', () => ({
-      validAttributes: {foo: true},
-      uiViewClassName: 'RCTView',
-    }));
-
-    let a;
-    let b;
-    const c = ReactFabric.render(
-      <View
-        foo="foo"
-        ref={v => {
-          a = v;
-        }}
-      />,
-      11,
-      function () {
-        b = this;
-      },
-    );
-
-    expect(a).toBeTruthy();
-    expect(a).toBe(b);
-    expect(a).toBe(c);
   });
 
   it('renders and reorders children', async () => {
@@ -604,352 +504,313 @@       }
     }
 
-    // Mini multi-child stress test: lots of reorders, some adds, some removes.
     const before = 'abcdefghijklmnopqrst';
     const after = 'mxhpgwfralkeoivcstzy';
 
     await act(() => {
       ReactFabric.render(<Component chars={before} />, 11, null, true);
     });
-    expect(nativeFabricUIManager.__dumpHierarchyForJestTestsOnly()).toBe(`11
+    expect(
+      nativeFabricUIManager.__dumpHierarchyForJestTestsOnly(),
+    ).toBe(`11
  RCTView null
-   RCTView {"title":"a"}
-   RCTView {"title":"b"}
-   RCTView {"title":"c"}
-   RCTView {"title":"d"}
-   RCTView {"title":"e"}
-   RCTView {"title":"f"}
-   RCTView {"title":"g"}
-   RCTView {"title":"h"}
-   RCTView {"title":"i"}
-   RCTView {"title":"j"}
-   RCTView {"title":"k"}
-   RCTView {"title":"l"}
-   RCTView {"title":"m"}
-   RCTView {"title":"n"}
-   RCTView {"title":"o"}
-   RCTView {"title":"p"}
-   RCTView {"title":"q"}
-   RCTView {"title":"r"}
-   RCTView {"title":"s"}
-   RCTView {"title":"t"}`);
+   ${before
+     .split('')
+     .map(c => `RCTView {"title":"${c}"}`)
+     .join('\n   ')}`);
 
     await act(() => {
       ReactFabric.render(<Component chars={after} />, 11, null, true);
     });
-    expect(nativeFabricUIManager.__dumpHierarchyForJestTestsOnly()).toBe(`11
+    expect(
+      nativeFabricUIManager.__dumpHierarchyForJestTestsOnly(),
+    ).toBe(`11
  RCTView null
-   RCTView {"title":"m"}
-   RCTView {"title":"x"}
-   RCTView {"title":"h"}
-   RCTView {"title":"p"}
-   RCTView {"title":"g"}
-   RCTView {"title":"w"}
-   RCTView {"title":"f"}
-   RCTView {"title":"r"}
-   RCTView {"title":"a"}
-   RCTView {"title":"l"}
-   RCTView {"title":"k"}
-   RCTView {"title":"e"}
-   RCTView {"title":"o"}
-   RCTView {"title":"i"}
-   RCTView {"title":"v"}
-   RCTView {"title":"c"}
-   RCTView {"title":"s"}
-   RCTView {"title":"t"}
-   RCTView {"title":"z"}
-   RCTView {"title":"y"}`);
-  });
-
-  it('recreates host parents even if only children changed', async () => {
-    const View = createReactNativeComponentClass('RCTView', () => ({
-      validAttributes: {title: true},
-      uiViewClassName: 'RCTView',
-    }));
-
-    const before = 'abcdefghijklmnopqrst';
-    const after = 'mxhpgwfralkeoivcstzy';
-
-    class Component extends React.Component {
-      state = {
-        chars: before,
-      };
+   ${after
+     .split('')
+     .map(c => `RCTView {"title":"${c}"}`)
+     .join('\n   ')}`);
+  });
+
+  // Find DOM handle deprecation and warnings
+
+  it('findHostInstance_DEPRECATED should warn if used to find a host component inside StrictMode', async () => {
+    const View = createReactNativeComponentClass('RCTView', () => ({
+      validAttributes: {foo: true},
+      uiViewClassName: 'RCTView',
+    }));
+
+    let parent, child;
+    class ContainsStrictModeChild extends React.Component {
       render() {
-        const chars = this.state.chars.split('');
         return (
-          <View>
-            {chars.map(text => (
-              <View key={text} title={text} />
-            ))}
-          </View>
+          <StrictMode>
+            <View ref={n => (child = n)} />
+          </StrictMode>
         );
       }
     }
 
-    const ref = React.createRef();
-    // Wrap in a host node.
-    await act(() => {
-      ReactFabric.render(
-        <View>
-          <Component ref={ref} />
-        </View>,
-        11,
-        null,
-        true,
-      );
-    });
-    expect(nativeFabricUIManager.__dumpHierarchyForJestTestsOnly()).toBe(
-      `11
- RCTView null
-   RCTView null
-     RCTView {"title":"a"}
-     RCTView {"title":"b"}
-     RCTView {"title":"c"}
-     RCTView {"title":"d"}
-     RCTView {"title":"e"}
-     RCTView {"title":"f"}
-     RCTView {"title":"g"}
-     RCTView {"title":"h"}
-     RCTView {"title":"i"}
-     RCTView {"title":"j"}
-     RCTView {"title":"k"}
-     RCTView {"title":"l"}
-     RCTView {"title":"m"}
-     RCTView {"title":"n"}
-     RCTView {"title":"o"}
-     RCTView {"title":"p"}
-     RCTView {"title":"q"}
-     RCTView {"title":"r"}
-     RCTView {"title":"s"}
-     RCTView {"title":"t"}`,
-    );
-
-    // Call setState() so that we skip over the top-level host node.
-    // It should still get recreated despite a bailout.
-    await act(() => {
-      ref.current.setState({
-        chars: after,
-      });
-    });
-    expect(nativeFabricUIManager.__dumpHierarchyForJestTestsOnly()).toBe(`11
- RCTView null
-   RCTView null
-     RCTView {"title":"m"}
-     RCTView {"title":"x"}
-     RCTView {"title":"h"}
-     RCTView {"title":"p"}
-     RCTView {"title":"g"}
-     RCTView {"title":"w"}
-     RCTView {"title":"f"}
-     RCTView {"title":"r"}
-     RCTView {"title":"a"}
-     RCTView {"title":"l"}
-     RCTView {"title":"k"}
-     RCTView {"title":"e"}
-     RCTView {"title":"o"}
-     RCTView {"title":"i"}
-     RCTView {"title":"v"}
-     RCTView {"title":"c"}
-     RCTView {"title":"s"}
-     RCTView {"title":"t"}
-     RCTView {"title":"z"}
-     RCTView {"title":"y"}`);
-  });
-
-  it('calls setState with no arguments', async () => {
-    let mockArgs;
-    class Component extends React.Component {
-      componentDidMount() {
-        this.setState({}, (...args) => (mockArgs = args));
-      }
+    await act(() => {
+      ReactFabric.render(<ContainsStrictModeChild ref={n => (parent = n)} />, 11, null, true);
+    });
+
+    const match = ReactFabric.findHostInstance_DEPRECATED(parent);
+    assertConsoleErrorDev([
+      'findHostInstance_DEPRECATED is deprecated in StrictMode. ' +
+        'findHostInstance_DEPRECATED was passed an instance of ContainsStrictModeChild which renders StrictMode children. ' +
+        'Instead, add a ref directly to the element you want to reference. ' +
+        'Learn more about using refs safely here: ' +
+        'https://react.dev/link/strict-mode-find-node' +
+        '\n    in RCTView (at **)' +
+        '\n    in ContainsStrictModeChild (at **)',
+    ]);
+    expect(match).toBe(child);
+  });
+
+  it('findHostInstance_DEPRECATED should warn if passed a component that is inside StrictMode', async () => {
+    const View = createReactNativeComponentClass('RCTView', () => ({
+      validAttributes: {foo: true},
+      uiViewClassName: 'RCTView',
+    }));
+
+    let parent, child;
+    class IsInStrictMode extends React.Component {
       render() {
-        return false;
+        return <View ref={n => (child = n)} />;
       }
     }
 
     await act(() => {
-      ReactFabric.render(<Component />, 11, null, true);
-    });
-    expect(mockArgs.length).toEqual(0);
-  });
-
-  it('should call complete after inserting children', async () => {
-    const View = createReactNativeComponentClass('RCTView', () => ({
-      validAttributes: {foo: true},
-      uiViewClassName: 'RCTView',
-    }));
-
-    const snapshots = [];
-    nativeFabricUIManager.completeRoot.mockImplementation(
-      function (rootTag, newChildSet) {
-        snapshots.push(
-          nativeFabricUIManager.__dumpChildSetForJestTestsOnly(newChildSet),
+      ReactFabric.render(
+        <StrictMode>
+          <IsInStrictMode ref={n => (parent = n)} />
+        </StrictMode>,
+        11,
+        null,
+        true,
+      );
+    });
+
+    const match = ReactFabric.findHostInstance_DEPRECATED(parent);
+    assertConsoleErrorDev([
+      'findHostInstance_DEPRECATED is deprecated in StrictMode. ' +
+        'findHostInstance_DEPRECATED was passed an instance of IsInStrictMode which is inside StrictMode. ' +
+        'Instead, add a ref directly to the element you want to reference. ' +
+        'Learn more about using refs safely here: ' +
+        'https://react.dev/link/strict-mode-find-node' +
+        '\n    in RCTView (at **)' +
+        '\n    in IsInStrictMode (at **)',
+    ]);
+    expect(match).toBe(child);
+  });
+
+  it('findNodeHandle should warn if used to find a host component inside StrictMode', async () => {
+    const View = createReactNativeComponentClass('RCTView', () => ({
+      validAttributes: {foo: true},
+      uiViewClassName: 'RCTView',
+    }));
+
+    let parent, child;
+    class ContainsStrictModeChild extends React.Component {
+      render() {
+        return (
+          <StrictMode>
+            <View ref={n => (child = n)} />
+          </StrictMode>
         );
-      },
-    );
-
-    await act(() => {
-      ReactFabric.render(
-        <View foo="a">
-          <View foo="b" />
-        </View>,
-        22,
-        null,
-        true,
-      );
-    });
-    expect(snapshots).toEqual([
-      `RCTView {"foo":"a"}
-  RCTView {"foo":"b"}`,
+      }
+    }
+
+    await act(() => {
+      ReactFabric.render(<ContainsStrictModeChild ref={n => (parent = n)} />, 11, null, true);
+    });
+
+    const match = ReactFabric.findNodeHandle(parent);
+    assertConsoleErrorDev([
+      'findNodeHandle is deprecated in StrictMode. ' +
+        'findNodeHandle was passed an instance of ContainsStrictModeChild which renders StrictMode children. ' +
+        'Instead, add a ref directly to the element you want to reference. ' +
+        'Learn more about using refs safely here: ' +
+        'https://react.dev/link/strict-mode-find-node' +
+        '\n    in RCTView (at **)' +
+        '\n    in ContainsStrictModeChild (at **)',
     ]);
-  });
-
-  it('should not throw when <View> is used inside of a <Text> ancestor', async () => {
-    const Image = createReactNativeComponentClass('RCTImage', () => ({
-      validAttributes: {},
-      uiViewClassName: 'RCTImage',
-    }));
-    const Text = createReactNativeComponentClass('RCTText', () => ({
+    expect(match).toBe(ReactNativePrivateInterface.getNativeTagFromPublicInstance(child));
+  });
+
+  it('findNodeHandle should warn if passed a component that is inside StrictMode', async () => {
+    const View = createReactNativeComponentClass('RCTView', () => ({
+      validAttributes: {foo: true},
+      uiViewClassName: 'RCTView',
+    }));
+
+    let parent, child;
+    class IsInStrictMode extends React.Component {
+      render() {
+        return <View ref={n => (child = n)} />;
+      }
+    }
+
+    await act(() => {
+      ReactFabric.render(
+        <StrictMode>
+          <IsInStrictMode ref={n => (parent = n)} />
+        </StrictMode>,
+        11,
+        null,
+        true,
+      );
+    });
+
+    const match = ReactFabric.findNodeHandle(parent);
+    assertConsoleErrorDev([
+      'findNodeHandle is deprecated in StrictMode. ' +
+        'findNodeHandle was passed an instance of IsInStrictMode which is inside StrictMode. ' +
+        'Instead, add a ref directly to the element you want to reference. ' +
+        'Learn more about using refs safely here: ' +
+        'https://react.dev/link/strict-mode-find-node' +
+        '\n    in RCTView (at **)' +
+        '\n    in IsInStrictMode (at **)',
+    ]);
+    expect(match).toBe(ReactNativePrivateInterface.getNativeTagFromPublicInstance(child));
+  });
+
+  it('should no-op if calling sendAccessibilityEvent on unmounted refs', async () => {
+    const View = createReactNativeComponentClass('RCTView', () => ({
+      validAttributes: {foo: true},
+      uiViewClassName: 'RCTView',
+    }));
+
+    nativeFabricUIManager.sendAccessibilityEvent.mockReset();
+
+    let viewRef;
+    await act(() => {
+      ReactFabric.render(
+        <View ref={ref => { viewRef = ref }} />,
+        11,
+        null,
+        true,
+      );
+    });
+    const dangerouslyRetainedViewRef = viewRef;
+
+    await act(() => {
+      ReactFabric.stopSurface(11);
+    });
+
+    ReactFabric.sendAccessibilityEvent(
+      dangerouslyRetainedViewRef,
+      'eventTypeName',
+    );
+    expect(nativeFabricUIManager.sendAccessibilityEvent).not.toBeCalled();
+  });
+
+  it('getNodeFromInternalInstanceHandle should return the correct shadow node', async () => {
+    const View = createReactNativeComponentClass('RCTView', () => ({
+      validAttributes: {foo: true},
+      uiViewClassName: 'RCTView',
+    }));
+
+    await act(() => {
+      ReactFabric.render(<View foo="test" />, 1, null, true);
+    });
+
+    // The internal handle is the 5th argument to createNode
+    const internalInstanceHandle =
+      nativeFabricUIManager.createNode.mock.calls[0][4];
+    expect(internalInstanceHandle).toEqual(expect.any(Object));
+
+    const expectedShadowNode =
+      nativeFabricUIManager.createNode.mock.results[0].value;
+    expect(expectedShadowNode).toEqual(expect.any(Object));
+
+    expect(
+      ReactFabric.getNodeFromInternalInstanceHandle(internalInstanceHandle),
+    ).toBe(expectedShadowNode);
+  });
+
+  it('getPublicInstanceFromInternalInstanceHandle should provide public instances for HostComponent', async () => {
+    const View = createReactNativeComponentClass('RCTView', () => ({
+      validAttributes: {foo: true},
+      uiViewClassName: 'RCTView',
+    }));
+
+    let viewRef;
+    await act(() => {
+      ReactFabric.render(
+        <View foo="test" ref={ref => (viewRef = ref)} />,
+        1,
+        null,
+        true,
+      );
+    });
+
+    const internalInstanceHandle =
+      nativeFabricUIManager.createNode.mock.calls[0][4];
+    expect(internalInstanceHandle).toEqual(expect.any(Object));
+
+    const publicInstance =
+      ReactFabric.getPublicInstanceFromInternalInstanceHandle(
+        internalInstanceHandle,
+      );
+    expect(publicInstance).toBe(viewRef);
+
+    await act(() => {
+      ReactFabric.render(null, 1, null, true);
+    });
+    const publicInstanceAfterUnmount =
+      ReactFabric.getPublicInstanceFromInternalInstanceHandle(
+        internalInstanceHandle,
+      );
+    expect(publicInstanceAfterUnmount).toBe(null);
+  });
+
+  it('getPublicInstanceFromInternalInstanceHandle should provide public instances for HostText', async () => {
+    jest.spyOn(ReactNativePrivateInterface, 'createPublicTextInstance');
+
+    const RCTText = createReactNativeComponentClass('RCTText', () => ({
       validAttributes: {},
       uiViewClassName: 'RCTText',
     }));
-    const View = createReactNativeComponentClass('RCTView', () => ({
-      validAttributes: {},
-      uiViewClassName: 'RCTView',
-    }));
-
-    await act(() => {
-      ReactFabric.render(
-        <Text>
-          <View />
-        </Text>,
-        11,
-        null,
-        true,
-      );
-    });
-
-    await act(() => {
-      ReactFabric.render(
-        <Text>
-          <Image />
-        </Text>,
-        11,
-        null,
-        true,
-      );
-    });
-  });
-
-  it('should console error for text not inside of a <Text> ancestor', async () => {
-    const ScrollView = createReactNativeComponentClass('RCTScrollView', () => ({
-      validAttributes: {},
-      uiViewClassName: 'RCTScrollView',
-    }));
-    const Text = createReactNativeComponentClass('RCTText', () => ({
-      validAttributes: {},
-      uiViewClassName: 'RCTText',
-    }));
-    const View = createReactNativeComponentClass('RCTView', () => ({
-      validAttributes: {},
-      uiViewClassName: 'RCTView',
-    }));
-
-    await act(() => {
-      ReactFabric.render(<View>this should warn</View>, 11, null, true);
-    });
-    assertConsoleErrorDev([
-      'Text strings must be rendered within a <Text> component.\n' +
-        '    in RCTView (at **)',
-    ]);
-
-    await act(() => {
-      ReactFabric.render(
-        <Text>
-          <ScrollView>hi hello hi</ScrollView>
-        </Text>,
-        11,
-        null,
-        true,
-      );
-    });
-    assertConsoleErrorDev([
-      'Text strings must be rendered within a <Text> component.\n' +
-        '    in RCTScrollView (at **)',
-    ]);
-  });
-
-  it('should not throw for text inside of an indirect <Text> ancestor', async () => {
-    const Text = createReactNativeComponentClass('RCTText', () => ({
-      validAttributes: {},
-      uiViewClassName: 'RCTText',
-    }));
-
-    const Indirection = () => 'Hi';
-
-    await act(() => {
-      ReactFabric.render(
-        <Text>
-          <Indirection />
-        </Text>,
-        11,
-        null,
-        true,
-      );
-    });
-  });
-
-  it('dispatches events to the last committed props', async () => {
-    const View = createReactNativeComponentClass('RCTView', () => ({
-      validAttributes: {},
-      uiViewClassName: 'RCTView',
-      directEventTypes: {
-        topTouchStart: {
-          registrationName: 'onTouchStart',
-        },
-      },
-    }));
-
-    const touchStart = jest.fn();
-    const touchStart2 = jest.fn();
-
-    await act(() => {
-      ReactFabric.render(<View onTouchStart={touchStart} />, 11, null, true);
-    });
-
-    expect(nativeFabricUIManager.createNode.mock.calls.length).toBe(1);
-    expect(nativeFabricUIManager.registerEventHandler.mock.calls.length).toBe(
-      1,
-    );
-
-    const [, , , , instanceHandle] =
-      nativeFabricUIManager.createNode.mock.calls[0];
-    const [dispatchEvent] =
-      nativeFabricUIManager.registerEventHandler.mock.calls[0];
-
-    const touchEvent = {
-      touches: [],
-      changedTouches: [],
-    };
-
-    expect(touchStart).not.toBeCalled();
-
-    dispatchEvent(instanceHandle, 'topTouchStart', touchEvent);
-
-    expect(touchStart).toBeCalled();
-    expect(touchStart2).not.toBeCalled();
-
-    await act(() => {
-      ReactFabric.render(<View onTouchStart={touchStart2} />, 11, null, true);
-    });
-
-    // Intentionally dispatch to the same instanceHandle again.
-    dispatchEvent(instanceHandle, 'topTouchStart', touchEvent);
-
-    // The current semantics dictate that we always dispatch to the last committed
-    // props even though the actual scheduling of the event could have happened earlier.
-    // This could change in the future.
-    expect(touchStart2).toBeCalled();
+
+    await act(() => {
+      ReactFabric.render(<RCTText>Text content</RCTText>, 1, null, true);
+    });
+
+    const internalInstanceHandle =
+      nativeFabricUIManager.createNode.mock.calls[0][4];
+    expect(internalInstanceHandle).toEqual(expect.any(Object));
+
+    // Instances are created lazily
+    expect(
+      ReactNativePrivateInterface.createPublicTextInstance,
+    ).not.toHaveBeenCalled();
+
+    const publicInstance =
+      ReactFabric.getPublicInstanceFromInternalInstanceHandle(
+        internalInstanceHandle,
+      );
+    expect(
+      ReactNativePrivateInterface.createPublicTextInstance,
+    ).toHaveBeenCalledTimes(1);
+    expect(
+      ReactNativePrivateInterface.createPublicTextInstance,
+    ).toHaveBeenCalledWith(internalInstanceHandle);
+
+    const expectedPublicInstance =
+      ReactNativePrivateInterface.createPublicTextInstance.mock.results[0]
+        .value;
+    expect(publicInstance).toBe(expectedPublicInstance);
+
+    await act(() => {
+      ReactFabric.render(null, 1, null, true);
+    });
+    const publicInstanceAfterUnmount =
+      ReactFabric.getPublicInstanceFromInternalInstanceHandle(
+        internalInstanceHandle,
+      );
+    expect(publicInstanceAfterUnmount).toBe(null);
   });
 
   describe('skipBubbling', () => {
@@ -1025,6 +886,7 @@       expect(targetCapture).toHaveBeenCalledTimes(1);
       expect(ancestorCapture).toHaveBeenCalledTimes(1);
       expect(ancestorBubble).toHaveBeenCalledTimes(1);
+
       ancestorBubble.mockReset();
       ancestorCapture.mockReset();
       targetBubble.mockReset();
@@ -1035,6 +897,7 @@       expect(targetCapture).toHaveBeenCalledTimes(1);
       expect(ancestorCapture).toHaveBeenCalledTimes(1);
       expect(ancestorBubble).toHaveBeenCalledTimes(1);
+
       ancestorBubble.mockReset();
       ancestorCapture.mockReset();
       targetBubble.mockReset();
@@ -1048,261 +911,56 @@     });
   });
 
-  it('dispatches event with target as instance', async () => {
-    const View = createReactNativeComponentClass('RCTView', () => ({
-      validAttributes: {
-        id: true,
-      },
-      uiViewClassName: 'RCTView',
-      directEventTypes: {
-        topTouchStart: {
-          registrationName: 'onTouchStart',
-        },
-        topTouchEnd: {
-          registrationName: 'onTouchEnd',
-        },
-      },
-    }));
-
-    function getViewById(id) {
-      const [reactTag, , , , instanceHandle] =
-        nativeFabricUIManager.createNode.mock.calls.find(
-          args => args[3] && args[3].id === id,
-        );
-
-      return {reactTag, instanceHandle};
+  it('should not clone nodes without children when updating props', async () => {
+    const View = createReactNativeComponentClass('RCTView', () => ({
+      validAttributes: {foo: true},
+      uiViewClassName: 'RCTView',
+    }));
+
+    const Component = ({foo}) => (
+      <View>
+        <View foo={foo} />
+      </View>
+    );
+
+    await act(() =>
+      ReactFabric.render(<Component foo={true} />, 11, null, true),
+    );
+    expect(nativeFabricUIManager.completeRoot).toBeCalled();
+    jest.clearAllMocks();
+
+    await act(() =>
+      ReactFabric.render(<Component foo={false} />, 11, null, true),
+    );
+    expect(nativeFabricUIManager.cloneNode).not.toBeCalled();
+    expect(nativeFabricUIManager.cloneNodeWithNewProps).toHaveBeenCalledTimes(
+      1,
+    );
+    expect(nativeFabricUIManager.cloneNodeWithNewProps).toHaveBeenCalledWith(
+      expect.anything(),
+      {foo: false},
+    );
+
+    expect(
+      nativeFabricUIManager.cloneNodeWithNewChildren,
+    ).toHaveBeenCalledTimes(1);
+    if (gate(flags => flags.passChildrenWhenCloningPersistedNodes)) {
+      expect(
+        nativeFabricUIManager.cloneNodeWithNewChildren,
+      ).toHaveBeenCalledWith(expect.anything(), [
+        expect.objectContaining({props: {foo: false}}),
+      ]);
+      expect(nativeFabricUIManager.appendChild).not.toBeCalled();
+    } else {
+      expect(
+        nativeFabricUIManager.cloneNodeWithNewChildren,
+      ).toHaveBeenCalledWith(expect.anything());
+      expect(nativeFabricUIManager.appendChild).toHaveBeenCalledTimes(1);
     }
-
-    const ref1 = React.createRef();
-    const ref2 = React.createRef();
-
-    await act(() => {
-      ReactFabric.render(
-        <View id="parent">
-          <View
-            ref={ref1}
-            id="one"
-            onResponderStart={event => {
-              expect(ref1.current).not.toBeNull();
-              // Check for referential equality
-              expect(ref1.current).toBe(event.target);
-              expect(ref1.current).toBe(event.currentTarget);
-            }}
-            onStartShouldSetResponder={() => true}
-          />
-          <View
-            ref={ref2}
-            id="two"
-            onResponderStart={event => {
-              expect(ref2.current).not.toBeNull();
-              // Check for referential equality
-              expect(ref2.current).toBe(event.target);
-              expect(ref2.current).toBe(event.currentTarget);
-            }}
-            onStartShouldSetResponder={() => true}
-          />
-        </View>,
-        1,
-        null,
-        true,
-      );
-    });
-
-    const [dispatchEvent] =
-      nativeFabricUIManager.registerEventHandler.mock.calls[0];
-
-    dispatchEvent(getViewById('one').instanceHandle, 'topTouchStart', {
-      target: getViewById('one').reactTag,
-      identifier: 17,
-      touches: [],
-      changedTouches: [],
-    });
-    dispatchEvent(getViewById('one').instanceHandle, 'topTouchEnd', {
-      target: getViewById('one').reactTag,
-      identifier: 17,
-      touches: [],
-      changedTouches: [],
-    });
-
-    dispatchEvent(getViewById('two').instanceHandle, 'topTouchStart', {
-      target: getViewById('two').reactTag,
-      identifier: 17,
-      touches: [],
-      changedTouches: [],
-    });
-
-    dispatchEvent(getViewById('two').instanceHandle, 'topTouchEnd', {
-      target: getViewById('two').reactTag,
-      identifier: 17,
-      touches: [],
-      changedTouches: [],
-    });
-
-    expect.assertions(6);
-  });
-
-  it('findHostInstance_DEPRECATED should warn if used to find a host component inside StrictMode', async () => {
-    const View = createReactNativeComponentClass('RCTView', () => ({
-      validAttributes: {foo: true},
-      uiViewClassName: 'RCTView',
-    }));
-
-    let parent = undefined;
-    let child = undefined;
-
-    class ContainsStrictModeChild extends React.Component {
-      render() {
-        return (
-          <StrictMode>
-            <View ref={n => (child = n)} />
-          </StrictMode>
-        );
-      }
-    }
-
-    await act(() => {
-      ReactFabric.render(
-        <ContainsStrictModeChild ref={n => (parent = n)} />,
-        11,
-        null,
-        true,
-      );
-    });
-
-    const match = ReactFabric.findHostInstance_DEPRECATED(parent);
-    assertConsoleErrorDev([
-      'findHostInstance_DEPRECATED is deprecated in StrictMode. ' +
-        'findHostInstance_DEPRECATED was passed an instance of ContainsStrictModeChild which renders StrictMode children. ' +
-        'Instead, add a ref directly to the element you want to reference. ' +
-        'Learn more about using refs safely here: ' +
-        'https://react.dev/link/strict-mode-find-node' +
-        '\n    in RCTView (at **)' +
-        '\n    in ContainsStrictModeChild (at **)',
-    ]);
-    expect(match).toBe(child);
-  });
-
-  it('findHostInstance_DEPRECATED should warn if passed a component that is inside StrictMode', async () => {
-    const View = createReactNativeComponentClass('RCTView', () => ({
-      validAttributes: {foo: true},
-      uiViewClassName: 'RCTView',
-    }));
-
-    let parent = undefined;
-    let child = undefined;
-
-    class IsInStrictMode extends React.Component {
-      render() {
-        return <View ref={n => (child = n)} />;
-      }
-    }
-
-    await act(() => {
-      ReactFabric.render(
-        <StrictMode>
-          <IsInStrictMode ref={n => (parent = n)} />
-        </StrictMode>,
-        11,
-        null,
-        true,
-      );
-    });
-
-    const match = ReactFabric.findHostInstance_DEPRECATED(parent);
-    assertConsoleErrorDev([
-      'findHostInstance_DEPRECATED is deprecated in StrictMode. ' +
-        'findHostInstance_DEPRECATED was passed an instance of IsInStrictMode which is inside StrictMode. ' +
-        'Instead, add a ref directly to the element you want to reference. ' +
-        'Learn more about using refs safely here: ' +
-        'https://react.dev/link/strict-mode-find-node' +
-        '\n    in RCTView (at **)' +
-        '\n    in IsInStrictMode (at **)',
-    ]);
-    expect(match).toBe(child);
-  });
-
-  it('findNodeHandle should warn if used to find a host component inside StrictMode', async () => {
-    const View = createReactNativeComponentClass('RCTView', () => ({
-      validAttributes: {foo: true},
-      uiViewClassName: 'RCTView',
-    }));
-
-    let parent = undefined;
-    let child = undefined;
-
-    class ContainsStrictModeChild extends React.Component {
-      render() {
-        return (
-          <StrictMode>
-            <View ref={n => (child = n)} />
-          </StrictMode>
-        );
-      }
-    }
-
-    await act(() => {
-      ReactFabric.render(
-        <ContainsStrictModeChild ref={n => (parent = n)} />,
-        11,
-        null,
-        true,
-      );
-    });
-
-    const match = ReactFabric.findNodeHandle(parent);
-    assertConsoleErrorDev([
-      'findNodeHandle is deprecated in StrictMode. ' +
-        'findNodeHandle was passed an instance of ContainsStrictModeChild which renders StrictMode children. ' +
-        'Instead, add a ref directly to the element you want to reference. ' +
-        'Learn more about using refs safely here: ' +
-        'https://react.dev/link/strict-mode-find-node' +
-        '\n    in RCTView (at **)' +
-        '\n    in ContainsStrictModeChild (at **)',
-    ]);
-    expect(match).toBe(
-      ReactNativePrivateInterface.getNativeTagFromPublicInstance(child),
-    );
-  });
-
-  it('findNodeHandle should warn if passed a component that is inside StrictMode', async () => {
-    const View = createReactNativeComponentClass('RCTView', () => ({
-      validAttributes: {foo: true},
-      uiViewClassName: 'RCTView',
-    }));
-
-    let parent = undefined;
-    let child = undefined;
-
-    class IsInStrictMode extends React.Component {
-      render() {
-        return <View ref={n => (child = n)} />;
-      }
-    }
-
-    await act(() => {
-      ReactFabric.render(
-        <StrictMode>
-          <IsInStrictMode ref={n => (parent = n)} />
-        </StrictMode>,
-        11,
-        null,
-        true,
-      );
-    });
-
-    const match = ReactFabric.findNodeHandle(parent);
-    assertConsoleErrorDev([
-      'findNodeHandle is deprecated in StrictMode. ' +
-        'findNodeHandle was passed an instance of IsInStrictMode which is inside StrictMode. ' +
-        'Instead, add a ref directly to the element you want to reference. ' +
-        'Learn more about using refs safely here: ' +
-        'https://react.dev/link/strict-mode-find-node' +
-        '\n    in RCTView (at **)' +
-        '\n    in IsInStrictMode (at **)',
-    ]);
-    expect(match).toBe(
-      ReactNativePrivateInterface.getNativeTagFromPublicInstance(child),
-    );
+    expect(
+      nativeFabricUIManager.cloneNodeWithNewChildrenAndProps,
+    ).not.toBeCalled();
+    expect(nativeFabricUIManager.completeRoot).toBeCalled();
   });
 
   it('findNodeHandle errors when called from render', async () => {
@@ -1312,16 +970,16 @@         return null;
       }
     }
-    await act(() => {
-      ReactFabric.render(<TestComponent />, 11, null, true);
-    });
-    assertConsoleErrorDev([
+    await expect(async () => {
+      await act(() => {
+        ReactFabric.render(<TestComponent />, 11, null, true);
+      });
+    }).toErrorDev([
       'TestComponent is accessing findNodeHandle inside its render(). ' +
         'render() should be a pure function of props and state. It should ' +
         'never access something that requires stale data from the previous ' +
         'render, such as refs. Move this logic to componentDidMount and ' +
-        'componentDidUpdate instead.\n' +
-        '    in TestComponent (at **)',
+        'componentDidUpdate instead.',
     ]);
   });
 
@@ -1338,156 +996,4 @@       ReactFabric.render(<TestComponent />, 11, null, true);
     });
   });
-
-  it('should no-op if calling sendAccessibilityEvent on unmounted refs', async () => {
-    const View = createReactNativeComponentClass('RCTView', () => ({
-      validAttributes: {foo: true},
-      uiViewClassName: 'RCTView',
-    }));
-
-    nativeFabricUIManager.sendAccessibilityEvent.mockReset();
-
-    let viewRef;
-    await act(() => {
-      ReactFabric.render(
-        <View
-          ref={ref => {
-            viewRef = ref;
-          }}
-        />,
-        11,
-        null,
-        true,
-      );
-    });
-    const dangerouslyRetainedViewRef = viewRef;
-    await act(() => {
-      ReactFabric.stopSurface(11);
-    });
-
-    ReactFabric.sendAccessibilityEvent(
-      dangerouslyRetainedViewRef,
-      'eventTypeName',
-    );
-
-    expect(nativeFabricUIManager.sendAccessibilityEvent).not.toBeCalled();
-  });
-
-  it('getNodeFromInternalInstanceHandle should return the correct shadow node', async () => {
-    const View = createReactNativeComponentClass('RCTView', () => ({
-      validAttributes: {foo: true},
-      uiViewClassName: 'RCTView',
-    }));
-
-    await act(() => {
-      ReactFabric.render(<View foo="test" />, 1, null, true);
-    });
-
-    const internalInstanceHandle =
-      nativeFabricUIManager.createNode.mock.calls[0][4];
-    expect(internalInstanceHandle).toEqual(expect.any(Object));
-
-    const expectedShadowNode =
-      nativeFabricUIManager.createNode.mock.results[0].value;
-    expect(expectedShadowNode).toEqual(expect.any(Object));
-
-    const node = ReactFabric.getNodeFromInternalInstanceHandle(
-      internalInstanceHandle,
-    );
-    expect(node).toBe(expectedShadowNode);
-  });
-
-  it('getPublicInstanceFromInternalInstanceHandle should provide public instances for HostComponent', async () => {
-    const View = createReactNativeComponentClass('RCTView', () => ({
-      validAttributes: {foo: true},
-      uiViewClassName: 'RCTView',
-    }));
-
-    let viewRef;
-    await act(() => {
-      ReactFabric.render(
-        <View
-          foo="test"
-          ref={ref => {
-            viewRef = ref;
-          }}
-        />,
-        1,
-        null,
-        true,
-      );
-    });
-
-    const internalInstanceHandle =
-      nativeFabricUIManager.createNode.mock.calls[0][4];
-    expect(internalInstanceHandle).toEqual(expect.any(Object));
-
-    const publicInstance =
-      ReactFabric.getPublicInstanceFromInternalInstanceHandle(
-        internalInstanceHandle,
-      );
-    expect(publicInstance).toBe(viewRef);
-
-    await act(() => {
-      ReactFabric.render(null, 1, null, true);
-    });
-
-    const publicInstanceAfterUnmount =
-      ReactFabric.getPublicInstanceFromInternalInstanceHandle(
-        internalInstanceHandle,
-      );
-    expect(publicInstanceAfterUnmount).toBe(null);
-  });
-
-  it('getPublicInstanceFromInternalInstanceHandle should provide public instances for HostText', async () => {
-    jest.spyOn(ReactNativePrivateInterface, 'createPublicTextInstance');
-
-    const RCTText = createReactNativeComponentClass('RCTText', () => ({
-      validAttributes: {},
-      uiViewClassName: 'RCTText',
-    }));
-
-    await act(() => {
-      ReactFabric.render(<RCTText>Text content</RCTText>, 1, null, true);
-    });
-
-    // Access the internal instance handle used to create the text node.
-    const internalInstanceHandle =
-      nativeFabricUIManager.createNode.mock.calls[0][4];
-    expect(internalInstanceHandle).toEqual(expect.any(Object));
-
-    // Text public instances should be created lazily.
-    expect(
-      ReactNativePrivateInterface.createPublicTextInstance,
-    ).not.toHaveBeenCalled();
-
-    const publicInstance =
-      ReactFabric.getPublicInstanceFromInternalInstanceHandle(
-        internalInstanceHandle,
-      );
-
-    // We just requested the text public instance, so it should have been created at this point.
-    expect(
-      ReactNativePrivateInterface.createPublicTextInstance,
-    ).toHaveBeenCalledTimes(1);
-    expect(
-      ReactNativePrivateInterface.createPublicTextInstance,
-    ).toHaveBeenCalledWith(internalInstanceHandle);
-
-    const expectedPublicInstance =
-      ReactNativePrivateInterface.createPublicTextInstance.mock.results[0]
-        .value;
-    expect(publicInstance).toBe(expectedPublicInstance);
-
-    await act(() => {
-      ReactFabric.render(null, 1, null, true);
-    });
-
-    const publicInstanceAfterUnmount =
-      ReactFabric.getPublicInstanceFromInternalInstanceHandle(
-        internalInstanceHandle,
-      );
-
-    expect(publicInstanceAfterUnmount).toBe(null);
-  });
 });