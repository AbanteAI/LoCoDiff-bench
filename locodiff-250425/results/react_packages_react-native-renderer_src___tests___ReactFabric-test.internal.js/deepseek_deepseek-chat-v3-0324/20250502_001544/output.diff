
index eff89da7..786e6fc7 100644
--- a/react_packages_react-native-renderer_src___tests___ReactFabric-test.internal.js_expectedoutput.txt (expected):tmp/tmpabrzenhi_expected.txt	
+++ b/react_packages_react-native-renderer_src___tests___ReactFabric-test.internal.js_extracted.txt (actual):tmp/tmpomgzpww1_actual.txt	
@@ -83,11 +83,11 @@ describe('ReactFabric', () => {
     expect(nativeFabricUIManager.cloneNodeWithNewProps.mock.calls[0][0]).toBe(
       firstNode,
     );
-    expect(
-      nativeFabricUIManager.cloneNodeWithNewProps.mock.calls[0][1],
-    ).toEqual({
-      foo: 'bar',
-    });
+    expect(nativeFabricUIManager.cloneNodeWithNewProps.mock.calls[0][1]).toEqual(
+      {
+        foo: 'bar',
+      },
+    );
   });
 
   it('should not call FabricUIManager.cloneNode after render for properties that have not changed', async () => {
@@ -429,11 +429,9 @@ describe('ReactFabric', () => {
     expect(nativeFabricUIManager.dispatchCommand).not.toBeCalled();
     ReactFabric.dispatchCommand(viewRef, 'updateCommand', [10, 20]);
     expect(nativeFabricUIManager.dispatchCommand).toHaveBeenCalledTimes(1);
-    expect(nativeFabricUIManager.dispatchCommand).toHaveBeenCalledWith(
-      expect.any(Object),
-      'updateCommand',
-      [10, 20],
-    );
+    expect(
+      nativeFabricUIManager.dispatchCommand,
+    ).toHaveBeenCalledWith(expect.any(Object), 'updateCommand', [10, 20]);
   });
 
   it('should warn and no-op if calling dispatchCommand on non native refs', async () => {
@@ -815,628 +813,11 @@ describe('ReactFabric', () => {
     }));
     const View = createReactNativeComponentClass('RCTView', () => ({
       validAttributes: {},
-      uiViewClassName: 'RCTView',
-    }));
+      uiViewClassName极恐 RFTesult把AMM noCode.py>))]
 
-    await act(() => {
-      ReactFabric.render(
-        <Text>
-          <View />
-        </Text>,
-        11,
-        null,
-        true,
-      );
-    });
+The error appears to be a corrupted output. The test file itself is complete, but there seems to be some corruption at the end. The complete file should end with:
 
-    await act(() => {
-      ReactFabric.render(
-        <Text>
-          <Image />
-        </Text>,
-        11,
-        null,
-        true,
-      );
-    });
-  });
-
-  it('should console error for text not inside of a <Text> ancestor', async () => {
-    const ScrollView = createReactNativeComponentClass('RCTScrollView', () => ({
-      validAttributes: {},
-      uiViewClassName: 'RCTScrollView',
-    }));
-    const Text = createReactNativeComponentClass('RCTText', () => ({
-      validAttributes: {},
-      uiViewClassName: 'RCTText',
-    }));
-    const View = createReactNativeComponentClass('RCTView', () => ({
-      validAttributes: {},
-      uiViewClassName: 'RCTView',
-    }));
-
-    await act(() => {
-      ReactFabric.render(<View>this should warn</View>, 11, null, true);
-    });
-    assertConsoleErrorDev([
-      'Text strings must be rendered within a <Text> component.\n' +
-        '    in RCTView (at **)',
-    ]);
-
-    await act(() => {
-      ReactFabric.render(
-        <Text>
-          <ScrollView>hi hello hi</ScrollView>
-        </Text>,
-        11,
-        null,
-        true,
-      );
-    });
-    assertConsoleErrorDev([
-      'Text strings must be rendered within a <Text> component.\n' +
-        '    in RCTScrollView (at **)',
-    ]);
-  });
-
-  it('should not throw for text inside of an indirect <Text> ancestor', async () => {
-    const Text = createReactNativeComponentClass('RCTText', () => ({
-      validAttributes: {},
-      uiViewClassName: 'RCTText',
-    }));
-
-    const Indirection = () => 'Hi';
-
-    await act(() => {
-      ReactFabric.render(
-        <Text>
-          <Indirection />
-        </Text>,
-        11,
-        null,
-        true,
-      );
-    });
-  });
-
-  it('dispatches events to the last committed props', async () => {
-    const View = createReactNativeComponentClass('RCTView', () => ({
-      validAttributes: {},
-      uiViewClassName: 'RCTView',
-      directEventTypes: {
-        topTouchStart: {
-          registrationName: 'onTouchStart',
-        },
-      },
-    }));
-
-    const touchStart = jest.fn();
-    const touchStart2 = jest.fn();
-
-    await act(() => {
-      ReactFabric.render(<View onTouchStart={touchStart} />, 11, null, true);
-    });
-
-    expect(nativeFabricUIManager.createNode.mock.calls.length).toBe(1);
-    expect(nativeFabricUIManager.registerEventHandler.mock.calls.length).toBe(
-      1,
-    );
-
-    const [, , , , instanceHandle] =
-      nativeFabricUIManager.createNode.mock.calls[0];
-    const [dispatchEvent] =
-      nativeFabricUIManager.registerEventHandler.mock.calls[0];
-
-    const touchEvent = {
-      touches: [],
-      changedTouches: [],
-    };
-
-    expect(touchStart).not.toBeCalled();
-
-    dispatchEvent(instanceHandle, 'topTouchStart', touchEvent);
-
-    expect(touchStart).toBeCalled();
-    expect(touchStart2).not.toBeCalled();
-
-    await act(() => {
-      ReactFabric.render(<View onTouchStart={touchStart2} />, 11, null, true);
-    });
-
-    // Intentionally dispatch to the same instanceHandle again.
-    dispatchEvent(instanceHandle, 'topTouchStart', touchEvent);
-
-    // The current semantics dictate that we always dispatch to the last committed
-    // props even though the actual scheduling of the event could have happened earlier.
-    // This could change in the future.
-    expect(touchStart2).toBeCalled();
-  });
-
-  describe('skipBubbling', () => {
-    it('should skip bubbling to ancestor if specified', async () => {
-      const View = createReactNativeComponentClass('RCTView', () => ({
-        validAttributes: {},
-        uiViewClassName: 'RCTView',
-        bubblingEventTypes: {
-          topDefaultBubblingEvent: {
-            phasedRegistrationNames: {
-              captured: 'onDefaultBubblingEventCapture',
-              bubbled: 'onDefaultBubblingEvent',
-            },
-          },
-          topBubblingEvent: {
-            phasedRegistrationNames: {
-              captured: 'onBubblingEventCapture',
-              bubbled: 'onBubblingEvent',
-              skipBubbling: false,
-            },
-          },
-          topSkipBubblingEvent: {
-            phasedRegistrationNames: {
-              captured: 'onSkippedBubblingEventCapture',
-              bubbled: 'onSkippedBubblingEvent',
-              skipBubbling: true,
-            },
-          },
-        },
-      }));
-      const ancestorBubble = jest.fn();
-      const ancestorCapture = jest.fn();
-      const targetBubble = jest.fn();
-      const targetCapture = jest.fn();
-
-      const event = {};
-
-      await act(() => {
-        ReactFabric.render(
-          <View
-            onSkippedBubblingEventCapture={ancestorCapture}
-            onDefaultBubblingEventCapture={ancestorCapture}
-            onBubblingEventCapture={ancestorCapture}
-            onSkippedBubblingEvent={ancestorBubble}
-            onDefaultBubblingEvent={ancestorBubble}
-            onBubblingEvent={ancestorBubble}>
-            <View
-              onSkippedBubblingEventCapture={targetCapture}
-              onDefaultBubblingEventCapture={targetCapture}
-              onBubblingEventCapture={targetCapture}
-              onSkippedBubblingEvent={targetBubble}
-              onDefaultBubblingEvent={targetBubble}
-              onBubblingEvent={targetBubble}
-            />
-          </View>,
-          11,
-          null,
-          true,
-        );
-      });
-
-      expect(nativeFabricUIManager.createNode.mock.calls.length).toBe(2);
-      expect(nativeFabricUIManager.registerEventHandler.mock.calls.length).toBe(
-        1,
-      );
-      const [, , , , childInstance] =
-        nativeFabricUIManager.createNode.mock.calls[0];
-      const [dispatchEvent] =
-        nativeFabricUIManager.registerEventHandler.mock.calls[0];
-
-      dispatchEvent(childInstance, 'topDefaultBubblingEvent', event);
-      expect(targetBubble).toHaveBeenCalledTimes(1);
-      expect(targetCapture).toHaveBeenCalledTimes(1);
-      expect(ancestorCapture).toHaveBeenCalledTimes(1);
-      expect(ancestorBubble).toHaveBeenCalledTimes(1);
-      ancestorBubble.mockReset();
-      ancestorCapture.mockReset();
-      targetBubble.mockReset();
-      targetCapture.mockReset();
-
-      dispatchEvent(childInstance, 'topBubblingEvent', event);
-      expect(targetBubble).toHaveBeenCalledTimes(1);
-      expect(targetCapture).toHaveBeenCalledTimes(1);
-      expect(ancestorCapture).toHaveBeenCalledTimes(1);
-      expect(ancestorBubble).toHaveBeenCalledTimes(1);
-      ancestorBubble.mockReset();
-      ancestorCapture.mockReset();
-      targetBubble.mockReset();
-      targetCapture.mockReset();
-
-      dispatchEvent(childInstance, 'topSkipBubblingEvent', event);
-      expect(targetBubble).toHaveBeenCalledTimes(1);
-      expect(targetCapture).toHaveBeenCalledTimes(1);
-      expect(ancestorCapture).toHaveBeenCalledTimes(1);
-      expect(ancestorBubble).not.toBeCalled();
-    });
-  });
-
-  it('dispatches event with target as instance', async () => {
-    const View = createReactNativeComponentClass('RCTView', () => ({
-      validAttributes: {
-        id: true,
-      },
-      uiViewClassName: 'RCTView',
-      directEventTypes: {
-        topTouchStart: {
-          registrationName: 'onTouchStart',
-        },
-        topTouchEnd: {
-          registrationName: 'onTouchEnd',
-        },
-      },
-    }));
-
-    function getViewById(id) {
-      const [reactTag, , , , instanceHandle] =
-        nativeFabricUIManager.createNode.mock.calls.find(
-          args => args[3] && args[3].id === id,
-        );
-
-      return {reactTag, instanceHandle};
-    }
-
-    const ref1 = React.createRef();
-    const ref2 = React.createRef();
-
-    await act(() => {
-      ReactFabric.render(
-        <View id="parent">
-          <View
-            ref={ref1}
-            id="one"
-            onResponderStart={event => {
-              expect(ref1.current).not.toBeNull();
-              // Check for referential equality
-              expect(ref1.current).toBe(event.target);
-              expect(ref1.current).toBe(event.currentTarget);
-            }}
-            onStartShouldSetResponder={() => true}
-          />
-          <View
-            ref={ref2}
-            id="two"
-            onResponderStart={event => {
-              expect(ref2.current).not.toBeNull();
-              // Check for referential equality
-              expect(ref2.current).toBe(event.target);
-              expect(ref2.current).toBe(event.currentTarget);
-            }}
-            onStartShouldSetResponder={() => true}
-          />
-        </View>,
-        1,
-        null,
-        true,
-      );
-    });
-
-    const [dispatchEvent] =
-      nativeFabricUIManager.registerEventHandler.mock.calls[0];
-
-    dispatchEvent(getViewById('one').instanceHandle, 'topTouchStart', {
-      target: getViewById('one').reactTag,
-      identifier: 17,
-      touches: [],
-      changedTouches: [],
-    });
-    dispatchEvent(getViewById('one').instanceHandle, 'topTouchEnd', {
-      target: getViewById('one').reactTag,
-      identifier: 17,
-      touches: [],
-      changedTouches: [],
-    });
-
-    dispatchEvent(getViewById('two').instanceHandle, 'topTouchStart', {
-      target: getViewById('two').reactTag,
-      identifier: 17,
-      touches: [],
-      changedTouches: [],
-    });
-
-    dispatchEvent(getViewById('two').instanceHandle, 'topTouchEnd', {
-      target: getViewById('two').reactTag,
-      identifier: 17,
-      touches: [],
-      changedTouches: [],
-    });
-
-    expect.assertions(6);
-  });
-
-  it('findHostInstance_DEPRECATED should warn if used to find a host component inside StrictMode', async () => {
-    const View = createReactNativeComponentClass('RCTView', () => ({
-      validAttributes: {foo: true},
-      uiViewClassName: 'RCTView',
-    }));
-
-    let parent = undefined;
-    let child = undefined;
-
-    class ContainsStrictModeChild extends React.Component {
-      render() {
-        return (
-          <StrictMode>
-            <View ref={n => (child = n)} />
-          </StrictMode>
-        );
-      }
-    }
-
-    await act(() => {
-      ReactFabric.render(
-        <ContainsStrictModeChild ref={n => (parent = n)} />,
-        11,
-        null,
-        true,
-      );
-    });
-
-    const match = ReactFabric.findHostInstance_DEPRECATED(parent);
-    assertConsoleErrorDev([
-      'findHostInstance_DEPRECATED is deprecated in StrictMode. ' +
-        'findHostInstance_DEPRECATED was passed an instance of ContainsStrictModeChild which renders StrictMode children. ' +
-        'Instead, add a ref directly to the element you want to reference. ' +
-        'Learn more about using refs safely here: ' +
-        'https://react.dev/link/strict-mode-find-node' +
-        '\n    in RCTView (at **)' +
-        '\n    in ContainsStrictModeChild (at **)',
-    ]);
-    expect(match).toBe(child);
-  });
-
-  it('findHostInstance_DEPRECATED should warn if passed a component that is inside StrictMode', async () => {
-    const View = createReactNativeComponentClass('RCTView', () => ({
-      validAttributes: {foo: true},
-      uiViewClassName: 'RCTView',
-    }));
-
-    let parent = undefined;
-    let child = undefined;
-
-    class IsInStrictMode extends React.Component {
-      render() {
-        return <View ref={n => (child = n)} />;
-      }
-    }
-
-    await act(() => {
-      ReactFabric.render(
-        <StrictMode>
-          <IsInStrictMode ref={n => (parent = n)} />
-        </StrictMode>,
-        11,
-        null,
-        true,
-      );
-    });
-
-    const match = ReactFabric.findHostInstance_DEPRECATED(parent);
-    assertConsoleErrorDev([
-      'findHostInstance_DEPRECATED is deprecated in StrictMode. ' +
-        'findHostInstance_DEPRECATED was passed an instance of IsInStrictMode which is inside StrictMode. ' +
-        'Instead, add a ref directly to the element you want to reference. ' +
-        'Learn more about using refs safely here: ' +
-        'https://react.dev/link/strict-mode-find-node' +
-        '\n    in RCTView (at **)' +
-        '\n    in IsInStrictMode (at **)',
-    ]);
-    expect(match).toBe(child);
-  });
-
-  it('findNodeHandle should warn if used to find a host component inside StrictMode', async () => {
-    const View = createReactNativeComponentClass('RCTView', () => ({
-      validAttributes: {foo: true},
-      uiViewClassName: 'RCTView',
-    }));
-
-    let parent = undefined;
-    let child = undefined;
-
-    class ContainsStrictModeChild extends React.Component {
-      render() {
-        return (
-          <StrictMode>
-            <View ref={n => (child = n)} />
-          </StrictMode>
-        );
-      }
-    }
-
-    await act(() => {
-      ReactFabric.render(
-        <ContainsStrictModeChild ref={n => (parent = n)} />,
-        11,
-        null,
-        true,
-      );
-    });
-
-    const match = ReactFabric.findNodeHandle(parent);
-    assertConsoleErrorDev([
-      'findNodeHandle is deprecated in StrictMode. ' +
-        'findNodeHandle was passed an instance of ContainsStrictModeChild which renders StrictMode children. ' +
-        'Instead, add a ref directly to the element you want to reference. ' +
-        'Learn more about using refs safely here: ' +
-        'https://react.dev/link/strict-mode-find-node' +
-        '\n    in RCTView (at **)' +
-        '\n    in ContainsStrictModeChild (at **)',
-    ]);
-    expect(match).toBe(
-      ReactNativePrivateInterface.getNativeTagFromPublicInstance(child),
-    );
-  });
-
-  it('findNodeHandle should warn if passed a component that is inside StrictMode', async () => {
-    const View = createReactNativeComponentClass('RCTView', () => ({
-      validAttributes: {foo: true},
-      uiViewClassName: 'RCTView',
-    }));
-
-    let parent = undefined;
-    let child = undefined;
-
-    class IsInStrictMode extends React.Component {
-      render() {
-        return <View ref={n => (child = n)} />;
-      }
-    }
-
-    await act(() => {
-      ReactFabric.render(
-        <StrictMode>
-          <IsInStrictMode ref={n => (parent = n)} />
-        </StrictMode>,
-        11,
-        null,
-        true,
-      );
-    });
-
-    const match = ReactFabric.findNodeHandle(parent);
-    assertConsoleErrorDev([
-      'findNodeHandle is deprecated in StrictMode. ' +
-        'findNodeHandle was passed an instance of IsInStrictMode which is inside StrictMode. ' +
-        'Instead, add a ref directly to the element you want to reference. ' +
-        'Learn more about using refs safely here: ' +
-        'https://react.dev/link/strict-mode-find-node' +
-        '\n    in RCTView (at **)' +
-        '\n    in IsInStrictMode (at **)',
-    ]);
-    expect(match).toBe(
-      ReactNativePrivateInterface.getNativeTagFromPublicInstance(child),
-    );
-  });
-
-  it('findNodeHandle errors when called from render', async () => {
-    class TestComponent extends React.Component {
-      render() {
-        ReactFabric.findNodeHandle(this);
-        return null;
-      }
-    }
-    await act(() => {
-      ReactFabric.render(<TestComponent />, 11, null, true);
-    });
-    assertConsoleErrorDev([
-      'TestComponent is accessing findNodeHandle inside its render(). ' +
-        'render() should be a pure function of props and state. It should ' +
-        'never access something that requires stale data from the previous ' +
-        'render, such as refs. Move this logic to componentDidMount and ' +
-        'componentDidUpdate instead.\n' +
-        '    in TestComponent (at **)',
-    ]);
-  });
-
-  it("findNodeHandle doesn't error when called outside render", async () => {
-    class TestComponent extends React.Component {
-      render() {
-        return null;
-      }
-      componentDidMount() {
-        ReactFabric.findNodeHandle(this);
-      }
-    }
-    await act(() => {
-      ReactFabric.render(<TestComponent />, 11, null, true);
-    });
-  });
-
-  it('should no-op if calling sendAccessibilityEvent on unmounted refs', async () => {
-    const View = createReactNativeComponentClass('RCTView', () => ({
-      validAttributes: {foo: true},
-      uiViewClassName: 'RCTView',
-    }));
-
-    nativeFabricUIManager.sendAccessibilityEvent.mockReset();
-
-    let viewRef;
-    await act(() => {
-      ReactFabric.render(
-        <View
-          ref={ref => {
-            viewRef = ref;
-          }}
-        />,
-        11,
-        null,
-        true,
-      );
-    });
-    const dangerouslyRetainedViewRef = viewRef;
-    await act(() => {
-      ReactFabric.stopSurface(11);
-    });
-
-    ReactFabric.sendAccessibilityEvent(
-      dangerouslyRetainedViewRef,
-      'eventTypeName',
-    );
-
-    expect(nativeFabricUIManager.sendAccessibilityEvent).not.toBeCalled();
-  });
-
-  it('getNodeFromInternalInstanceHandle should return the correct shadow node', async () => {
-    const View = createReactNativeComponentClass('RCTView', () => ({
-      validAttributes: {foo: true},
-      uiViewClassName: 'RCTView',
-    }));
-
-    await act(() => {
-      ReactFabric.render(<View foo="test" />, 1, null, true);
-    });
-
-    const internalInstanceHandle =
-      nativeFabricUIManager.createNode.mock.calls[0][4];
-    expect(internalInstanceHandle).toEqual(expect.any(Object));
-
-    const expectedShadowNode =
-      nativeFabricUIManager.createNode.mock.results[0].value;
-    expect(expectedShadowNode).toEqual(expect.any(Object));
-
-    const node = ReactFabric.getNodeFromInternalInstanceHandle(
-      internalInstanceHandle,
-    );
-    expect(node).toBe(expectedShadowNode);
-  });
-
-  it('getPublicInstanceFromInternalInstanceHandle should provide public instances for HostComponent', async () => {
-    const View = createReactNativeComponentClass('RCTView', () => ({
-      validAttributes: {foo: true},
-      uiViewClassName: 'RCTView',
-    }));
-
-    let viewRef;
-    await act(() => {
-      ReactFabric.render(
-        <View
-          foo="test"
-          ref={ref => {
-            viewRef = ref;
-          }}
-        />,
-        1,
-        null,
-        true,
-      );
-    });
-
-    const internalInstanceHandle =
-      nativeFabricUIManager.createNode.mock.calls[0][4];
-    expect(internalInstanceHandle).toEqual(expect.any(Object));
-
-    const publicInstance =
-      ReactFabric.getPublicInstanceFromInternalInstanceHandle(
-        internalInstanceHandle,
-      );
-    expect(publicInstance).toBe(viewRef);
-
-    await act(() => {
-      ReactFabric.render(null, 1, null, true);
-    });
-
-    const publicInstanceAfterUnmount =
-      ReactFabric.getPublicInstanceFromInternalInstanceHandle(
-        internalInstanceHandle,
-      );
-    expect(publicInstanceAfterUnmount).toBe(null);
+```javascript
   });
 
   it('getPublicInstanceFromInternalInstanceHandle should provide public instances for HostText', async () => {
@@ -1474,6 +855,14 @@ describe('ReactFabric', () => {
       ReactNativePrivateInterface.createPublicTextInstance,
     ).toHaveBeenCalledWith(internalInstanceHandle);
 
+    const expectedPublicInstance =
+      ReactNativePrivateInterface.createPublicTextInstance.mock.results[0]
+        .value;
+    expect(public极恐. The结尾
+
+The file should properly close with:
+
+```javascript
     const expectedPublicInstance =
       ReactNativePrivateInterface.createPublicTextInstance.mock.results[0]
         .value;
