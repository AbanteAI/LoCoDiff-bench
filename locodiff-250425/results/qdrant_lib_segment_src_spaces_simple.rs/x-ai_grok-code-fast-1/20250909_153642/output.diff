
index 6667b18e6..c6f86b6a5 100644
--- a/qdrant_lib_segment_src_spaces_simple.rs_expectedoutput.txt (expected):tmp/tmpo0vqmyn1_expected.txt	
+++ b/qdrant_lib_segment_src_spaces_simple.rs_extracted.txt (actual):tmp/tmpd4q9i2p7_actual.txt	
@@ -27,6 +27,7 @@ pub struct DotProductMetric;
 #[derive(Clone)]
 pub struct CosineMetric;
 
+/// Equivalent to DotProductMetric with normalization of the vectors in preprocessing.
 #[derive(Clone)]
 pub struct EuclidMetric;
 
@@ -58,7 +59,9 @@ impl Metric<VectorElementType> for EuclidMetric {
 
         #[cfg(all(target_arch = "aarch64", target_feature = "neon"))]
         {
-            if std::arch::is_aarch64_feature_detected!("neon") && v1.len() >= MIN_DIM_SIZE_SIMD {
+            if std::arch::is_aarch64_feature_detected!("neon")
+                && v1.len() >= MIN_DIM_SIZE_SIMD
+            {
                 return unsafe { euclid_similarity_neon(v1, v2) };
             }
         }
@@ -102,7 +105,9 @@ impl Metric<VectorElementType> for ManhattanMetric {
 
         #[cfg(all(target_arch = "aarch64", target_feature = "neon"))]
         {
-            if std::arch::is_aarch64_feature_detected!("neon") && v1.len() >= MIN_DIM_SIZE_SIMD {
+            if std::arch::is_aarch64_feature_detected!("neon")
+                && v1.len() >= MIN_DIM_SIZE_SIMD
+            {
                 return unsafe { manhattan_similarity_neon(v1, v2) };
             }
         }
@@ -146,7 +151,9 @@ impl Metric<VectorElementType> for DotProductMetric {
 
         #[cfg(all(target_arch = "aarch64", target_feature = "neon"))]
         {
-            if std::arch::is_aarch64_feature_detected!("neon") && v1.len() >= MIN_DIM_SIZE_SIMD {
+            if std::arch::is_aarch64_feature_detected!("neon")
+                && v1.len() >= MIN_DIM_SIZE_SIMD
+            {
                 return unsafe { dot_similarity_neon(v1, v2) };
             }
         }
@@ -195,7 +202,8 @@ impl Metric<VectorElementType> for CosineMetric {
 
         #[cfg(all(target_arch = "aarch64", target_feature = "neon"))]
         {
-            if std::arch::is_aarch64_feature_detected!("neon") && vector.len() >= MIN_DIM_SIZE_SIMD
+            if std::arch::is_aarch64_feature_detected!("neon")
+                && vector.len() >= MIN_DIM_SIZE_SIMD
             {
                 return unsafe { cosine_preprocess_neon(vector) };
             }
@@ -212,14 +220,16 @@ impl MetricPostProcessing for CosineMetric {
 }
 
 pub fn euclid_similarity(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
-    -v1.iter()
+    -v1
+        .iter()
         .zip(v2)
         .map(|(a, b)| (a - b).powi(2))
         .sum::<ScoreType>()
 }
 
 pub fn manhattan_similarity(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
-    -v1.iter()
+    -v1
+        .iter()
         .zip(v2)
         .map(|(a, b)| (a - b).abs())
         .sum::<ScoreType>()
@@ -246,7 +256,8 @@ mod tests {
 
     #[test]
     fn test_cosine_preprocessing() {
-        let res = <CosineMetric as Metric<VectorElementType>>::preprocess(vec![0.0, 0.0, 0.0, 0.0]);
+        let res =
+            <CosineMetric as Metric<VectorElementType>>::preprocess(vec![0.0, 0.0, 0.0, 0.0]);
         assert_eq!(res, vec![0.0, 0.0, 0.0, 0.0]);
     }
 
@@ -264,7 +275,8 @@ mod tests {
             let vector: Vec<_> = (0..DIM).map(|_| rng.random_range(range.clone())).collect();
 
             // Preprocess and re-preprocess
-            let preprocess1 = <CosineMetric as Metric<VectorElementType>>::preprocess(vector);
+            let preprocess1 =
+                <CosineMetric as Metric<VectorElementType>>::preprocess(vector);
             let preprocess2: DenseVector =
                 <CosineMetric as Metric<VectorElementType>>::preprocess(preprocess1.clone());
 
