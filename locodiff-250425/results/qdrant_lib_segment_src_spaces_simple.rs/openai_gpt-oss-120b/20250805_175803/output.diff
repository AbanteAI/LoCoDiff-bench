
index 6667b18e6..b4e551683 100644
--- a/qdrant_lib_segment_src_spaces_simple.rs_expectedoutput.txt (expected):tmp/tmpsjh1rsj4_expected.txt	
+++ b/qdrant_lib_segment_src_spaces_simple.rs_extracted.txt (actual):tmp/tmp1a0n1l1v_actual.txt	
@@ -58,7 +58,9 @@ impl Metric<VectorElementType> for EuclidMetric {
 
         #[cfg(all(target_arch = "aarch64", target_feature = "neon"))]
         {
-            if std::arch::is_aarch64_feature_detected!("neon") && v1.len() >= MIN_DIM_SIZE_SIMD {
+            if std::arch::is_aarch64_feature_detected!("neon")
+                && v1.len() >= MIN_DIM_SIZE_SIMD
+            {
                 return unsafe { euclid_similarity_neon(v1, v2) };
             }
         }
@@ -86,7 +88,9 @@ impl Metric<VectorElementType> for ManhattanMetric {
         #[cfg(target_arch = "x86_64")]
         {
             if is_x86_feature_detected!("avx")
-                && is_x86_feature_detected!("fma")
+                && is_x86_feature_det
+
+ected!("fma")
                 && v1.len() >= MIN_DIM_SIZE_AVX
             {
                 return unsafe { manhattan_similarity_avx(v1, v2) };
@@ -102,7 +106,9 @@ impl Metric<VectorElementType> for ManhattanMetric {
 
         #[cfg(all(target_arch = "aarch64", target_feature = "neon"))]
         {
-            if std::arch::is_aarch64_feature_detected!("neon") && v1.len() >= MIN_DIM_SIZE_SIMD {
+            if std::arch::is_aarch64_feature_detected!("neon")
+                && v1.len() >= MIN_DIM_SIZE_SIMD
+            {
                 return unsafe { manhattan_similarity_neon(v1, v2) };
             }
         }
@@ -133,7 +139,7 @@ impl Metric<VectorElementType> for DotProductMetric {
                 && is_x86_feature_detected!("fma")
                 && v1.len() >= MIN_DIM_SIZE_AVX
             {
-                return unsafe { dot_similarity_avx(v1, v2) };
+                unsafe { return dot_similarity_avx(v1, v2) };
             }
         }
 
@@ -146,7 +152,9 @@ impl Metric<VectorElementType> for DotProductMetric {
 
         #[cfg(all(target_arch = "aarch64", target_feature = "neon"))]
         {
-            if std::arch::is_aarch64_feature_detected!("neon") && v1.len() >= MIN_DIM_SIZE_SIMD {
+            if std::arch::is_aarch64_feature_detected!("neon")
+                && v1.len() >= MIN_DIM_SIZE_SIMD
+            {
                 return unsafe { dot_similarity_neon(v1, v2) };
             }
         }
@@ -165,7 +173,7 @@ impl MetricPostProcessing for DotProductMetric {
     }
 }
 
-/// Equivalent to DotProductMetric with normalization of the vectors in preprocessing.
+/// Equivalent to DotProductMetric with vector normalization in preprocessing.
 impl Metric<VectorElementType> for CosineMetric {
     fn distance() -> Distance {
         Distance::Cosine
@@ -195,12 +203,14 @@ impl Metric<VectorElementType> for CosineMetric {
 
         #[cfg(all(target_arch = "aarch64", target_feature = "neon"))]
         {
-            if std::arch::is_aarch64_feature_detected!("neon") && vector.len() >= MIN_DIM_SIZE_SIMD
+            if std::arch::is_aarch64_feature_detected!("neon")
+                && vector.len() >= MIN_DIM_SIZE_SIMD
             {
                 return unsafe { cosine_preprocess_neon(vector) };
             }
         }
 
+        // If the vector is zero-length or already normalized, return it unchanged.
         cosine_preprocess(vector)
     }
 }
@@ -211,6 +221,8 @@ impl MetricPostProcessing for CosineMetric {
     }
 }
 
+// ----- Core similarity implementations -----
+
 pub fn euclid_similarity(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
     -v1.iter()
         .zip(v2)
@@ -243,15 +255,14 @@ mod tests {
     use rand::Rng;
 
     use super::*;
-
     #[test]
     fn test_cosine_preprocessing() {
-        let res = <CosineMetric as Metric<VectorElementType>>::preprocess(vec![0.0, 0.0, 0.0, 0.0]);
+        let res = <CosineMetric as Metric<VectorElementType>>::preprocess(vec![
+            0.0, 0.0, 0.0, 0.0,
+        ]);
         assert_eq!(res, vec![0.0, 0.0, 0.0, 0.0]);
     }
 
-    /// If we preprocess a vector multiple times, we expect the same result.
-    /// Renormalization should not produce something different.
     #[test]
     fn test_cosine_stable_preprocessing() {
         const DIM: usize = 1500;
@@ -260,19 +271,19 @@ mod tests {
         let mut rng = rand::rng();
 
         for attempt in 0..ATTEMPTS {
-            let range = rng.random_range(-2.5..=0.0)..=rng.random_range(0.0..2.5);
-            let vector: Vec<_> = (0..DIM).map(|_| rng.random_range(range.clone())).collect();
+            let range = rng.random_range(-2.5..=0.0)..=random_range(0.0..2.5);
+            let vector: Vec<_> = (0..DIM)
+                .map(|_| rng.random_range(range.clone()))
+                .collect();
 
             // Preprocess and re-preprocess
-            let preprocess1 = <CosineMetric as Metric<VectorElementType>>::preprocess(vector);
+            let preprocess1 =
+                <CosineMetric as Metric<VectorElementType>>::preprocess(vector);
             let preprocess2: DenseVector =
                 <CosineMetric as Metric<VectorElementType>>::preprocess(preprocess1.clone());
 
             // All following preprocess attempts must be the same
-            assert_eq!(
-                preprocess1, preprocess2,
-                "renormalization is not stable (vector #{attempt})"
-            );
+            assert_eq!(preprocess1, preprocess2);
         }
     }
 }
\ No newline at end of file
