--- qdrant_lib_segment_src_index_hnsw_index_graph_layers.rs_expectedoutput.txt (expected)+++ qdrant_lib_segment_src_index_hnsw_index_graph_layers.rs_extracted.txt (actual)@@ -20,6 +20,10 @@ use crate::index::hnsw_index::point_scorer::FilteredScorer;
 use crate::index::hnsw_index::search_context::SearchContext;
 use crate::index::visited_pool::{VisitedListHandle, VisitedPool};
+#[cfg(test)]
+use crate::vector_storage::chunked_vector_storage::VectorOffsetType;
+#[cfg(test)]
+use crate::vector_storage::DEFAULT_STOPPED;
 
 pub type LinkContainer = Vec<PointOffsetType>;
 pub type LayersContainer = Vec<LinkContainer>;
@@ -55,6 +59,37 @@ 
     /// Get M based on current level
     fn get_m(&self, level: usize) -> usize;
+
+    /// Greedy search for closest points within a single graph layer
+    fn _search_on_level(
+        &self,
+        searcher: &mut SearchContext,
+        level: usize,
+        visited_list: &mut VisitedListHandle,
+        points_scorer: &mut FilteredScorer,
+        is_stopped: &AtomicBool,
+    ) -> CancellableResult<()>;
+}
+
+impl GraphLayersBase for GraphLayers {
+    fn get_visited_list_from_pool(&self) -> VisitedListHandle {
+        self.visited_pool.get(self.links.num_points())
+    }
+
+    fn links_map<F>(&self, point_id: PointOffsetType, level: usize, f: F)
+    where
+        F: FnMut(PointOffsetType),
+    {
+        self.links.links(point_id, level).for_each(f);
+    }
+
+    fn get_m(&self, level: usize) -> usize {
+        if level == 0 {
+            self.m0
+        } else {
+            self.m
+        }
+    }
 
     /// Greedy search for closest points within a single graph layer
     fn _search_on_level(
@@ -90,122 +125,6 @@         }
 
         Ok(())
-    }
-
-    fn search_on_level(
-        &self,
-        level_entry: ScoredPointOffset,
-        level: usize,
-        ef: usize,
-        points_scorer: &mut FilteredScorer,
-        is_stopped: &AtomicBool,
-    ) -> CancellableResult<FixedLengthPriorityQueue<ScoredPointOffset>> {
-        let mut visited_list = self.get_visited_list_from_pool();
-        visited_list.check_and_update_visited(level_entry.idx);
-        let mut search_context = SearchContext::new(level_entry, ef);
-
-        self._search_on_level(
-            &mut search_context,
-            level,
-            &mut visited_list,
-            points_scorer,
-            is_stopped,
-        )?;
-        Ok(search_context.nearest)
-    }
-
-    /// Greedy searches for entry point of level `target_level`.
-    /// Beam size is 1.
-    fn search_entry(
-        &self,
-        entry_point: PointOffsetType,
-        top_level: usize,
-        target_level: usize,
-        points_scorer: &mut FilteredScorer,
-        is_stopped: &AtomicBool,
-    ) -> CancellableResult<ScoredPointOffset> {
-        let mut links: Vec<PointOffsetType> = Vec::with_capacity(2 * self.get_m(0));
-
-        let mut current_point = ScoredPointOffset {
-            idx: entry_point,
-            score: points_scorer.score_point(entry_point),
-        };
-        for level in rev_range(top_level, target_level) {
-            check_process_stopped(is_stopped)?;
-
-            let limit = self.get_m(level);
-
-            let mut changed = true;
-            while changed {
-                changed = false;
-
-                links.clear();
-                self.links_map(current_point.idx, level, |link| {
-                    links.push(link);
-                });
-
-                let scores = points_scorer.score_points(&mut links, limit);
-                scores.iter().copied().for_each(|score_point| {
-                    if score_point.score > current_point.score {
-                        changed = true;
-                        current_point = score_point;
-                    }
-                });
-            }
-        }
-        Ok(current_point)
-    }
-
-    #[cfg(test)]
-    #[cfg(feature = "gpu")]
-    fn search_entry_on_level(
-        &self,
-        entry_point: PointOffsetType,
-        level: usize,
-        points_scorer: &mut FilteredScorer,
-    ) -> ScoredPointOffset {
-        let limit = self.get_m(level);
-        let mut links: Vec<PointOffsetType> = Vec::with_capacity(2 * self.get_m(0));
-        let mut current_point = ScoredPointOffset {
-            idx: entry_point,
-            score: points_scorer.score_point(entry_point),
-        };
-
-        let mut changed = true;
-        while changed {
-            changed = false;
-
-            links.clear();
-            self.links_map(current_point.idx, level, |link| {
-                links.push(link);
-            });
-
-            let scores = points_scorer.score_points(&mut links, limit);
-            scores.iter().copied().for_each(|score_point| {
-                if score_point.score > current_point.score {
-                    changed = true;
-                    current_point = score_point;
-                }
-            });
-        }
-        current_point
-    }
-}
-
-impl GraphLayersBase for GraphLayers {
-    fn get_visited_list_from_pool(&self) -> VisitedListHandle {
-        self.visited_pool.get(self.links.num_points())
-    }
-
-    fn links_map<F>(&self, point_id: PointOffsetType, level: usize, f: F)
-    where
-        F: FnMut(PointOffsetType),
-    {
-        self.links.links(point_id, level).for_each(f);
-    }
-
-    fn get_m(&self, level: usize) -> usize {
-        if level == 0 { self.m0 } else { self.m }
     }
 }
 
@@ -242,6 +161,85 @@             })
     }
 
+    /// Greedy searches for entry point of level `target_level`.
+    /// Beam size is 1.
+    fn search_entry(
+        &self,
+        entry_point: PointOffsetType,
+        top_level: usize,
+        target_level: usize,
+        points_scorer: &mut FilteredScorer,
+        is_stopped: &AtomicBool,
+    ) -> CancellableResult<ScoredPointOffset> {
+        let mut links: Vec<PointOffsetType> = Vec::with_capacity(2 * self.get_m(0));
+
+        let mut current_point = ScoredPointOffset {
+            idx: entry_point,
+            score: points_scorer.score_point(entry_point),
+        };
+        for level in rev_range(top_level, target_level) {
+            check_process_stopped(is_stopped)?;
+
+            let limit = self.get_m(level);
+
+            let mut changed = true;
+            while changed {
+                changed = false;
+
+                links.clear();
+                self.links_map(current_point.idx, level, |link| {
+                    links.push(link);
+                });
+
+                let scores = points_scorer.score_points(&mut links, limit);
+                scores.iter().copied().for_each(|score_point| {
+                    if score_point.score > current_point.score {
+                        changed = true;
+                        current_point = score_point;
+                    }
+                });
+            }
+        }
+        Ok(current_point)
+    }
+
+    #[cfg(test)]
+    #[cfg(feature = "gpu")]
+    fn search_entry_on_level(
+        &self,
+        entry_point: PointOffsetType,
+        level: usize,
+        points_scorer: &mut FilteredScorer,
+        is_stopped: &AtomicBool,
+    ) -> CancellableResult<ScoredPointOffset> {
+        let limit = self.get_m(level);
+        let mut links: Vec<PointOffsetType> = Vec::with_capacity(2 * self.get_m(0));
+        let mut current_point = ScoredPointOffset {
+            idx: entry_point,
+            score: points_scorer.score_point(entry_point),
+        };
+
+        let mut changed = true;
+        while changed {
+            check_process_stopped(is_stopped)?;
+            changed = false;
+
+            links.clear();
+            self.links_map(current_point.idx, level, |link| {
+                links.push(link);
+            });
+
+            let scores = points_scorer.score_points(&mut links, limit);
+            scores.iter().copied().for_each(|score_point| {
+                if score_point.score > current_point.score {
+                    changed = true;
+                    current_point = score_point;
+                }
+            });
+        }
+        Ok(current_point)
+    }
+
     pub fn search(
         &self,
         top: usize,
@@ -289,13 +287,11 @@         ]
     }
 
-    pub fn num_points(&self) -> usize {
-        self.links.num_points()
-    }
-}
-
-impl GraphLayers {
-    pub fn load(dir: &Path, on_disk: bool, compress: bool) -> OperationResult<Self> {
+    pub fn load(
+        dir: &Path,
+        on_disk: bool,
+        compress: bool,
+    ) -> OperationResult<Self> {
         let graph_data: GraphLayerData = read_bin(&GraphLayers::get_path(dir))?;
 
         if compress {
@@ -373,6 +369,7 @@     }
 }
 
+
 #[cfg(test)]
 mod tests {
     use rand::SeedableRng;
@@ -391,7 +388,6 @@     };
     use crate::spaces::metric::Metric;
     use crate::spaces::simple::{CosineMetric, DotProductMetric};
-    use crate::vector_storage::DEFAULT_STOPPED;
     use crate::vector_storage::chunked_vector_storage::VectorOffsetType;
 
     fn search_in_graph(
@@ -432,6 +428,7 @@         let graph_layers = GraphLayers {
             m,
             m0: 2 * m,
+            // ef_construct: Removed,
             links: GraphLinksSerializer::new(graph_links.clone(), format, m, 2 * m)
                 .to_graph_links_ram(),
             entry_points: EntryPoints::new(entry_points_num),
@@ -485,9 +482,6 @@         let mut rng = StdRng::seed_from_u64(42);
 
         let dir = Builder::new().prefix("graph_dir").tempdir().unwrap();
-
-        let query = random_vector(&mut rng, dim);
-
         let (vector_holder, graph_layers_builder) =
             create_graph_layer_builder_fixture(num_vectors, M, dim, false, &mut rng);
         let graph1 = graph_layers_builder
@@ -497,7 +491,7 @@         let res1 = search_in_graph(&query, top, &vector_holder, &graph1);
         drop(graph1);
 
-        let graph2 = GraphLayers::load(dir.path(), false, compress).unwrap();
+        let graph2 = GraphLayers::load(dir.path(), false, compress, false).unwrap();
         if compress {
             assert_eq!(graph2.links.format(), GraphLinksFormat::Compressed);
         } else {
