/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @emails react-core
 * @jest-environment node
 */

'use strict';

let React;
let ReactDOMServer;
let PropTypes;
let ReactSharedInternals;
let assertConsoleErrorDev;

describe('ReactDOMServer', () => {
  beforeEach(() => {
    jest.resetModules();
    React = require('react');
    PropTypes = require('prop-types');
    ReactDOMServer = require('react-dom/server');
    assertConsoleErrorDev = require('internal-test-utils').assertConsoleErrorDev;
    ReactSharedInternals =
      React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
  });

  describe('renderToString', () => {
    it('should generate simple markup', () => {
      const response = ReactDOMServer.renderToString(
        <span>hello world</span>,
      );
      expect(response).toMatch(new RegExp('<span>hello world</span>'));
    });

    it('should generate simple markup for self-closing tags', () => {
      const response = ReactDOMServer.renderToString(<img />);
      expect(response).toMatch(new RegExp('<img' + '/>'));
    });

    it('should generate comment markup for component returns null', () => {
      class NullComponent extends React.Component {
        render() {
          return null;
        }
      }
      const response = ReactDOMServer.renderToString(
        <NullComponent />,
      );
      expect(response).toBe('');
    });

    it('should render composite components', () => {
      class Parent extends React.Component {
        render() {
          return (
            <div>
              <Child name="child" />
            </div>
          );
        }
      }
      class Child extends React.Component {
        render() {
          return <span>My name is {this.props.name}</span>;
        }
      }
      const response = ReactDOMServer.renderToString(
        <Parent />,
      );
      expect(response).toMatch(
        new RegExp(
          '<div>' +
            '<span>' +
            'My name is <!-- -->child' +
            '</span>' +
            '</div>',
        ),
      );
    });

    it('should only execute certain lifecycle methods', () => {
      function runTest() {
        const lifecycle = [];

        class TestComponent extends React.Component {
          constructor(props) {
            super(props);
            lifecycle.push('getInitialState');
            this.state = { name: 'TestComponent' };
          }
          UNSAFE_componentWillMount() {
            lifecycle.push('componentWillMount');
          }
          componentDidMount() {
            lifecycle.push('componentDidMount');
          }
          render() {
            lifecycle.push('render');
            return (
              <span>Component name: {this.state.name}</span>
            );
          }
          UNSAFE_componentWillUpdate() {
            lifecycle.push('componentWillUpdate');
          }
          componentDidUpdate() {
            lifecycle.push('componentDidUpdate');
          }
          shouldComponentUpdate() {
            lifecycle.push('shouldComponentUpdate');
          }
          UNSAFE_componentWillReceiveProps() {
            lifecycle.push('componentWillReceiveProps');
          }
          componentWillUnmount() {
            lifecycle.push('componentWillUnmount');
          }
        }

        const response = ReactDOMServer.renderToString(
          <TestComponent />,
        );

        expect(response).toMatch(
          new RegExp(
            '<span>' +
              'Component name: <!-- -->TestComponent' +
              '</span>',
          ),
        );
        expect(lifecycle).toEqual([
          'getInitialState',
          'componentWillMount',
          'render',
        ]);
      }

      runTest();
    });

    it('should throw with silly args', () => {
      expect(
        ReactDOMServer.renderToString.bind(
          ReactDOMServer,
          { x: 123 },
        ),
      ).toThrowError(
        'Objects are not valid as a React child (found: object with keys {x})',
      );
    });

    it('should throw prop mapping error for an <iframe /> with invalid props', () => {
      expect(() => {
        ReactDOMServer.renderToString(
          <iframe style="border:none;" />,
        );
      }).toThrowError();
    });
  });

  describe('renderToStaticMarkup', () => {
    it('should not put checksum and React ID on components', () => {
      class Nested extends React.Component {
        render() {
          return <div>inner text</div>;
        }
      }
      class Test extends React.Component {
        render() {
          return (
            <span>
              <Nested />
            </span>
          );
        }
      }
      const response = ReactDOMServer.renderToStaticMarkup(
        <Test />,
      );
      expect(response).toBe('<span><div>inner text</div></span>');
    });

    it('should not put checksum and React ID on text components', () => {
      class Test extends React.Component {
        render() {
          return (
            <span>
              {'hello'} {'world'}
            </span>
          );
        }
      }
      const response = ReactDOMServer.renderToStaticMarkup(
        <Test />,
      );
      expect(response).toBe('<span>hello world</span>');
    });

    it('should not use comments for empty nodes', () => {
      class Test extends React.Component {
        render() {
          return null;
          }
      }
      const response = ReactDOMServer.renderToStaticMarkup(
        <Test />,
      );
      expect(response).toBe('');
    });

    it('should only execute certain lifecycle methods', () => {
      function runTest() {
        const lifecycle = [];

        class TestComponent extends React.Component {
          constructor(props) {
            super(props);
            lifecycle.push('getInitialState');
            this.state = { name: 'TestComponent' };
          }
          UNSAFE_componentWillMount() {
            lifecycle.push('componentWillMount');
          }
          componentDidMount() {
            lifecycle.push('componentDidMount');
          }
          render() {
            lifecycle.push('render');
            return <span>Component name: {this.state.name}</span>;
          }
          UNSAFE_componentWillUpdate() {
            lifecycle.push('componentWillUpdate');
          }
          componentDidUpdate() {
            lifecycle.push('componentDidUpdate');
          }
          shouldComponentUpdate() {
            lifecycle.push('shouldComponentUpdate');
          }
          UNSAFE_componentWillReceiveProps() {
            lifecycle.push('componentWillReceiveProps');
          }
          componentWillUnmount() {
            lifecycle.push('componentWillUnmount');
          }
        }

        const response = ReactDOMServer.renderToStaticMarkup(
          <TestComponent />,
        );

        expect(response).toBe(
          '<span>Component name: TestComponent</span>',
        );
        expect(lifecycle).toEqual([
          'getInitialState',
          'componentWillMount',
          'render',
        ]);
      }

      runTest();
    });

    it('should throw with silly args', () => {
      expect(
        ReactDOMServer.renderToStaticMarkup.bind(
          ReactDOMServer,
          { x: 123 },
        ),
      ).toThrowError(
        'Objects are not valid as a React child (found: object with keys {x})',
      );
    });

    it('allows setState in componentWillMount without using DOM', () => {
      class Component extends React.Component {
        UNSAFE_componentWillMount() {
          this.setState({ text: 'hello, world' });
        }
        render() {
          return <div>{this.state.text}</div>;
        }
      }
      const markup = ReactDOMServer.renderToString(
        <Component />,
      );
      expect(markup).toContain('hello, world');
    });

    it('allows setState in componentWillMount with custom constructor', () => {
      class Component extends React.Component {
        constructor() {
          super();
          this.state = { text: 'default state' };
        }
        UNSAFE_componentWillMount() {
          this.setState({ text: 'hello, world' });
        }
        render() {
          return <div>{this.state.text}</div>;
          }
        }
      const markup = ReactDOMServer.renderToString(
        <Component />,
      );
      expect(markup).toContain('hello, world');
    });

    it('renders with props when using custom constructor', () => {
      class Component extends React.Component {
        render() {
          return <div>{this.props.text}</div>;
        }
      }
      const markup = ReactDOMServer.renderToString(
        <Component text="hello, world" />,
      );
      expect(markup).toContain('hello, world');
    });

    it('renders with context when using custom constructor', () => {
      class Component extends React.Component {
        render() {
          return <div>{this.context.text}</div>;
          }
        }
      Component.contextTypes = {
        text: PropTypes.string.isRequired,
      };
      class Provider extends React.Component {
        getChildContext() {
          return { text: 'hello, world' };
        }
      }
      Provider.childContextTypes = {
        text: PropTypes.string,
      };
      const markup = ReactDOMServer.renderToString(
        <Provider>
          <Component />
        </Provider>,
      );
      expect(markup).toContain('hello, world');
    });

    it('renders with new context API', () => {
      const Context = React.createContext(0);
      function Consumer(props) {
        return <Context.Consumer>{value => 'Result: ' + value}</Context.Consumer>;
      }
      const Indirection = React.Fragment;
      function App(props) {
        return (
          <Context.Provider value={props.value}>
            <Context.Provider value={2}>
              <Consumer />
            </Context.Provider>
            <Indirection>
              <Indirection>
                <Consumer />
                <Context.Provider value={3}>
                  <Consumer />
                </Context.Provider>
              </Indirection>
            </Indirection>
            <Consumer />
          </Context.Provider>
        );
      }
      const markup = ReactDOMServer.renderToString(
        <App value={1} />,
      );
      const results = markup.match(/\d+/g).map(Number);
      expect(results).toEqual([2, 1, 3, 1]);
    });

    it('renders with dispatcher.readContext mechanism', () => {
      const Context = React.createContext(0);
      function readContext(context) {
        return ReactSharedInternals.H.readContext(context);
      }
      function Consumer(props) {
        return 'Result: ' + readContext(Context);
      }
      const Indirection = React.Fragment;
      function App(props) {
        return (
          <Context.Provider value={props.value}>
            <Context.Provider value={2}>
              <Consumer />
            </Context.Provider>
            <Indirection>
              <Indirection>
                <Consumer />
                <Context.Provider value={3}>
                  <Consumer />
                </Provider>
              </Indirection>
            </Indirection>
            <Consumer />
          </Provider>
        );
      }
      const markup = ReactDOMServer.renderToString(
        <App value={1} />,
      );
      const results = markup.match(/\d+/g).map(Number);
      expect(results).toEqual([2, 1, 3, 1]);
    });
  });

  it('warns with a no-op when an async setState is triggered', () => {
    class Foo extends React.Component {
      UNSAFE_componentWillMount() {
        this.setState({ text: 'hello' });
        setTimeout(() => {
          this.setState({ text: 'error' });
        });
      }
      render() {
        return <div>{this.state.text}</div>;
      }
    }
    ReactDOMServer.renderToString(
      <Foo />,
    );
    setTimeout(() => {}, 0); // Ensures all timers are run.
    assertConsoleErrorDev([
      'Can only update a mounting component. This usually means you called setState() outside componentWillMount() on the server. This is a no-op.\n\nPlease check the code for the Foo component.',
    ], { withoutStack: true });
    const markup = ReactDOMServer.renderToStaticMarkup(
      <Foo />,
    );
    expect(markup).toBe('<div>hello</div>');
    // No additional warnings are expected
    setTimeout(() => {}, 0);
  });

  it('warns with a no-op when an async forceUpdate is triggered', () => {
    class Baz extends React.Component {
      UNSAFE_componentWillMount() {
        this.forceUpdate();
        setTimeout(() => {
          this.forceUpdate();
        });
      }
      render() {
        return <div></div>;
      }
    }
    ReactDOMServer.renderToString(
      <Baz />,
    );
    assertConsoleErrorDev([
      'Can only update a mounting component. This usually means you called forceUpdate() outside componentWillMount() on the server. This is a no-op.\n\nPlease check the code for the Baz component.',
    ], { withoutStack: true });
    const markup = ReactDOMServer.renderToStaticMarkup(
      <Baz />,
    );
    expect(markup).toBe('<div></div>');
  });

  it('should throw (in dev) when children are mutated during render', () => {
    function Wrapper(props) {
      const children = props.children.slice();
      children[1] = <p key={1} />;
      return <div>{children}</div>;
    }
    expect(() => {
      ReactDOMServer.renderToStaticMarkup(
        <Wrapper>
          <span key={0} />
          <span key={1} />
          <span key={2} />
        </Wrapper>,
      );
    }).toThrowError(/Cannot assign to read only property.*/);
  });

  it('warns about lowercase html but not in svg tags', () => {
    function CompositeG(props) {
      return <g>{props.children}</g>;
    }
    ReactDOMServer.renderToStaticMarkup(
      <div>
        <inPUT />
        <svg>
          <CompositeG>
            <linearGradient />
            <foreignObject>
              <iFrame />
            </foreignObject>
          </CompositeG>
        </svg>
      </div>,
    );
    assertConsoleErrorDev([
      '<inPUT /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.\n    in inPUT (at **)',
      '<iFrame /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.\n    in iFrame (at **)',
    ]);
  });

  it('should warn about contentEditable and children', () => {
    ReactDOMServer.renderToString(
      <div contentEditable={true} children="" />,
    );
    assertConsoleErrorDev([
      'A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.\n    in div (at **)',
    ]);
  });

  it('should warn when server rendering a class with a render method that does not extend React.Component', () => {
    class FooClass {
      render() {
        return <div />;
      }
    }
    expect(() => {
      ReactDOMServer.renderToString(
        <FooClass />,
      );
    }).toThrow(TypeError);
    assertConsoleErrorDev([
      'The <FooClass /> component appears to have a render method, but doesn’t extend React.Component. This is likely to cause errors. Change FooClass to extend React.Component.',
    ]);
    expect(() => {
      ReactDOMServer.renderToString(
        <FooClass />,
      );
    }).toThrow(TypeError);
  });

  it('should warn if an invalid contextType is defined', () => {
    const Context = React.createContext();
    class ComponentA extends React.Component {
      static contextType = Context.Consumer;
      render() {
        return <div />;
      }
    }

    ReactDOMServer.renderToString(
      <ComponentA />,
    );
    assertConsoleErrorDev(
      'ComponentA defines an invalid context type. Context type should be a context object. Did you accidentally pass the Context.Consumer instead?',
    );

    // No duplication for same component type.
    ReactDOMServer.renderToString(<ComponentA />);

    class ComponentB extends React.Component {
      static contextType = Context; //.Provider === Context
      render() {
        return <div />;
      }
    }

    // Does not warn because Context === Provider
    ReactDOMServer.renderToString(<ComponentB />);
  });

  it('should not warn when class contextType is null', () => {
    class Foo extends React.Component {
      static contextType = null;
      render() {
        return this.context.hello.world;
      }
    }

    expect(() => {
      ReactDOMServer.renderToString(
        <Foo />,
      );
    }).toThrow('Cannot read property \'world\' of undefined');
  });

  it('should warn when class contextType is undefined', () => {
    class Foo extends React.Component {
      static contextType = undefined;
      render() {
        return this.context.hello.world;
      }
    }

    expect(() => {
      ReactDOMServer.renderToString(
        <Foo />,
      );
    }).toThrow('Cannot read property \'world\' of undefined');
    assertConsoleErrorDev([
      'Foo defines an invalid contextType. However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency; try moving createContext() to a separate file.',
    ]);
  });

  it('should warn when class contextType is an object', () => {
    class Foo extends React.Component {
      static contextType = { x: 42, y: 'hi' };
      render() {
        return this.context.hello.world;
      }
    }

    expect(() => {
      ReactDOMServer.renderToString(
        <Foo />,
      );
    }).toThrow('Cannot read property \'hello\' of undefined');
    assertConsoleErrorDev([
      'Foo defines an invalid contextType. However, it is an object with keys {x, y}.',
    ]);
  });

  it('should warn when class contextType is a primitive', () => {
    class Foo extends React.Component {
      static contextType = 'foo';
      render() {
        return this.context.hello.world;
      }
    }

    expect(() => {
      ReactDOMServer.renderToString(
        <Foo />,
      );
    }).toThrow('Cannot read property \'world\' of undefined');
    assertConsoleErrorDev([
      'Foo defines an invalid contextType. However, it is a string.',
    ]);
  });

  describe('custom element server rendering', () => {
    it('String properties should be server rendered for custom elements', () => {
      const output = ReactDOMServer.renderToString(
        <my-custom-element foo="bar" />,
      );
      expect(output).toBe('<my-custom-element foo="bar"></my-element>');
    });
    it('Number properties should be server rendered for custom elements', () => {
      const output = ReactDOMServer.renderToString(
        <my-custom-element foo={5} />,
      );
      expect(output).toBe('<my-custom-element foo="5"></my-element>');
    });
    // @gate enableCustomElementPropertySupport
    it('Object properties should not be server rendered for custom elements', () => {
      const output = ReactDOMServer.renderToString(
        <my-custom-element foo={{ foo: 'bar' }} />,
      );
      expect(output).toBe('<my-custom-element></my-element>');
    });
    // @gate enableCustomElementPropertySupport
    it('Array properties should not be server rendered for custom elements', () => {
      const output = ReactDOMServer.renderToString(
        <my-custom-element foo={['foo', 'bar']} />,
      );
      expect(output).toBe('<my-custom-element></my-element>');
    });
    it('Function properties should not be server rendered for custom elements', () => {
      const output = ReactDOMServer.renderToString(
        <my-custom-element foo={() => console.log('bar')} />,
      );
      expect(output).toBe('<my-custom-element></my-element>');
    });
  });
});