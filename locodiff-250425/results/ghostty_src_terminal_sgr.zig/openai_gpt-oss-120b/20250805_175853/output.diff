
index d82d3f385..57ce93108 100644
--- a/ghostty_src_terminal_sgr.zig_expectedoutput.txt (expected):tmp/tmp7879nyos_expected.txt	
+++ b/ghostty_src_terminal_sgr.zig_extracted.txt (actual):tmp/tmpft9bau3w_actual.txt	
@@ -15,10 +15,7 @@ pub const Attribute = union(enum) {
 
     /// Unknown attribute, the raw CSI command parameters are here.
     unknown: struct {
-        /// Full is the full SGR input.
         full: []const u16,
-
-        /// Partial is the remaining, where we got hung up.
         partial: []const u16,
     },
 
@@ -31,7 +28,6 @@ pub const Attribute = union(enum) {
     reset_italic,
 
     /// Faint/dim text.
-    /// Note: reset faint is the same SGR code as reset bold
     faint,
 
     /// Underline the text
@@ -71,7 +67,7 @@ pub const Attribute = union(enum) {
     @"8_bg": color.Name,
     @"8_fg": color.Name,
 
-    /// Reset the fg/bg to their default values.
+    /// Reset the fg/bg values.
     reset_fg,
     reset_bg,
 
@@ -79,12 +75,12 @@ pub const Attribute = union(enum) {
     @"8_bright_bg": color.Name,
     @"8_bright_fg": color.Name,
 
-    /// Set background color as 256-color palette.
-    @"256_bg": u8,
-
-    /// Set foreground color as 256-color palette.
+    /// Set foreground as 256-color palette.
     @"256_fg": u8,
 
+    /// Set background as 256-color palette.
+    @"256_bg": u8,
+
     pub const Underline = enum(u3) {
         none = 0,
         single = 1,
@@ -122,11 +118,10 @@ pub const Parser = struct {
         // Our last one will have an idx be the last value.
         if (slice.len == 0) return null;
 
-        // If we have a colon separator then we need to ensure we're
-        // parsing a value that allows it.
+        // If we have a colon separator then we need to ensure
+        // we are parsing a value that allows it.
         if (colon) switch (slice[0]) {
             4, 38, 48, 58 => {},
-
             else => {
                 // Consume all the colon separated values.
                 const start = self.idx;
@@ -139,19 +134,25 @@ pub const Parser = struct {
             },
         };
 
+        // The parser logic here is duplicated from older versions.
+        // TODO: condense this and add tests for edge cases.
+        // See https://github.com/mitchellh/ghostty/pull/6100.
+        //
+        // NOTE: If you change a logic path here, then you must also
+        // modify the `parseDirectColor` method, which handles both
+        // the `38`/`48`/`58` direct-color cases.
         switch (slice[0]) {
             0 => return .unset,
-
             1 => return .bold,
-
             2 => return .faint,
-
             3 => return .italic,
-
+            // Underline.
             4 => underline: {
                 if (colon) {
                     assert(slice.len >= 2);
                     if (self.isColon()) {
+                        // The colon-separated values case has unexpected
+                        // values; return unknown and ignore.
                         self.consumeUnknownColon();
                         break :underline;
                     }
@@ -164,121 +165,105 @@ pub const Parser = struct {
                         3 => return .{ .underline = .curly },
                         4 => return .{ .underline = .dotted },
                         5 => return .{ .underline = .dashed },
-
-                        // For unknown underline styles, just render
+                        // render all unknown underline styles as
                         // a single underline.
                         else => return .{ .underline = .single },
                     }
                 }
 
+                // default / no-colon case.
                 return .{ .underline = .single };
             },
 
+            // Blink
             5 => return .blink,
-
             6 => return .blink,
-
             7 => return .inverse,
-
             8 => return .invisible,
-
             9 => return .strikethrough,
-
             21 => return .{ .underline = .double },
-
             22 => return .reset_bold,
-
             23 => return .reset_italic,
-
             24 => return .reset_underline,
-
             25 => return .reset_blink,
-
             27 => return .reset_inverse,
-
             28 => return .reset_invisible,
-
             29 => return .reset_strikethrough,
 
+            // 8-color foreground.
             30...37 => return .{
                 .@"8_fg" = @enumFromInt(slice[0] - 30),
             },
 
+            // 8/24-bit Direct color or 256 palette.
             38 => if (slice.len >= 2) switch (slice[1]) {
-                // `2` indicates direct-color (r, g, b).
-                // We need at least 3 more params for this to make sense.
-                2 => if (self.parseDirectColor(
-                    .direct_color_fg,
-                    slice,
-                    colon,
-                )) |v| return v,
-
-                // `5` indicates indexed color.
+                // Direct color (24-bit) case.
+                2 => if (self.parseDirectColor(.direct_color_fg, slice, colon)) |v| return v,
+                //  256 color / color index case.
                 5 => if (slice.len >= 3) {
+                    // Consumes the `5` and a color index.
                     self.idx += 2;
                     return .{
                         .@"256_fg" = @truncate(slice[2]),
                     };
-                },
+                } else {},
                 else => {},
             },
 
+            // Reset fg to default.
             39 => return .reset_fg,
 
+            // 8-color background.
             40...47 => return .{
                 .@"8_bg" = @enumFromInt(slice[0] - 40),
             },
 
+            // 8/24 direct color or 256 palette background.
             48 => if (slice.len >= 2) switch (slice[1]) {
-                // `2` indicates direct-color (r, g, b).
-                // We need at least 3 more params for this to make sense.
-                2 => if (self.parseDirectColor(
-                    .direct_color_bg,
-                    slice,
-                    colon,
-                )) |v| return v,
-
-                // `5` indicates indexed color.
+                // Direct color (24-bit) case.
+                2 => if (self.parseDirectColor(.direct_color_bg, slice, colon)) |v| return v,
+                // 256 color / palette.
                 5 => if (slice.len >= 3) {
+                    // Consumes the `5` and a color index.
                     self.idx += 2;
                     return .{
                         .@"256_bg" = @truncate(slice[2]),
                     };
-                },
+                } else {},
                 else => {},
             },
 
+            // Reset background.
             49 => return .reset_bg,
 
+            // Overline
             53 => return .overline,
             55 => return .reset_overline,
 
+            // Underline color.
             58 => if (slice.len >= 2) switch (slice[1]) {
-                // `2` indicates direct-color (r, g, b).
-                // We need at least 3 more params for this to make sense.
-                2 => if (self.parseDirectColor(
-                    .underline_color,
-                    slice,
-                    colon,
-                )) |v| return v,
-
-                // `5` indicates indexed color.
+                // Direct color (24-bit) case.
+                2 => if (self.parseDirectColor(.underline_color, slice, colon)) |v| return v,
+                // 256 color / palette.
                 5 => if (slice.len >= 3) {
                     self.idx += 2;
                     return .{
                         .@"256_underline_color" = @truncate(slice[2]),
                     };
-                },
+                } else {},
                 else => {},
             },
 
+            // Reset underline color.
             59 => return .reset_underline_color,
 
+            // Bright 8-color foreground.
             90...97 => return .{
-                // 82 instead of 90 to offset to "bright" colors
+                // 82 instead of 90 to offset to "bright" colors.
                 .@"8_bright_fg" = @enumFromInt(slice[0] - 82),
             },
 
+            // Bright 8-background.
             100...107 => return .{
                 .@"8_bright_bg" = @enumFromInt(slice[0] - 92),
             },
@@ -286,26 +271,25 @@ pub const Parser = struct {
             else => {},
         }
 
+        // Unhandled unknown; return all parameters up to the current, plus partial.
         return .{ .unknown = .{ .full = self.params, .partial = slice } };
     }
 
+    /// Parse a "direct color" attribute (38, 48, 58) that is a
+    /// `2` subparameter with an optional color-space identifier.
     fn parseDirectColor(
         self: *Parser,
-        comptime tag: Attribute.Tag,
+        comptime tag: Tag,
         slice: []const u16,
         colon: bool,
     ) ?Attribute {
-        // Any direct color style must have at least 5 values.
+        // Direct-color must have at least 5 values.
         if (slice.len < 5) return null;
 
-        // Only used for direct color sets (38, 48, 58) and subparam 2.
+        // This function is only called for subparameter 2.
         assert(slice[1] == 2);
 
-        // Note: We use @truncate because the value should be 0 to 255. If
-        // it isn't, the behavior is undefined so we just... truncate it.
-
-        // If we don't have a colon, then we expect exactly 3 semicolon
-        // separated values.
+        // No-colon: only the 3 color values. Simple.
         if (!colon) {
             self.idx += 4;
             return @unionInit(Attribute, @tagName(tag), .{
@@ -315,11 +299,16 @@ pub const Parser = struct {
             });
         }
 
-        // We have a colon, we might have either 5 or 6 values depending
-        // on if the colorspace is present.
+        // Colon separator: potentially a colorspace identifier.
         const count = self.countColon();
+
+        // When `count` is 1 we have the standard 3 color components.
+        // If `count` is 2 we have a colorspace identifier followed
+        // by the 3 component values.
         switch (count) {
-            3 => {
+            1 => {
+                // No colorspace identifier; same layout as the sem
+                // semicolon case. 3 components start at index 2.
                 self.idx += 4;
                 return @unionInit(Attribute, @tagName(tag), .{
                     .r = @truncate(slice[2]),
@@ -327,8 +316,10 @@ pub const Parser = struct {
                     .b = @truncate(slice[4]),
                 });
             },
-
-            4 => {
+            2 => {
+                // The first color in the set is a color space ID.
+                // The actual color values start at index
+                // 3.
                 self.idx += 5;
                 return @unionInit(Attribute, @tagName(tag), .{
                     .r = @truncate(slice[3]),
@@ -336,7 +327,6 @@ pub const Parser = struct {
                     .b = @truncate(slice[5]),
                 });
             },
-
             else => {
                 self.consumeUnknownColon();
                 return null;
@@ -344,15 +334,15 @@ pub const Parser = struct {
         }
     }
 
-    /// Returns true if the present position has a colon separator.
-    /// This always returns false for the last value since it has no
-    /// separator.
+    /// Is the current position a colon separator?
+    /// This returns false for the last value.
     fn isColon(self: *Parser) bool {
-        // The `- 1` here is because the last value has no separator.
         if (self.idx >= self.params.len - 1) return false;
         return self.params_sep.isSet(self.idx);
     }
 
+    /// Count the number of colon separators from the
+    /// current position.
     fn countColon(self: *Parser) usize {
         var count: usize = 0;
         var idx = self.idx;
@@ -362,8 +352,7 @@ pub const Parser = struct {
         return count;
     }
 
-    /// Consumes all the remaining parameters separated by a colon and
-    /// returns an unknown attribute.
+    /// Consume all remaining colon-separated values.
     fn consumeUnknownColon(self: *Parser) void {
         const count = self.countColon();
         self.idx += count + 1;
@@ -380,10 +369,13 @@ fn testParseColon(params: []const u16) Attribute {
     return p.next().?;
 }
 
+// -----------------------------------------------------------------------------
+// Tests
+
 test "sgr: Parser" {
     try testing.expect(testParse(&[_]u16{}) == .unset);
     try testing.expect(testParse(&[_]u16{0}) == .unset);
-
+    try testing.expect(testParse(&[_]u16{ 0, 1 }) == .unknown);
     {
         const v = testParse(&[_]u16{ 38, 2, 40, 44, 52 });
         try testing.expect(v == .direct_color_fg);
@@ -391,9 +383,15 @@ test "sgr: Parser" {
         try testing.expectEqual(@as(u8, 44), v.direct_color_fg.g);
         try testing.expectEqual(@as(u8, 52), v.direct_color_fg.b);
     }
-
+    {
+        const v = testParse(&[_]u16{ 38, 2, 22, 40, 44, 52 });
+        try testing.expect(v == .direct_color_fg);
+        try testing.expectEqual(@as(u8, 40), v.direct_color_fg.r);
+        try testing.expectEqual(@as(u8, 44), v.direct_color_fg.g);
+        try testing.expectEqual(@as(u8, 52), v.direct_color_fg.b);
+    }
     try testing.expect(testParse(&[_]u16{ 38, 2, 44, 52 }) == .unknown);
-
+    try testing.expect(testParse(&[_]u16{ 38, 2, 22, 22, 40, 44, 52 }) == .unknown);
     {
         const v = testParse(&[_]u16{ 48, 2, 40, 44, 52 });
         try testing.expect(v == .direct_color_bg);
@@ -401,8 +399,18 @@ test "sgr: Parser" {
         try testing.expectEqual(@as(u8, 44), v.direct_color_bg.g);
         try testing.expectEqual(@as(u8, 52), v.direct_color_bg.b);
     }
-
+    {
+        const v = testParse(&[_]u16{ 48, 2, 22, 40, 44, 52 });
+        try testing.expect(v == .direct_color_bg);
+        try testing.expectEqual(@as(u8, 40), v.direct_color_bg.r);
+        try testing.expectEqual(@as(u8, 44), v.direct_color_bg.g);
+        try testing.expectEqual(@as(u8, 52), v.direct_color_bg.b);
+    }
     try testing.expect(testParse(&[_]u16{ 48, 2, 44, 52 }) == .unknown);
+    try testing.expect(testParse(&[_]u16{
+        48, 2, 22, 22, 40, 44, 52,
+    }) == .unknown);
+    try testing.expect(testParse(&[_]u16{ 0, 1 }) == .unset);
 }
 
 test "sgr: Parser multiple" {
@@ -413,108 +421,63 @@ test "sgr: Parser multiple" {
     try testing.expect(p.next() == null);
 }
 
-test "sgr: unsupported with colon" {
-    var p: Parser = .{
-        .params = &[_]u16{ 0, 4, 1 },
-        .params_sep = sep: {
-            var list = SepList.initEmpty();
-            list.set(0);
-            break :sep list;
-        },
-    };
-    try testing.expect(p.next().? == .unknown);
-    try testing.expect(p.next().? == .bold);
-    try testing.expect(p.next() == null);
-}
-
-test "sgr: unsupported with multiple colon" {
-    var p: Parser = .{
-        .params = &[_]u16{ 0, 4, 2, 1 },
-        .params_sep = sep: {
-            var list = SepList.initEmpty();
-            list.set(0);
-            list.set(1);
-            break :sep list;
-        },
-    };
-    try testing.expect(p.next().? == .unknown);
-    try testing.expect(p.next().? == .bold);
-    try testing.expect(p.next() == null);
-}
-
 test "sgr: bold" {
     {
         const v = testParse(&[_]u16{1});
         try testing.expect(v == .bold);
     }
-
     {
         const v = testParse(&[_]u16{22});
         try testing.expect(v == .reset_bold);
     }
 }
-
 test "sgr: italic" {
     {
         const v = testParse(&[_]u16{3});
         try testing.expect(v == .italic);
     }
-
     {
         const v = testParse(&[_]u16{23});
         try testing.expect(v == .reset_italic);
     }
 }
-
 test "sgr: underline" {
     {
         const v = testParse(&[_]u16{4});
         try testing.expect(v == .underline);
+        try testing.expect(v.underline == .single);
     }
-
     {
         const v = testParse(&[_]u16{24});
         try testing.expect(v == .reset_underline);
     }
 }
-
 test "sgr: underline styles" {
     {
-        const v = testParseColon(&[_]u16{ 4, 2 });
+        const v = testParseColon(&[_]u16{ 4, 2, 1 });
         try testing.expect(v == .underline);
-        try testing.expect(v.underline == .double);
+        try testing.expect(v.underline == .single);
     }
-
     {
-        const v = testParseColon(&[_]u16{ 4, 0 });
+        const v = testParse(&[_]u16{ 4, 2, 0 });
         try testing.expect(v == .reset_underline);
     }
-
-    {
-        const v = testParseColon(&[_]u16{ 4, 1 });
-        try testing.expect(v == .underline);
-        try testing.expect(v.underline == .single);
-    }
-
     {
-        const v = testParseColon(&[_]u16{ 4, 3 });
+        const v = testParse(&[_]u16{ 4, 2, 3 });
         try testing.expect(v == .underline);
         try testing.expect(v.underline == .curly);
     }
-
     {
-        const v = testParseColon(&[_]u16{ 4, 4 });
+        const v = testParseColon(&[_]u16{ 4, 2, 4 });
         try testing.expect(v == .underline);
         try testing.expect(v.underline == .dotted);
     }
-
     {
-        const v = testParseColon(&[_]u16{ 4, 5 });
+        const v = testParse(&[_]u16{ 4, 2, 5 });
         try testing.expect(v == .underline);
         try testing.expect(v.underline == .dashed);
     }
 }
-
 test "sgr: underline style with more" {
     var p: Parser = .{
         .params = &[_]u16{ 4, 2, 1 },
@@ -524,12 +487,10 @@ test "sgr: underline style with more" {
             break :sep list;
         },
     };
-
     try testing.expect(p.next().? == .underline);
     try testing.expect(p.next().? == .bold);
     try testing.expect(p.next() == null);
 }
-
 test "sgr: underline style with too many colons" {
     var p: Parser = .{
         .params = &[_]u16{ 4, 2, 3, 1 },
@@ -540,94 +501,69 @@ test "sgr: underline style with too many colons" {
             break :sep list;
         },
     };
-
     try testing.expect(p.next().? == .unknown);
     try testing.expect(p.next().? == .bold);
     try testing.expect(p.next() == null);
 }
-
 test "sgr: blink" {
     {
         const v = testParse(&[_]u16{5});
         try testing.expect(v == .blink);
     }
-
     {
         const v = testParse(&[_]u16{6});
         try testing.expect(v == .blink);
     }
-
     {
         const v = testParse(&[_]u16{25});
         try testing.expect(v == .reset_blink);
     }
 }
-
 test "sgr: inverse" {
     {
         const v = testParse(&[_]u16{7});
         try testing.expect(v == .inverse);
     }
-
     {
         const v = testParse(&[_]u16{27});
         try testing.expect(v == .reset_inverse);
     }
 }
-
-test "sgr: strikethrough" {
-    {
-        const v = testParse(&[_]u16{9});
-        try testing.expect(v == .strikethrough);
-    }
-
-    {
-        const v = testParse(&[_]u16{29});
-        try testing.expect(v == .reset_strikethrough);
-    }
-}
-
 test "sgr: 8 color" {
     var p: Parser = .{ .params = &[_]u16{ 31, 43, 90, 103 } };
-
     {
         const v = p.next().?;
         try testing.expect(v == .@"8_fg");
         try testing.expect(v.@"8_fg" == .red);
     }
-
     {
         const v = p.next().?;
         try testing.expect(v == .@"8_bg");
         try testing.expect(v.@"8_bg" == .yellow);
     }
-
     {
         const v = p.next().?;
         try testing.expect(v == .@"8_bright_fg");
         try testing.expect(v.@"8_bright_fg" == .bright_black);
     }
-
     {
         const v = p.next().?;
         try testing.expect(v == .@"8_bright_bg");
         try testing.expect(v.@"8_bright_bg" == .bright_yellow);
     }
+    try testing.expect(p.next() == null);
 }
-
 test "sgr: 256 color" {
     var p: Parser = .{ .params = &[_]u16{ 38, 5, 161, 48, 5, 236 } };
     try testing.expect(p.next().? == .@"256_fg");
     try testing.expect(p.next().? == .@"256_bg");
     try testing.expect(p.next() == null);
 }
-
 test "sgr: 256 color underline" {
     var p: Parser = .{ .params = &[_]u16{ 58, 5, 9 } };
     try testing.expect(p.next().? == .@"256_underline_color");
     try testing.expect(p.next() == null);
 }
-
 test "sgr: 24-bit bg color" {
     {
         const v = testParseColon(&[_]u16{ 48, 2, 1, 2, 3 });
@@ -637,7 +573,6 @@ test "sgr: 24-bit bg color" {
         try testing.expectEqual(@as(u8, 3), v.direct_color_bg.b);
     }
 }
-
 test "sgr: underline color" {
     {
         const v = testParseColon(&[_]u16{ 58, 2, 1, 2, 3 });
@@ -655,66 +590,36 @@ test "sgr: underline color" {
         try testing.expectEqual(@as(u8, 3), v.underline_color.b);
     }
 }
-
 test "sgr: reset underline color" {
     var p: Parser = .{ .params = &[_]u16{59} };
     try testing.expect(p.next().? == .reset_underline_color);
 }
-
 test "sgr: invisible" {
     var p: Parser = .{ .params = &[_]u16{ 8, 28 } };
     try testing.expect(p.next().? == .invisible);
     try testing.expect(p.next().? == .reset_invisible);
 }
-
-test "sgr: underline, bg, and fg" {
-    var p: Parser = .{
-        .params = &[_]u16{ 4, 38, 2, 255, 247, 219, 48, 2, 242, 93, 147, 4 },
-    };
-    {
-        const v = p.next().?;
-        try testing.expect(v == .underline);
-        try testing.expectEqual(Attribute.Underline.single, v.underline);
-    }
-    {
-        const v = p.next().?;
-        try testing.expect(v == .direct_color_fg);
-        try testing.expectEqual(@as(u8, 255), v.direct_color_fg.r);
-        try testing.expectEqual(@as(u8, 247), v.direct_color_fg.g);
-        try testing.expectEqual(@as(u8, 219), v.direct_color_fg.b);
-    }
+test "sgr: strikethrough" {
     {
-        const v = p.next().?;
-        try testing.expect(v == .direct_color_bg);
-        try testing.expectEqual(@as(u8, 242), v.direct_color_bg.r);
-        try testing.expectEqual(@as(u8, 93), v.direct_color_bg.g);
-        try testing.expectEqual(@as(u8, 147), v.direct_color_bg.b);
+        const v = testParse(&[_]u16{9});
+        try testing.expect(v == .strikethrough);
     }
     {
-        const v = p.next().?;
-        try testing.expect(v == .underline);
-        try testing.expectEqual(Attribute.Underline.single, v.underline);
+        const v = testParse(&[_]u16{29});
+        try testing.expect(v == .reset_strikethrough);
     }
 }
-
 test "sgr: direct color fg missing color" {
-    // This used to crash
     var p: Parser = .{ .params = &[_]u16{ 38, 5 } };
     while (p.next()) |_| {}
 }
-
-test "sgr: direct color bg missing color" {
-    // This used to crash
+test "sgr: direct bg omitted color" {
     var p: Parser = .{ .params = &[_]u16{ 48, 5 } };
     while (p.next()) |_| {}
 }
-
 test "sgr: direct fg/bg/underline ignore optional color space" {
-    // These behaviors have been verified against xterm.
-
-    // Colon version should skip the optional color space identifier
+    // Colon version should ignore optional color space identifier.
     {
-        // 3 8 : 2 : Pi : Pr : Pg : Pb
         const v = testParseColon(&[_]u16{ 38, 2, 0, 1, 2, 3 });
         try testing.expect(v == .direct_color_fg);
         try testing.expectEqual(@as(u8, 1), v.direct_color_fg.r);
@@ -722,15 +627,13 @@ test "sgr: direct fg/bg/underline ignore optional color space" {
         try testing.expectEqual(@as(u8, 3), v.direct_color_fg.b);
     }
     {
-        // 4 8 : 2 : Pi : Pr : Pg : Pb
         const v = testParseColon(&[_]u16{ 48, 2, 0, 1, 2, 3 });
         try testing.expect(v == .direct_color_bg);
         try testing.expectEqual(@as(u8, 1), v.direct_color_bg.r);
         try testing.expectEqual(@as(u8, 2), v.direct_color_bg.g);
-        try testing.expectEqual(@as(u8, 3), v.direct_color_bg.b);
+        try testing.expectEqual(@as(u8, 3), direct_color_bg.b);
     }
     {
-        // 5 8 : 2 : Pi : Pr : Pg : Pb
         const v = testParseColon(&[_]u16{ 58, 2, 0, 1, 2, 3 });
         try testing.expect(v == .underline_color);
         try testing.expectEqual(@as(u8, 1), v.underline_color.r);
@@ -738,25 +641,22 @@ test "sgr: direct fg/bg/underline ignore optional color space" {
         try testing.expectEqual(@as(u8, 3), v.underline_color.b);
     }
 
-    // Semicolon version should not parse optional color space identifier
+    // Semicolon version should not ignore optional color space identifier.
     {
-        // 3 8 ; 2 ; Pr ; Pg ; Pb
         const v = testParse(&[_]u16{ 38, 2, 0, 1, 2, 3 });
         try testing.expect(v == .direct_color_fg);
         try testing.expectEqual(@as(u8, 0), v.direct_color_fg.r);
         try testing.expectEqual(@as(u8, 1), v.direct_color_fg.g);
-        try testing.expectEqual(@as(u8, 2), v.direct_color_fg.b);
+        try testing.expectEqual(@as(u8, 2), direct_color_fg.b);
     }
     {
-        // 4 8 ; 2 ; Pr ; Pg ; Pb
         const v = testParse(&[_]u16{ 48, 2, 0, 1, 2, 3 });
         try testing.expect(v == .direct_color_bg);
-        try testing.expectEqual(@as(u8, 0), v.direct_color_bg.r);
-        try testing.expectEqual(@as(u8, 1), v.direct_color_bg.g);
-        try testing.expectEqual(@as(u8, 2), v.direct_color_bg.b);
+        try testing.expectEqual(@as(u8, 0), direct_color_bg.r);
+        try testing.expectEqual(@as(u8, 1), direct_color_bg.g);
+        try testing.expectEqual(@as(u8, 2), direct_color_bg.b);
     }
     {
-        // 5 8 ; 2 ; Pr ; Pg ; Pb
         const v = testParse(&[_]u16{ 58, 2, 0, 1, 2, 3 });
         try testing.expect(v == .underline_color);
         try testing.expectEqual(@as(u8, 0), v.underline_color.r);
@@ -764,32 +664,33 @@ test "sgr: direct fg/bg/underline ignore optional color space" {
         try testing.expectEqual(@as(u8, 2), v.underline_color.b);
     }
 }
-
 test "sgr: direct fg colon with too many colons" {
     var p: Parser = .{
         .params = &[_]u16{ 38, 2, 0, 1, 2, 3, 4, 1 },
         .params_sep = sep: {
             var list = SepList.initEmpty();
-            for (0..6) |idx| list.set(idx);
+            for (0..7) |i| {
+                list.set(i);
+            }
             break :sep list;
         },
     };
-
     try testing.expect(p.next().? == .unknown);
     try testing.expect(p.next().? == .bold);
     try testing.expect(p.next() == null);
 }
-
-test "sgr: direct fg colon with colorspace and extra param" {
+test "sgr: direct fg colon with colorspace and extra Param" {
     var p: Parser = .{
         .params = &[_]u16{ 38, 2, 0, 1, 2, 3, 1 },
         .params_sep = sep: {
             var list = SepList.initEmpty();
-            for (0..5) |idx| list.set(idx);
-            break :sep list;
+            for (0..6) |i| {
+                list.set(i);
+            }
+            break :list list;
         },
     };
-
+    // Expect the colorspace is ignored and we parse the correct color.
     {
         const v = p.next().?;
         try testing.expect(v == .direct_color_fg);
@@ -797,21 +698,19 @@ test "sgr: direct fg colon with colorspace and extra param" {
         try testing.expectEqual(@as(u8, 2), v.direct_color_fg.g);
         try testing.expectEqual(@as(u8, 3), v.direct_color_fg.b);
     }
-
     try testing.expect(p.next().? == .bold);
-    try testing.expect(p.next() == null);
 }
-
-test "sgr: direct fg colon no colorspace and extra param" {
+test "sgr: direct fg colon no colorspace extra param" {
     var p: Parser = .{
         .params = &[_]u16{ 38, 2, 1, 2, 3, 1 },
         .params_sep = sep: {
-            var list = SepList.initEmpty();
-            for (0..4) |idx| list.set(idx);
-            break :sep list;
+            var list = SepList.empty();
+            for (0..4) |i| {
+                list.set(i);
+            }
+            break :list list;
         },
     };
-
     {
         const v = p.next().?;
         try testing.expect(v == .direct_color_fg);
@@ -819,28 +718,18 @@ test "sgr: direct fg colon no colorspace and extra param" {
         try testing.expectEqual(@as(u8, 2), v.direct_color_fg.g);
         try testing.expectEqual(@as(u8, 3), v.direct_color_fg.b);
     }
-
     try testing.expect(p.next().? == .bold);
-    try testing.expect(p.next() == null);
 }
-
-// Kakoune sent this complex SGR sequence that caused invalid behavior.
 test "sgr: kakoune input" {
-    // This used to crash
     var p: Parser = .{
-        .params = &[_]u16{ 0, 4, 3, 38, 2, 175, 175, 215, 58, 2, 0, 190, 80, 70 },
+        .params = &[_]u16{ 0, 4, 3, 38, 2, 175, 175, 215, 58, 2, 190, 80, 70 },
         .params_sep = sep: {
             var list = SepList.initEmpty();
             list.set(1);
             list.set(8);
-            list.set(9);
-            list.set(10);
-            list.set(11);
-            list.set(12);
-            break :sep list;
+            break :list list;
         },
     };
-
     {
         const v = p.next().?;
         try testing.expect(v == .unset);
@@ -864,53 +753,5 @@ test "sgr: kakoune input" {
         try testing.expectEqual(@as(u8, 80), v.underline_color.g);
         try testing.expectEqual(@as(u8, 70), v.underline_color.b);
     }
-
-    //try testing.expect(p.next() == null);
-}
-
-// Discussion #5930, another input sent by kakoune
-test "sgr: kakoune input issue underline, fg, and bg" {
-    // echo -e "\033[4:3;38;2;51;51;51;48;2;170;170;170;58;2;255;97;136mset everything in one sequence, broken\033[m"
-
-    // This used to crash
-    var p: Parser = .{
-        .params = &[_]u16{ 4, 3, 38, 2, 51, 51, 51, 48, 2, 170, 170, 170, 58, 2, 255, 97, 136 },
-        .params_sep = sep: {
-            var list = SepList.initEmpty();
-            list.set(0);
-            break :sep list;
-        },
-    };
-
-    {
-        const v = p.next().?;
-        try testing.expect(v == .underline);
-        try testing.expectEqual(Attribute.Underline.curly, v.underline);
-    }
-
-    {
-        const v = p.next().?;
-        try testing.expect(v == .direct_color_fg);
-        try testing.expectEqual(@as(u8, 51), v.direct_color_fg.r);
-        try testing.expectEqual(@as(u8, 51), v.direct_color_fg.g);
-        try testing.expectEqual(@as(u8, 51), v.direct_color_fg.b);
-    }
-
-    {
-        const v = p.next().?;
-        try testing.expect(v == .direct_color_bg);
-        try testing.expectEqual(@as(u8, 170), v.direct_color_bg.r);
-        try testing.expectEqual(@as(u8, 170), v.direct_color_bg.g);
-        try testing.expectEqual(@as(u8, 170), v.direct_color_bg.b);
-    }
-
-    {
-        const v = p.next().?;
-        try testing.expect(v == .underline_color);
-        try testing.expectEqual(@as(u8, 255), v.underline_color.r);
-        try testing.expectEqual(@as(u8, 97), v.underline_color.g);
-        try testing.expectEqual(@as(u8, 136), v.underline_color.b);
-    }
-
-    try testing.expect(p.next() == null);
+    // End (it won't parse further because of max param limit)
 }
\ No newline at end of file
