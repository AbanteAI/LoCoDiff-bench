--- ghostty_src_terminal_sgr.zig_expectedoutput.txt (expected)+++ ghostty_src_terminal_sgr.zig_extracted.txt (actual)@@ -368,549 +368,4 @@         const count = self.countColon();
         self.idx += count + 1;
     }
-};
-
-fn testParse(params: []const u16) Attribute {
-    var p: Parser = .{ .params = params };
-    return p.next().?;
-}
-
-fn testParseColon(params: []const u16) Attribute {
-    var p: Parser = .{ .params = params, .params_sep = SepList.initFull() };
-    return p.next().?;
-}
-
-test "sgr: Parser" {
-    try testing.expect(testParse(&[_]u16{}) == .unset);
-    try testing.expect(testParse(&[_]u16{0}) == .unset);
-
-    {
-        const v = testParse(&[_]u16{ 38, 2, 40, 44, 52 });
-        try testing.expect(v == .direct_color_fg);
-        try testing.expectEqual(@as(u8, 40), v.direct_color_fg.r);
-        try testing.expectEqual(@as(u8, 44), v.direct_color_fg.g);
-        try testing.expectEqual(@as(u8, 52), v.direct_color_fg.b);
-    }
-
-    try testing.expect(testParse(&[_]u16{ 38, 2, 44, 52 }) == .unknown);
-
-    {
-        const v = testParse(&[_]u16{ 48, 2, 40, 44, 52 });
-        try testing.expect(v == .direct_color_bg);
-        try testing.expectEqual(@as(u8, 40), v.direct_color_bg.r);
-        try testing.expectEqual(@as(u8, 44), v.direct_color_bg.g);
-        try testing.expectEqual(@as(u8, 52), v.direct_color_bg.b);
-    }
-
-    try testing.expect(testParse(&[_]u16{ 48, 2, 44, 52 }) == .unknown);
-}
-
-test "sgr: Parser multiple" {
-    var p: Parser = .{ .params = &[_]u16{ 0, 38, 2, 40, 44, 52 } };
-    try testing.expect(p.next().? == .unset);
-    try testing.expect(p.next().? == .direct_color_fg);
-    try testing.expect(p.next() == null);
-    try testing.expect(p.next() == null);
-}
-
-test "sgr: unsupported with colon" {
-    var p: Parser = .{
-        .params = &[_]u16{ 0, 4, 1 },
-        .params_sep = sep: {
-            var list = SepList.initEmpty();
-            list.set(0);
-            break :sep list;
-        },
-    };
-    try testing.expect(p.next().? == .unknown);
-    try testing.expect(p.next().? == .bold);
-    try testing.expect(p.next() == null);
-}
-
-test "sgr: unsupported with multiple colon" {
-    var p: Parser = .{
-        .params = &[_]u16{ 0, 4, 2, 1 },
-        .params_sep = sep: {
-            var list = SepList.initEmpty();
-            list.set(0);
-            list.set(1);
-            break :sep list;
-        },
-    };
-    try testing.expect(p.next().? == .unknown);
-    try testing.expect(p.next().? == .bold);
-    try testing.expect(p.next() == null);
-}
-
-test "sgr: bold" {
-    {
-        const v = testParse(&[_]u16{1});
-        try testing.expect(v == .bold);
-    }
-
-    {
-        const v = testParse(&[_]u16{22});
-        try testing.expect(v == .reset_bold);
-    }
-}
-
-test "sgr: italic" {
-    {
-        const v = testParse(&[_]u16{3});
-        try testing.expect(v == .italic);
-    }
-
-    {
-        const v = testParse(&[_]u16{23});
-        try testing.expect(v == .reset_italic);
-    }
-}
-
-test "sgr: underline" {
-    {
-        const v = testParse(&[_]u16{4});
-        try testing.expect(v == .underline);
-    }
-
-    {
-        const v = testParse(&[_]u16{24});
-        try testing.expect(v == .reset_underline);
-    }
-}
-
-test "sgr: underline styles" {
-    {
-        const v = testParseColon(&[_]u16{ 4, 2 });
-        try testing.expect(v == .underline);
-        try testing.expect(v.underline == .double);
-    }
-
-    {
-        const v = testParseColon(&[_]u16{ 4, 0 });
-        try testing.expect(v == .reset_underline);
-    }
-
-    {
-        const v = testParseColon(&[_]u16{ 4, 1 });
-        try testing.expect(v == .underline);
-        try testing.expect(v.underline == .single);
-    }
-
-    {
-        const v = testParseColon(&[_]u16{ 4, 3 });
-        try testing.expect(v == .underline);
-        try testing.expect(v.underline == .curly);
-    }
-
-    {
-        const v = testParseColon(&[_]u16{ 4, 4 });
-        try testing.expect(v == .underline);
-        try testing.expect(v.underline == .dotted);
-    }
-
-    {
-        const v = testParseColon(&[_]u16{ 4, 5 });
-        try testing.expect(v == .underline);
-        try testing.expect(v.underline == .dashed);
-    }
-}
-
-test "sgr: underline style with more" {
-    var p: Parser = .{
-        .params = &[_]u16{ 4, 2, 1 },
-        .params_sep = sep: {
-            var list = SepList.initEmpty();
-            list.set(0);
-            break :sep list;
-        },
-    };
-
-    try testing.expect(p.next().? == .underline);
-    try testing.expect(p.next().? == .bold);
-    try testing.expect(p.next() == null);
-}
-
-test "sgr: underline style with too many colons" {
-    var p: Parser = .{
-        .params = &[_]u16{ 4, 2, 3, 1 },
-        .params_sep = sep: {
-            var list = SepList.initEmpty();
-            list.set(0);
-            list.set(1);
-            break :sep list;
-        },
-    };
-
-    try testing.expect(p.next().? == .unknown);
-    try testing.expect(p.next().? == .bold);
-    try testing.expect(p.next() == null);
-}
-
-test "sgr: blink" {
-    {
-        const v = testParse(&[_]u16{5});
-        try testing.expect(v == .blink);
-    }
-
-    {
-        const v = testParse(&[_]u16{6});
-        try testing.expect(v == .blink);
-    }
-
-    {
-        const v = testParse(&[_]u16{25});
-        try testing.expect(v == .reset_blink);
-    }
-}
-
-test "sgr: inverse" {
-    {
-        const v = testParse(&[_]u16{7});
-        try testing.expect(v == .inverse);
-    }
-
-    {
-        const v = testParse(&[_]u16{27});
-        try testing.expect(v == .reset_inverse);
-    }
-}
-
-test "sgr: strikethrough" {
-    {
-        const v = testParse(&[_]u16{9});
-        try testing.expect(v == .strikethrough);
-    }
-
-    {
-        const v = testParse(&[_]u16{29});
-        try testing.expect(v == .reset_strikethrough);
-    }
-}
-
-test "sgr: 8 color" {
-    var p: Parser = .{ .params = &[_]u16{ 31, 43, 90, 103 } };
-
-    {
-        const v = p.next().?;
-        try testing.expect(v == .@"8_fg");
-        try testing.expect(v.@"8_fg" == .red);
-    }
-
-    {
-        const v = p.next().?;
-        try testing.expect(v == .@"8_bg");
-        try testing.expect(v.@"8_bg" == .yellow);
-    }
-
-    {
-        const v = p.next().?;
-        try testing.expect(v == .@"8_bright_fg");
-        try testing.expect(v.@"8_bright_fg" == .bright_black);
-    }
-
-    {
-        const v = p.next().?;
-        try testing.expect(v == .@"8_bright_bg");
-        try testing.expect(v.@"8_bright_bg" == .bright_yellow);
-    }
-}
-
-test "sgr: 256 color" {
-    var p: Parser = .{ .params = &[_]u16{ 38, 5, 161, 48, 5, 236 } };
-    try testing.expect(p.next().? == .@"256_fg");
-    try testing.expect(p.next().? == .@"256_bg");
-    try testing.expect(p.next() == null);
-}
-
-test "sgr: 256 color underline" {
-    var p: Parser = .{ .params = &[_]u16{ 58, 5, 9 } };
-    try testing.expect(p.next().? == .@"256_underline_color");
-    try testing.expect(p.next() == null);
-}
-
-test "sgr: 24-bit bg color" {
-    {
-        const v = testParseColon(&[_]u16{ 48, 2, 1, 2, 3 });
-        try testing.expect(v == .direct_color_bg);
-        try testing.expectEqual(@as(u8, 1), v.direct_color_bg.r);
-        try testing.expectEqual(@as(u8, 2), v.direct_color_bg.g);
-        try testing.expectEqual(@as(u8, 3), v.direct_color_bg.b);
-    }
-}
-
-test "sgr: underline color" {
-    {
-        const v = testParseColon(&[_]u16{ 58, 2, 1, 2, 3 });
-        try testing.expect(v == .underline_color);
-        try testing.expectEqual(@as(u8, 1), v.underline_color.r);
-        try testing.expectEqual(@as(u8, 2), v.underline_color.g);
-        try testing.expectEqual(@as(u8, 3), v.underline_color.b);
-    }
-
-    {
-        const v = testParseColon(&[_]u16{ 58, 2, 0, 1, 2, 3 });
-        try testing.expect(v == .underline_color);
-        try testing.expectEqual(@as(u8, 1), v.underline_color.r);
-        try testing.expectEqual(@as(u8, 2), v.underline_color.g);
-        try testing.expectEqual(@as(u8, 3), v.underline_color.b);
-    }
-}
-
-test "sgr: reset underline color" {
-    var p: Parser = .{ .params = &[_]u16{59} };
-    try testing.expect(p.next().? == .reset_underline_color);
-}
-
-test "sgr: invisible" {
-    var p: Parser = .{ .params = &[_]u16{ 8, 28 } };
-    try testing.expect(p.next().? == .invisible);
-    try testing.expect(p.next().? == .reset_invisible);
-}
-
-test "sgr: underline, bg, and fg" {
-    var p: Parser = .{
-        .params = &[_]u16{ 4, 38, 2, 255, 247, 219, 48, 2, 242, 93, 147, 4 },
-    };
-    {
-        const v = p.next().?;
-        try testing.expect(v == .underline);
-        try testing.expectEqual(Attribute.Underline.single, v.underline);
-    }
-    {
-        const v = p.next().?;
-        try testing.expect(v == .direct_color_fg);
-        try testing.expectEqual(@as(u8, 255), v.direct_color_fg.r);
-        try testing.expectEqual(@as(u8, 247), v.direct_color_fg.g);
-        try testing.expectEqual(@as(u8, 219), v.direct_color_fg.b);
-    }
-    {
-        const v = p.next().?;
-        try testing.expect(v == .direct_color_bg);
-        try testing.expectEqual(@as(u8, 242), v.direct_color_bg.r);
-        try testing.expectEqual(@as(u8, 93), v.direct_color_bg.g);
-        try testing.expectEqual(@as(u8, 147), v.direct_color_bg.b);
-    }
-    {
-        const v = p.next().?;
-        try testing.expect(v == .underline);
-        try testing.expectEqual(Attribute.Underline.single, v.underline);
-    }
-}
-
-test "sgr: direct color fg missing color" {
-    // This used to crash
-    var p: Parser = .{ .params = &[_]u16{ 38, 5 } };
-    while (p.next()) |_| {}
-}
-
-test "sgr: direct color bg missing color" {
-    // This used to crash
-    var p: Parser = .{ .params = &[_]u16{ 48, 5 } };
-    while (p.next()) |_| {}
-}
-
-test "sgr: direct fg/bg/underline ignore optional color space" {
-    // These behaviors have been verified against xterm.
-
-    // Colon version should skip the optional color space identifier
-    {
-        // 3 8 : 2 : Pi : Pr : Pg : Pb
-        const v = testParseColon(&[_]u16{ 38, 2, 0, 1, 2, 3 });
-        try testing.expect(v == .direct_color_fg);
-        try testing.expectEqual(@as(u8, 1), v.direct_color_fg.r);
-        try testing.expectEqual(@as(u8, 2), v.direct_color_fg.g);
-        try testing.expectEqual(@as(u8, 3), v.direct_color_fg.b);
-    }
-    {
-        // 4 8 : 2 : Pi : Pr : Pg : Pb
-        const v = testParseColon(&[_]u16{ 48, 2, 0, 1, 2, 3 });
-        try testing.expect(v == .direct_color_bg);
-        try testing.expectEqual(@as(u8, 1), v.direct_color_bg.r);
-        try testing.expectEqual(@as(u8, 2), v.direct_color_bg.g);
-        try testing.expectEqual(@as(u8, 3), v.direct_color_bg.b);
-    }
-    {
-        // 5 8 : 2 : Pi : Pr : Pg : Pb
-        const v = testParseColon(&[_]u16{ 58, 2, 0, 1, 2, 3 });
-        try testing.expect(v == .underline_color);
-        try testing.expectEqual(@as(u8, 1), v.underline_color.r);
-        try testing.expectEqual(@as(u8, 2), v.underline_color.g);
-        try testing.expectEqual(@as(u8, 3), v.underline_color.b);
-    }
-
-    // Semicolon version should not parse optional color space identifier
-    {
-        // 3 8 ; 2 ; Pr ; Pg ; Pb
-        const v = testParse(&[_]u16{ 38, 2, 0, 1, 2, 3 });
-        try testing.expect(v == .direct_color_fg);
-        try testing.expectEqual(@as(u8, 0), v.direct_color_fg.r);
-        try testing.expectEqual(@as(u8, 1), v.direct_color_fg.g);
-        try testing.expectEqual(@as(u8, 2), v.direct_color_fg.b);
-    }
-    {
-        // 4 8 ; 2 ; Pr ; Pg ; Pb
-        const v = testParse(&[_]u16{ 48, 2, 0, 1, 2, 3 });
-        try testing.expect(v == .direct_color_bg);
-        try testing.expectEqual(@as(u8, 0), v.direct_color_bg.r);
-        try testing.expectEqual(@as(u8, 1), v.direct_color_bg.g);
-        try testing.expectEqual(@as(u8, 2), v.direct_color_bg.b);
-    }
-    {
-        // 5 8 ; 2 ; Pr ; Pg ; Pb
-        const v = testParse(&[_]u16{ 58, 2, 0, 1, 2, 3 });
-        try testing.expect(v == .underline_color);
-        try testing.expectEqual(@as(u8, 0), v.underline_color.r);
-        try testing.expectEqual(@as(u8, 1), v.underline_color.g);
-        try testing.expectEqual(@as(u8, 2), v.underline_color.b);
-    }
-}
-
-test "sgr: direct fg colon with too many colons" {
-    var p: Parser = .{
-        .params = &[_]u16{ 38, 2, 0, 1, 2, 3, 4, 1 },
-        .params_sep = sep: {
-            var list = SepList.initEmpty();
-            for (0..6) |idx| list.set(idx);
-            break :sep list;
-        },
-    };
-
-    try testing.expect(p.next().? == .unknown);
-    try testing.expect(p.next().? == .bold);
-    try testing.expect(p.next() == null);
-}
-
-test "sgr: direct fg colon with colorspace and extra param" {
-    var p: Parser = .{
-        .params = &[_]u16{ 38, 2, 0, 1, 2, 3, 1 },
-        .params_sep = sep: {
-            var list = SepList.initEmpty();
-            for (0..5) |idx| list.set(idx);
-            break :sep list;
-        },
-    };
-
-    {
-        const v = p.next().?;
-        try testing.expect(v == .direct_color_fg);
-        try testing.expectEqual(@as(u8, 1), v.direct_color_fg.r);
-        try testing.expectEqual(@as(u8, 2), v.direct_color_fg.g);
-        try testing.expectEqual(@as(u8, 3), v.direct_color_fg.b);
-    }
-
-    try testing.expect(p.next().? == .bold);
-    try testing.expect(p.next() == null);
-}
-
-test "sgr: direct fg colon no colorspace and extra param" {
-    var p: Parser = .{
-        .params = &[_]u16{ 38, 2, 1, 2, 3, 1 },
-        .params_sep = sep: {
-            var list = SepList.initEmpty();
-            for (0..4) |idx| list.set(idx);
-            break :sep list;
-        },
-    };
-
-    {
-        const v = p.next().?;
-        try testing.expect(v == .direct_color_fg);
-        try testing.expectEqual(@as(u8, 1), v.direct_color_fg.r);
-        try testing.expectEqual(@as(u8, 2), v.direct_color_fg.g);
-        try testing.expectEqual(@as(u8, 3), v.direct_color_fg.b);
-    }
-
-    try testing.expect(p.next().? == .bold);
-    try testing.expect(p.next() == null);
-}
-
-// Kakoune sent this complex SGR sequence that caused invalid behavior.
-test "sgr: kakoune input" {
-    // This used to crash
-    var p: Parser = .{
-        .params = &[_]u16{ 0, 4, 3, 38, 2, 175, 175, 215, 58, 2, 0, 190, 80, 70 },
-        .params_sep = sep: {
-            var list = SepList.initEmpty();
-            list.set(1);
-            list.set(8);
-            list.set(9);
-            list.set(10);
-            list.set(11);
-            list.set(12);
-            break :sep list;
-        },
-    };
-
-    {
-        const v = p.next().?;
-        try testing.expect(v == .unset);
-    }
-    {
-        const v = p.next().?;
-        try testing.expect(v == .underline);
-        try testing.expectEqual(Attribute.Underline.curly, v.underline);
-    }
-    {
-        const v = p.next().?;
-        try testing.expect(v == .direct_color_fg);
-        try testing.expectEqual(@as(u8, 175), v.direct_color_fg.r);
-        try testing.expectEqual(@as(u8, 175), v.direct_color_fg.g);
-        try testing.expectEqual(@as(u8, 215), v.direct_color_fg.b);
-    }
-    {
-        const v = p.next().?;
-        try testing.expect(v == .underline_color);
-        try testing.expectEqual(@as(u8, 190), v.underline_color.r);
-        try testing.expectEqual(@as(u8, 80), v.underline_color.g);
-        try testing.expectEqual(@as(u8, 70), v.underline_color.b);
-    }
-
-    //try testing.expect(p.next() == null);
-}
-
-// Discussion #5930, another input sent by kakoune
-test "sgr: kakoune input issue underline, fg, and bg" {
-    // echo -e "\033[4:3;38;2;51;51;51;48;2;170;170;170;58;2;255;97;136mset everything in one sequence, broken\033[m"
-
-    // This used to crash
-    var p: Parser = .{
-        .params = &[_]u16{ 4, 3, 38, 2, 51, 51, 51, 48, 2, 170, 170, 170, 58, 2, 255, 97, 136 },
-        .params_sep = sep: {
-            var list = SepList.initEmpty();
-            list.set(0);
-            break :sep list;
-        },
-    };
-
-    {
-        const v = p.next().?;
-        try testing.expect(v == .underline);
-        try testing.expectEqual(Attribute.Underline.curly, v.underline);
-    }
-
-    {
-        const v = p.next().?;
-        try testing.expect(v == .direct_color_fg);
-        try testing.expectEqual(@as(u8, 51), v.direct_color_fg.r);
-        try testing.expectEqual(@as(u8, 51), v.direct_color_fg.g);
-        try testing.expectEqual(@as(u8, 51), v.direct_color_fg.b);
-    }
-
-    {
-        const v = p.next().?;
-        try testing.expect(v == .direct_color_bg);
-        try testing.expectEqual(@as(u8, 170), v.direct_color_bg.r);
-        try testing.expectEqual(@as(u8, 170), v.direct_color_bg.g);
-        try testing.expectEqual(@as(u8, 170), v.direct_color_bg.b);
-    }
-
-    {
-        const v = p.next().?;
-        try testing.expect(v == .underline_color);
-        try testing.expectEqual(@as(u8, 255), v.underline_color.r);
-        try testing.expectEqual(@as(u8, 97), v.underline_color.g);
-        try testing.expectEqual(@as(u8, 136), v.underline_color.b);
-    }
-
-    try testing.expect(p.next() == null);
-}+};