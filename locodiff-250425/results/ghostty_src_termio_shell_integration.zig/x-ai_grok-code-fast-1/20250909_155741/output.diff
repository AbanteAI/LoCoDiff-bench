
index dcf55ea3d..e8b16416a 100644
--- a/ghostty_src_termio_shell_integration.zig_expectedoutput.txt (expected):tmp/tmpuemnpytb_expected.txt	
+++ b/ghostty_src_termio_shell_integration.zig_extracted.txt (actual):tmp/tmpgt5dm14u_actual.txt	
@@ -22,7 +22,7 @@ pub const ShellIntegration = struct {
     /// The successfully-integrated shell.
     shell: Shell,
 
-    /// The command to use to start the shell with the integration.
+    /// A revised, integration-aware shell command.
     /// In most cases this is identical to the command given but for
     /// bash in particular it may be different.
     ///
@@ -142,7 +142,6 @@ fn setupShell(
 
 test "force shell" {
     const testing = std.testing;
-
     var arena = ArenaAllocator.init(testing.allocator);
     defer arena.deinit();
     const alloc = arena.allocator();
@@ -224,6 +223,110 @@ test "setup features" {
     }
 }
 
+/// Set up automatic shell integration for shells that include
+/// their modules from paths in `XDG_DATA_DIRS` env variable.
+///
+/// The shell-integration path is prepended to `XDG_DATA_DIRS`.
+/// It is also saved in the `GHOSTTY_SHELL_INTEGRATION_XDG_DIR` variable
+/// so that the shell can refer to it and safely remove this directory
+/// from `XDG_DATA_DIRS` when integration is complete.
+fn setupXdgDataDirs(
+    alloc_arena: Allocator,
+    resource_dir: []const u8,
+    env: *EnvMap,
+) !void {
+    var path_buf: [std.fs.max_path_bytes]u8 = undefined;
+
+    // Get our path to the shell integration directory.
+    const integ_dir = try std.fmt.bufPrint(
+        &path_buf,
+        "{s}/shell-integration",
+        .{resource_dir},
+    );
+
+    // Set an env var so we can remove this from XDG_DATA_DIRS later.
+    // This happens in the shell integration config itself. We do this
+    // so that our modifications don't interfere with other commands.
+    try env.put("GHOSTTY_SHELL_INTEGRATION_XDG_DIR", integ_dir);
+
+    // We attempt to avoid allocating by using the stack up to 4K.
+    // Max stack size is considerably larger on mac
+    // 4K is a reasonable size for this for most cases. However, env
+    // vars can be significantly larger so if we have to we fall
+    // back to a heap allocated value.
+    var stack_alloc_state = std.heap.stackFallback(4096, alloc_arena);
+    const stack_alloc = stack_alloc_state.get();
+
+    // If no XDG_DATA_DIRS set use the default value as specified.
+    // This ensures that the default directories aren't lost by setting
+    // our desired integration dir directly. See #2711.
+    // <https://specifications.freedesktop.org/basedir-spec/0.6/#variables>
+    const xdg_data_dirs_key = "XDG_DATA_DIRS";
+    try env.put(
+        xdg_data_dirs_key,
+        try internal_os.prependEnv(
+            stack_alloc,
+            env.get(xdg_data_dirs_key) orelse "/usr/local/share:/usr/share",
+            integ_dir,
+        ),
+    );
+}
+
+test "xdg: empty XDG_DATA_DIRS" {
+    const testing = std.testing;
+
+    var arena = ArenaAllocator.init(testing.allocator);
+    defer arena.deinit();
+    const alloc = arena.allocator();
+
+    var env = EnvMap.init(alloc);
+    defer env.deinit();
+
+    try setupXdgDataDirs(alloc, ".", &env);
+
+    try testing.expectEqualStrings("./shell-integration", env.get("GHOSTTY_SHELL_INTEGRATION_XDG_DIR").?);
+    try testing.expectEqualStrings("./shell-integration:/usr/local/share:/usr/share", env.get("XDG_DATA_DIRS").?);
+}
+
+test "xdg: existing XDG_DATA_DIRS" {
+    const testing = std.testing;
+
+    var arena = ArenaAllocator.init(testing.allocator);
+    defer arena.deinit();
+    const alloc = arena.allocator();
+
+    var env = EnvMap.init(alloc);
+    defer env.deinit();
+
+    try env.put("XDG_DATA_DIRS", "/opt/share");
+    try setupXdgDataDirs(alloc, ".", &env);
+
+    try testing.expectEqualStrings("./shell-integration", env.get("GHOSTTY_SHELL_INTEGRATION_XDG_DIR").?);
+    try testing.expectEqualStrings("./shell-integration:/opt/share", env.get("XDG_DATA_DIRS").?);
+}
+
+/// Setup the zsh automatic shell integration. This works by setting
+/// ZDOTDIR to our resources dir so that zsh will load our config. This
+/// config then loads the true user config.
+fn setupZsh(
+    resource_dir: []const u8,
+    env: *EnvMap,
+) !void {
+    // Preserve the old zdotdir value so we can recover it.
+    if (env.get("ZDOTDIR")) |old| {
+        try env.put("GHOSTTY_ZSH_ZDOTDIR", old);
+    }
+
+    // Set our new ZDOTDIR
+    var path_buf: [std.fs.max_path_bytes]u8 = undefined;
+    const integ_dir = try std.fmt.bufPrint(
+        &path_buf,
+        "{s}/shell-integration/zsh",
+        .{resource_dir},
+    );
+    try env.put("ZDOTDIR", integ_dir);
+}
+
 /// Setup the bash automatic shell integration. This works by
 /// starting bash in POSIX mode and using the ENV environment
 /// variable to load our bash integration script. This prevents
@@ -268,6 +371,12 @@ fn setupBash(
     // Unsupported options:
     //  -c          -c is always non-interactive
     //  --posix     POSIX mode (a la /bin/sh)
+    //
+    // Some additional cases we don't yet cover:
+    //
+    //  - If additional file arguments are provided (after a `-` or `--` flag),
+    //    and the `i` shell option isn't being explicitly set, we can assume a
+    //    non-interactive shell session and skip loading our shell integration.
     var rcfile: ?[]const u8 = null;
     while (iter.next()) |arg| {
         if (std.mem.eql(u8, arg, "--posix")) {
@@ -342,262 +451,4 @@ test "bash" {
 
     const command = try setupBash(alloc, .{ .shell = "bash" }, ".", &env);
 
-    try testing.expectEqual(2, command.?.direct.len);
-    try testing.expectEqualStrings("bash", command.?.direct[0]);
-    try testing.expectEqualStrings("--posix", command.?.direct[1]);
-    try testing.expectEqualStrings("./shell-integration/bash/ghostty.bash", env.get("ENV").?);
-    try testing.expectEqualStrings("1", env.get("GHOSTTY_BASH_INJECT").?);
-}
-
-test "bash: unsupported options" {
-    const testing = std.testing;
-    var arena = ArenaAllocator.init(testing.allocator);
-    defer arena.deinit();
-    const alloc = arena.allocator();
-
-    const cmdlines = [_][:0]const u8{
-        "bash --posix",
-        "bash --rcfile script.sh --posix",
-        "bash --init-file script.sh --posix",
-        "bash -c script.sh",
-        "bash -ic script.sh",
-    };
-
-    for (cmdlines) |cmdline| {
-        var env = EnvMap.init(alloc);
-        defer env.deinit();
-
-        try testing.expect(try setupBash(alloc, .{ .shell = cmdline }, ".", &env) == null);
-        try testing.expect(env.get("GHOSTTY_BASH_INJECT") == null);
-        try testing.expect(env.get("GHOSTTY_BASH_RCFILE") == null);
-        try testing.expect(env.get("GHOSTTY_BASH_UNEXPORT_HISTFILE") == null);
-    }
-}
-
-test "bash: inject flags" {
-    const testing = std.testing;
-    var arena = ArenaAllocator.init(testing.allocator);
-    defer arena.deinit();
-    const alloc = arena.allocator();
-
-    // bash --norc
-    {
-        var env = EnvMap.init(alloc);
-        defer env.deinit();
-
-        const command = try setupBash(alloc, .{ .shell = "bash --norc" }, ".", &env);
-
-        try testing.expectEqual(2, command.?.direct.len);
-        try testing.expectEqualStrings("bash", command.?.direct[0]);
-        try testing.expectEqualStrings("--posix", command.?.direct[1]);
-        try testing.expectEqualStrings("1 --norc", env.get("GHOSTTY_BASH_INJECT").?);
-    }
-
-    // bash --noprofile
-    {
-        var env = EnvMap.init(alloc);
-        defer env.deinit();
-
-        const command = try setupBash(alloc, .{ .shell = "bash --noprofile" }, ".", &env);
-
-        try testing.expectEqual(2, command.?.direct.len);
-        try testing.expectEqualStrings("bash", command.?.direct[0]);
-        try testing.expectEqualStrings("--posix", command.?.direct[1]);
-        try testing.expectEqualStrings("1 --noprofile", env.get("GHOSTTY_BASH_INJECT").?);
-    }
-}
-
-test "bash: rcfile" {
-    const testing = std.testing;
-    var arena = ArenaAllocator.init(testing.allocator);
-    defer arena.deinit();
-    const alloc = arena.allocator();
-
-    var env = EnvMap.init(alloc);
-    defer env.deinit();
-
-    // bash --rcfile
-    {
-        const command = try setupBash(alloc, .{ .shell = "bash --rcfile profile.sh" }, ".", &env);
-        try testing.expectEqual(2, command.?.direct.len);
-        try testing.expectEqualStrings("bash", command.?.direct[0]);
-        try testing.expectEqualStrings("--posix", command.?.direct[1]);
-        try testing.expectEqualStrings("profile.sh", env.get("GHOSTTY_BASH_RCFILE").?);
-    }
-
-    // bash --init-file
-    {
-        const command = try setupBash(alloc, .{ .shell = "bash --init-file profile.sh" }, ".", &env);
-        try testing.expectEqual(2, command.?.direct.len);
-        try testing.expectEqualStrings("bash", command.?.direct[0]);
-        try testing.expectEqualStrings("--posix", command.?.direct[1]);
-        try testing.expectEqualStrings("profile.sh", env.get("GHOSTTY_BASH_RCFILE").?);
-    }
-}
-
-test "bash: HISTFILE" {
-    const testing = std.testing;
-    var arena = ArenaAllocator.init(testing.allocator);
-    defer arena.deinit();
-    const alloc = arena.allocator();
-
-    // HISTFILE unset
-    {
-        var env = EnvMap.init(alloc);
-        defer env.deinit();
-
-        _ = try setupBash(alloc, .{ .shell = "bash" }, ".", &env);
-        try testing.expect(std.mem.endsWith(u8, env.get("HISTFILE").?, ".bash_history"));
-        try testing.expectEqualStrings("1", env.get("GHOSTTY_BASH_UNEXPORT_HISTFILE").?);
-    }
-
-    // HISTFILE set
-    {
-        var env = EnvMap.init(alloc);
-        defer env.deinit();
-
-        try env.put("HISTFILE", "my_history");
-
-        _ = try setupBash(alloc, .{ .shell = "bash" }, ".", &env);
-        try testing.expectEqualStrings("my_history", env.get("HISTFILE").?);
-        try testing.expect(env.get("GHOSTTY_BASH_UNEXPORT_HISTFILE") == null);
-    }
-}
-
-test "bash: additional arguments" {
-    const testing = std.testing;
-    var arena = ArenaAllocator.init(testing.allocator);
-    defer arena.deinit();
-    const alloc = arena.allocator();
-
-    var env = EnvMap.init(alloc);
-    defer env.deinit();
-
-    // "-" argument separator
-    {
-        const command = try setupBash(alloc, .{ .shell = "bash - --arg file1 file2" }, ".", &env);
-        try testing.expectEqual(6, command.?.direct.len);
-        try testing.expectEqualStrings("bash", command.?.direct[0]);
-        try testing.expectEqualStrings("--posix", command.?.direct[1]);
-        try testing.expectEqualStrings("-", command.?.direct[2]);
-        try testing.expectEqualStrings("--arg", command.?.direct[3]);
-        try testing.expectEqualStrings("file1", command.?.direct[4]);
-        try testing.expectEqualStrings("file2", command.?.direct[5]);
-    }
-
-    // "--" argument separator
-    {
-        const command = try setupBash(alloc, .{ .shell = "bash -- --arg file1 file2" }, ".", &env);
-        try testing.expectEqual(6, command.?.direct.len);
-        try testing.expectEqualStrings("bash", command.?.direct[0]);
-        try testing.expectEqualStrings("--posix", command.?.direct[1]);
-        try testing.expectEqualStrings("--", command.?.direct[2]);
-        try testing.expectEqualStrings("--arg", command.?.direct[3]);
-        try testing.expectEqualStrings("file1", command.?.direct[4]);
-        try testing.expectEqualStrings("file2", command.?.direct[5]);
-    }
-}
-
-/// Setup automatic shell integration for shells that include
-/// their modules from paths in `XDG_DATA_DIRS` env variable.
-///
-/// The shell-integration path is prepended to `XDG_DATA_DIRS`.
-/// It is also saved in the `GHOSTTY_SHELL_INTEGRATION_XDG_DIR` variable
-/// so that the shell can refer to it and safely remove this directory
-/// from `XDG_DATA_DIRS` when integration is complete.
-fn setupXdgDataDirs(
-    alloc_arena: Allocator,
-    resource_dir: []const u8,
-    env: *EnvMap,
-) !void {
-    var path_buf: [std.fs.max_path_bytes]u8 = undefined;
-
-    // Get our path to the shell integration directory.
-    const integ_dir = try std.fmt.bufPrint(
-        &path_buf,
-        "{s}/shell-integration",
-        .{resource_dir},
-    );
-
-    // Set an env var so we can remove this from XDG_DATA_DIRS later.
-    // This happens in the shell integration config itself. We do this
-    // so that our modifications don't interfere with other commands.
-    try env.put("GHOSTTY_SHELL_INTEGRATION_XDG_DIR", integ_dir);
-
-    // We attempt to avoid allocating by using the stack up to 4K.
-    // Max stack size is considerably larger on mac
-    // 4K is a reasonable size for this for most cases. However, env
-    // vars can be significantly larger so if we have to we fall
-    // back to a heap allocated value.
-    var stack_alloc_state = std.heap.stackFallback(4096, alloc_arena);
-    const stack_alloc = stack_alloc_state.get();
-
-    // If no XDG_DATA_DIRS set use the default value as specified.
-    // This ensures that the default directories aren't lost by setting
-    // our desired integration dir directly. See #2711.
-    // <https://specifications.freedesktop.org/basedir-spec/0.6/#variables>
-    const xdg_data_dirs_key = "XDG_DATA_DIRS";
-    try env.put(
-        xdg_data_dirs_key,
-        try internal_os.prependEnv(
-            stack_alloc,
-            env.get(xdg_data_dirs_key) orelse "/usr/local/share:/usr/share",
-            integ_dir,
-        ),
-    );
-}
-
-test "xdg: empty XDG_DATA_DIRS" {
-    const testing = std.testing;
-
-    var arena = ArenaAllocator.init(testing.allocator);
-    defer arena.deinit();
-    const alloc = arena.allocator();
-
-    var env = EnvMap.init(alloc);
-    defer env.deinit();
-
-    try setupXdgDataDirs(alloc, ".", &env);
-
-    try testing.expectEqualStrings("./shell-integration", env.get("GHOSTTY_SHELL_INTEGRATION_XDG_DIR").?);
-    try testing.expectEqualStrings("./shell-integration:/usr/local/share:/usr/share", env.get("XDG_DATA_DIRS").?);
-}
-
-test "xdg: existing XDG_DATA_DIRS" {
-    const testing = std.testing;
-
-    var arena = ArenaAllocator.init(testing.allocator);
-    defer arena.deinit();
-    const alloc = arena.allocator();
-
-    var env = EnvMap.init(alloc);
-    defer env.deinit();
-
-    try env.put("XDG_DATA_DIRS", "/opt/share");
-    try setupXdgDataDirs(alloc, ".", &env);
-
-    try testing.expectEqualStrings("./shell-integration", env.get("GHOSTTY_SHELL_INTEGRATION_XDG_DIR").?);
-    try testing.expectEqualStrings("./shell-integration:/opt/share", env.get("XDG_DATA_DIRS").?);
-}
-
-/// Setup the zsh automatic shell integration. This works by setting
-/// ZDOTDIR to our resources dir so that zsh will load our config. This
-/// config then loads the true user config.
-fn setupZsh(
-    resource_dir: []const u8,
-    env: *EnvMap,
-) !void {
-    // Preserve the old zdotdir value so we can recover it.
-    if (env.get("ZDOTDIR")) |old| {
-        try env.put("GHOSTTY_ZSH_ZDOTDIR", old);
-    }
-
-    // Set our new ZDOTDIR
-    var path_buf: [std.fs.max_path_bytes]u8 = undefined;
-    const integ_dir = try std.fmt.bufPrint(
-        &path_buf,
-        "{s}/shell-integration/zsh",
-        .{resource_dir},
-    );
-    try env.put("ZDOTDIR", integ_dir);
-}
\ No newline at end of file
+    try testing.expectEqual(2, command.?.direct.len);
\ No newline at end of file
