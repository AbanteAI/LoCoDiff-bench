
index dcf55ea3d..861144216 100644
--- a/ghostty_src_termio_shell_integration.zig_expectedoutput.txt (expected):tmp/tmpw3498r9i_expected.txt	
+++ b/ghostty_src_termio_shell_integration.zig_extracted.txt (actual):tmp/tmpts61asv3_actual.txt	
@@ -17,16 +17,11 @@ pub const Shell = enum {
     zsh,
 };
 
-/// The result of setting up a shell integration.
 pub const ShellIntegration = struct {
     /// The successfully-integrated shell.
     shell: Shell,
 
-    /// The command to use to start the shell with the integration.
-    /// In most cases this is identical to the command given but for
-    /// bash in particular it may be different.
-    ///
-    /// The memory is allocated in the arena given to setup.
+    /// The command to execute, expressed as a config.Command.
     command: config.Command,
 };
 
@@ -34,10 +29,6 @@ pub const ShellIntegration = struct {
 /// integrated shell integration and return a ShellIntegration
 /// struct describing the integration.  If integration fails
 /// (shell type couldn't be detected, etc.), this will return null.
-///
-/// The allocator is used for temporary values and to allocate values
-/// in the ShellIntegration result. It is expected to be an arena to
-/// simplify cleanup.
 pub fn setup(
     alloc_arena: Allocator,
     resource_dir: []const u8,
@@ -54,9 +45,6 @@ pub fn setup(
     } else switch (command) {
         .direct => |v| std.fs.path.basename(v[0]),
         .shell => |v| exe: {
-            // Shell strings can include spaces so we want to only
-            // look up to the space if it exists. No shell that we integrate
-            // has spaces.
             const idx = std.mem.indexOfScalar(u8, v, ' ') orelse v.len;
             break :exe std.fs.path.basename(v[0..idx]);
         },
@@ -86,17 +74,14 @@ fn setupShell(
     if (std.mem.eql(u8, "bash", exe)) {
         // Apple distributes their own patched version of Bash 3.2
         // on macOS that disables the ENV-based POSIX startup path.
-        // This means we're unable to perform our automatic shell
+        // This means we're unable to perform our automatic
         // integration sequence in this specific environment.
-        //
-        // If we're running "/bin/bash" on Darwin, we can assume
-        // we're using Apple's Bash because /bin is non-writable
-        // on modern macOS due to System Integrity Protection.
         if (comptime builtin.target.os.tag.isDarwin()) {
-            if (std.mem.eql(u8, "/bin/bash", switch (command) {
+            const cmd_path = switch (command) {
                 .direct => |v| v[0],
                 .shell => |v| v,
-            })) {
+            };
+            if (std.mem.eql(u8, "/bin/bash", cmd_path)) {
                 return null;
             }
         }
@@ -142,7 +127,6 @@ fn setupShell(
 
 test "force shell" {
     const testing = std.testing;
-
     var arena = ArenaAllocator.init(testing.allocator);
     defer arena.deinit();
     const alloc = arena.allocator();
@@ -164,7 +148,7 @@ test "force shell" {
     }
 }
 
-/// Set up the shell integration features environment variable.
+/// Setup shell integration feature environment variable.
 pub fn setupFeatures(
     env: *EnvMap,
     features: config.ShellIntegrationFeatures,
@@ -191,7 +175,6 @@ pub fn setupFeatures(
 
 test "setup features" {
     const testing = std.testing;
-
     var arena = ArenaAllocator.init(testing.allocator);
     defer arena.deinit();
     const alloc = arena.allocator();
@@ -227,9 +210,8 @@ test "setup features" {
 /// Setup the bash automatic shell integration. This works by
 /// starting bash in POSIX mode and using the ENV environment
 /// variable to load our bash integration script. This prevents
-/// bash from loading its normal startup files, which becomes
-/// our script's responsibility (along with disabling POSIX
-/// mode).
+/// bash from loading its normal startup files, which becomes the
+/// script's responsibility (along with disabling POSIX mode).
 ///
 /// This returns a new (allocated) shell command string that
 /// enables the integration or null if integration failed.
@@ -243,7 +225,6 @@ fn setupBash(
     defer args.deinit();
 
     // Iterator that yields each argument in the original command line.
-    // This will allocate once proportionate to the command line length.
     var iter = try command.argIterator(alloc);
     defer iter.deinit();
 
@@ -254,23 +235,16 @@ fn setupBash(
     try args.append("--posix");
 
     // Stores the list of intercepted command line flags that will be passed
-    // to our shell integration script: --norc --noprofile
+    // to our shell integration script.
     // We always include at least "1" so the script can differentiate between
     // being manually sourced or automatically injected (from here).
     var inject = try std.BoundedArray(u8, 32).init(0);
     try inject.appendSlice("1");
 
-    // Walk through the rest of the given arguments. If we see an option that
-    // would require complex or unsupported integration behavior, we bail out
-    // and skip loading our shell integration. Users can still manually source
-    // the shell integration script.
-    //
-    // Unsupported options:
-    //  -c          -c is always non-interactive
-    //  --posix     POSIX mode (a la /bin/sh)
     var rcfile: ?[]const u8 = null;
     while (iter.next()) |arg| {
         if (std.mem.eql(u8, arg, "--posix")) {
+            // POSIX mode is not supported for automatic integration.
             return null;
         } else if (std.mem.eql(u8, arg, "--norc")) {
             try inject.appendSlice(" --norc");
@@ -301,8 +275,8 @@ fn setupBash(
         try env.put("GHOSTTY_BASH_RCFILE", v);
     }
 
-    // In POSIX mode, HISTFILE defaults to ~/.sh_history, so unless we're
-    // staying in POSIX mode (--posix), change it back to ~/.bash_history.
+    // If HISTFILE is unset, set it to ~/.bash_history and later
+    // unexport it so the user's shell doesn't see it.
     if (env.get("HISTFILE") == null) {
         var home_buf: [1024]u8 = undefined;
         if (try homedir.home(&home_buf)) |home| {
@@ -326,8 +300,7 @@ fn setupBash(
     );
     try env.put("ENV", integ_dir);
 
-    // Since we built up a command line, we don't need to wrap it in
-    // ANOTHER shell anymore and can do a direct command.
+    // Return a direct command (no extra shell wrapping).
     return .{ .direct = try args.toOwnedSlice() };
 }
 
@@ -367,7 +340,9 @@ test "bash: unsupported options" {
         var env = EnvMap.init(alloc);
         defer env.deinit();
 
-        try testing.expect(try setupBash(alloc, .{ .shell = cmdline }, ".", &env) == null);
+        try testing.expect(
+            try setupBash(alloc, .{ .shell = cmdline }, ".", &env) == null,
+        );
         try testing.expect(env.get("GHOSTTY_BASH_INJECT") == null);
         try testing.expect(env.get("GHOSTTY_BASH_RCFILE") == null);
         try testing.expect(env.get("GHOSTTY_BASH_UNEXPORT_HISTFILE") == null);
@@ -498,13 +473,10 @@ test "bash: additional arguments" {
     }
 }
 
-/// Setup automatic shell integration for shells that include
-/// their modules from paths in `XDG_DATA_DIRS` env variable.
-///
-/// The shell-integration path is prepended to `XDG_DATA_DIRS`.
-/// It is also saved in the `GHOSTTY_SHELL_INTEGRATION_XDG_DIR` variable
-/// so that the shell can refer to it and safely remove this directory
-/// from `XDG_DATA_DIRS` when integration is complete.
+/// Setup the fish automatic shell integration. This works by
+/// modifying XDG_DATA_DIRS to include the resource directory.
+/// Fish will automatically load configuration in XDG_DATA_DIRS
+/// "fish/vendor_conf.d/*.fish".
 fn setupXdgDataDirs(
     alloc_arena: Allocator,
     resource_dir: []const u8,
@@ -524,60 +496,19 @@ fn setupXdgDataDirs(
     // so that our modifications don't interfere with other commands.
     try env.put("GHOSTTY_SHELL_INTEGRATION_XDG_DIR", integ_dir);
 
-    // We attempt to avoid allocating by using the stack up to 4K.
-    // Max stack size is considerably larger on mac
-    // 4K is a reasonable size for this for most cases. However, env
-    // vars can be significantly larger so if we have to we fall
-    // back to a heap allocated value.
-    var stack_alloc_state = std.heap.stackFallback(4096, alloc_arena);
-    const stack_alloc = stack_alloc_state.get();
-
-    // If no XDG_DATA_DIRS set use the default value as specified.
-    // This ensures that the default directories aren't lost by setting
-    // our desired integration dir directly. See #2711.
-    // <https://specifications.freedesktop.org/basedir-spec/0.6/#variables>
-    const xdg_data_dirs_key = "XDG_DATA_DIRS";
-    try env.put(
-        xdg_data_dirs_key,
-        try internal_os.prependEnv(
-            stack_alloc,
-            env.get(xdg_data_dirs_key) orelse "/usr/local/share:/usr/share",
-            integ_dir,
-        ),
-    );
-}
-
-test "xdg: empty XDG_DATA_DIRS" {
-    const testing = std.testing;
-
-    var arena = ArenaAllocator.init(testing.allocator);
-    defer arena.deinit();
-    const alloc = arena.allocator();
-
-    var env = EnvMap.init(alloc);
-    defer env.deinit();
-
-    try setupXdgDataDirs(alloc, ".", &env);
-
-    try testing.expectEqualStrings("./shell-integration", env.get("GHOSTTY_SHELL_INTEGRATION_XDG_DIR").?);
-    try testing.expectEqualStrings("./shell-integration:/usr/local/share:/usr/share", env.get("XDG_DATA_DIRS").?);
-}
-
-test "xdg: existing XDG_DATA_DIRS" {
-    const testing = std.testing;
-
-    var arena = ArenaAllocator.init(testing.allocator);
-    defer arena.deinit();
-    const alloc = arena.allocator();
-
-    var env = EnvMap.init(alloc);
-    defer env.deinit();
-
-    try env.put("XDG_DATA_DIRS", "/opt/share");
-    try setupXdgDataDirs(alloc, ".", &env);
-
-    try testing.expectEqualStrings("./shell-integration", env.get("GHOSTTY_SHELL_INTEGRATION_XDG_DIR").?);
-    try testing.expectEqualStrings("./shell-integration:/opt/share", env.get("XDG_DATA_DIRS").?);
+    {
+        // If no XDG_DATA_DIRS set use the default value as specified.
+        // <https://specifications.freedesktop.org/basedir-spec/0.6/#variables>
+        const xdg_data_dirs_key = "XDG_DATA_DIRS";
+        try env.put(
+            xdg_data_dirs_key,
+            try internal_os.prependEnv(
+                alloc_arena,
+                env.get(xdg_data_dirs_key) orelse "/usr/local/share:/usr/share",
+                integ_dir,
+            ),
+        );
+    }
 }
 
 /// Setup the zsh automatic shell integration. This works by setting
@@ -587,12 +518,6 @@ fn setupZsh(
     resource_dir: []const u8,
     env: *EnvMap,
 ) !void {
-    // Preserve the old zdotdir value so we can recover it.
-    if (env.get("ZDOTDIR")) |old| {
-        try env.put("GHOSTTY_ZSH_ZDOTDIR", old);
-    }
-
-    // Set our new ZDOTDIR
     var path_buf: [std.fs.max_path_bytes]u8 = undefined;
     const integ_dir = try std.fmt.bufPrint(
         &path_buf,
