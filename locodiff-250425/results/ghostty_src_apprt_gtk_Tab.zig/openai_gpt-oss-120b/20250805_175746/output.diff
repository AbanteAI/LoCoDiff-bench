
index 6405bedb7..b444f9493 100644
--- a/ghostty_src_apprt_gtk_Tab.zig_expectedoutput.txt (expected):tmp/tmph5cs6l2i_expected.txt	
+++ b/ghostty_src_apprt_gtk_Tab.zig_extracted.txt (actual):tmp/tmpnfsblpuk_actual.txt	
@@ -1,6 +1,6 @@
 //! The state associated with a single tab in the window.
 //!
-//! A tab can contain one or more terminals due to splits.
+/// A tab can contain one or more terminals due to splits.
 const Tab = @This();
 
 const std = @import("std");
@@ -16,31 +16,31 @@ const CoreSurface = @import("../../Surface.zig");
 
 const Surface = @import("Surface.zig");
 const Window = @import("Window.zig");
+const adwaita = @import("adwaita.zig");
 const CloseDialog = @import("CloseDialog.zig");
 
+const c = @import("c.zig").c;
+
 const log = std.log.scoped(.gtk);
 
 pub const GHOSTTY_TAB = "ghostty_tab";
 
-/// The window that owns this tab.
 window: *Window,
-
 /// The tab label. The tab label is the text that appears on the tab.
 label_text: *gtk.Label,
-
 /// We'll put our children into this box instead of packing them
 /// directly, so that we can send the box into `c.g_signal_connect_data`
-/// for the close button
+/// for the close button.
 box: *gtk.Box,
-
 /// The element of this tab so that we can handle splits and so on.
 elem: Surface.Container.Elem,
-
-// We'll update this every time a Surface gains focus, so that we have it
-// when we switch to another Tab. Then when we switch back to this tab, we
-// can easily re-focus that terminal.
+/// We'll update this every time a Surface gains focus, so that we have it
+/// when we switch to another Tab. Then when we switch back to this tab,
+/// we can easily re-focus that terminal.
 focus_child: ?*Surface,
 
+/// Allocate a new `Tab`. `self` must be a stable pointer because we use it for
+/// GTK events.
 pub fn create(alloc: Allocator, window: *Window, parent_: ?*CoreSurface) !*Tab {
     var tab = try alloc.create(Tab);
     errdefer alloc.destroy(tab);
@@ -48,8 +48,8 @@ pub fn create(alloc: Allocator, window: *Window, parent_: ?*CoreSurface) !*Tab {
     return tab;
 }
 
-/// Initialize the tab, create a surface, and add it to the window. "self" needs
-/// to be a stable pointer, since it is used for GTK events.
+/// Initialize the tab, create a surface, and add it to the window. `self` needs to be a
+/// stable pointer, since it is used for GTK events.
 pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
     self.* = .{
         .window = window,
@@ -59,9 +59,40 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
         .focus_child = null,
     };
 
-    // Create a Box in which we'll later keep either Surface or Split. Using a
-    // box makes it easier to maintain the tab contents because we never need to
-    // change the root widget of the notebook page (tab).
+    // Build the tab label
+    const label_box_widget = c.gtk_box_new(c.GTK_ORIENTATION_HORIZONTAL, 0);
+    const label_box = @as(*c.GtkBox, @ptrCast(label_box_widget));
+    const label_text_widget = c.gtk_label_new("Ghostty");
+    const label_text: *c.GtkLabel = @ptrCast(label_text_widget);
+    self.label_text = @ptrCast(label_text);
+    c.gtk_box_append(label_box, label_text_widget);
+    const label_close_widget = c.gtk_button_new_from_icon_name("window-close-symbolic");
+    const label_close: *c.GtkButton = @ptrCast(label_close_widget);
+    c.gtk_button_set_has_frame(label_close, 0);
+    c.gtk_box_append(label_box, label_close_widget);
+    _ = c.g_signal_connect_data(
+        label_close,
+        "clicked",
+        c.G_CALLBACK(&gtkTabCloseClick),
+        self,
+        null,
+        c.G_CONNECT_DEFAULT,
+    );
+
+    // Wide style GTK tabs
+    if (window.app.config.@"gtk-wide-tabs") {
+        c.gtk_widget_set_hexpand(label_box_widget, 1);
+        c.gtk_widget_set_halign(label_box_widget, c.GTK_ALIGN_FILL);
+        c.gtk_widget_set_hexpand(label_text_widget, 1);
+        c.gtk_widget_set_halign(label_text_widget, c.GTK_ALIGN_FILL);
+        c.gtk_label_set_max_width_chars(label_text, 1);
+        c.gtk_label_set_ellipsize(label_text, c.PANGO_ELLIPSIZE_END);
+        c.gtk_widget_set_size_request(label_text_widget, 100, 1);
+    }
+
+    // Create a Box in which we'll later keep either Surface or Split.
+    // Using a box makes it easier to maintain the tab contents because
+    // we never need to change the root widget of the notebook page (tab).
     const box = gtk.Box.new(.vertical, 0);
     errdefer box.unref();
     const box_widget = box.as(gtk.Widget);
@@ -73,7 +104,7 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
     var surface = try Surface.create(window.app.core_app.alloc, window.app, .{
         .parent = parent_,
     });
-    errdefer surface.unref();
+    errdefer surface.unref(); // Surface implements unref for its underlying widgets
     surface.container = .{ .tab_ = self };
     self.elem = .{ .surface = surface };
 
@@ -82,7 +113,7 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
 
     // Set the userdata of the box to point to this tab.
     self.box.as(gobject.Object).setData(GHOSTTY_TAB, self);
-    window.notebook.addTab(self, "Ghostty");
+    try window.notebook.addTab(self, "Ghostty");
 
     // Attach all events
     _ = gtk.Widget.signals.destroy.connect(
@@ -98,32 +129,32 @@ pub fn init(self: *Tab, window: *Window, parent_: ?*CoreSurface) !void {
     surface.grabFocus();
 }
 
-/// Deinits tab by deiniting child elem.
-pub fn deinit(self: *Tab, alloc: Allocator) void {
-    self.elem.deinit(alloc);
-}
-
-/// Deinit and deallocate the tab.
+/// Deinitialize the tab. This releases any child elements and the GTK objects we
+/// created (but not the notebook page widget).
 pub fn destroy(self: *Tab, alloc: Allocator) void {
-    self.deinit(alloc);
-    alloc.destroy(self);
+    // Deinit the child element (surface or split)
+    self.elem.deinit(alloc);
+    // Unparent the label text widget (the rest of the widgets are owned by the
+    // notebook page and will be destroyed automatically).
+    _ = c.gtk_widget_unparent(@ptrCast(self.label_text));
+    // The box will be unreferenced when the notebook page is destroyed.
 }
 
-// TODO: move this
 /// Replace the surface element that this tab is showing.
 pub fn replaceElem(self: *Tab, elem: Surface.Container.Elem) void {
     // Remove our previous widget
     self.box.remove(self.elem.widget());
-
     // Add our new one
     self.box.append(elem.widget());
     self.elem = elem;
 }
 
+/// Set the title text for the tab.
 pub fn setTitleText(self: *Tab, title: [:0]const u8) void {
     self.window.notebook.setTabTitle(self, title);
 }
 
+/// Set the tooltip text for the tab.
 pub fn setTooltipText(self: *Tab, tooltip: [:0]const u8) void {
     self.window.notebook.setTabTooltip(self, tooltip);
 }
@@ -133,7 +164,8 @@ pub fn remove(self: *Tab) void {
     self.window.closeTab(self);
 }
 
-/// Helper function to check if any surface in the split hierarchy needs close confirmation
+/// Helper function to check if any surface in the split hierarchy needs close
+/// confirmation.
 fn needsConfirm(elem: Surface.Container.Elem) bool {
     return switch (elem) {
         .surface => |s| s.core_surface.needsConfirmQuit(),
@@ -150,10 +182,11 @@ pub fn closeWithConfirmation(tab: *Tab) void {
         ),
         .split => |s| {
             if (!needsConfirm(s.top_left) and !needsConfirm(s.bottom_right)) {
+                // No confirmations required, just close the tab.
                 tab.remove();
                 return;
             }
-
+            // Show a close confirmation dialog.
             CloseDialog.show(.{ .tab = tab }) catch |err| {
                 log.err("failed to open close dialog={}", .{err});
             };
@@ -161,11 +194,15 @@ pub fn closeWithConfirmation(tab: *Tab) void {
     }
 }
 
+/// GTK destroy signal handler for the tab's container box.
 fn gtkDestroy(_: *gtk.Box, self: *Tab) callconv(.C) void {
     log.debug("tab box destroy", .{});
-
     const alloc = self.window.app.core_app.alloc;
-
-    // When our box is destroyed, we want to destroy our tab, too.
     self.destroy(alloc);
+}
+
+/// GTK click handler for the tab close button.
+fn gtkTabCloseClick(_: *c.GtkButton, ud: ?*anyopaque) callconv(.C) void {
+    const tab: *Tab = @ptrCast(@alignCast(ud));
+    tab.closeWithConfirmation();
 }
\ No newline at end of file
