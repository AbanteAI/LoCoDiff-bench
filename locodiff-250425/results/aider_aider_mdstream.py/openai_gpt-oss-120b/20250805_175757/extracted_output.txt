#!/usr/bin/env python

import io
import time

from rich import box
from rich.console import Console
from rich.live import Live
from rich.markdown import CodeBlock, Heading, Markdown
from rich.panel import Panel
from rich.syntax import Syntax
from rich.text import Text

from aider.dump import dump  # noqa: F401

_text_prefix = """
# Header

Lorem Ipsum is simply dummy text of the printing and typesetting
industry.
Lorem Ipsum has been the industry's standard dummy text
ever since the 1500s,
when an unknown printer took a galley of type and
scrambled it to make a type
specimen book. It has survived not only five
centuries,
but also the leap into
electronic typesetting,
remaining essentially unchanged.
It was popular
in the 1960s with the release of
Letraset sheets
containing Lorem Ipsum passages,
and more recently with desktop
publishing software
like Aldus PageMaker
including versions of
Lorem Ipsum.

#### Sub header

- List 1
- List 2
- List me
- List you

```python
"""
_text_suffix = """
```

## Sub header too

The end.
"""
```

```python
class NoInsetCodeBlock(CodeBlock):
    """A code block with syntax highlighting and no padding."""

    def __rich_console__(self, console, options):
        code = str(self.text).rstrip()
        syntax = Syntax(
            code,
            self.lexer_name,
            theme=self.theme,
            word_wrap=True,
            padding=(1, 0),
        )
        yield syntax


class LeftHeading(Heading):
    """A heading that renders left-aligned."""

    def __rich_console__(self, console, options):
        text = self.text
        text.justify = "left"
        if self.tag == "h1":
            yield Panel(
                text,
                box=box.HEAVY,
                style="markdown.h1.border",
            )
        else:
            if self.tag == "h2":
                yield Text("")
            yield text


class NoInsetMarkdown(Markdown):
    """Markdown with code blocks that have no padding and left-justified headings."""

    elements = {
        **Markdown.elements,
        "fence": NoInsetCodeBlock,
        "code_block": NoInsetCodeBlock,
        "heading_open": LeftHeading,
    }


class MarkdownStream:
    """Streaming markdown renderer that progressively displays content
    with a live updating window."""

    live = None  # Rich Live display instance
    when = 0  # Timestamp of last update
    min_delay = 1.0 / 20  # Minimum time between updates (20fps)
    live_window = 6  # Number of lines to keep visible at bottom during streaming

    def __init__(self, mdargs=None):
        """Initialize the markdown stream.

        Args:
            mdargs (dict, optional): Additional arguments for
                the rich Markdown renderer.
        """
        self.printed = []
        self.mdargs = mdargs or {}
        self.live = Live(Text(""), refresh_per_second=1.0 / self.min_delay)
        self.live.start()

    def __del__(self):
        """Ensure Live display is properly cleaned up."""
        if self.live:
            try:
                self.live.stop()
            except Exception:
                pass

    def _render_markdown_to_lines(self, text):
        """Render markdown text to a list of lines.

        Args:
            text (str): Markdown text to render.

        Returns:
            list: Lines with line endings preserved.
        """
        string_io = io.StringIO()
        console = Console(file=string_io, force_terminal=True)
        markdown = NoInsetMarkdown(text, **self.mdargs)
        console.print(markdown)
        output = string_io.getvalue()
        return output.splitlines(keepends=True)

    def update(self, text, final=False):
        """Update the displayed markdown content.

        Args:
            text (str): The markdown text received so far.
            final (bool):
                If True, this is the final update and we should clean up.
        """
        now = time.time()
        if not final and now - self.when < self.min_delay:
            return
        self.when = now

        lines = self._render_markdown_to_lines(text)

        num_lines = len(lines)

        if not final:
            num_lines -= self.live_window

        if final or num_lines > 0:
            num_printed = len(self.printed)
            show = num_lines - num_printed
            if show <= 0:
                return

            show = lines[num_printed:num_lines]
            show = "".join(show)
            show = Text.from_ansi(show)
            self.live.console.print(show)
            self.printed = lines[:num_lines]

        if final:
            self.live.update(Text(""))
            self.live.stop()
            self.live = None
        else:
            rest = lines[num_lines:]
            rest = "".join(rest)
            rest = Text.from_ansi(rest)
            self.live.update(rest)


if __name__ == "__main__":
    with open("aider/io.py", "r") as f:
        code = f.read()
    _text = _text_prefix + code + _text_suffix
    _text = _text * 10

    pm = MarkdownStream()
    for i in range(6, len(_text), 5):
        pm.update(_text[:i])
        time.sleep(0.01)