
index ce88caa28..6af21a14b 100644
--- a/tldraw_apps_dotcom_sync-worker_src_TLDrawDurableObject.ts_expectedoutput.txt (expected):tmp/tmpsw_ndoyt_expected.txt	
+++ b/tldraw_apps_dotcom_sync-worker_src_TLDrawDurableObject.ts_extracted.txt (actual):tmp/tmp6acqzswc_actual.txt	
@@ -6,7 +6,6 @@ import {
 	APP_ASSET_UPLOAD_ENDPOINT,
 	DB,
 	FILE_PREFIX,
-	LOCAL_FILE_PREFIX,
 	PUBLISH_PREFIX,
 	READ_ONLY_LEGACY_PREFIX,
 	READ_ONLY_PREFIX,
@@ -311,36 +310,7 @@ export class TLDrawDurableObject extends DurableObject {
 		}
 	}
 
-	// this might return null if the file doesn't exist yet in the backend, or if it was deleted
 	_fileRecordCache: TlaFile | null = null
-	async getAppFileRecord(): Promise<TlaFile | null> {
-		try {
-			return await retry(
-				async () => {
-					if (this._fileRecordCache) {
-						return this._fileRecordCache
-					}
-					const result = await this.db
-						.selectFrom('file')
-						.where('id', '=', this.documentInfo.slug)
-						.selectAll()
-						.executeTakeFirst()
-					if (!result) {
-						throw new Error('File not found')
-					}
-					this._fileRecordCache = result
-					return this._fileRecordCache
-				},
-				{
-					attempts: 10,
-					waitDuration: 100,
-				}
-			)
-		} catch (_e) {
-			return null
-		}
-	}
-
 	async onRequest(req: IRequest, openMode: RoomOpenMode) {
 		// extract query params from request, should include instanceId
 		const url = new URL(req.url)
@@ -497,51 +467,34 @@ export class TLDrawDurableObject extends DurableObject {
 		}
 	}
 
-	async handleFileCreateFromSource() {
-		assert(this._fileRecordCache, 'we need to have a file record to create a file from source')
-		const split = this._fileRecordCache.createSource?.split('/')
-		if (!split || split?.length !== 2) {
-			return { type: 'room_not_found' as const }
-		}
-
-		let data: RoomSnapshot | string | null | undefined = undefined
-		const [prefix, id] = split
-		switch (prefix) {
-			case FILE_PREFIX: {
-				await getRoomDurableObject(this.env, id).awaitPersist()
-				data = await this.r2.rooms
-					.get(getR2KeyForRoom({ slug: id, isApp: true }))
-					.then((r) => r?.text())
-				break
-			}
-			case ROOM_PREFIX:
-				data = await getLegacyRoomData(this.env, id, ROOM_OPEN_MODE.READ_WRITE)
-				break
-			case READ_ONLY_PREFIX:
-				data = await getLegacyRoomData(this.env, id, ROOM_OPEN_MODE.READ_ONLY)
-				break
-			case READ_ONLY_LEGACY_PREFIX:
-				data = await getLegacyRoomData(this.env, id, ROOM_OPEN_MODE.READ_ONLY_LEGACY)
-				break
-			case SNAPSHOT_PREFIX:
-				data = await getLegacyRoomData(this.env, id, 'snapshot')
-				break
-			case PUBLISH_PREFIX:
-				data = await getPublishedRoomSnapshot(this.env, id)
-				break
-			case LOCAL_FILE_PREFIX:
-				// create empty room, the client will populate it
-				data = new TLSyncRoom({ schema: createTLSchema() }).getSnapshot()
-				break
-		}
-
-		if (!data) {
-			return { type: 'room_not_found' as const }
+	// this might return null if the file doesn't exist yet in the backend, or if it was deleted
+	_fileRecordCache: TlaFile | null = null
+	async getAppFileRecord(): Promise<TlaFile | null> {
+		try {
+			return await retry(
+				async () => {
+					if (this._fileRecordCache) {
+						return this._fileRecordCache
+					}
+					const result = await this.db
+						.selectFrom('file')
+						.where('id', '=', this.documentInfo.slug)
+						.selectAll()
+						.executeTakeFirst()
+					if (!result) {
+						throw new Error('File not found')
+					}
+					this._fileRecordCache = result
+					return this._fileRecordCache
+				},
+				{
+					attempts: 10,
+					waitDuration: 100,
+				}
+			)
+		} catch (_e) {
+			return null
 		}
-		const serialized = typeof data === 'string' ? data : JSON.stringify(data)
-		const snapshot = typeof data === 'string' ? JSON.parse(data) : data
-		await this.r2.rooms.put(this._fileRecordCache.id, serialized)
-		return { type: 'room_found' as const, snapshot }
 	}
 
 	// Load the room's drawing data. First we check the R2 bucket, then we fallback to supabase (legacy).
@@ -714,6 +667,53 @@ export class TLDrawDurableObject extends DurableObject {
 		await this.scheduler.onAlarm()
 	}
 
+	async handleFileCreateFromSource() {
+		assert(this._fileRecordCache, 'we need to have a file record to create a file from source')
+		const split = this._fileRecordCache.createSource?.split('/')
+		if (!split || split?.length !== 2) {
+			return { type: 'room_not_found' as const }
+		}
+
+		let data: RoomSnapshot | string | null | undefined = undefined
+		const [prefix, id] = split
+		switch (prefix) {
+			case FILE_PREFIX: {
+				await getRoomDurableObject(this.env, id).awaitPersist()
+				data = await this.r2.rooms
+					.get(getR2KeyForRoom({ slug: id, isApp: true }))
+					.then((r) => r?.text())
+				break
+			}
+			case ROOM_PREFIX:
+				data = await getLegacyRoomData(this.env, id, ROOM_OPEN_MODE.READ_WRITE)
+				break
+			case READ_ONLY_PREFIX:
+				data = await getLegacyRoomData(this.env, id, ROOM_OPEN_MODE.READ_ONLY)
+				break
+			case READ_ONLY_LEGACY_PREFIX:
+				data = await getLegacyRoomData(this.env, id, ROOM_OPEN_MODE.READ_ONLY_LEGACY)
+				break
+			case SNAPSHOT_PREFIX:
+				data = await getLegacyRoomData(this.env, id, 'snapshot')
+				break
+			case PUBLISH_PREFIX:
+				data = await getPublishedRoomSnapshot(this.env, id)
+				break
+			case 'local':
+				// create empty room, the client will populate it
+				data = new TLSyncRoom({ schema: createTLSchema() }).getSnapshot()
+				break
+		}
+
+		if (!data) {
+			return { type: 'room_not_found' as const }
+		}
+		const serialized = typeof data === 'string' ? data : JSON.stringify(data)
+		const snapshot = typeof data === 'string' ? JSON.parse(data) : data
+		await this.r2.rooms.put(this._fileRecordCache.id, serialized)
+		return { type: 'room_found' as const, snapshot }
+	}
+
 	async appFileRecordCreated(file: TlaFile) {
 		if (this._fileRecordCache) return
 		this._fileRecordCache = file
