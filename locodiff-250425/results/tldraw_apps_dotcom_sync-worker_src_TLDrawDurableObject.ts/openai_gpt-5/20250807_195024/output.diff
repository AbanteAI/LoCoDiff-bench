
index ce88caa28..063f4f98a 100644
--- a/tldraw_apps_dotcom_sync-worker_src_TLDrawDurableObject.ts_expectedoutput.txt (expected):tmp/tmp4lwvcul4_expected.txt	
+++ b/tldraw_apps_dotcom_sync-worker_src_TLDrawDurableObject.ts_extracted.txt (actual):tmp/tmp1_tez09l_actual.txt	
@@ -25,14 +25,7 @@ import {
 	type PersistedRoomSnapshotForSupabase,
 } from '@tldraw/sync-core'
 import { TLDOCUMENT_ID, TLDocument, TLRecord, createTLSchema } from '@tldraw/tlschema'
-import {
-	ExecutionQueue,
-	assert,
-	assertExists,
-	exhaustiveSwitchError,
-	retry,
-	uniqueId,
-} from '@tldraw/utils'
+import { ExecutionQueue, assert, assertExists, exhaustiveSwitchError, retry, uniqueId } from '@tldraw/utils'
 import { createSentry } from '@tldraw/worker-shared'
 import { DurableObject } from 'cloudflare:workers'
 import { IRequest, Router } from 'itty-router'
@@ -78,79 +71,6 @@ export class TLDrawDurableObject extends DurableObject {
 
 	sentry: ReturnType<typeof createSentry> | null = null
 
-	getRoom() {
-		if (!this._documentInfo) {
-			throw new Error('documentInfo must be present when accessing room')
-		}
-		const slug = this._documentInfo.slug
-		if (!this._room) {
-			this._room = this.loadFromDatabase(slug).then(async (result) => {
-				switch (result.type) {
-					case 'room_found': {
-						const room = new TLSocketRoom<TLRecord, SessionMeta>({
-							initialSnapshot: result.snapshot,
-							onSessionRemoved: async (room, args) => {
-								this.logEvent({
-									type: 'client',
-									roomId: slug,
-									name: 'leave',
-									instanceId: args.sessionId,
-									localClientId: args.meta.storeId,
-								})
-
-								if (args.numSessionsRemaining > 0) return
-								if (!this._room) return
-								this.logEvent({
-									type: 'client',
-									roomId: slug,
-									name: 'last_out',
-									instanceId: args.sessionId,
-									localClientId: args.meta.storeId,
-								})
-								try {
-									await this.persistToDatabase()
-								} catch {
-									// already logged
-								}
-								// make sure nobody joined the room while we were persisting
-								if (room.getNumActiveSessions() > 0) return
-								this._room = null
-								this.logEvent({ type: 'room', roomId: slug, name: 'room_empty' })
-								room.close()
-							},
-							onDataChange: () => {
-								this.triggerPersistSchedule()
-							},
-							onBeforeSendMessage: ({ message, stringified }) => {
-								this.logEvent({
-									type: 'send_message',
-									roomId: slug,
-									messageType: message.type,
-									messageLength: stringified.length,
-								})
-							},
-						})
-
-						this.logEvent({ type: 'room', roomId: slug, name: 'room_start' })
-						// Also associate file assets after we load the room
-						setTimeout(this.maybeAssociateFileAssets.bind(this), PERSIST_INTERVAL_MS)
-						return room
-					}
-					case 'room_not_found': {
-						throw ROOM_NOT_FOUND
-					}
-					case 'error': {
-						throw result.error
-					}
-					default: {
-						exhaustiveSwitchError(result)
-					}
-				}
-			})
-		}
-		return this._room
-	}
-
 	// For storage
 	storage: DurableObjectStorage
 
@@ -283,6 +203,79 @@ export class TLDrawDurableObject extends DurableObject {
 		}
 	}
 
+	getRoom() {
+		if (!this._documentInfo) {
+			throw new Error('documentInfo must be present when accessing room')
+		}
+		const slug = this._documentInfo.slug
+		if (!this._room) {
+			this._room = this.loadFromDatabase(slug).then(async (result) => {
+				switch (result.type) {
+					case 'room_found': {
+						const room = new TLSocketRoom<TLRecord, SessionMeta>({
+							initialSnapshot: result.snapshot,
+							onSessionRemoved: async (room, args) => {
+								this.logEvent({
+									type: 'client',
+									roomId: slug,
+									name: 'leave',
+									instanceId: args.sessionId,
+									localClientId: args.meta.storeId,
+								})
+
+								if (args.numSessionsRemaining > 0) return
+								if (!this._room) return
+								this.logEvent({
+									type: 'client',
+									roomId: slug,
+									name: 'last_out',
+									instanceId: args.sessionId,
+									localClientId: args.meta.storeId,
+								})
+								try {
+									await this.persistToDatabase()
+								} catch {
+									// already logged
+								}
+								// make sure nobody joined the room while we were persisting
+								if (room.getNumActiveSessions() > 0) return
+								this._room = null
+								this.logEvent({ type: 'room', roomId: slug, name: 'room_empty' })
+								room.close()
+							},
+							onDataChange: () => {
+								this.triggerPersistSchedule()
+							},
+							onBeforeSendMessage: ({ message, stringified }) => {
+								this.logEvent({
+									type: 'send_message',
+									roomId: slug,
+									messageType: message.type,
+									messageLength: stringified.length,
+								})
+							},
+						})
+
+						this.logEvent({ type: 'room', roomId: slug, name: 'room_start' })
+						// Also associate file assets after we load the room
+						setTimeout(this.maybeAssociateFileAssets.bind(this), PERSIST_INTERVAL_MS)
+						return room
+					}
+					case 'room_not_found': {
+						throw ROOM_NOT_FOUND
+					}
+					case 'error': {
+						throw result.error
+					}
+					default: {
+						exhaustiveSwitchError(result)
+					}
+				}
+			})
+		}
+		return this._room
+	}
+
 	_isRestoring = false
 	async onRestore(req: IRequest) {
 		this._isRestoring = true
@@ -311,8 +304,9 @@ export class TLDrawDurableObject extends DurableObject {
 		}
 	}
 
-	// this might return null if the file doesn't exist yet in the backend, or if it was deleted
+	_ownerId: string | null = null
 	_fileRecordCache: TlaFile | null = null
+	// this might return null if the file doesn't exist yet in the backend, or if it was deleted
 	async getAppFileRecord(): Promise<TlaFile | null> {
 		try {
 			return await retry(
@@ -588,7 +582,7 @@ export class TLDrawDurableObject extends DurableObject {
 				return { type: 'error', error: new Error(error.message) }
 			}
 			// if it didn't find a document, data will be an empty array
-			if (data.length === 0) {
+			if (!data || data.length === 0) {
 				return { type: 'room_not_found' }
 			}
 
