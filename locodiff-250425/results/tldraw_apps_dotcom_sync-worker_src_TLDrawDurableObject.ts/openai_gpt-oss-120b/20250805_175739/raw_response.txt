```typescript
/// <reference no-default-lib="true"/>
/// <reference types="@cloudflare/workers-types" />

import { SupabaseClient } from '@supabase/supabase-js'
import {
    DB,
    FILE_PREFIX,
    PUBLISH_PREFIX,
    READ_ONLY_LEGACY_PREFIX,
    READ_ONLY_PREFIX,
    ROOM_OPEN_MODE,
    ROOM_PREFIX,
    SNAPSHOT_PREFIX,
    TlaFile,
    type RoomOpenMode,
} from '@tldraw/dotcom-shared'
import {
    RoomSnapshot,
    TLSocketRoom,
    TLSyncRoom,
    TLSyncErrorCloseEventCode,
    TLSyncErrorCloseEventReason,
    TLCloseEventCode,
    type PersistedRoomSnapshotForSupabase,
    /* Note: TLSocketRoom was imported earlier */
} from '@tldraw/sync-core'
import { TLDOCUMENT_ID, TLDocument, TLRecord, createTLSchema } from '@tldraw/tlschema'
import {
    ExecutionQueue,
    assert,
    assertExists,
    exhaustiveSwitchError,
    retry,
    uniqueId,
} from '@tldraw/utils'
import { createSentry } from '@tldraw/worker-shared'
import { DurableObject } from 'cloudflare:workers'
import { IRequest, Router } from 'itty-router'
import { AlarmScheduler } from './AlarmScheduler'
import { PERSIST_INTERVAL_MS } from './config'
import { createPostgresConnectionPool } from './postgres'
import { getR2KeyForRoom } from './r2'
import { getPublishedRoomSnapshot } from './routes/tla/getPublishedFile'
import { Analytics, DBLoadResult, Environment, TLServerEvent } from './types'
import { EventData, writeDataPoint } from './utils/analytics'
import { createSupabaseClient } from './utils/createSupabaseClient'
import { getRoomDurableObject } from './utils/durableObjects'
import { isRateLimited } from './utils/rateLimit'
import { getSlug } from './utils/roomOpenMode'
import { throttle } from './utils/throttle'
import { getAuth } from './utils/tla/getAuth'
import { getLegacyRoomData } from './utils/tla/getLegacyRoomData'

const MAX_CONNECTIONS = 50

// increment this any time you make a change to this type
const CURRENT_DOCUMENT_INFO_VERSION = 3

interface DocumentInfo {
    version: number
    slug: string
    isApp: boolean
    deleted: boolean
}

interface SessionMeta {
    storeId: string
    userId: string | null
}

export class TLDrawDurableObject extends DurableObject {
    // A unique identifier for this instance of the Durable Object
    id: DurableObjectId

    // For TLSyncRoom
    private _room: Promise<TLSocketRoom<TLRecord, SessionMeta>> | null = null

    // For storage
    storage: DurableObjectStorage

    // For persistence
    supabaseClient: SupabaseClient | void

    // For analytics
    measure: Analytics | undefined

    // For error tracking
    sentryDSN: string | undefined

    // DurableObject Sentry helper
    sentry: ReturnType<typeof createSentry> | null = null

    readonly supabaseTable: string
    readonly r2: {
        readonly rooms: R2Bucket
        readonly versionCache: R2Bucket
    }

    _documentInfo: DocumentInfo | null = null
    _fileRecordCache: TlaFile | null = null

    db: Kysely<DB>

    constructor(private state: DurableObjectState, override env: Environment) {
        super(state, env);
        this.id = state.id
        this.storage = state.storage
        this.sentryDSN = env.SENTRY_DSN
        this.measure = env.MEASURE
        this.sentry = createSentry(this.state, env)
        this.supabaseClient = createSupabaseClient(env)

        this.supabaseTable = env.TLDRAW_ENV === 'production' ? 'drawings' : 'drawings_staging'
        this.r2 = {
            rooms: env.ROOMS,
            versionCache: env.ROOMS_HISTORY_EPHEMERAL,
        }

        // Load any cached document info
        state.blockConcurrencyWhile(async () => {
            const existingInfo = (await this.storage.get('documentInfo')) as DocumentInfo | null
            if (existingInfo?.version !== CURRENT_DOCUMENT_INFO_VERSION) {
                this._documentInfo = null
            } else {
                this._documentInfo = existingInfo
            }
        })

        // Create a Kysely DB connection pool
        this.db = createPostgresConnectionPool(env, 'TLDrawDurableObject')
    }

    readonly router = Router()
        .get(
            `/${ROOM_PREFIX}/:roomId`,
            (req) => this.extractDocumentInfoFromRequest(req, ROOM_OPEN_MODE.READ_WRITE),
            (req) => this.onRequest(req, ROOM_OPEN_MODE.READ_WRITE)
        )
        .get(
            `/${READ_ONLY_LEGACY_PREFIX}/:roomId`,
            (req) => this.extractDocumentInfoFromRequest(req, ROOM_OPEN_MODE.READ_ONLY_LEGACY),
            (req) => this.onRequest(req, ROOM_OPEN_MODE.READ_ONLY_LEGACY)
        )
        .get(
            `/${READ_ONLY_PREFIX}/:roomId`,
            (req) => this.extractDocumentInfoFromRequest(req, ROOM_OPEN_MODE.READ_ONLY),
            (req) => this.onRequest(req, ROOM_OPEN_MODE.READ_ONLY)
        )
        .post(
            `/${ROOM_PREFIX}/:roomId/restore`,
            (req) => this.extractDocumentInfoFromRequest(req, ROOM_OPEN_MODE.READ_WRITE),
            (req) => this.onRestore(req)
        )
        .all('*', () => new Response('Not found', { status: 404 }))

    readonly scheduler = new AlarmScheduler({
        storage: () => this.storage,
        alarms: {
            persist: async () => {
                this.persistToDatabase()
            },
        },
    })

    // "documentInfo" getter
    get documentInfo() {
        return assertExists(this._documentInfo, 'documentInfo must be present')
    }

    // Helper to persist documentInfo
    setDocumentInfo(info: DocumentInfo) {
        this._documentInfo = info
        this.storage.put('documentInfo', info)
    }

    getRoom() {
        if (!this._documentInfo) {
            throw new Error('documentInfo must be present when accessing room')
        }
        const slug = this._documentInfo.slug
        if (!this._room) {
            this._room = this.loadFromDatabase(slug).then((result) => {
                switch (result.type) {
                    case 'room_found': {
                        const room = new TLSocketRoom<TLRecord, SessionMeta>({
                            initialSnapshot: result.snapshot,
                            onSessionRemoved: async (room, args) => {
                                this.logEvent({
                                    type: 'client',
                                    roomId: slug,
                                    name: 'leave',
                                    instanceId: args.sessionId,
                                    localClientId: args.meta.storeId,
                                })
                                if (args.numSessionsRemaining > 0) return
                                if (!this._room) return
                                this.logEvent({
                                    type: 'client',
                                    roomId: slug,
                                    name: 'last_out',
                                    instanceId: args.sessionId,
                                    localClientId: args.storeId,
                                })
                                try {
                                    await this.persistToDatabase()
                                } catch (err) {
                                    // already logged
                                }
                                if (room.getNumActiveSessions() > 0) return
                                this._room = null
                                this.logEvent({ type: 'room', roomId: slug, name: 'room_empty' })
                                room.close()
                            },
                            onDataChange: () => {
                                this.triggerPersistSchedule()
                            },
                            onBeforeSendMessage: ({ message, stringified }) => {
                                this.logEvent({
                                    type: 'send_message',
                                    roomId: slug,
                                    messageType: message.type,
                                    messageLength: stringified.length,
                                })
                            },
                        })
                        this.logEvent({ type: 'room', roomId: slug, name: 'room_start' })
                        // also associate file assets after loading
                        setTimeout(this.maybeAssociateFileAssets.bind(this), PERSIST_INTERVAL_MS)
                        return room
                    }
                    case 'room_not_found':
                        throw ROOM_NOT_FOUND
                    case 'error':
                        throw result.error
                    default:
                        exhaustiveSwitchError(result)
                }
            })
        }
        return this._room
    }

    async extractDocumentInfoFromRequest(req: IRequest, roomOpenMode: RoomOpenMode) {
        const slug = assertExists(
            await getSlug(this.env, req.params.roomId, roomOpenMode),
            'roomId must be present'
        )
        const isApp = new URL(req.url).pathname.startsWith('/app/')

        if (this._documentInfo) {
            assert(this._documentInfo.slug === slug, 'slug must match')
        } else {
            this.setDocumentInfo({
                version: CURRENT_DOCUMENT_INFO_VERSION,
                slug,
                isApp,
                deleted: false,
            })
        }
    }

    async getAppFileRecord(): Promise<TlaFile | null> {
        if (this._fileRecordCache) {
            return this._fileRecordCache
        }
        try {
            const result = await this.db
                .selectFrom('file')
                .where('id', '=', this.documentInfo.slug)
                .selectAll()
                .executeTakeFirst()
            if (!result) {
                throw new Error('File not found')
            }
            this._fileRecordCache = result as TlaFile
            return this._fileRecordCache
        } catch {
            return null
        }
    }

    async onRequest(req: IRequest, openMode: RoomOpenMode) {
        const { 0: clientWebSocket, 1: serverWebSocket } = new WebSocketPair()
        serverWebSocket.accept()

        const closeSocket = (reason: TLSyncErrorCloseEventReason) => {
            serverWebSocket.close(TLSyncErrorCloseEventCode, reason)
            return new Response(null, { status: 101, webSocket: clientWebSocket })
        }

        if (this.documentInfo.deleted) {
            return closeSocket(TLSyncErrorCloseEventReason.NOT_FOUND)
        }

        const auth = await getAuth(req, this.env)

        if (this.documentInfo.isApp) {
            // For app files, ensure we have a record
            openMode = ROOM_OPEN_MODE.READ_WRITE
            const file = await this.getAppFileRecord()
            if (file) {
                if (file.isDeleted) {
                    return closeSocket(TLSyncErrorCloseEventReason.NOT_FOUND)
                }
                if (!auth && !file.shared) {
                    return closeSocket(TLSyncErrorCloseEventReason.NOT_AUTHENTICATED)
                }
                if (file.ownerId !== auth?.userId) {
                    if (!file.shared) {
                        return closeSocket(TLSyncErrorCloseEventReason.FORBIDDEN)
                    }
                    if (file.sharedLinkType === 'view') {
                        openMode = ROOM_OPEN_MODE.READ_ONLY
                    }
                }
            } else if (!this.documentInfo.isApp) {
                // temporary room for non-app paths
            } else {
                // file does not exist; treat as NOT_FOUND
                return closeSocket(TLSyncErrorCloseEventReason.NOT_FOUND)
            }
        }

        try {
            const room = await this.getRoom()
            // Max connections check
            if (room.getNumActiveSessions() > MAX_CONNECTIONS) {
                return closeSocket(TLSyncErrorCloseEventReason.ROOM_FULL)
            }

            // Rate limiting
            if (auth?.userId) {
                const rateLimited = await isRateLimited(this.env, auth?.userId)
                if (rateLimited) {
                    this.logEvent({
                        type: 'client',
                        userId: auth.userId,
                        localClientId: '',
                        name: 'rate_limited',
                    })
                    return closeSocket(TLSyncErrorCloseEventReason.RATE_LIMITED)
                }
            } else {
                const id = req.headers.get('Sec-WebSocket-Key') ?? ''
                const rateLimited = await isRateLimited(this.env, id)
                if (rateLimited) {
                    this.logEvent({
                        type: 'client',
                        userId: null,
                        localClientId: '',
                        name: 'rate_limited',
                    })
                    return closeSocket(TLSyncErrorCloseEventReason.RATE_LIMITED)
                }
            }

            const url = new URL(req.url)
            const params = Object.fromEntries(url.searchParams.entries())
            let { sessionId, storeId } = params as any
            const { 0: clientWebSocket, 1: serverWebSocket } = new WebSocketPair()
            serverWebSocket.accept()

            // ... (extract sessionId/storeId handling omitted for brevity)

            // Connect socket
            room.handleSocketConnect({
                sessionId,
                socket: serverWebSocket,
                meta: {
                    storeId,
                    userId: auth?.userId ?? null,
                    // For simplicity, we ignore readOnly for now; it is set based on openMode
                    // (the TLSocketRoom will manage readOnly flag)
                },
                isReadonly:
                    openMode === ROOM_OPEN_MODE.READ_ONLY ||
                    openMode === ROOM_OPEN_MODE.READ_ONLY_LEGACY,
            })

            this.logEvent({
                type: 'client',
                roomId: this.documentInfo.slug,
                name: 'enter',
                instanceId: sessionId,
                localClientId: storeId,
            })

            return new Response(null, {
                status: 101,
                webSocket: clientWebSocket,
            })
        } catch (e) {
            if (e === ROOM_NOT_FOUND) {
                return closeSocket(TLSyncErrorCloseEventReason.NOT_FOUND)
            }
            throw e
        }
    }

    async onRestore(req: IRequest) {
        // Restores a snapshot at a given timestamp
        this._isRestoring = true
        try {
            const roomId = this.documentInfo.slug
            const roomKey = getR2KeyForRoom({ slug: roomId, isApp: this.documentInfo.isApp })
            const timestamp = ((await req.json()) as any).timestamp
            if (!timestamp) {
                return new Response('Missing timestamp', { status: 400 })
            }
            const data = await this.r2.rooms.get(`${roomKey}/${timestamp}`)
            if (!data) {
                return new Response('Version not found', { status: 400 })
            }
            const dataText = await data.text()
            await this.r2.rooms.put(roomKey, dataText)
            const room = await this.getRoom()
            const snapshot: RoomSnapshot = JSON.parse(dataText)
            room.loadSnapshot(snapshot)
            return new Response()
        } finally {
            this._isRestoring = false
        }
    }

    // helper for file creation with a source (duplicate or slurped docs)
    async handleFileCreateFromSource() {
        assert(this._fileRecordCache, 'we need to have a file record to create from source')
        const split = this._fileRecordCache.createSource?.split('/')
        if (!split || split.length !== 2) {
            return { type: 'room_not_found' as const }
        }
        const [prefix, id] = split
        let data: string | null | undefined = undefined
        switch (prefix) {
            case FILE_PREFIX: {
                await getRoomDurableObject(this.env, id).awaitPersist()
                data = await this.r2.rooms
                    .get(getR2KeyForRoom({ slug: id, isApp: true }))
                    .then((r) => r?.text())
                break
            }
            case ROOM_PREFIX:
                data = await getLegacyRoomData(this.env, id, ROOM_OPEN_MODE.READ_WRITE)
                break
            case READ_ONLY_PREFIX:
                data = await getLegacyRoomData(this.env, id, ROOM_OPEN_MODE.READ_ONLY)
                break
            case READ_ONLY_LEGACY_PREFIX:
                data = await getLegacyRoomData(this.env, id, ROOM_OPEN_MODE.READ_ONLY_LEGACY)
                break
            case SNAPSHOT_PREFIX:
                data = await getLegacyRoomData(this.env, id, 'snapshot')
                break
            case PUBLISH_PREFIX:
                data = await getPublishedRoomSnapshot(this.env, id)
                break
        }
        if (!data) {
            return { type: 'room_not_found' as const }
        }
        const serialized = typeof data === 'string' ? data : JSON.stringify(data)
        await this.r2.rooms.put(this._fileRecordCache.id, serialized)
        return { type: 'room_found' as const, snapshot: typeof data === 'string' ? JSON.parse(data) : data }
    }

    // Load data from DB or R2
    async loadFromDatabase(slug: string): Promise<DBLoadResult> {
        try {
            const key = getR2KeyForRoom({ slug, isApp: this.documentInfo.isApp })
            const roomFromBucket = await this.r2.rooms.get(key)
            if (roomFromBucket) {
                return { type: 'room_found', snapshot: await roomFromBucket.json() }
            }

            if (this._fileRecordCache?.createSource) {
                const roomData = await this.handleFileCreateFromSource()
                if (roomData.type === 'room_found') {
                    // Save to bucket to avoid repeated slurps.
                    await this.r2.rooms.put(key, JSON.stringify(roomData.snapshot))
                }
                return roomData
            }

            if (this.documentInfo.isApp) {
                const file = await this.getAppFileRecord()
                if (!file) {
                    return { type: 'room_not_found' }
                }
                return {
                    type: 'room_found',
                    snapshot: new TLSyncRoom({ schema: createTLSchema() }).getSnapshot(),
                }
            }

            // Legacy fallback to Supabase (no longer used for app files)
            if (!this.supabaseClient) {
                return { type: 'room_not_found' }
            }
            const { data, error } = await this.supabaseClient
                .from(this.supabaseTable)
                .select('*')
                .eq('slug', slug)
            if (error) {
                this.logEvent({
                    type: 'room',
                    roomId: slug,
                    name: 'failed_load_from_db',
                })
                console.error('failed to retrieve document', slug, error)
                return { type: 'error', error: new Error(error.message) }
            }
            if (!data || data.length === 0) {
                return { type: 'room_not_found' }
            }
            const fromSupabase = data[0] as PersistedRoomSnapshotForSupabase
            return { type: 'room_found', snapshot: fromSupabase.drawing }
        } catch (error) {
            this.logEvent({
                type: 'room',
                roomId: slug,
                name: 'failed_load_from_db',
            })
            console.error('failed to fetch doc', slug, error)
            return { type: 'error', error: error as Error }
        }
    }

    // Periodic persist
    _lastPersistedClock: number | null = null
    executionQueue = new ExecutionQueue()

    async persistToDatabase() {
        try {
            await this.executionQueue.push(async () => {
                if (!this._room) return
                const slug = this.documentInfo.slug
                const room = await this.getRoom()
                const clock = room.getCurrentDocumentClock()
                if (this._lastPersistedClock === clock) return
                if (this._isRestoring) return

                const snapshot = JSON.stringify(room.getCurrentSnapshot())
                const key = getR2KeyForRoom({ slug, isApp: this.documentInfo.isApp })
                await Promise.all([
                    this.r2.rooms.put(key, snapshot),
                    this.r2.versionCache.put(`${key}/${new Date().toISOString()}`, snapshot),
                ])
                this._lastPersistedClock = clock

                // Update updatedAt timestamp
                if (this.documentInfo.isApp) {
                    await this.db
                        .updateTable('file')
                        .set({ updatedAt: new Date().getTime() })
                        .where('id', '=', this.documentInfo.slug)
                        .execute()
                        .catch((e) => this.reportError(e))
                }
            })
        } catch (e) {
            this.reportError(e)
        }
    }

    triggerPersistSchedule = throttle(() => {
        this.schedulePersist()
    }, 2000)

    private writeEvent(name: string, eventData: EventData) {
        try {
            writeDataPoint(this.sentry, this.measure, this.env, name, eventData)
        } catch (e) {
            console.error('Failed to write analytics data point', e)
        }
    }

    // Event logging
    logEvent(event: TLServerEvent) {
        switch (event.type) {
            case 'room':
                this.writeEvent(event.name, {
                    blobs: [event.roomId, this.env.WORKER_NAME ?? 'development-tldraw-multiplayer'],
                    indexes: [event.name],
                })
                break
            case 'client':
                if (event.name === 'rate_limited') {
                    this.writeEvent(event.name, {
                        blobs: [event.userId ?? 'anon'],
                        indexes: [event.localClientId],
                    })
                } else {
                    this.writeEvent(event.name, {
                        blobs: [event.roomId, 'unused', event.instanceId],
                        indexes: [event.localClientId],
                    })
                }
                break
            case 'send_message':
                this.writeEvent(event.type, {
                    blobs: [event.roomId, event.messageType],
                    doubles: [event.messageLength],
                })
                break
            default:
                exhaustiveSwitchError(event)
        }
    }

    async schedulePersist() {
        await this.scheduler.scheduleAlarmAfter('persist', PERSIST_INTERVAL_MS, {
            overwrite: 'if-sooner',
        })
    }

    // associate assets with file
    async maybeAssociateFileAssets() {
        if (!this.documentInfo.isApp) return
        const slug = this.documentInfo.slug
        const room = await this.getRoom()
        const assetsToUpdate: { objectName: string; fileId: string }[] = []
        await room.updateStore(async (store) => {
            const records = store.getAll()
            for (const record of records) {
                if (record.typeName !== 'asset') continue
                const asset = record as any
                const meta = asset.meta as any
                if (meta?.fileId === slug) continue
                const src = asset.props?.src
                if (!src) continue
                const objectName = src.split('/').pop()
                if (!objectName) continue
                const currentAsset = await this.env.UPLOADS.get(objectName)
                if (!currentAsset) continue

                const split = objectName.split('-')
                const fileType = split.length > 1 ? split.pop() : null
                const id = uniqueId()
                const newObjectName = fileType ? `${id}-${fileType}` : id
                await this.env.UPLOADS.put(newObjectName, currentAsset.body, {
                    httpMetadata: currentAsset.httpMetadata,
                })
                asset.props.src = `${this.env.MULTIPLAYER_SERVER.replace(/^ws/, 'http')}${APP_ASSET_UPLOAD_ENDPOINT}${newObjectName}`
                asset.meta.fileId = slug
                store.put(asset)
                assetsToUpdate.push({ objectName: newObjectName, fileId: slug })
            }
        })

        if (assetsToUpdate.length === 0) return

        await this.db
            .insertInto('asset')
            .values(assetsToUpdate)
            .onConflict((oc) => oc.column('objectName').doUpdateSet({ fileId: slug }))
            .execute()
    }

    // File record lifecycle hooks
    async appFileRecordCreated(file: TlaFile) {
        if (this._fileRecordCache) return
        this._fileRecordCache = file
        this.setDocumentInfo({
            version: CURRENT_DOCUMENT_INFO_VERSION,
            slug: file.id,
            isApp: true,
            deleted: false,
        })
        await this.getRoom()
    }

    async appFileRecordDidUpdate(file: TlaFile) {
        if (!file) {
            console.error('file record updated but no file found')
            return
        }
        this._fileRecordCache = file
        if (!this._documentInfo) {
            this.setDocumentInfo({
                version: CURRENT_DOCUMENT_INFO_VERSION,
                slug: file.id,
                isApp: true,
                deleted: false,
            })
        }
        const room = await this.getRoom()
        // Update document name if changed
        const docRecord = room.getRecord(TLDOCUMENT_ID) as TLDocument
        if (docRecord.name !== file.name) {
            room.updateStore((store) => {
                store.put({ ...docRecord, name: file.name })
            })
        }

        // Update session permissions based on sharing
        const roomIsReadOnlyForGuests = file.shared && file.sharedLinkType === 'view'
        for (const session of room.getSessions()) {
            if (session.meta.userId === file.ownerId) continue
            if (!file.shared) {
                room.closeSession(session.sessionId, TLSyncErrorCloseEventReason.FORBIDDEN)
            } else if (session.isReadonly && !roomIsReadOnlyForGuests) {
                // Force reconnect
                room.closeSession(session.sessionId)
            } else if (!session.isReadonly && roomIsReadOnlyForGuests) {
                // Force reconnect
                room.closeSession(session.sessionId)
            }
        }
    }

    async appFileRecordDeleted({ id, publishedSlug }: Pick<TlaFile, 'id' | 'publishedSlug'>) {
        if (this._documentInfo?.deleted) return
        this._fileRecordCache = null
        // prevent new connections while cleaning up
        this.setDocumentInfo({
            version: CURRENT_DOCUMENT_INFO_VERSION,
            slug: this.documentInfo.slug,
            isApp: true,
            deleted: true,
        })
        await this.executionQueue.push(async () => {
            if (this._room) {
                const room = await this.getRoom()
                for (const session of room.getSessions()) {
                    room.closeSession(session.sessionId, TLSyncErrorCloseEventReason.NOT_FOUND)
                }
                room.close()
            }
            // Delete published slug mapping
            await this.env.SNAPSHOT_SLUG_TO_PARENT_SLUG.delete(publishedSlug)

            // delete published snapshots
            const publishedPrefix = getR2KeyForRoom({
                slug: `${id}/${publishedSlug}`,
                isApp: true,
            })
            const publishedKeys = await listAllObjectKeys(this.env.ROOM_SNAPSHOTS, `${publishedPrefix}/`)
            if (publishedKeys.length) {
                await this.env.ROOM_SNAPSHOTS.delete(publishedKeys)
            }

            // delete edit history
            const historyKey = getR2KeyForRoom({ slug: id, isApp: true })
            const historyKeys = await listAllObjectKeys(this.env.ROOMS_HISTORY_EPHEMERAL, `${historyKey}/`)
            if (historyKeys.length) {
                await this.env.ROOMS_HISTORY_EPHEMERAL.delete(historyKeys)
            }

            // delete main file
            await this.env.ROOMS.delete(getR2KeyForRoom({ slug: id, isApp: true }))
        })
    }

    // Admin functions for migration/management
    async __admin__hardDeleteIfLegacy() {
        if (!this._documentInfo || this.documentInfo.isApp) return false
        this.setDocumentInfo({
            version: CURRENT_DOCUMENT_INFO_VERSION,
            slug: this.documentInfo.slug,
            isApp: false,
            deleted: true,
        })
        if (this._room) {
            const room = await this.getRoom()
            room.close()
        }
        const key = getR2KeyForRoom({ slug: this.documentInfo.slug, isApp: false })
        // delete edit history
        const historyKeys = await listAllObjectKeys(this.env.ROOMS_HISTORY_EPHEMERAL, `${key}/`)
        if (historyKeys.length) {
            await this.env.ROOMS_HISTORY_EPHEMERAL.delete(hist... )
        }
        // delete main file
        await this.env.ROOMS.delete(key)
        return true
    }

    async __admin__createLegacyRoom(id: string) {
        this.setDocumentInfo({
            version: CURRENT_DOCUMENT_INFO_VERSION,
            slug: id,
            isApp: false,
            deleted: false,
        })
        const key = getR2KeyForRoom({ slug: id, isApp: false })
        await this.r2.rooms.put(
            key,
            JSON.stringify(new TLSyncRoom({ schema: createTLSchema() }).getSnapshot())
        )
        await this.getRoom()
    }

    private reportError(e: unknown) {
        // eslint-disable-next-line @typescript-eslint/no-deprecated
        this.sentry?.captureException(e as any)
        console.error(e)
    }
}

// Utility to list all keys in a bucket prefix
async function listAllObjectKeys(bucket: R2Bucket, prefix: string): Promise<string[]> {
    const keys: string[] = []
    let cursor: string | undefined
    do {
        const result = await bucket.list({ prefix, cursor })
        keys.push(...result.objects.map((o) => o.key))
        cursor = result.truncated ? result.cursor : undefined
    } while (cursor)
    return keys
}
```