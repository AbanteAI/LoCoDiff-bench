
index 71e15f9b2..1bd0ec85e 100644
--- a/qdrant_lib_collection_src_collection_mod.rs_expectedoutput.txt (expected):tmp/tmpkf5s2tmf_expected.txt	
+++ b/qdrant_lib_collection_src_collection_mod.rs_extracted.txt (actual):tmp/tmp7gs9vlqm_actual.txt	
@@ -5,14 +5,12 @@ mod facet;
 pub mod payload_index_schema;
 mod point_ops;
 pub mod query;
-mod resharding;
 mod search;
 mod shard_transfer;
 mod sharding_keys;
 mod snapshots;
 mod state_management;
 
-use std::collections::HashMap;
 use std::ops::Deref;
 use std::path::{Path, PathBuf};
 use std::sync::Arc;
@@ -644,7 +642,7 @@ impl Collection {
         // We must track this here so we can reference it when checking for tranfser limits,
         // because transfers we propose now will not be in the consensus state within the lifetime
         // of this function
-        let mut proposed = HashMap::<PeerId, usize>::new();
+        let mut proposed = std::collections::HashMap::<PeerId, usize>::new();
 
         // Check for proper replica states
         for replica_set in shard_holder.all_shards() {
@@ -774,6 +772,26 @@ impl Collection {
         Ok(())
     }
 
+    /// Check that proposed number of incoming and outgoing shard transfers on a node stay within the limits
+    ///
+    /// Incoming and outgoing transfer counts are considered separately.
+    /// The maximum number of incoming OR outgoing in both cases must stay below the maximum limits.
+    fn check_auto_shard_transfer_limit(&self, incoming: usize, outgoing: usize) -> bool {
+        let (in_limit, out_limit) = self
+            .shared_storage_config
+            .automatic_shard_transfer_limits
+            .unwrap_or_default();
+
+        if incoming >= in_limit.get() {
+            return true; // We hit the incoming limit
+        }
+        if outgoing >= out_limit.get() {
+            return true; // We hit the outgoing limit
+        }
+
+        false
+    }
+
     pub async fn get_telemetry_data(&self, detail: TelemetryDetail) -> CollectionTelemetry {
         let (shards_telemetry, transfers, resharding) = {
             if detail.level >= DetailsLevel::Level3 {
@@ -838,16 +856,6 @@ impl Collection {
         }
     }
 
-    pub async fn effective_optimizers_config(&self) -> CollectionResult<OptimizersConfig> {
-        let config = self.collection_config.read().await;
-
-        if let Some(optimizers_overwrite) = self.optimizers_overwrite.clone() {
-            Ok(optimizers_overwrite.update(&config.optimizer_config)?)
-        } else {
-            Ok(config.optimizer_config.clone())
-        }
-    }
-
     pub async fn lock_updates(&self) -> RwLockWriteGuard<()> {
         self.updates_lock.write().await
     }
