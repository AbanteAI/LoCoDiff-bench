
index 71e15f9b2..e6ac6eeb5 100644
--- a/qdrant_lib_collection_src_collection_mod.rs_expectedoutput.txt (expected):tmp/tmpgfdzguds_expected.txt	
+++ b/qdrant_lib_collection_src_collection_mod.rs_extracted.txt (actual):tmp/tmphct2fb5a_actual.txt	
@@ -12,7 +12,6 @@ mod sharding_keys;
 mod snapshots;
 mod state_management;
 
-use std::collections::HashMap;
 use std::ops::Deref;
 use std::path::{Path, PathBuf};
 use std::sync::Arc;
@@ -375,7 +374,7 @@ impl Collection {
         let shard = shard_holder_read.get_shard(shard_id);
         let Some(replica_set) = shard else {
             return Err(CollectionError::NotFound {
-                what: format!("Shard {shard_id}"),
+                what: "Shard {shard_id}".into(),
             });
         };
 
@@ -563,30 +562,6 @@ impl Collection {
         }
     }
 
-    pub async fn remove_shards_at_peer(&self, peer_id: PeerId) -> CollectionResult<()> {
-        // Abort resharding, if shards are removed from peer driving resharding
-        // (which *usually* means the *peer* is being removed from consensus)
-        let resharding_state = self
-            .resharding_state()
-            .await
-            .filter(|state| state.peer_id == peer_id);
-
-        if let Some(state) = resharding_state {
-            if let Err(err) = self.abort_resharding(state.key(), true).await {
-                log::error!(
-                    "Failed to abort resharding {} while removing peer {peer_id}: {err}",
-                    state.key(),
-                );
-            }
-        }
-
-        self.shards_holder
-            .read()
-            .await
-            .remove_shards_at_peer(peer_id)
-            .await
-    }
-
     pub async fn sync_local_state(
         &self,
         on_transfer_failure: OnTransferFailure,
@@ -644,7 +619,7 @@ impl Collection {
         // We must track this here so we can reference it when checking for tranfser limits,
         // because transfers we propose now will not be in the consensus state within the lifetime
         // of this function
-        let mut proposed = HashMap::<PeerId, usize>::new();
+        let mut proposed = std::collections::HashMap::<PeerId, usize>::new();
 
         // Check for proper replica states
         for replica_set in shard_holder.all_shards() {
