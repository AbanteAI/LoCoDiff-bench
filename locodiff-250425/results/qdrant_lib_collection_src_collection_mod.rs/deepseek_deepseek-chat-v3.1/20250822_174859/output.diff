
index 71e15f9b2..c66a94bae 100644
--- a/qdrant_lib_collection_src_collection_mod.rs_expectedoutput.txt (expected):tmp/tmph6p0x1kf_expected.txt	
+++ b/qdrant_lib_collection_src_collection_mod.rs_extracted.txt (actual):tmp/tmpqk89y7qa_actual.txt	
@@ -1,4 +1,3 @@
-mod clean;
 mod collection_ops;
 pub mod distance_matrix;
 mod facet;
@@ -247,8 +246,6 @@ impl Collection {
         });
         collection_config.validate_and_warn();
 
-        let mut shard_holder = ShardHolder::new(path).expect("Can not create shard holder");
-
         let mut effective_optimizers_config = collection_config.optimizer_config.clone();
 
         if let Some(optimizers_overwrite) = optimizers_overwrite.clone() {
@@ -257,6 +254,8 @@ impl Collection {
                 .expect("Can not apply optimizer overwrite");
         }
 
+        let mut shard_holder = ShardHolder::new(path).expect("Can not create shard holder");
+
         let shared_collection_config = Arc::new(RwLock::new(collection_config.clone()));
 
         let payload_index_schema = Arc::new(
@@ -829,69 +828,4 @@ impl Collection {
         let optimizers_status = shard_optimization_statuses
             .into_iter()
             .max()
-            .unwrap_or(OptimizersStatus::Ok);
-
-        CollectionsAggregatedTelemetry {
-            vectors,
-            optimizers_status,
-            params: self.collection_config.read().await.params.clone(),
-        }
-    }
-
-    pub async fn effective_optimizers_config(&self) -> CollectionResult<OptimizersConfig> {
-        let config = self.collection_config.read().await;
-
-        if let Some(optimizers_overwrite) = self.optimizers_overwrite.clone() {
-            Ok(optimizers_overwrite.update(&config.optimizer_config)?)
-        } else {
-            Ok(config.optimizer_config.clone())
-        }
-    }
-
-    pub async fn lock_updates(&self) -> RwLockWriteGuard<()> {
-        self.updates_lock.write().await
-    }
-
-    pub fn wait_collection_initiated(&self, timeout: Duration) -> bool {
-        self.is_initialized.await_ready_for_timeout(timeout)
-    }
-
-    pub fn request_shard_transfer(&self, shard_transfer: ShardTransfer) {
-        self.request_shard_transfer_cb.deref()(shard_transfer)
-    }
-
-    pub fn snapshots_path(&self) -> &Path {
-        &self.snapshots_path
-    }
-
-    pub fn shards_holder(&self) -> Arc<LockedShardHolder> {
-        self.shards_holder.clone()
-    }
-
-    pub async fn trigger_optimizers(&self) {
-        self.shards_holder.read().await.trigger_optimizers().await;
-    }
-
-    async fn estimate_collection_size_stats(
-        shards_holder: &Arc<RwLock<ShardHolder>>,
-    ) -> Option<CollectionSizeStats> {
-        let shard_lock = shards_holder.read().await;
-        shard_lock.estimate_collection_size_stats().await
-    }
-
-    /// Returns estimations of collection sizes. This values are cached and might be not 100% up to date.
-    /// The cache gets updated every 32 calls.
-    pub(crate) async fn estimated_collection_stats(&self) -> Option<&CollectionSizeAtomicStats> {
-        self.collection_stats_cache
-            .get_or_update_cache(|| Self::estimate_collection_size_stats(&self.shards_holder))
-            .await
-    }
-}
-
-struct CollectionVersion;
-
-impl StorageVersion for CollectionVersion {
-    fn current_raw() -> &'static str {
-        env!("CARGO_PKG_VERSION")
-    }
-}
\ No newline at end of file
+            .unwrap
\ No newline at end of file
