
index 47f78e903..13fdd2701 100644
--- a/qdrant_lib_segment_src_index_struct_payload_index.rs_expectedoutput.txt (expected):tmp/tmp69zwclb9_expected.txt	
+++ b/qdrant_lib_segment_src_index_struct_payload_index.rs_extracted.txt (actual):tmp/tmpz_xvr3jo_actual.txt	
@@ -23,7 +23,6 @@ use crate::common::operation_error::{OperationError, OperationResult};
 use crate::common::rocksdb_wrapper::open_db_with_existing_cf;
 use crate::common::utils::IndexesMap;
 use crate::id_tracker::IdTrackerSS;
-use crate::index::PayloadIndex;
 use crate::index::field_index::{
     CardinalityEstimation, FieldIndex, PayloadBlockCondition, PrimaryCondition,
 };
@@ -32,6 +31,7 @@ use crate::index::query_estimator::estimate_filter;
 use crate::index::query_optimization::payload_provider::PayloadProvider;
 use crate::index::struct_filter_context::StructFilterContext;
 use crate::index::visited_pool::VisitedPool;
+use crate::index::PayloadIndex;
 use crate::json_path::JsonPath;
 use crate::payload_storage::payload_storage_enum::PayloadStorageEnum;
 use crate::payload_storage::{FilterContext, PayloadStorage};
@@ -70,44 +70,6 @@ pub struct StructPayloadIndex {
 }
 
 impl StructPayloadIndex {
-    pub fn estimate_field_condition(
-        &self,
-        condition: &FieldCondition,
-        nested_path: Option<&JsonPath>,
-        hw_counter: &HardwareCounterCell,
-    ) -> Option<CardinalityEstimation> {
-        let full_path = JsonPath::extend_or_new(nested_path, &condition.key);
-        self.field_indexes.get(&full_path).and_then(|indexes| {
-            // rewrite condition with fullpath to enable cardinality estimation
-            let full_path_condition = FieldCondition {
-                key: full_path,
-                ..condition.clone()
-            };
-
-            indexes
-                .iter()
-                .find_map(|index| index.estimate_cardinality(&full_path_condition, hw_counter))
-        })
-    }
-
-    fn query_field<'a>(
-        &'a self,
-        condition: &'a PrimaryCondition,
-        hw_counter: &'a HardwareCounterCell,
-    ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + 'a>> {
-        match condition {
-            PrimaryCondition::Condition(field_condition) => {
-                let field_key = &field_condition.key;
-                let field_indexes = self.field_indexes.get(field_key)?;
-                field_indexes
-                    .iter()
-                    .find_map(|field_index| field_index.filter(field_condition, hw_counter))
-            }
-            PrimaryCondition::Ids(ids) => Some(Box::new(ids.iter().copied())),
-            PrimaryCondition::HasVector(_) => None,
-        }
-    }
-
     fn config_path(&self) -> PathBuf {
         PayloadConfig::get_config_path(&self.path)
     }
@@ -205,7 +167,7 @@ impl StructPayloadIndex {
 
         if !index.config_path().exists() {
             // Save default config
-            index.save_config()?;
+            index.save_config()?
         }
 
         index.load_all_fields()?;
@@ -359,6 +321,7 @@ impl StructPayloadIndex {
         }
         Ok(())
     }
+
     pub fn config(&self) -> &PayloadConfig {
         &self.config
     }
@@ -434,6 +397,44 @@ impl StructPayloadIndex {
         }
     }
 
+    fn estimate_field_condition(
+        &self,
+        condition: &FieldCondition,
+        nested_path: Option<&JsonPath>,
+        hw_counter: &HardwareCounterCell,
+    ) -> Option<CardinalityEstimation> {
+        let full_path = JsonPath::extend_or_new(nested_path, &condition.key);
+        self.field_indexes.get(&full_path).and_then(|indexes| {
+            // rewrite condition with fullpath to enable cardinality estimation
+            let full_path_condition = FieldCondition {
+                key: full_path,
+                ..condition.clone()
+            };
+
+            indexes
+                .iter()
+                .find_map(|index| index.estimate_cardinality(&full_path_condition, hw_counter))
+        })
+    }
+
+    fn query_field<'a>(
+        &'a self,
+        condition: &'a PrimaryCondition,
+        hw_counter: &'a HardwareCounterCell,
+    ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + 'a>> {
+        match condition {
+            PrimaryCondition::Condition(field_condition) => {
+                let field_key = &field_condition.key;
+                let field_indexes = self.field_indexes.get(field_key)?;
+                field_indexes
+                    .iter()
+                    .find_map(|field_index| field_index.filter(field_condition, hw_counter))
+            }
+            PrimaryCondition::Ids(ids) => Some(Box::new(ids.iter().copied())),
+            PrimaryCondition::HasVector(_) => None,
+        }
+    }
+
     pub fn get_facet_index(&self, key: &JsonPath) -> OperationResult<FacetIndexEnum> {
         self.field_indexes
             .get(key)
@@ -609,6 +610,7 @@ impl PayloadIndex for StructPayloadIndex {
             .borrow_mut()
             .overwrite(point_id, payload, hw_counter)?;
 
+        // TODO(io_measurement): Maybe add measurements to index here too.
         for (field, field_index) in &mut self.field_indexes {
             let field_value = payload.get_value(field);
             if !field_value.is_empty() {
