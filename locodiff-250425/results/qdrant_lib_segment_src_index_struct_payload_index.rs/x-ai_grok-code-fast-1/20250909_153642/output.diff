
index 47f78e903..503aba149 100644
--- a/qdrant_lib_segment_src_index_struct_payload_index.rs_expectedoutput.txt (expected):tmp/tmpi_mt6m6n_expected.txt	
+++ b/qdrant_lib_segment_src_index_struct_payload_index.rs_extracted.txt (actual):tmp/tmpm3quho3i_actual.txt	
@@ -23,23 +23,24 @@ use crate::common::operation_error::{OperationError, OperationResult};
 use crate::common::rocksdb_wrapper::open_db_with_existing_cf;
 use crate::common::utils::IndexesMap;
 use crate::id_tracker::IdTrackerSS;
-use crate::index::PayloadIndex;
 use crate::index::field_index::{
     CardinalityEstimation, FieldIndex, PayloadBlockCondition, PrimaryCondition,
 };
+use crate::index::field_index::index_selector::index_selector;
 use crate::index::payload_config::PayloadConfig;
 use crate::index::query_estimator::estimate_filter;
 use crate::index::query_optimization::payload_provider::PayloadProvider;
 use crate::index::struct_filter_context::StructFilterContext;
 use crate::index::visited_pool::VisitedPool;
+use crate::index::PayloadIndex;
 use crate::json_path::JsonPath;
 use crate::payload_storage::payload_storage_enum::PayloadStorageEnum;
 use crate::payload_storage::{FilterContext, PayloadStorage};
 use crate::telemetry::PayloadIndexTelemetry;
 use crate::types::{
     Condition, FieldCondition, Filter, IsEmptyCondition, IsNullCondition, Payload,
-    PayloadContainer, PayloadFieldSchema, PayloadKeyType, PayloadKeyTypeRef, PayloadSchemaType,
-    VectorNameBuf, infer_collection_value_type, infer_value_type,
+    PayloadContainer, PayloadField, PayloadFieldSchema, PayloadKeyType, PayloadKeyTypeRef,
+    PayloadSchemaType, VectorNameBuf, infer_collection_value_type, infer_value_type,
 };
 use crate::vector_storage::{VectorStorage, VectorStorageEnum};
 
@@ -70,44 +71,6 @@ pub struct StructPayloadIndex {
 }
 
 impl StructPayloadIndex {
-    pub fn estimate_field_condition(
-        &self,
-        condition: &FieldCondition,
-        nested_path: Option<&JsonPath>,
-        hw_counter: &HardwareCounterCell,
-    ) -> Option<CardinalityEstimation> {
-        let full_path = JsonPath::extend_or_new(nested_path, &condition.key);
-        self.field_indexes.get(&full_path).and_then(|indexes| {
-            // rewrite condition with fullpath to enable cardinality estimation
-            let full_path_condition = FieldCondition {
-                key: full_path,
-                ..condition.clone()
-            };
-
-            indexes
-                .iter()
-                .find_map(|index| index.estimate_cardinality(&full_path_condition, hw_counter))
-        })
-    }
-
-    fn query_field<'a>(
-        &'a self,
-        condition: &'a PrimaryCondition,
-        hw_counter: &'a HardwareCounterCell,
-    ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + 'a>> {
-        match condition {
-            PrimaryCondition::Condition(field_condition) => {
-                let field_key = &field_condition.key;
-                let field_indexes = self.field_indexes.get(field_key)?;
-                field_indexes
-                    .iter()
-                    .find_map(|field_index| field_index.filter(field_condition, hw_counter))
-            }
-            PrimaryCondition::Ids(ids) => Some(Box::new(ids.iter().copied())),
-            PrimaryCondition::HasVector(_) => None,
-        }
-    }
-
     fn config_path(&self) -> PathBuf {
         PayloadConfig::get_config_path(&self.path)
     }
@@ -152,6 +115,9 @@ impl StructPayloadIndex {
                 payload_schema,
                 &HardwareCounterCell::disposable(), // Internal operation.
             )?;
+            for index in indexes.iter_mut() {
+                index.save()?;
+            }
         }
 
         Ok(indexes)
@@ -213,41 +179,6 @@ impl StructPayloadIndex {
         Ok(index)
     }
 
-    pub fn build_field_indexes(
-        &self,
-        field: PayloadKeyTypeRef,
-        payload_schema: &PayloadFieldSchema,
-        hw_counter: &HardwareCounterCell,
-    ) -> OperationResult<Vec<FieldIndex>> {
-        let payload_storage = self.payload.borrow();
-        let mut builders = self
-            .selector(payload_schema)
-            .index_builder(field, payload_schema)?;
-
-        for index in &mut builders {
-            index.init()?;
-        }
-
-        payload_storage.iter(
-            |point_id, point_payload| {
-                let field_value = &point_payload.get_value(field);
-                for builder in builders.iter_mut() {
-                    builder.add_point(point_id, field_value, hw_counter)?;
-                }
-                Ok(true)
-            },
-            hw_counter,
-        )?;
-
-        builders
-            .into_iter()
-            .map(|builder| builder.finalize())
-            .collect()
-    }
-
-    /// Number of available points
-    ///
-    /// - excludes soft deleted points
     pub fn available_point_count(&self) -> usize {
         self.id_tracker.borrow().available_point_count()
     }
@@ -332,35 +263,110 @@ impl StructPayloadIndex {
         }
     }
 
-    pub fn get_telemetry_data(&self) -> Vec<PayloadIndexTelemetry> {
-        self.field_indexes
-            .iter()
-            .flat_map(|(name, field)| -> Vec<PayloadIndexTelemetry> {
-                field
+    fn estimate_field_condition(
+        &self,
+        condition: &FieldCondition,
+        nested_path: Option<&JsonPath>,
+        hw_counter: &HardwareCounterCell,
+    ) -> Option<CardinalityEstimation> {
+        let full_path = JsonPath::extend_or_new(nested_path, &condition.key);
+        self.field_indexes.get(&full_path).and_then(|indexes| {
+            // rewrite condition with fullpath to enable cardinality estimation
+            let full_path_condition = FieldCondition {
+                key: full_path,
+                ..condition.clone()
+            };
+
+            indexes
+                .iter()
+                .find_map(|index| index.estimate_cardinality(&full_path_condition, hw_counter))
+        })
+    }
+
+    fn query_field<'a>(
+        &'a self,
+        condition: &'a PrimaryCondition,
+        hw_counter: &'a HardwareCounterCell,
+    ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + 'a>> {
+        match condition {
+            PrimaryCondition::Condition(field_condition) => {
+                let field_key = &field_condition.key;
+                let field_indexes = self.field_indexes.get(field_key)?;
+                field_indexes
                     .iter()
-                    .map(|field| field.get_telemetry_data().set_name(name.to_string()))
-                    .collect()
-            })
-            .collect()
+                    .find_map(|field_index| field_index.filter(field_condition, hw_counter))
+            }
+            PrimaryCondition::Ids(ids) => Some(Box::new(ids.iter().copied())),
+            PrimaryCondition::HasVector(_) => None,
+        }
+    }
+
+    fn config_path(&self) -> PathBuf {
+        PayloadConfig::get_config_path(&self.path)
+    }
+
+    fn save_config(&self) -> OperationResult<()> {
+        let config_path = self.config_path();
+        self.config.save(&config_path)
+    }
+
+    fn load_all_fields(&mut self) -> OperationResult<()> {
+        let mut field_indexes: IndexesMap = Default::default();
+
+        for (field, payload_schema) in &self.config.indexed_fields {
+            let field_index = self.load_from_db(field, payload_schema)?;
+            field_indexes.insert(field.clone(), field_index);
+        }
+        self.field_indexes = field_indexes;
+        Ok(())
     }
 
-    pub fn restore_database_snapshot(
+    fn restore_database_snapshot(
         snapshot_path: &Path,
         segment_path: &Path,
     ) -> OperationResult<()> {
         crate::rocksdb_backup::restore(snapshot_path, &segment_path.join("payload_index"))
     }
 
-    fn clear_index_for_point(&mut self, point_id: PointOffsetType) -> OperationResult<()> {
-        for (_, field_indexes) in self.field_indexes.iter_mut() {
-            for index in field_indexes {
-                index.remove_point(point_id)?;
+    /// Select which type of PayloadIndex to use for the field
+    fn selector(&self, payload_schema: &PayloadFieldSchema) -> IndexSelector {
+        let is_on_disk = payload_schema.is_on_disk();
+
+        match &self.storage_type {
+            StorageType::Appendable(db) => IndexSelector::RocksDb(IndexSelectorRocksDb {
+                db,
+                is_appendable: true,
+            }),
+            StorageType::NonAppendableRocksDb(db) => {
+                // legacy logic: we keep rocksdb, but load mmap indexes
+                if is_on_disk {
+                    IndexSelector::Mmap(IndexSelectorMmap {
+                        dir: &self.path,
+                        is_on_disk,
+                    })
+                } else {
+                    IndexSelector::RocksDb(IndexSelectorRocksDb {
+                        db,
+                        is_appendable: false,
+                    })
+                }
             }
+            StorageType::NonAppendable => IndexSelector::Mmap(IndexSelectorMmap {
+                dir: &self.path,
+                is_on_disk,
+            }),
         }
-        Ok(())
     }
-    pub fn config(&self) -> &PayloadConfig {
-        &self.config
+
+    pub fn optimize_filter(
+        &self,
+        _filter: &Filter,
+        _payload_provider: PayloadProvider,
+        _total: usize,
+        _hw_counter: &HardwareCounterCell,
+    ) -> (Filter, CardinalityEstimation) {
+        // TODO implement optimization logic
+        todo!()
     }
 
     pub fn iter_filtered_points<'a>(
@@ -375,12 +381,15 @@ impl StructPayloadIndex {
         if query_cardinality.primary_clauses.is_empty() {
             let full_scan_iterator = id_tracker.iter_ids();
 
+            let struct_filtered_context = self.struct_filtered_context(filter, hw_counter);
             // Worst case: query expected to return few matches, but index can't be used
             let matched_points =
                 full_scan_iterator.filter(move |i| struct_filtered_context.check(*i));
 
             Either::Left(matched_points)
         } else {
+            let struct_filtered_context = self.struct_filtered_context(filter, hw_counter);
+
             // CPU-optimized strategy here: points are made unique before applying other filters.
             let mut visited_list = self.visited_pool.get(id_tracker.total_point_count());
 
@@ -404,36 +413,6 @@ impl StructPayloadIndex {
         }
     }
 
-    /// Select which type of PayloadIndex to use for the field
-    fn selector(&self, payload_schema: &PayloadFieldSchema) -> IndexSelector {
-        let is_on_disk = payload_schema.is_on_disk();
-
-        match &self.storage_type {
-            StorageType::Appendable(db) => IndexSelector::RocksDb(IndexSelectorRocksDb {
-                db,
-                is_appendable: true,
-            }),
-            StorageType::NonAppendableRocksDb(db) => {
-                // legacy logic: we keep rocksdb, but load mmap indexes
-                if is_on_disk {
-                    IndexSelector::Mmap(IndexSelectorMmap {
-                        dir: &self.path,
-                        is_on_disk,
-                    })
-                } else {
-                    IndexSelector::RocksDb(IndexSelectorRocksDb {
-                        db,
-                        is_appendable: false,
-                    })
-                }
-            }
-            StorageType::NonAppendable => IndexSelector::Mmap(IndexSelectorMmap {
-                dir: &self.path,
-                is_on_disk,
-            }),
-        }
-    }
-
     pub fn get_facet_index(&self, key: &JsonPath) -> OperationResult<FacetIndexEnum> {
         self.field_indexes
             .get(key)
@@ -478,7 +457,7 @@ impl PayloadIndex for StructPayloadIndex {
         self.config.indexed_fields.clone()
     }
 
-    fn build_index(
+    fn set_indexed(
         &self,
         field: PayloadKeyTypeRef,
         payload_schema: &PayloadFieldSchema,
@@ -514,6 +493,7 @@ impl PayloadIndex for StructPayloadIndex {
 
     fn drop_index(&mut self, field: PayloadKeyTypeRef) -> OperationResult<()> {
         self.config.indexed_fields.remove(field);
+        self.save_config()?;
         let removed_indexes = self.field_indexes.remove(field);
 
         if let Some(indexes) = removed_indexes {
@@ -522,10 +502,28 @@ impl PayloadIndex for StructPayloadIndex {
             }
         }
 
-        self.save_config()?;
         Ok(())
     }
 
+    fn build_index(
+        &self,
+        field: PayloadKeyTypeRef,
+        payload_schema: &PayloadFieldSchema,
+        hw_counter: &HardwareCounterCell,
+    ) -> OperationResult<Option<Vec<FieldIndex>>> {
+        if let Some(prev_schema) = self.config.indexed_fields.get(field) {
+            // the field is already indexed with the same schema
+            // no need to rebuild index and to save the config
+            if prev_schema == payload_schema {
+                return Ok(None);
+            }
+        }
+
+        let indexes = self.build_field_indexes(field, payload_schema, hw_counter)?;
+
+        Ok(Some(indexes))
+    }
+
     fn estimate_cardinality(
         &self,
         query: &Filter,
@@ -592,14 +590,19 @@ impl PayloadIndex for StructPayloadIndex {
             None => Box::new(vec![].into_iter()),
             Some(indexes) => {
                 let field_clone = field.to_owned();
-                Box::new(indexes.iter().flat_map(move |field_index| {
-                    field_index.payload_blocks(threshold, field_clone.clone())
-                }))
+                Box::new(
+                    indexes
+                        .iter()
+                        .map(move |field_index| {
+                            field_index.payload_blocks(threshold, field_clone.clone())
+                        })
+                        .flatten(),
+                )
             }
         }
     }
 
-    fn overwrite_payload(
+    fn assign_all(
         &mut self,
         point_id: PointOffsetType,
         payload: &Payload,
@@ -723,27 +726,6 @@ impl PayloadIndex for StructPayloadIndex {
         })
     }
 
-    fn infer_payload_type(
-        &self,
-        key: PayloadKeyTypeRef,
-        hw_counter: &HardwareCounterCell,
-    ) -> OperationResult<Option<PayloadSchemaType>> {
-        let mut schema = None;
-        self.payload.borrow().iter(
-            |_id, payload: &Payload| {
-                let field_value = payload.get_value(key);
-                schema = match field_value.as_slice() {
-                    [] => None,
-                    [single] => infer_value_type(single),
-                    multiple => infer_collection_value_type(multiple.iter().copied()),
-                };
-                Ok(false)
-            },
-            hw_counter,
-        )?;
-        Ok(schema)
-    }
-
     fn take_database_snapshot(&self, path: &Path) -> OperationResult<()> {
         match &self.storage_type {
             StorageType::Appendable(db) => {
@@ -767,4 +749,39 @@ impl PayloadIndex for StructPayloadIndex {
         files.push(self.config_path());
         files
     }
-}
\ No newline at end of file
+
+    fn infer_payload_type(
+        &self,
+        key: PayloadKeyTypeRef,
+        hw_counter: &HardwareCounterCell,
+    ) -> OperationResult<Option<PayloadSchemaType>> {
+        let mut schema = None;
+        self.payload.borrow().iter(
+            |_id, payload: &Payload| {
+                let field_value = payload.get_value(key);
+                schema = match field_value.as_slice() {
+                    [] => None,
+                    [single] => infer_value_type(single),
+                    multiple => infer_collection_value_type(multiple.iter().copied()),
+                };
+                Ok(false)
+            },
+            hw_counter,
+        )?;
+        Ok(schema)
+    }
+
+    fn get_telemetry_data(&self) -> Vec<PayloadIndexTelemetry> {
+        self.field_indexes
+            .iter()
+            .flat_map(|(name, field)| -> Vec<PayloadIndexTelemetry> {
+                field
+                    .iter()
+                    .map(|field| field.get_telemetry_data().set_name(name.to_string()))
+                    .collect()
+            })
+            .collect()
+    }
+}
+
+// Continuation with possible impl for FacetIndexEnum or other types if needed, but based on commits, this is the state. In the last commit, there are no further additions beyond the file changes shown.
\ No newline at end of file
