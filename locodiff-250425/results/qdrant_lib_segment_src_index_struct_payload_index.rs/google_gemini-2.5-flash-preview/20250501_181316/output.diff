--- qdrant_lib_segment_src_index_struct_payload_index.rs_expectedoutput.txt (expected)+++ qdrant_lib_segment_src_index_struct_payload_index.rs_extracted.txt (actual)@@ -17,7 +17,9 @@ 
 use super::field_index::FieldIndexBuilderTrait as _;
 use super::field_index::facet_index::FacetIndexEnum;
-use super::field_index::index_selector::{IndexSelector, IndexSelectorMmap, IndexSelectorRocksDb};
+use super::field_index::index_selector::{
+    IndexSelector, IndexSelectorMmap, IndexSelectorRocksDb,
+};
 use crate::common::Flusher;
 use crate::common::operation_error::{OperationError, OperationResult};
 use crate::common::rocksdb_wrapper::open_db_with_existing_cf;
@@ -27,7 +29,6 @@ use crate::index::field_index::{
     CardinalityEstimation, FieldIndex, PayloadBlockCondition, PrimaryCondition,
 };
-use crate::index::payload_config::PayloadConfig;
 use crate::index::query_estimator::estimate_filter;
 use crate::index::query_optimization::payload_provider::PayloadProvider;
 use crate::index::struct_filter_context::StructFilterContext;
@@ -37,9 +38,9 @@ use crate::payload_storage::{FilterContext, PayloadStorage};
 use crate::telemetry::PayloadIndexTelemetry;
 use crate::types::{
-    Condition, FieldCondition, Filter, IsEmptyCondition, IsNullCondition, Payload,
-    PayloadContainer, PayloadFieldSchema, PayloadKeyType, PayloadKeyTypeRef, PayloadSchemaType,
-    VectorNameBuf, infer_collection_value_type, infer_value_type,
+    infer_collection_value_type, infer_value_type, Condition, FieldCondition, Filter,
+    IsEmptyCondition, IsNullCondition, Payload, PayloadContainer, PayloadField, PayloadFieldSchema,
+    PayloadKeyType, PayloadKeyTypeRef, PayloadSchemaType, VectorNameBuf,
 };
 use crate::vector_storage::{VectorStorage, VectorStorageEnum};
 
@@ -70,93 +71,9 @@ }
 
 impl StructPayloadIndex {
-    pub fn estimate_field_condition(
-        &self,
-        condition: &FieldCondition,
-        nested_path: Option<&JsonPath>,
-        hw_counter: &HardwareCounterCell,
-    ) -> Option<CardinalityEstimation> {
-        let full_path = JsonPath::extend_or_new(nested_path, &condition.key);
-        self.field_indexes.get(&full_path).and_then(|indexes| {
-            // rewrite condition with fullpath to enable cardinality estimation
-            let full_path_condition = FieldCondition {
-                key: full_path,
-                ..condition.clone()
-            };
-
-            indexes
-                .iter()
-                .find_map(|index| index.estimate_cardinality(&full_path_condition, hw_counter))
-        })
-    }
-
-    fn query_field<'a>(
-        &'a self,
-        condition: &'a PrimaryCondition,
-        hw_counter: &'a HardwareCounterCell,
-    ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + 'a>> {
-        match condition {
-            PrimaryCondition::Condition(field_condition) => {
-                let field_key = &field_condition.key;
-                let field_indexes = self.field_indexes.get(field_key)?;
-                field_indexes
-                    .iter()
-                    .find_map(|field_index| field_index.filter(field_condition, hw_counter))
-            }
-            PrimaryCondition::Ids(ids) => Some(Box::new(ids.iter().copied())),
-            PrimaryCondition::HasVector(_) => None,
-        }
-    }
-
-    fn config_path(&self) -> PathBuf {
-        PayloadConfig::get_config_path(&self.path)
-    }
-
-    fn save_config(&self) -> OperationResult<()> {
-        let config_path = self.config_path();
-        self.config.save(&config_path)
-    }
-
-    fn load_all_fields(&mut self) -> OperationResult<()> {
-        let mut field_indexes: IndexesMap = Default::default();
-
-        for (field, payload_schema) in &self.config.indexed_fields {
-            let field_index = self.load_from_db(field, payload_schema)?;
-            field_indexes.insert(field.clone(), field_index);
-        }
-        self.field_indexes = field_indexes;
-        Ok(())
-    }
-
-    fn load_from_db(
-        &self,
-        field: PayloadKeyTypeRef,
-        payload_schema: &PayloadFieldSchema,
-    ) -> OperationResult<Vec<FieldIndex>> {
-        let mut indexes = self
-            .selector(payload_schema)
-            .new_index(field, payload_schema)?;
-
-        let mut is_loaded = true;
-        for ref mut index in indexes.iter_mut() {
-            if !index.load()? {
-                is_loaded = false;
-                break;
-            }
-        }
-        if !is_loaded {
-            debug!("Index for `{field}` was not loaded. Building...");
-            // todo(ivan): decide what to do with indexes, which were not loaded
-            indexes = self.build_field_indexes(
-                field,
-                payload_schema,
-                &HardwareCounterCell::disposable(), // Internal operation.
-            )?;
-        }
-
-        Ok(indexes)
-    }
-
+    /// Open a payload index at the given path.
+    /// If the path does not exist, a new index is created.
+    #[allow(clippy::too_many_arguments)]
     pub fn open(
         payload: Arc<AtomicRefCell<PayloadStorageEnum>>,
         id_tracker: Arc<AtomicRefCell<IdTrackerSS>>,
@@ -213,195 +130,47 @@         Ok(index)
     }
 
-    pub fn build_field_indexes(
+    fn save_config(&self) -> OperationResult<()> {
+        let config_path = PayloadConfig::get_config_path(&self.path);
+        self.config.save(&config_path)
+    }
+
+    fn load_all_fields(&mut self) -> OperationResult<()> {
+        let mut field_indexes: IndexesMap = Default::default();
+
+        for (field, payload_schema) in &self.config.indexed_fields {
+            let field_index = self.load_from_db(field, payload_schema)?;
+            field_indexes.insert(field.clone(), field_index);
+        }
+        self.field_indexes = field_indexes;
+        Ok(())
+    }
+
+    fn load_from_db(
         &self,
         field: PayloadKeyTypeRef,
         payload_schema: &PayloadFieldSchema,
-        hw_counter: &HardwareCounterCell,
     ) -> OperationResult<Vec<FieldIndex>> {
-        let payload_storage = self.payload.borrow();
-        let mut builders = self
-            .selector(payload_schema)
-            .index_builder(field, payload_schema)?;
-
-        for index in &mut builders {
-            index.init()?;
-        }
-
-        payload_storage.iter(
-            |point_id, point_payload| {
-                let field_value = &point_payload.get_value(field);
-                for builder in builders.iter_mut() {
-                    builder.add_point(point_id, field_value, hw_counter)?;
-                }
-                Ok(true)
-            },
-            hw_counter,
-        )?;
-
-        builders
-            .into_iter()
-            .map(|builder| builder.finalize())
-            .collect()
-    }
-
-    /// Number of available points
-    ///
-    /// - excludes soft deleted points
-    pub fn available_point_count(&self) -> usize {
-        self.id_tracker.borrow().available_point_count()
-    }
-
-    pub fn struct_filtered_context<'a>(
-        &'a self,
-        filter: &'a Filter,
-        hw_counter: &HardwareCounterCell,
-    ) -> StructFilterContext<'a> {
-        let payload_provider = PayloadProvider::new(self.payload.clone());
-
-        let (optimized_filter, _) = self.optimize_filter(
-            filter,
-            payload_provider,
-            self.available_point_count(),
-            hw_counter,
-        );
-
-        StructFilterContext::new(optimized_filter)
-    }
-
-    pub(super) fn condition_cardinality(
-        &self,
-        condition: &Condition,
-        nested_path: Option<&JsonPath>,
-        hw_counter: &HardwareCounterCell,
-    ) -> CardinalityEstimation {
-        match condition {
-            Condition::Filter(_) => panic!("Unexpected branching"),
-            Condition::Nested(nested) => {
-                // propagate complete nested path in case of multiple nested layers
-                let full_path = JsonPath::extend_or_new(nested_path, &nested.array_key());
-                self.estimate_nested_cardinality(nested.filter(), &full_path, hw_counter)
-            }
-            Condition::IsEmpty(IsEmptyCondition { is_empty: field }) => {
-                let available_points = self.available_point_count();
-                let condition = FieldCondition::new_is_empty(field.key.clone());
-
-                self.estimate_field_condition(&condition, nested_path, hw_counter)
-                    .unwrap_or_else(|| CardinalityEstimation::unknown(available_points))
-            }
-            Condition::IsNull(IsNullCondition { is_null: field }) => {
-                let available_points = self.available_point_count();
-                let condition = FieldCondition::new_is_null(field.key.clone());
-
-                self.estimate_field_condition(&condition, nested_path, hw_counter)
-                    .unwrap_or_else(|| CardinalityEstimation::unknown(available_points))
-            }
-            Condition::HasId(has_id) => {
-                let id_tracker_ref = self.id_tracker.borrow();
-                let mapped_ids: AHashSet<PointOffsetType> = has_id
-                    .has_id
-                    .iter()
-                    .filter_map(|external_id| id_tracker_ref.internal_id(*external_id))
-                    .collect();
-                let num_ids = mapped_ids.len();
-                CardinalityEstimation {
-                    primary_clauses: vec![PrimaryCondition::Ids(mapped_ids)],
-                    min: num_ids,
-                    exp: num_ids,
-                    max: num_ids,
-                }
-            }
-            Condition::HasVector(has_vectors) => {
-                if let Some(vector_storage) = self.vector_storages.get(&has_vectors.has_vector) {
-                    let vector_storage = vector_storage.borrow();
-                    let vectors = vector_storage.available_vector_count();
-                    CardinalityEstimation::exact(vectors).with_primary_clause(
-                        PrimaryCondition::HasVector(has_vectors.has_vector.clone()),
-                    )
-                } else {
-                    CardinalityEstimation::exact(0)
-                }
-            }
-            Condition::Field(field_condition) => self
-                .estimate_field_condition(field_condition, nested_path, hw_counter)
-                .unwrap_or_else(|| CardinalityEstimation::unknown(self.available_point_count())),
-
-            Condition::CustomIdChecker(cond) => {
-                cond.estimate_cardinality(self.id_tracker.borrow().available_point_count())
-            }
-        }
-    }
-
-    pub fn get_telemetry_data(&self) -> Vec<PayloadIndexTelemetry> {
-        self.field_indexes
-            .iter()
-            .flat_map(|(name, field)| -> Vec<PayloadIndexTelemetry> {
-                field
-                    .iter()
-                    .map(|field| field.get_telemetry_data().set_name(name.to_string()))
-                    .collect()
-            })
-            .collect()
-    }
-
-    pub fn restore_database_snapshot(
-        snapshot_path: &Path,
-        segment_path: &Path,
-    ) -> OperationResult<()> {
-        crate::rocksdb_backup::restore(snapshot_path, &segment_path.join("payload_index"))
-    }
-
-    fn clear_index_for_point(&mut self, point_id: PointOffsetType) -> OperationResult<()> {
-        for (_, field_indexes) in self.field_indexes.iter_mut() {
-            for index in field_indexes {
-                index.remove_point(point_id)?;
-            }
-        }
-        Ok(())
-    }
-    pub fn config(&self) -> &PayloadConfig {
-        &self.config
-    }
-
-    pub fn iter_filtered_points<'a>(
-        &'a self,
-        filter: &'a Filter,
-        id_tracker: &'a IdTrackerSS,
-        query_cardinality: &'a CardinalityEstimation,
-        hw_counter: &'a HardwareCounterCell,
-    ) -> impl Iterator<Item = PointOffsetType> + 'a {
-        let struct_filtered_context = self.struct_filtered_context(filter, hw_counter);
-
-        if query_cardinality.primary_clauses.is_empty() {
-            let full_scan_iterator = id_tracker.iter_ids();
-
-            // Worst case: query expected to return few matches, but index can't be used
-            let matched_points =
-                full_scan_iterator.filter(move |i| struct_filtered_context.check(*i));
-
-            Either::Left(matched_points)
-        } else {
-            // CPU-optimized strategy here: points are made unique before applying other filters.
-            let mut visited_list = self.visited_pool.get(id_tracker.total_point_count());
-
-            let iter = query_cardinality
-                .primary_clauses
-                .iter()
-                .flat_map(move |clause| {
-                    self.query_field(clause, hw_counter).unwrap_or_else(|| {
-                        // index is not built
-                        Box::new(id_tracker.iter_ids().measure_hw_with_cell(
-                            hw_counter,
-                            size_of::<PointOffsetType>(),
-                            |i| i.cpu_counter(),
-                        ))
-                    })
-                })
-                .filter(move |&id| !visited_list.check_and_update_visited(id))
-                .filter(move |&i| struct_filtered_context.check(i));
-
-            Either::Right(iter)
-        }
+        let mut indexes = self.selector(payload_schema).new_index(field, payload_schema)?;
+
+        let mut is_loaded = true;
+        for index in indexes.iter_mut() {
+            if !index.load()? {
+                is_loaded = false;
+                break;
+            }
+        }
+        if !is_loaded {
+            debug!("Index for `{field}` was not loaded. Building...");
+            // todo(ivan): decide what to do with indexes, which were not loaded
+            indexes = self.build_field_indexes(
+                field,
+                payload_schema,
+                &HardwareCounterCell::disposable(), // Internal operation.
+            )?;
+        }
+
+        Ok(indexes)
     }
 
     /// Select which type of PayloadIndex to use for the field
@@ -434,11 +203,224 @@         }
     }
 
+    pub fn build_field_indexes(
+        &self,
+        field: PayloadKeyTypeRef,
+        payload_schema: &PayloadFieldSchema,
+        hw_counter: &HardwareCounterCell,
+    ) -> OperationResult<Vec<FieldIndex>> {
+        let payload_storage = self.payload.borrow();
+        let mut builders = self
+            .selector(payload_schema)
+            .index_builder(field, payload_schema)?;
+
+        for builder in &mut builders {
+            builder.init()?;
+        }
+
+        payload_storage.iter(
+            |point_id, point_payload| {
+                let field_value = &point_payload.get_value(field);
+                for builder in builders.iter_mut() {
+                    builder.add_point(point_id, field_value, hw_counter)?;
+                }
+                Ok(true)
+            },
+            hw_counter,
+        )?;
+
+        builders
+            .into_iter()
+            .map(|builder| builder.finalize())
+            .collect()
+    }
+
+    /// Number of available points
+    ///
+    /// - excludes soft deleted points
+    pub fn available_point_count(&self) -> usize {
+        self.id_tracker.borrow().available_point_count()
+    }
+
+    pub fn struct_filtered_context<'a>(
+        &'a self,
+        filter: &'a Filter,
+        hw_counter: &HardwareCounterCell,
+    ) -> StructFilterContext<'a> {
+        let payload_provider = PayloadProvider::new(self.payload.clone());
+
+        let (optimized_filter, _) = self.optimize_filter(
+            filter,
+            payload_provider,
+            self.available_point_count(),
+            hw_counter,
+        );
+
+        StructFilterContext::new(optimized_filter)
+    }
+
+    /// Check if payload of point satisfies condition
+    pub(super) fn check_condition(
+        &self,
+        point_id: PointOffsetType,
+        condition: &Condition,
+        hw_counter: &HardwareCounterCell,
+    ) -> OperationResult<bool> {
+        let payload = self.payload.borrow();
+        payload.check(point_id, condition, hw_counter)
+    }
+
+    /// Cardinality estimation with concrete condition, with nested available in nested_path
+    pub(super) fn condition_cardinality(
+        &self,
+        condition: &Condition,
+        nested_path: Option<&JsonPath>,
+        hw_counter: &HardwareCounterCell,
+    ) -> CardinalityEstimation {
+        match condition {
+            Condition::Filter(_) => panic!("Unexpected branching"),
+            Condition::Nested(nested) => {
+                // propagate complete nested path in case of multiple nested layers
+                let full_path = JsonPath::extend_or_new(nested_path, &nested.array_key());
+                self.estimate_nested_cardinality(nested.filter(), &full_path, hw_counter)
+            }
+            Condition::IsEmpty(IsEmptyCondition { is_empty: field }) => {
+                let available_points = self.available_point_count();
+                let condition = FieldCondition::new_is_empty(field.key.clone());
+
+                self.estimate_field_condition(&condition, nested_path, hw_counter)
+                    .unwrap_or_else(|| CardinalityEstimation::unknown(available_points))
+            }
+            Condition::IsNull(IsNullCondition { is_null: field }) => {
+                let available_points = self.available_point_count();
+                let condition = FieldCondition::new_is_null(field.key.clone());
+
+                self.estimate_field_condition(&condition, nested_path, hw_counter)
+                    .unwrap_or_else(|| CardinalityEstimation::unknown(available_points))
+            }
+            Condition::HasId(has_id) => {
+                let id_tracker_ref = self.id_tracker.borrow();
+                let mapped_ids: AHashSet<PointOffsetType> = has_id
+                    .has_id
+                    .iter()
+                    .filter_map(|external_id| id_tracker_ref.internal_id(*external_id))
+                    .collect();
+                let num_ids = mapped_ids.len();
+                CardinalityEstimation {
+                    primary_clauses: vec![PrimaryCondition::Ids(mapped_ids)],
+                    min: num_ids,
+                    exp: num_ids,
+                    max: num_ids,
+                }
+            }
+            Condition::HasVector(has_vectors) => {
+                if let Some(vector_storage) = self.vector_storages.get(&has_vectors.has_vector) {
+                    let vector_storage = vector_storage.borrow();
+                    let vectors = vector_storage.available_vector_count();
+                    CardinalityEstimation::exact(vectors).with_primary_clause(
+                        PrimaryCondition::HasVector(has_vectors.has_vector.clone()),
+                    )
+                } else {
+                    CardinalityEstimation::exact(0)
+                }
+            }
+            Condition::Field(field_condition) => self
+                .estimate_field_condition(field_condition, nested_path, hw_counter)
+                .unwrap_or_else(|| CardinalityEstimation::unknown(self.available_point_count())),
+
+            Condition::CustomIdChecker(cond) => {
+                cond.estimate_cardinality(self.id_tracker.borrow().available_point_count())
+            }
+        }
+    }
+
+    fn query_field<'a>(
+        &'a self,
+        condition: &'a PrimaryCondition,
+        hw_counter: &'a HardwareCounterCell,
+    ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + 'a>> {
+        match condition {
+            PrimaryCondition::Condition(field_condition) => {
+                let field_key = &field_condition.key;
+                let field_indexes = self.field_indexes.get(field_key)?;
+                field_indexes
+                    .iter()
+                    .find_map(|field_index| field_index.filter(field_condition, hw_counter))
+            }
+            PrimaryCondition::Ids(ids) => Some(Box::new(ids.iter().copied())),
+            PrimaryCondition::HasVector(_) => None,
+        }
+    }
+
+    pub fn optimize_filter<'a>(
+        &'a self,
+        filter: &'a Filter,
+        payload_provider: PayloadProvider<'a>,
+        available_points: usize,
+        hw_counter: &HardwareCounterCell,
+    ) -> (OptimizedFilter<'a>, CardinalityEstimation) {
+        let estimator =
+            |condition: &Condition| self.condition_cardinality(condition, None, hw_counter);
+        optimize_filter(
+            filter,
+            &estimator,
+            payload_provider,
+            available_points,
+            hw_counter,
+        )
+    }
+
+    pub fn iter_filtered_points<'a>(
+        &'a self,
+        filter: &'a Filter,
+        id_tracker: &'a IdTrackerSS,
+        query_cardinality: &'a CardinalityEstimation,
+        hw_counter: &'a HardwareCounterCell,
+    ) -> impl Iterator<Item = PointOffsetType> + 'a {
+        let struct_filtered_context = self.struct_filtered_context(filter, hw_counter);
+
+        if query_cardinality.primary_clauses.is_empty() {
+            let full_scan_iterator = id_tracker.iter_ids();
+
+            // Worst case: query expected to return few matches, but index can't be used
+            let matched_points =
+                full_scan_iterator.filter(move |i| struct_filtered_context.check(*i));
+
+            Either::Left(matched_points)
+        } else {
+            // CPU-optimized strategy here: points are made unique before applying other filters.
+            let mut visited_list = self.visited_pool.get(id_tracker.total_point_count());
+
+            let iter = query_cardinality
+                .primary_clauses
+                .iter()
+                .flat_map(move |clause| {
+                    self.query_field(clause, hw_counter)
+                        .unwrap_or_else(|| {
+                            // index is not built
+                            Box::new(id_tracker.iter_ids().measure_hw_with_cell(
+                                hw_counter,
+                                std::mem::size_of::<PointOffsetType>(),
+                                |i| i.cpu_counter(),
+                            ))
+                        })
+                })
+                .filter(move |&id| !visited_list.check_and_update_visited(id))
+                .filter(move |&i| struct_filtered_context.check(i));
+
+            Either::Right(iter)
+        }
+    }
+
+    pub fn config(&self) -> &PayloadConfig {
+        &self.config
+    }
+
     pub fn get_facet_index(&self, key: &JsonPath) -> OperationResult<FacetIndexEnum> {
         self.field_indexes
             .get(key)
             .and_then(|index| index.iter().find_map(|index| index.as_facet_index()))
-            .ok_or_else(|| OperationError::MissingMapIndexForFacet {
+            .ok_or(OperationError::MissingMapIndexForFacet {
                 key: key.to_string(),
             })
     }
@@ -587,14 +569,14 @@         &self,
         field: PayloadKeyTypeRef,
         threshold: usize,
-    ) -> Box<dyn Iterator<Item = PayloadBlockCondition> + '_> {
+    ) -> Vec<PayloadBlockCondition> {
         match self.field_indexes.get(field) {
-            None => Box::new(vec![].into_iter()),
+            None => vec![],
             Some(indexes) => {
                 let field_clone = field.to_owned();
-                Box::new(indexes.iter().flat_map(move |field_index| {
-                    field_index.payload_blocks(threshold, field_clone.clone())
-                }))
+                indexes.iter().flat_map(|index| {
+                    index.payload_blocks(threshold, field_clone.clone())
+                }).collect()
             }
         }
     }
@@ -605,10 +587,9 @@         payload: &Payload,
         hw_counter: &HardwareCounterCell,
     ) -> OperationResult<()> {
-        self.payload
-            .borrow_mut()
-            .overwrite(point_id, payload, hw_counter)?;
-
+        self.payload.borrow_mut().overwrite(point_id, payload, hw_counter)?;
+
+        // TODO(io_measurement): Maybe add measurements to index here too.
         for (field, field_index) in &mut self.field_indexes {
             let field_value = payload.get_value(field);
             if !field_value.is_empty() {
@@ -643,7 +624,7 @@ 
         let updated_payload = self.get_payload(point_id, hw_counter)?;
         for (field, field_index) in &mut self.field_indexes {
-            if !field.is_affected_by_value_set(&payload.0, key.as_ref()) {
+            if !field.is_affected_by_value_set(&payload.0, key.as_ref()) { // check if the field value in the payload has changed
                 continue;
             }
             let field_value = updated_payload.get_value(field);
@@ -737,34 +718,4 @@                     [single] => infer_value_type(single),
                     multiple => infer_collection_value_type(multiple.iter().copied()),
                 };
-                Ok(false)
-            },
-            hw_counter,
-        )?;
-        Ok(schema)
-    }
-
-    fn take_database_snapshot(&self, path: &Path) -> OperationResult<()> {
-        match &self.storage_type {
-            StorageType::Appendable(db) => {
-                let db_guard = db.read();
-                crate::rocksdb_backup::create(&db_guard, path)
-            }
-            StorageType::NonAppendableRocksDb(db) => {
-                let db_guard = db.read();
-                crate::rocksdb_backup::create(&db_guard, path)
-            }
-            StorageType::NonAppendable => Ok(()),
-        }
-    }
-
-    fn files(&self) -> Vec<PathBuf> {
-        let mut files = self
-            .field_indexes
-            .values()
-            .flat_map(|indexes| indexes.iter().flat_map(|index| index.files().into_iter()))
-            .collect::<Vec<PathBuf>>();
-        files.push(self.config_path());
-        files
-    }
-}+                Ok(false)