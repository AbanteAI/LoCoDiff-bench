--- tldraw_apps_dotcom_sync-worker_src_TLUserDurableObject.ts_expectedoutput.txt (expected)+++ tldraw_apps_dotcom_sync-worker_src_TLUserDurableObject.ts_extracted.txt (actual)@@ -91,6 +91,59 @@ 		})
 		.get(`/app/:userId/connect`, (req) => this.onRequest(req))
 
+	private assertCache(): asserts this is { cache: UserDataSyncer } {
+		assert(this.cache, 'no cache')
+	}
+
+	interval: NodeJS.Timeout | null = null
+
+	private maybeStartInterval() {
+		if (!this.interval) {
+			this.interval = setInterval(() => {
+				// do cache persist + cleanup
+				this.cache?.onInterval()
+
+				// clean up closed sockets if there are any
+				for (const socket of this.sockets) {
+					if (socket.readyState === WebSocket.CLOSED || socket.readyState === WebSocket.CLOSING) {
+						this.sockets.delete(socket)
+					}
+				}
+
+				if (this.sockets.size === 0 && typeof this.interval === 'number') {
+					clearInterval(this.interval)
+					this.interval = null
+				}
+			}, 2000)
+		}
+	}
+
+	private readonly sockets = new Set<WebSocket>()
+	private readonly messageQueue = new ExecutionQueue()
+
+	maybeReportColdStartTime(type: ZServerSentMessage['type']) {
+		if (type !== 'initial_data' || !this.coldStartStartTime) return
+		const time = Date.now() - this.coldStartStartTime
+		this.coldStartStartTime = null
+		this.logEvent({ type: 'cold_start_time', id: this.userId!, duration: time })
+	}
+
+	broadcast(message: ZServerSentMessage) {
+		this.logEvent({ type: 'broadcast_message', id: this.userId! })
+		this.maybeReportColdStartTime(message.type)
+		const msg = JSON.stringify(message)
+		for (const socket of this.sockets) {
+			if (socket.readyState === WebSocket.OPEN) {
+				socket.send(msg)
+			} else if (
+				socket.readyState === WebSocket.CLOSED ||
+				socket.readyState === WebSocket.CLOSING
+			) {
+				this.sockets.delete(socket)
+			}
+		}
+	}
+
 	// Handle a request to the Durable Object.
 	override async fetch(req: IRequest) {
 		const sentry = createSentry(this.ctx, this.env, req)
@@ -112,59 +165,6 @@ 		}
 	}
 
-	private assertCache(): asserts this is { cache: UserDataSyncer } {
-		assert(this.cache, 'no cache')
-	}
-
-	interval: NodeJS.Timeout | null = null
-
-	private maybeStartInterval() {
-		if (!this.interval) {
-			this.interval = setInterval(() => {
-				// do cache persist + cleanup
-				this.cache?.onInterval()
-
-				// clean up closed sockets if there are any
-				for (const socket of this.sockets) {
-					if (socket.readyState === WebSocket.CLOSED || socket.readyState === WebSocket.CLOSING) {
-						this.sockets.delete(socket)
-					}
-				}
-
-				if (this.sockets.size === 0 && typeof this.interval === 'number') {
-					clearInterval(this.interval)
-					this.interval = null
-				}
-			}, 2000)
-		}
-	}
-
-	private readonly sockets = new Set<WebSocket>()
-
-	maybeReportColdStartTime(type: ZServerSentMessage['type']) {
-		if (type !== 'initial_data' || !this.coldStartStartTime) return
-		const time = Date.now() - this.coldStartStartTime
-		this.coldStartStartTime = null
-		this.logEvent({ type: 'cold_start_time', id: this.userId!, duration: time })
-	}
-
-	broadcast(message: ZServerSentMessage) {
-		this.logEvent({ type: 'broadcast_message', id: this.userId! })
-		this.maybeReportColdStartTime(message.type)
-		const msg = JSON.stringify(message)
-		for (const socket of this.sockets) {
-			if (socket.readyState === WebSocket.OPEN) {
-				socket.send(msg)
-			} else if (
-				socket.readyState === WebSocket.CLOSED ||
-				socket.readyState === WebSocket.CLOSING
-			) {
-				this.sockets.delete(socket)
-			}
-		}
-	}
-	private readonly messageQueue = new ExecutionQueue()
-
 	async onRequest(req: IRequest) {
 		assert(this.userId, 'User ID not set')
 		// handle legacy param names
@@ -217,6 +217,17 @@ 		}
 
 		return new Response(null, { status: 101, webSocket: clientWebSocket })
+	}
+
+	private debug(...args: any[]) {
+		// uncomment for dev time debugging
+		// console.log('[TLUserDurableObject]: ', ...args)
+		if (this.sentry) {
+			// eslint-disable-next-line @typescript-eslint/no-deprecated
+			this.sentry.addBreadcrumb({
+				message: `[TLUserDurableObject]: ${args.map((a) => (typeof a === 'object' ? JSON.stringify(a) : a)).join(' ')}`,
+			})
+		}
 	}
 
 	private async handleSocketMessage(socket: WebSocket, message: string) {
