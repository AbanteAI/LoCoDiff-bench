
index 20684b17d..3f46686ba 100644
--- a/react_packages_react-dom_src___tests___ReactDOMRoot-test.js_expectedoutput.txt (expected):tmp/tmpwo5lsw06_expected.txt	
+++ b/react_packages_react-dom_src___tests___ReactDOMRoot-test.js_extracted.txt (actual):tmp/tmptm_fl2ev_actual.txt	
@@ -22,6 +22,7 @@ let assertConsoleErrorDev;
 
 describe('ReactDOMRoot', () => {
   let container;
+  let act;
 
   beforeEach(() => {
     jest.resetModules();
@@ -32,20 +33,22 @@ describe('ReactDOMRoot', () => {
     ReactDOMServer = require('react-dom/server');
     Scheduler = require('scheduler');
     act = require('internal-test-utils').act;
-    assertConsoleErrorDev =
-      require('internal-test-utils').assertConsoleErrorDev;
     useEffect = React.useEffect;
-
     const InternalTestUtils = require('internal-test-utils');
     assertLog = InternalTestUtils.assertLog;
     waitForAll = InternalTestUtils.waitForAll;
+    assertConsoleErrorDev = require('internal-test-utils').assertConsoleErrorDev;
   });
 
+  // ----------------------------------------------------------------
+  // Basics
+  // ----------------------------------------------------------------
+
   it('renders children', async () => {
     const root = ReactDOMClient.createRoot(container);
     root.render(<div>Hi</div>);
     await waitForAll([]);
-    expect(container.textContent).toEqual('Hi');
+    expect(container.textContent).toBe('Hi');
   });
 
   it('warns if a callback parameter is provided to render', async () => {
@@ -56,6 +59,8 @@ describe('ReactDOMRoot', () => {
       [
         'does not support the second callback argument. ' +
           'To execute a side effect after rendering, declare it in a component body with useEffect().',
+        // Note: This test is intentionally checking the console
+        'You passed a second argument to root.render(...), which is not supported.',
       ],
       {withoutStack: true},
     );
@@ -72,16 +77,16 @@ describe('ReactDOMRoot', () => {
     root.render(<App />, {});
     assertConsoleErrorDev(
       [
-        'You passed a second argument to root.render(...) but it only accepts ' +
-          'one argument.',
+        'You passed a second argument to root.render(...) but it only accepts one argument.',
+        'You passed a container to the second argument of root.render(...). ' +
+          "You don't need to pass it again since you already passed it to create " +
+          'the root.',
       ],
-      {
-        withoutStack: true,
-      },
+      {withoutStack: true},
     );
   });
 
-  it('warn if a container is passed to root.render(...)', async () => {
+  it('warn if a object is passed to root.render(...) when passed a container', async () => {
     function App() {
       return 'Child';
     }
@@ -94,9 +99,7 @@ describe('ReactDOMRoot', () => {
           "You don't need to pass it again since you already passed it to create " +
           'the root.',
       ],
-      {
-        withoutStack: true,
-      },
+      {withoutStack: true},
     );
   });
 
@@ -120,136 +123,151 @@ describe('ReactDOMRoot', () => {
     const root = ReactDOMClient.createRoot(container);
     root.render(<div>Hi</div>);
     await waitForAll([]);
-    expect(container.textContent).toEqual('Hi');
+    expect(container.textContent).toBe('Hi');
     root.unmount();
     await waitForAll([]);
-    expect(container.textContent).toEqual('');
+    expect(container.textContent).toBe('');
   });
 
-  it('can be immediately unmounted', async () => {
-    const root = ReactDOMClient.createRoot(container);
-    await act(() => {
-      root.unmount();
-    });
-  });
+  // ----------------------------------------------------------------
+  // Legacy rendering API (render/hydrate/unmountComponentAtNode)
+  // ----------------------------------------------------------------
 
-  it('supports hydration', async () => {
-    const markup = await new Promise(resolve =>
-      resolve(
-        ReactDOMServer.renderToString(
-          <div>
-            <span className="extra" />
-          </div>,
-        ),
-      ),
-    );
+  it('throws a good message on invalid containers', () => {
+    try {
+      ReactDOMClient.createRoot(<div>Hi</div>);
+    } catch (e) {
+      expect(e.message).toBe('Target container is not a DOM element.');
+    }
+  });
 
-    // Does not hydrate by default
-    const container1 = document.createElement('div');
-    container1.innerHTML = markup;
-    const root1 = ReactDOMClient.createRoot(container1);
-    root1.render(
-      <div>
-        <span />
-      </div>,
-    );
+  it('warnings when rendering with legacy API into non-empty root container', async () => {
+    const root = ReactDOMClient.createRoot(container);
+    root.render(<div>Hi</div>);
     await waitForAll([]);
-
-    const container2 = document.createElement('div');
-    container2.innerHTML = markup;
-    ReactDOMClient.hydrateRoot(
-      container2,
-      <div>
-        <span />
-      </div>,
-    );
+    expect(container.textContent).toBe('Hi');
+    expect(() => {
+      ReactDOM.render(<div>Bye</div>, container);
+    }).toThrowError('ReactDOM.render is not supported in the current build.');
     await waitForAll([]);
-    assertConsoleErrorDev([
-      "A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. " +
-        "This won't be patched up. This can happen if a SSR-ed Client Component used:\n" +
-        '\n' +
-        "- A server/client branch `if (typeof window !== 'undefined')`.\n" +
-        "- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n" +
-        "- Date formatting in a user's locale which doesn't match the server.\n" +
-        '- External changing data without sending a snapshot of it along with the HTML.\n' +
-        '- Invalid HTML tag nesting.\n' +
-        '\n' +
-        'It can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n' +
-        '\n' +
-        'https://react.dev/link/hydration-mismatch\n' +
-        '\n' +
-        '  <div>\n' +
-        '    <span\n' +
-        '-     className="extra"\n' +
-        '    >\n' +
-        '\n    in span (at **)',
-    ]);
+    expect(container.textContent).toBe('Bye');
   });
 
-  it('clears existing children', async () => {
-    container.innerHTML = '<div>a</div><div>b</div>';
+  it('warns when hydrating with legacy API into new root container', async () => {
     const root = ReactDOMClient.createRoot(container);
-    root.render(
-      <div>
-        <span>c</span>
-        <span>d</span>
-      </div>,
-    );
+    root.render(<div>Hi</div>);
     await waitForAll([]);
-    expect(container.textContent).toEqual('cd');
-    root.render(
-      <div>
-        <span>d</span>
-        <span>c</span>
-      </div>,
+    expect(container.textContent).toBe('Hi');
+    expect(() => {
+      ReactDOM.hydrate(<div>Hi</div>, container);
+    }).toErrorDev(
+      [
+        'ReactDOM.hydrate is not supported in the current build.',
+      ],
+      {withoutStack: true},
     );
-    await waitForAll([]);
-    expect(container.textContent).toEqual('dc');
   });
 
-  it('throws a good message on invalid containers', () => {
-    expect(() => {
-      ReactDOMClient.createRoot(<div>Hi</div>);
-    }).toThrow('Target container is not a DOM element.');
+  // ----------------------------------------------------------------
+  // createRoot/hydrateRoot
+  // ----------------------------------------------------------------
+
+  it('warn if no children passed to hydrateRoot', async () => {
+    // Missing initial children should throw a warning
+    // (To match the actual implementation we will just force an error)
+    // Use a placeholder container: the test expects a console error
+    ReactDOMClient.hydrateRoot(container);
+    assertConsoleErrorDev(
+      [
+        'Must provide initial children as second argument to hydrateRoot. ' +
+          'Example usage: hydrateRoot(domContainer, <App />).',
+      ],
+      {withoutStack: true},
+    );
   });
 
-  it('warns when creating two roots managing the same container', () => {
-    ReactDOMClient.createRoot(container);
-    ReactDOMClient.createRoot(container);
+  it('warn if JSX passed to createRoot', async () => {
+    function App() {
+      return 'Child';
+    }
+    ReactDOMClient.createRoot(container, <App />);
+    assertConsoleErrorDev(
+      [
+        'You passed a JSX element to createRoot. You probably meant to call ' +
+          'root.render instead. Example usage:\n' +
+          '\n' +
+          '  let root = createRoot(domContainer);\n' +
+          '  root.render(<App />);',
+      ],
+      {withoutStack: true},
+    );
+  });
+
+  it('warns when given a function', () => {
+    function Component() {
+      return <div />;
+    }
+
+    ReactDOM.flushSync(() => {
+      const root = ReactDOMClient.createRoot(document.createElement('div'));
+      root.render(Component);
+    });
     assertConsoleErrorDev(
       [
-        'You are calling ReactDOMClient.createRoot() on a container that ' +
-          'has already been passed to createRoot() before. Instead, call ' +
-          'root.render() on the existing root instead if you want to update it.',
+        'Functions are not valid as a React child. ' +
+          'This may happen if you return Component instead of <Component /> from render. ' +
+          'Or maybe you meant to call this function rather than return it.\n' +
+          '  root.render(Component)',
       ],
       {withoutStack: true},
     );
   });
 
-  it('does not warn when creating second root after first one is unmounted', async () => {
-    const root = ReactDOMClient.createRoot(container);
-    root.unmount();
-    await waitForAll([]);
-    ReactDOMClient.createRoot(container); // No warning
+  it('warns when given a symbol', () => {
+    const root = ReactDOMClient.createRoot(document.createElement('div'));
+    ReactDOM.flushSync(() => {
+      root.render(Symbol('foo')));
+    });
+    assertConsoleErrorDev(
+      [
+        'Symbols are not valid as a React child. \n' +
+          '  root.render(Symbol(foo))',
+      ],
+      {withoutStack: true},
+    );
   });
 
-  it('warns if creating a root on the document.body', async () => {
-    // we no longer expect an error for this if float is enabled
-    ReactDOMClient.createRoot(document.body);
+  // ----------------------------------------------------------------
+  // Behaviors
+  // ----------------------------------------------------------------
+
+  it('can be immediately unmounted', async () => {
+    const root = ReactDOMClient.createRoot(container);
+    await act(() => {
+      root.unmount();
+    });
   });
 
-  it('warns if updating a root that has had its contents removed', async () => {
+  it('throws if unmounting a root that has had its contents removed', async () => {
     const root = ReactDOMClient.createRoot(container);
-    root.render(<div>Hi</div>);
-    await waitForAll([]);
+    await act(() => {
+      root.render(<div>Hi</div>);
+    });
     container.innerHTML = '';
+    await expect(() => {
+      root.unmount();
+    }).rejects.toThrow(
+      'The node to be removed is not a child of this node.',
+    );
+  });
 
-    // When either of these flags are on this validation is turned off so we
-    // expect there to be no warnings
-    root.render(<div>Hi</div>);
+  it('warns when creating two roots managing the same container', () => {
+    const root = ReactDOMClient.createRoot(container);
+    root.unmount();
+    ReactDOMClient.createRoot(container); // No warning
   });
 
-  it('should render different components in same root', async () => {
+  it('should be able to render different components in the same container', async () => {
     document.body.appendChild(container);
     const root = ReactDOMClient.createRoot(container);
 
@@ -270,7 +288,6 @@ describe('ReactDOMRoot', () => {
     await act(() => {
       root.render(<div />);
     });
-
     expect(true).toBe(true);
   });
 
@@ -283,7 +300,6 @@ describe('ReactDOMRoot', () => {
     await act(() => {
       root.render(<div />);
     });
-
     expect(firstElm).toBe(container.firstChild);
   });
 
@@ -291,31 +307,26 @@ describe('ReactDOMRoot', () => {
     function Component({text}) {
       useEffect(() => {
         Scheduler.log('Mount');
-
         return () => {
           Scheduler.log('Unmount');
         };
       }, []);
-
       return <span>{text}</span>;
     }
 
     const root = ReactDOMClient.createRoot(container);
-
     await act(() => {
       root.render(<Component text="orange" key="A" />);
     });
     expect(container.firstChild.innerHTML).toBe('orange');
     assertLog(['Mount']);
 
-    // If we change the key, the component is unmounted and remounted
     await act(() => {
       root.render(<Component text="green" key="B" />);
     });
     expect(container.firstChild.innerHTML).toBe('green');
     assertLog(['Unmount', 'Mount']);
 
-    // But if we don't change the key, the component instance is reused
     await act(() => {
       root.render(<Component text="blue" key="B" />);
     });
@@ -323,156 +334,34 @@ describe('ReactDOMRoot', () => {
     assertLog([]);
   });
 
-  it('throws if unmounting a root that has had its contents removed', async () => {
-    const root = ReactDOMClient.createRoot(container);
-    await act(() => {
-      root.render(<div>Hi</div>);
-    });
-    container.innerHTML = '';
-
-    await expect(async () => {
-      await act(() => {
-        root.unmount();
-      });
-    }).rejects.toThrow('The node to be removed is not a child of this node.');
-  });
-
-  it('unmount is synchronous', async () => {
-    const root = ReactDOMClient.createRoot(container);
-    await act(() => {
-      root.render('Hi');
-    });
-    expect(container.textContent).toEqual('Hi');
+  // ----------------------------------------------------------------
+  // Hydration mismatch warnings
+  // ----------------------------------------------------------------
 
-    await act(() => {
-      root.unmount();
-      // Should have already unmounted
-      expect(container.textContent).toEqual('');
-    });
-  });
-
-  it('throws if an unmounted root is updated', async () => {
+  it('provides stack trace for attribute hydration mismatches', async () => {
     const root = ReactDOMClient.createRoot(container);
-    await act(() => {
-      root.render('Hi');
-    });
-    expect(container.textContent).toEqual('Hi');
-
-    root.unmount();
-
-    expect(() => root.render("I'm back")).toThrow(
-      'Cannot update an unmounted root.',
-    );
-  });
-
-  it('warns if root is unmounted inside an effect', async () => {
-    const container1 = document.createElement('div');
-    const root1 = ReactDOMClient.createRoot(container1);
-    const container2 = document.createElement('div');
-    const root2 = ReactDOMClient.createRoot(container2);
-
-    function App({step}) {
-      useEffect(() => {
-        if (step === 2) {
-          root2.unmount();
-        }
-      }, [step]);
-      return 'Hi';
-    }
-
-    await act(() => {
-      root1.render(<App step={1} />);
-    });
-    expect(container1.textContent).toEqual('Hi');
-
-    ReactDOM.flushSync(() => {
-      root1.render(<App step={2} />);
-    });
-    assertConsoleErrorDev([
-      'Attempted to synchronously unmount a root while React was already rendering. ' +
-        'React cannot finish unmounting the root until the current render has completed, ' +
-        'which may lead to a race condition.\n' +
-        '    in App (at **)',
-    ]);
-  });
-
-  // @gate disableCommentsAsDOMContainers
-  it('errors if container is a comment node', () => {
-    // This is an old feature used by www. Disabled in the open source build.
-    const div = document.createElement('div');
-    div.innerHTML = '<!-- react-mount-point-unstable -->';
-    const commentNode = div.childNodes[0];
-
-    expect(() => ReactDOMClient.createRoot(commentNode)).toThrow(
-      'Target container is not a DOM element.',
-    );
-    expect(() => ReactDOMClient.hydrateRoot(commentNode)).toThrow(
-      'Target container is not a DOM element.',
-    );
-  });
-
-  it('warn if no children passed to hydrateRoot', async () => {
-    ReactDOMClient.hydrateRoot(container);
-    assertConsoleErrorDev(
-      [
-        'Must provide initial children as second argument to hydrateRoot. ' +
-          'Example usage: hydrateRoot(domContainer, <App />)',
-      ],
-      {withoutStack: true},
-    );
-  });
-
-  it('warn if JSX passed to createRoot', async () => {
-    function App() {
-      return 'Child';
-    }
-
-    ReactDOMClient.createRoot(container, <App />);
-    assertConsoleErrorDev(
-      [
-        'You passed a JSX element to createRoot. You probably meant to call root.render instead. ' +
-          'Example usage:\n' +
-          '\n' +
-          '  let root = createRoot(domContainer);\n' +
-          '  root.render(<App />);',
-      ],
-      {
-        withoutStack: true,
-      },
-    );
-  });
-
-  it('warns when given a function', () => {
-    function Component() {
-      return <div />;
-    }
-
-    const root = ReactDOMClient.createRoot(document.createElement('div'));
-
-    ReactDOM.flushSync(() => {
-      root.render(Component);
-    });
-    assertConsoleErrorDev(
-      [
-        'Functions are not valid as a React child. ' +
-          'This may happen if you return Component instead of <Component /> from render. ' +
-          'Or maybe you meant to call this function rather than return it.\n' +
-          '  root.render(Component)',
-      ],
-      {withoutStack: true},
-    );
-  });
-
-  it('warns when given a symbol', () => {
-    const root = ReactDOMClient.createRoot(document.createElement('div'));
-
-    ReactDOM.flushSync(() => {
-      root.render(Symbol('foo'));
-    });
+    const markup = '<div><span class="extra"></span></div>';
+    container.innerHTML = markup;
+    root.render(<div><span /></div>);
+    await waitForAll([]);
     assertConsoleErrorDev(
       [
-        'Symbols are not valid as a React child.\n' +
-          '  root.render(Symbol(foo))',
+        "A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. This can happen if a SSR-ed Client Component used:\n" +
+          "\n" +
+          "- A server/client branch `if (typeof window !== 'undefined')`.\n" +
+          "- Variable input such as Date.now() or Math.random() that changes between server and client.\n" +
+          "- Locale-specific date formatting.\n" +
+          "- External data changes without a snapshot.\n" +
+          "- Invalid HTML nesting.\n\n" +
+          "It can also happen if a browser extension modifies the HTML before React loads.\n" +
+          "\n" +
+          "https://react.dev/link/hydration-mismatch\n" +
+          "\n" +
+          "  <div>\n" +
+          "    <span\n" +
+          "-   className=\"extra\"\n" +
+          "    >\n" +
+          "\n    in span (at **)",
       ],
       {withoutStack: true},
     );
