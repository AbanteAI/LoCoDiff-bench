use std::cmp::Reverse;
use std::fs::File;
use std::io::Write;
use std::mem::take;
use std::path::Path;
use std::sync::Arc;

use common::bitpacking::packed_bits;
use common::bitpacking_links::{for_each_packed_link, pack_links,
    MIN_BITS_PER_VALUE};
use common::bitpacking_ordered;
use common::types::PointOffsetType;
use common::zeros::WriteZerosExt as _;
use itertools::{Either, Itertools as _};
use memmap2::Mmap;
use memory::madvise::{Advice, AdviceSetting};
use memory::mmap_ops;
use memory::mmap_ops::open_read_mmap;
use zerocopy::little_endian::U64 as LittleU64;
use zerocopy::native_endian::U64 as NativeU64;
use zerocopy::{FromBytes, Immutable, IntoBytes, KnownLayout};

/*   ***   Graph Links   *** */

/*
Links data for whole graph layers.

                                    sorted
                     points:        points:
points to lvl        012345         142350
     0 -> 0
     1 -> 4    lvl4:  7       lvl4: 7
     2 -> 2    lvl3:  Z  Y    lvl3: ZY
     3 -> 2    lvl2:  abcd    lvl2: adbc
     4 -> 3    lvl1:  ABCDE   lvl1: ADBCE
     5 -> 1    lvl0: 123456  lvl0: 123456  <- lvl 0 is not sorted

lvl offset:        6       11     15     17
                   │       │      │      │
                   │       │      │      │
                   ▼       ▼      ▼      ▼
   indexes:   012345   6789A   BCDE   FG     H

   flatten: 123456   ADBCE   adbc   ZY     7
                ▲   ▲   ▲   ▲   ▲   ▲   ▲      ▲
                │   │   │   │   │   │   │      │
                │   │   │   │   │   │   │      │
                │   │   │   │   │   │   │      │
                └─  →  142350  142350 142350 142350  (the same for each level)

for lvl > 0:
  links offset = level_offsets[level] + offsets[reindex[point_id]]
*/

pub mod header;
mod serializer;
mod view;

pub use serializer::GraphLinksSerializer;
use view::{CompressionInfo, GraphLinksView, LinksIterator};

self_cell::self_cell! {
    pub struct GraphLinks {
        owner: GraphLinksEnum,
        #[covariant]
        dependent: GraphLinksView,
    }

    impl {Debug}
}

#[derive(Debug, Clone, Copy, Eq, PartialEq)]
pub enum GraphLinksFormat {
    Plain,
    Compressed,
}

#[derive(FromBytes, Immutable, IntoBytes, KnownLayout)]
#[repr(C, align(8))]
struct HeaderPlain {
    point_count: u64,
    levels_count: u64,
    total_links_count: u64,
    total_offsets_len: u64,
    offsets_padding_bytes: u64,
    zero_padding: [u8; 24],
}

#[derive(FromBytes, Immutable, IntoBytes, KnownLayout)]
#[repr(C, align(8))]
struct HeaderCompressed {
    point_count: LittleU64,
    version: LittleU64,
    levels_count: LittleU64,
    total_links_bytes: LittleU64,
    offsets_parameters: bitpacking_ordered::Parameters,
    m: LittleU64,
    m0: LittleU64,
    zero_padding: [u8; 5],
}

const HEADER_VERSION_COMPRESSED: u64 = 0xFFFF_FFFF_FFFF_FF01;

enum GraphLinksEnum {
    Ram(Vec<u8>),
    Mmap(Arc<Mmap>),
}

impl GraphLinksEnum {
    fn load_view(&self, format: GraphLinksFormat) -> OperationResult<GraphViews> {
        let data = match self {
            GraphLinksEnum::Ram(d) => d,
            GraphLinksEnum::Mmap(m) => &m[..],
        };
        GraphViews::load(data, format)
    }
}

impl GraphLinks {
    pub fn load_from_file(
        path: &Path,
        on_disk: bool,
        format: GraphLinksFormat,
    ) -> OperationResult<Self> {
        let populate = !on_disk;
        let mmap = open_read_mmap(
            path,
            AdviceSetting::Advice(Advice::Random),
            populate,
        )?;
        Self::try_new(
            GraphLinksEnum::Mmap(Arc::new(mmap)),
            |x| x.load_view(format),
        )
    }

    fn view(&self) -> &Views {
        self.borrow_dependent()
    }

    pub fn format(&self) -> GraphLinksFormat {
        match self.view().compression {
            CompressionInfo::Uncompressed { .. } => GraphLinksFormat::Plain,
            CompressionInfo::Compressed { .. } => GraphLinksFormat::Compressed,
        }
    }

    pub fn on_disk(&self) -> bool {
        matches!(self.borrow_owner(), GraphLinksEnum::Ram(_))
    }

    pub fn num_points(&self) -> usize {
        self.view().reindex().len()
    }

    pub fn for_each_link(
        &self,
        point_id: PointOffsetType,
        level: usize,
        f: impl FnMut(PointOffsetType),
    ) {
        self.links(point_id, level).for_each(f);
    }

    pub fn point_level(&self, point_id: PointOffsetType) -> usize {
        self.view().point_level(point_id)
    }

    #[inline]
    pub fn links(&self, point_id: PointOffsetType, level: usize) -> LinksIterator {
        self.view().links(point_id, level)
    }

    pub fn into_edges(self) -> Vec<Vec<Vec<PointOffsetType>>> {
        let mut edges = Vec::with_capacity(self.num_points());
        for point_id in 0..self.num_points() {
            let levels = self
                .point_level(point_id as _)
                .range(0..)
                .map(|lvl| self.links(point_id as _, lvl as _).collect())
                .collect();
            edges.push(levels);
        }
        edges
    }

    pub fn populate(&self) -> OperationResult<()> {
        match self.borrow_owner() {
            GraphLinksEnum::Mmap(mmap) => mmap.populate(),
            GraphEnums::Ram(_) => {}
        }
        Ok(())
    }
}