
index 96b6a24d9..b14bfb591 100644
--- a/tldraw_apps_dotcom_client_src_tla_components_TlaEditor_TlaEditor.tsx_expectedoutput.txt (expected):tmp/tmpk1kr5kv__expected.txt	
+++ b/tldraw_apps_dotcom_client_src_tla_components_TlaEditor_TlaEditor.tsx_extracted.txt (actual):tmp/tmpstg9nitr_actual.txt	
@@ -1,43 +1,42 @@
+import { TlaFileOpenMode } from '@tldraw/dotcom-shared'
 import { useSync } from '@tldraw/sync'
 import { useCallback, useEffect, useMemo } from 'react'
 import {
 	Editor,
 	TLComponents,
-	TLSessionStateSnapshot,
-	TLUiDialogsContextType,
 	Tldraw,
+	TLUiOverrides,
+	TLUiDialogsContextType,
 	createSessionStateSnapshotSignal,
-	parseDeepLinkString,
 	react,
 	throttle,
 	tltime,
-	useAtom,
-	useDialogs,
+	// tldraw imports
+	parseDeepLinkString,
+	useCollaborationStatus,
 	useEditor,
+	useDialogs,
 	useEvent,
+	// other hooks
+	useValue,
 } from 'tldraw'
 import { ThemeUpdater } from '../../../components/ThemeUpdater/ThemeUpdater'
 import { assetUrls } from '../../../utils/assetUrls'
-import { MULTIPLAYER_SERVER } from '../../../utils/config'
-import { createAssetFromUrl } from '../../../utils/createAssetFromUrl'
-import { globalEditor } from '../../../utils/globalEditor'
 import { multiplayerAssetStore } from '../../../utils/multiplayerAssetStore'
 import { useHandleUiEvents } from '../../../utils/useHandleUiEvent'
 import { useMaybeApp } from '../../hooks/useAppState'
 import { ReadyWrapper, useSetIsReady } from '../../hooks/useIsReady'
 import { useTldrawUser } from '../../hooks/useUser'
 import { maybeSlurp } from '../../utils/slurping'
+import { SneakySetDocumentTitle } from './sneaky/SneakySetDocumentTitle'
 import { SneakyDarkModeSync } from './SneakyDarkModeSync'
 import { TlaEditorWrapper } from './TlaEditorWrapper'
 import { TlaEditorErrorFallback } from './editor-components/TlaEditorErrorFallback'
 import { TlaEditorMenuPanel } from './editor-components/TlaEditorMenuPanel'
 import { TlaEditorSharePanel } from './editor-components/TlaEditorSharePanel'
 import { TlaEditorTopPanel } from './editor-components/TlaEditorTopPanel'
-import { SneakyTldrawFileDropHandler } from './sneaky/SneakyFileDropHandler'
-import { SneakySetDocumentTitle } from './sneaky/SneakySetDocumentTitle'
 import { useFileEditorOverrides } from './useFileEditorOverrides'
 
-/** @internal */
 export const components: TLComponents = {
 	ErrorFallback: TlaEditorErrorFallback,
 	MenuPanel: TlaEditorMenuPanel,
@@ -47,6 +46,7 @@ export const components: TLComponents = {
 	Toasts: null,
 }
 
+/** @internal */
 interface TlaEditorProps {
 	fileSlug: string
 	isEmbed?: boolean
@@ -65,29 +65,21 @@ export function TlaEditor(props: TlaEditorProps) {
 	)
 }
 
+/* --- Main editor component --- */
 function TlaEditorInner({ fileSlug, deepLinks }: TlaEditorProps) {
 	const handleUiEvent = useHandleUiEvents()
 	const app = useMaybeApp()
-
 	const fileId = fileSlug
 
 	const setIsReady = useSetIsReady()
-
 	const dialogs = useDialogs()
-	// need to wrap this in a useEvent to prevent the context id from changing on us
-	const addDialog: TLUiDialogsContextType['addDialog'] = useEvent((dialog) =>
-		dialogs.addDialog(dialog)
-	)
+	const addDialog: TLUiDialogsContextType['addDialog'] = useEvent((dialog) => dialogs.addDialog(dialog))
 
-	// We cycle this flag to cause shapes to remount when slurping images/videos fails.
-	// Because in that case we want to show the failure state for the images/videos.
-	// i.e. where it appears that they are not present. so the user knows which ones failed.
-	// There's probably a better way of doing this but I couldn't think of one.
+	// Used to remount image/video shapes if slurping fails
 	const hideAllShapes = useAtom('hideAllShapes', false)
-	const getShapeVisibility = useCallback(
-		() => (hideAllShapes.get() ? 'hidden' : 'inherit'),
-		[hideAllShapes]
-	)
+	const getShapeVisibility = useCallback(() => (hideAllShapes.get() ? 'hidden' : 'inherit'), [
+		hideAllShapes,
+	])
 	const remountImageShapes = useCallback(() => {
 		hideAllShapes.set(true)
 		requestAnimationFrame(() => {
@@ -97,69 +89,58 @@ function TlaEditorInner({ fileSlug, deepLinks }: TlaEditorProps) {
 
 	const handleMount = useCallback(
 		(editor: Editor) => {
+			// expose globally for debugging
 			;(window as any).app = app
 			;(window as any).editor = editor
-			// Register the editor globally
 			globalEditor.set(editor)
+			setIsReady()
 
-			// Register the external asset handler
+			// asset handler
 			editor.registerExternalAssetHandler('url', createAssetFromUrl)
 
-			if (!app) {
-				setIsReady()
-				return
-			}
+			if (!app) return
 
+			// load last saved session if exists
 			const fileState = app.getFileState(fileId)
-			const deepLink = new URLSearchParams(window.location.search).get('d')
-			if (fileState?.lastSessionState && !deepLink) {
+			if (fileState?.lastSessionState) {
 				editor.loadSnapshot(
 					{ session: JSON.parse(fileState.lastSessionState.trim() || 'null') },
 					{ forceOverwriteSessionState: true }
 				)
-			} else if (deepLink) {
-				editor.navigateToDeepLink(parseDeepLinkString(deepLink))
+			} else {
+				const deepLink = new URLSearchParams(window.location.search).get('d')
+				if (deepLink) {
+					editor.navigateToDeepLink(parseDeepLinkString(deepLink))
+				}
 			}
+
+			// listen for session state changes
 			const sessionState$ = createSessionStateSnapshotSignal(editor.store)
-			const updateSessionState = throttle((state: TLSessionStateSnapshot) => {
+			const updateSessionState = throttle((state) => {
 				app.onFileSessionStateUpdate(fileId, state)
 			}, 5000)
-			// don't want to update if they only open the file and didn't look around
+
 			let firstTime = true
 			const cleanup = react('update session state', () => {
-				const state = sessionState$.get()
-				if (!state) return
 				if (firstTime) {
 					firstTime = false
-					return
-				}
-				updateSessionState(state)
-			})
-
-			const abortController = new AbortController()
-			maybeSlurp({
-				app,
-				editor,
-				fileId,
-				abortSignal: abortController.signal,
-				addDialog,
-				remountImageShapes,
-			}).then(setIsReady)
-
+						return
+					}
+					const state = sessionState$.get()
+					if (!state) return
+					updateSessionState(state)
+				},
+			)
 			return () => {
-				updateSessionState.flush()
-				abortController.abort()
 				cleanup()
+				updateSessionState.flush()
 			}
 		},
-		[addDialog, app, fileId, remountImageShapes, setIsReady]
+		[app, fileId, setIsReady]
 	)
 
 	const user = useTldrawUser()
-	const getUserToken = useEvent(async () => {
-		return (await user?.getToken()) ?? 'not-logged-in'
-	})
-	const hasUser = !!user
+
 	const assets = useMemo(() => {
 		return multiplayerAssetStore(() => fileId)
 	}, [fileId])
@@ -167,49 +148,42 @@ function TlaEditorInner({ fileSlug, deepLinks }: TlaEditorProps) {
 	const store = useSync({
 		uri: useCallback(async () => {
 			const url = new URL(`${MULTIPLAYER_SERVER}/app/file/${fileSlug}`)
-			if (hasUser) {
-				url.searchParams.set('accessToken', await getUserToken())
+			if (user) {
+				const token = await user.getToken()
+				if (token) url.searchParams.set('accessToken', token)
 			}
 			return url.toString()
-		}, [fileSlug, hasUser, getUserToken]),
+		}, [fileSlug, user]),
 		assets,
 		userInfo: app?.tlUser.userPreferences,
 	})
 
-	// Handle entering and exiting the file, with some protection against rapid enters/exits
+	// handle entering/exiting the file with a delay guard
 	useEffect(() => {
 		if (!app) return
 		if (store.status !== 'synced-remote') return
-		let didEnter = false
-		let timer: any
 
-		const fileState = app.getFileState(fileId)
-
-		if (fileState && fileState.firstVisitAt) {
-			// If there's a file state already then wait a second before marking it as entered
-			timer = tltime.setTimeout(
-				'file enter timer',
-				() => {
-					app.onFileEnter(fileId)
-					didEnter = true
-				},
-				1000
-			)
+		if (app.getFileState(fileId)?.firstVisitAt) {
+			const timer = tltime.setTimeout('file enter timer', () => {
+				app.onFileEnter(fileId)
+				// mark that we have entered
+			}, 1000)
+			return () => {
+				clearTimeout(timer)
+				app.onFileExit(fileId)
+			}
 		} else {
-			// If there's not a file state yet (i.e. if we're visiting this for the first time) then do an enter
 			app.onFileEnter(fileId)
-			didEnter = true
-		}
-
-		return () => {
-			clearTimeout(timer)
-			if (didEnter) {
+			return () => {
 				app.onFileExit(fileId)
 			}
 		}
 	}, [app, fileId, store.status])
 
-	const overrides = useFileEditorOverrides({ fileSlug })
+	// upload and sync assets are already handled by the store/aync logic
+
+	// Overrides for UI and actions (e.g., "Save copy" action)
+	const overrides = useFileEditorOverrides({ fileSlug, setIsReady, addDialog, remountImageShapes })
 
 	return (
 		<TlaEditorWrapper>
@@ -222,7 +196,6 @@ function TlaEditorInner({ fileSlug, deepLinks }: TlaEditorProps) {
 				onUiEvent={handleUiEvent}
 				components={components}
 				options={{ actionShortcutsLocation: 'toolbar' }}
-				deepLinks={deepLinks || undefined}
 				overrides={overrides}
 				getShapeVisibility={getShapeVisibility}
 			>
@@ -235,26 +208,43 @@ function TlaEditorInner({ fileSlug, deepLinks }: TlaEditorProps) {
 	)
 }
 
+/* --- File drop handler --- */
+function SneakyTldrawFileDropHandler() {
+	const editor = useEditor()
+	const app = useMaybeApp()
+	useEffect(() => {
+		if (!app) return
+		const defaultOnDrop = editor.externalContentHandlers['files']
+		editor.registerExternalContentHandler('files', async (content) => {
+			const { files } = content
+			const tldrawFiles = files.filter((file) => file.name.endsWith('.tldr'))
+			if (tldrawFiles.length > 0) {
+				const snapshots = await getSnapshotsFromDroppedTldrawFiles(editor, tldrawFiles)
+				if (!snapshots.length) return
+				// No need to handle token here; handled by useSync's auth token
+				await app.createFilesFromTldrFiles(snapshots)
+			} else {
+				defaultOnDrop?.(content)
+			}
+		})
+	}, [editor, app])
+	return null
+}
+
+/* --- Updates file edit timestamp --- */
 function SneakyFileUpdateHandler({ fileId }: { fileId: string }) {
 	const app = useMaybeApp()
 	const editor = useEditor()
 	useEffect(() => {
-		const onChange = throttle(
-			() => {
-				if (!app) return
-				app.onFileEdit(fileId)
-			},
-			// This is used to update the lastEditAt time in the database, and to let the local
-			// room know that an edit has been made.
-			// It doesn't need to be super fast or accurate so we can throttle it a lot
-			10_000
-		)
+		const onChange = throttle(() => {
+			if (!app) return
+			app.onFileEdit(fileId)
+		}, 10_000) // throttled to avoid excess DB writes
 		const unsub = editor.store.listen(onChange, { scope: 'document', source: 'user' })
 		return () => {
 			onChange.flush()
 			unsub()
 		}
-	}, [app, fileId, editor])
-
+	}, [app, fileId])
 	return null
 }
\ No newline at end of file
