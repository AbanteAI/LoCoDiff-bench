
index 5ea95b92f..87d4a268b 100644
--- a/tldraw_packages_tldraw_src_lib_ui_hooks_useClipboardEvents.ts_expectedoutput.txt (expected):tmp/tmpz9hk4wyk_expected.txt	
+++ b/tldraw_packages_tldraw_src_lib_ui_hooks_useClipboardEvents.ts_extracted.txt (actual):tmp/tmpkmdoxkh7_actual.txt	
@@ -1,7 +1,12 @@
 import {
 	Editor,
 	FileHelpers,
+	TLArrowShape,
+	TLBookmarkShape,
+	TLEmbedShape,
 	TLExternalContentSource,
+	TLGeoShape,
+	TLTextShape,
 	Vec,
 	VecLike,
 	assert,
@@ -21,29 +26,6 @@ import { TLUiEventSource, useUiEvents } from '../context/events'
 import { pasteFiles } from './clipboard/pasteFiles'
 import { pasteUrl } from './clipboard/pasteUrl'
 
-// Expected paste mime types. The earlier in this array they appear, the higher preference we give
-// them. For example, we prefer the `web image/png+tldraw` type to plain `image/png` as it does not
-// strip some of the extra metadata we write into it.
-const expectedPasteFileMimeTypes = [
-	TLDRAW_CUSTOM_PNG_MIME_TYPE,
-	'image/png',
-	'image/jpeg',
-	'image/webp',
-	'image/svg+xml',
-] satisfies string[]
-
-/**
- * Strip HTML tags from a string.
- * @param html - The HTML to strip.
- * @internal
- */
-function stripHtml(html: string) {
-	// See <https://github.com/developit/preact-markup/blob/tldraw_packages_tldraw_src_lib_ui_hooks_useClipboardEvents.ts_extracted.txt (actual): string) => {
 	try {
@@ -56,8 +38,8 @@ export const isValidHttpURL = (url: string) => {
 
 /** @public */
 const getValidHttpURLList = (url: string) => {
-	const urls = url.split(/[\n\s]/)
-	for (const url of urls) {
+	const urls = url.split(/[\s\n]+/)
+	for (const url of urls.filter(Boolean)) {
 		try {
 			const u = new URL(url)
 			if (!(u.protocol === 'http:' || u.protocol === 'https:')) {
@@ -78,19 +60,14 @@ const isSvgText = (text: string) => {
 const INPUTS = ['input', 'select', 'textarea']
 
 /**
- * Get whether to disallow clipboard events.
- *
+ * Strip HTML tags from a string.
+ * @param html - The HTML to strip.
  * @internal
  */
-function areShortcutsDisabled(editor: Editor) {
-	const { activeElement } = document
-
-	return (
-		editor.menus.hasAnyOpenMenus() ||
-		(activeElement &&
-			((activeElement as HTMLElement).isContentEditable ||
-				INPUTS.indexOf(activeElement.tagName.toLowerCase()) > -1))
-	)
+function stripHtml(html: string) {
+	const doc = document.implementation.createHTMLDocument('')
+	doc.documentElement.innerHTML = html.trim()
+	return doc.body.textContent || doc.body.innerText || ''
 }
 
 /**
@@ -133,39 +110,18 @@ const handleText = (
 }
 
 /**
- * Something found on the clipboard, either through the event's clipboard data or the browser's clipboard API.
- * @internal
+ * Expected paste mime types in order of preference
  */
-type ClipboardThing =
-	| {
-			type: 'file'
-			source: Promise<File | null>
-	  }
-	| {
-			type: 'blob'
-			source: Promise<Blob | null>
-	  }
-	| {
-			type: 'url'
-			source: Promise<string>
-	  }
-	| {
-			type: 'html'
-			source: Promise<string>
-	  }
-	| {
-			type: 'text'
-			source: Promise<string>
-	  }
-	| {
-			type: string
-			source: Promise<string>
-	  }
+const expectedPasteFileMimeTypes = [
+	TLDRAW_CUSTOM_PNG_MIME_TYPE,
+	'image/png',
+	'image/jpeg',
+	'image/webp',
+	'image/svg+xml',
+] satisfies string[]
 
 /**
- * Handle a paste using event clipboard data. This is the "original"
- * paste method that uses the clipboard data from the paste event.
- * https://developer.mozilla.org/en-US/docs/Web/tldraw_packages_tldraw_src_lib_ui_hooks_useClipboardEvents.ts_extracted.txt (actual): DataTransfer,
 	point?: VecLike
 ) => {
-	// Do not paste while in any editing state
 	if (editor.getEditingShapeId() !== null) return
 
 	if (!clipboardData) {
@@ -189,27 +144,34 @@ const handlePasteFromEventClipboardData = async (
 	for (const item of Object.values(clipboardData.items)) {
 		switch (item.kind) {
 			case 'file': {
-				// files are always blobs
 				things.push({
 					type: 'file',
-					source: new Promise((r) => r(item.getAsFile())) as Promise<File | null>,
+					source: Promise.resolve(item.getAsFile()) as Promise<File | null>,
 				})
 				break
 			}
 			case 'string': {
-				// strings can be text or html
 				if (item.type === 'text/html') {
 					things.push({
 						type: 'html',
-						source: new Promise((r) => item.getAsString(r)) as Promise<string>,
+						source: new Promise((resolve) => {
+							item.getAsString(resolve)
+						}) as Promise<string>,
 					})
 				} else if (item.type === 'text/plain') {
 					things.push({
 						type: 'text',
-						source: new Promise((r) => item.getAsString(r)) as Promise<string>,
+						source: new Promise((resolve) => {
+							item.getAsString(resolve)
+						}) as Promise<string>,
 					})
 				} else {
-					things.push({ type: item.type, source: new Promise((r) => item.getAsString(r)) })
+					things.push({
+						type: item.type,
+						source: new Promise((resolve) => {
+							item.getAsString(resolve)
+						}),
+					})
 				}
 				break
 			}
@@ -219,14 +181,34 @@ const handlePasteFromEventClipboardData = async (
 	handleClipboardThings(editor, things, point)
 }
 
+type ClipboardThing =
+	| {
+			type: 'file'
+			source: Promise<File | null>
+	  }
+	| {
+			type: 'blob'
+			source: Promise<Blob | null>
+	  }
+	| {
+			type: 'url'
+			source: Promise<string>
+	  }
+	| {
+			type: 'html'
+			source: Promise<string>
+	  }
+	| {
+			type: 'text'
+			source: Promise<string>
+	  }
+	| {
+			type: string
+			source: Promise<string>
+	  }
+
 /**
  * Handle a paste using items retrieved from the Clipboard API.
- * https://developer.mozilla.org/en-US/docs/Web/tldraw_packages_tldraw_src_lib_ui_hooks_useClipboardEvents.ts_extracted.txt (actual): VecLike
 	fallbackFiles?: File[]
 }) => {
-	// We need to populate the array of clipboard things
-	// based on the ClipboardItems from the Clipboard API.
-	// This is done in a different way than when using
-	// the clipboard data from the paste event.
-
 	const things: ClipboardThing[] = []
 
 	for (const item of clipboardItems) {
@@ -297,9 +274,6 @@ const handlePasteFromClipboardApi = async ({
 			...fallbackFiles.map((f): ClipboardThing => ({ type: 'file', source: Promise.resolve(f) }))
 		)
 	} else if (fallbackFiles?.length && things.length === 0) {
-		// Files pasted in Safari from your computer don't have types, so we need to use the fallback files directly
-		// if they're available. This only works if pasted keyboard shortcuts. Pasting from the menu in Safari seems to never
-		// let you access files that are copied from your computer.
 		things.push(
 			...fallbackFiles.map((f): ClipboardThing => ({ type: 'file', source: Promise.resolve(f) }))
 		)
@@ -309,133 +283,100 @@ const handlePasteFromClipboardApi = async ({
 }
 
 async function handleClipboardThings(editor: Editor, things: ClipboardThing[], point?: VecLike) {
-	// 1. Handle files
-	//
-	// We need to handle files separately because if we want them to
-	// be placed next to each other, we need to create them all at once.
-
-	const files = things.filter(
-		(t) => (t.type === 'file' || t.type === 'blob') && t.source !== null
-	) as Extract<ClipboardThing, { type: 'file' } | { type: 'blob' }>[]
-
-	// Just paste the files, nothing else
-	if (files.length) {
-		if (files.length > editor.options.maxFilesAtOnce) {
-			throw Error('Too many files')
-		}
-		const fileBlobs = compact(await Promise.all(files.map((t) => t.source)))
-		return await pasteFiles(editor, fileBlobs, point)
-	}
-
-	// 2. Generate clipboard results for non-file things
-	//
-	// Getting the source from the items is async, however they must be accessed syncronously;
-	// we can't await them in a loop. So we'll map them to promises and await them all at once,
-	// then make decisions based on what we find.
-
 	const results = await Promise.all<TLExternalContentSource>(
 		things
 			.filter((t) => t.type !== 'file')
-			.map(
-				(t) =>
-					new Promise((r) => {
-						const thing = t as Exclude<ClipboardThing, { type: 'file' } | { type: 'blob' }>
-
-						if (thing.type === 'file') {
-							r({ type: 'error', data: null, reason: 'unexpected file' })
-							return
-						}
+			.map((t) =>
+				new Promise((resolve) => {
+					const thing = t as Exclude<ClipboardThing, { type: 'file' } | { type: 'blob' }>
 
-						thing.source.then((text) => {
-							// first, see if we can find tldraw content, which is JSON inside of an html comment
-							const tldrawHtmlComment = text.match(/<div data-tldraw[^>]*>(.*)<\/div>/)?.[1]
+					if (thing.type === 'blob') {
+						resolve({ type: 'error', data: null, reason: 'unexpected blob' })
+						return
+					}
+
+					thing.source.then((text) => {
+						const tldrawHtmlComment = text.match(/<div data-tldraw[^>]*>(.*)<\/div>/)?.[1]
 
-							if (tldrawHtmlComment) {
-								try {
-									// If we've found tldraw content in the html string, use that as JSON
-									const jsonComment = lz.decompressFromBase64(tldrawHtmlComment)
-									if (jsonComment === null) {
-										r({
+						if (tldrawHtmlComment) {
+							try {
+								const jsonComment = lz.decompressFromBase64(tldrawHtmlComment)
+								if (jsonComment === null) {
+									resolve({
+										type: 'error',
+										data: jsonComment,
+										reason: 'found tldraw data comment but could not parse base64',
+									})
+									return
+								} else {
+									const json = JSON.parse(jsonComment)
+									if (json.type !== 'application/tldraw') {
+										resolve({
 											type: 'error',
-											data: jsonComment,
-											reason: `found tldraw data comment but could not parse base64`,
+											data: json,
+											reason: `found tldraw data comment but JSON was of a different type: ${json.type}`,
+										})
+									}
+
+									if (typeof json.data !== 'string') {
+										resolve({
+											type: 'tldraw',
+											data: json.data,
 										})
-										return
-									} else {
-										const json = JSON.parse(jsonComment)
-										if (json.type !== 'application/tldraw') {
-											r({
-												type: 'error',
-												data: json,
-												reason: `found tldraw data comment but JSON was of a different type: ${json.type}`,
-											})
-										}
-
-										if (typeof json.data === 'string') {
-											r({
-												type: 'error',
-												data: json,
-												reason:
-													'found tldraw json but data was a string instead of a TLClipboardModel object',
-											})
-											return
-										}
-
-										r({ type: 'tldraw', data: json.data })
 										return
 									}
-								} catch {
-									r({
-										type: 'error',
-										data: tldrawHtmlComment,
-										reason:
-											'found tldraw json but data was a string instead of a TLClipboardModel object',
-									})
-									return
-								}
-							} else {
-								if (thing.type === 'html') {
-									r({ type: 'text', data: text, subtype: 'html' })
-									return
 								}
+							} catch {
+								resolve({
+									type: 'error',
+									data: tldrawHtmlComment,
+									reason: 'caught error',
+								})
+								return
+							}
+						} else {
+							if (thing.type === 'html') {
+								resolve({ type: 'text', data: text, subtype: 'html' })
+								return
+							}
 
-								if (thing.type === 'url') {
-									r({ type: 'text', data: text, subtype: 'url' })
-									return
-								}
+							if (thing.type === 'url') {
+								resolve({ type: 'text', data: text, subtype: 'url' })
+								return
+							}
 
-								// if we have not found a tldraw comment, Otherwise, try to parse the text as JSON directly.
-								try {
-									const json = JSON.parse(text)
-									if (json.type === 'excalidraw/clipboard') {
-										// If the clipboard contains content copied from excalidraw, then paste that
-										r({ type: 'excalidraw', data: json })
-										return
-									} else {
-										r({ type: 'text', data: text, subtype: 'json' })
-										return
-									}
-								} catch {
-									// If we could not parse the text as JSON, then it's just text
-									r({ type: 'text', data: text, subtype: 'text' })
+							try {
+								const json = JSON.parse(text)
+								if (json.type === 'excalidraw/clipboard') {
+									resolve({ type: 'excalidraw', data: json })
+									return
+								} else {
+									resolve({ type: 'text', data: text, subtype: 'json' })
 									return
 								}
+							} catch {
+								resolve({ type: 'text', data: text, subtype: 'text' })
+								return
 							}
+						}
 
-							r({ type: 'error', data: text, reason: 'unhandled case' })
-						})
+						resolve({ type: 'error', data: text, reason: 'unhandled case' })
 					})
+				})
 			)
 	)
 
-	// 3.
-	//
-	// Now that we know what kind of stuff we're dealing with, we can actual create some content.
-	// There are priorities here, so order matters: we've already handled images and files, which
-	// take first priority; then we want to handle tldraw content, then excalidraw content, then
-	// html content, then links, and finally text content.
+	const files = things.filter(
+		(t) => (t.type === 'file' || t.type === 'blob') && t.source !== null
+	) as Extract<ClipboardThing, { type: 'file' } | { type: 'blob' }>[]
+
+	if (files.length && files.length > editor.options.maxFilesAtOnce) {
+		throw Error('Too many files')
+	} else if (files.length) {
+		const fileBlobs = compact(await Promise.all(files.map((t) => t.source)))
+		return await pasteFiles(editor, fileBlobs, point)
+	}
 
-	// Try to paste tldraw content
 	for (const result of results) {
 		if (result.type === 'tldraw') {
 			editor.markHistoryStoppingPoint('paste')
@@ -444,7 +385,6 @@ async function handleClipboardThings(editor: Editor, things: ClipboardThing[], p
 		}
 	}
 
-	// Try to paste excalidraw content
 	for (const result of results) {
 		if (result.type === 'excalidraw') {
 			editor.markHistoryStoppingPoint('paste')
@@ -453,16 +393,11 @@ async function handleClipboardThings(editor: Editor, things: ClipboardThing[], p
 		}
 	}
 
-	// Try to paste html content
 	for (const result of results) {
 		if (result.type === 'text' && result.subtype === 'html') {
-			// try to find a link
 			const rootNode = new DOMParser().parseFromString(result.data, 'text/html')
 			const bodyNode = rootNode.querySelector('body')
 
-			// Edge on Windows 11 home appears to paste a link as a single <a/tldraw_packages_tldraw_src_lib_ui_hooks_useClipboardEvents.ts_expectedoutput.txt (expected): Editor, things: ClipboardThing[], p
 				return
 			}
 
-			// If the html is NOT a link, and we have NO OTHER texty content, then paste the html as text
-			if (!results.some((r) => r.type === 'text' && r.subtype !== 'html') && result.data.trim()) {
-				const html = stripHtml(result.data) ?? ''
-				if (html) {
-					handleText(editor, stripHtml(result.data), point, results)
-					return
-				}
+			const html = stripHtml(result.data) ?? ''
+			if (html) {
+				handleText(editor, stripHtml(result.data), point, results)
+				return
 			}
 
-			// If the html is NOT a link, and we have other texty content, then paste the html as a text shape
 			if (results.some((r) => r.type === 'text' && r.subtype !== 'html')) {
 				const html = stripHtml(result.data) ?? ''
 				if (html) {
@@ -502,10 +433,10 @@ async function handleClipboardThings(editor: Editor, things: ClipboardThing[], p
 				}
 			}
 		}
+	}
 
-		// Allow you to paste YouTube or Google Maps embeds, for example.
+	for (const result of results) {
 		if (result.type === 'text' && result.subtype === 'text' && result.data.startsWith('<iframe ')) {
-			// try to find an iframe
 			const rootNode = new DOMParser().parseFromString(result.data, 'text/html')
 			const bodyNode = rootNode.querySelector('body')
 
@@ -525,7 +456,6 @@ async function handleClipboardThings(editor: Editor, things: ClipboardThing[], p
 		}
 	}
 
-	// Try to paste a link
 	for (const result of results) {
 		if (result.type === 'text' && result.subtype === 'url') {
 			pasteUrl(editor, result.data, point, results)
@@ -533,22 +463,14 @@ async function handleClipboardThings(editor: Editor, things: ClipboardThing[], p
 		}
 	}
 
-	// Finally, if we haven't bailed on anything yet, we can paste text content
 	for (const result of results) {
 		if (result.type === 'text' && result.subtype === 'text' && result.data.trim()) {
-			// The clipboard may include multiple text items, but we only want to paste the first one
 			handleText(editor, result.data, point, results)
 			return
 		}
 	}
 }
 
-/**
- * When the user copies, write the contents to local storage and to the clipboard
- *
- * @param editor - The editor instance.
- * @public
- */
 const handleNativeOrMenuCopy = async (editor: Editor) => {
 	const content = await editor.resolveAssetsInContent(
 		editor.getContentFromCurrentPage(editor.getSelectedShapeIds())
@@ -571,7 +493,6 @@ const handleNativeOrMenuCopy = async (editor: Editor) => {
 	if (typeof navigator === 'undefined') {
 		return
 	} else {
-		// Extract the text from the clipboard
 		const textItems = content.shapes
 			.map((shape) => {
 				const util = editor.getShapeUtil(shape)
@@ -586,9 +507,6 @@ const handleNativeOrMenuCopy = async (editor: Editor) => {
 
 			let textContent = textItems.join(' ')
 
-			// This is a bug in chrome android where it won't paste content if
-			// the text/plain content is "" so we need to always add an empty
-			// space 🤬
 			if (textContent === '') {
 				textContent = ' '
 			}
@@ -596,7 +514,6 @@ const handleNativeOrMenuCopy = async (editor: Editor) => {
 			navigator.clipboard.write([
 				new ClipboardItem({
 					'text/html': htmlBlob,
-					// What is this second blob used for?
 					'text/plain': new Blob([textContent], { type: 'text/plain' }),
 				}),
 			])
@@ -606,14 +523,23 @@ const handleNativeOrMenuCopy = async (editor: Editor) => {
 	}
 }
 
-/** @public */
+function areShortcutsDisabled(editor: Editor) {
+	const { activeElement } = document
+	return (
+		editor.menus.hasAnyOpenMenus() ||
+		(activeElement &&
+			((activeElement as HTMLElement).isContentEditable ||
+				INPUTS.indexOf(activeElement.tagName.toLowerCase()) > -1))
+	)
+}
+
 export function useMenuClipboardEvents() {
 	const editor = useMaybeEditor()
 	const trackEvent = useUiEvents()
 
 	const copy = useCallback(
 		async function onCopy(source: TLUiEventSource) {
-			assert(editor, 'editor is required for copy')
+			if (!editor) return
 			if (editor.getSelectedShapeIds().length === 0) return
 
 			await handleNativeOrMenuCopy(editor)
@@ -641,16 +567,12 @@ export function useMenuClipboardEvents() {
 			point?: VecLike
 		) {
 			if (!editor) return
-			// If we're editing a shape, or we are focusing an editable input, then
-			// we would want the user's paste interaction to go to that element or
-			// input instead; e.g. when pasting text into a text shape's content
 			if (editor.getEditingShapeId() !== null) return
 
 			if (Array.isArray(data) && data[0] instanceof ClipboardItem) {
 				handlePasteFromClipboardApi({ editor, clipboardItems: data, point })
 				trackEvent('paste', { source: 'menu' })
 			} else {
-				// Read it first and then recurse, kind of weird
 				navigator.clipboard.read().then((clipboardItems) => {
 					paste(clipboardItems, source, point)
 				})
@@ -666,7 +588,6 @@ export function useMenuClipboardEvents() {
 	}
 }
 
-/** @public */
 export function useNativeClipboardEvents() {
 	const editor = useEditor()
 	const trackEvent = useUiEvents()
@@ -691,98 +612,7 @@ export function useNativeClipboardEvents() {
 			trackEvent('copy', { source: 'kbd' })
 		}
 
-		async function cut(e: ClipboardEvent) {
+		function cut(e: ClipboardEvent) {
 			if (
 				editor.getSelectedShapeIds().length === 0 ||
-				editor.getEditingShapeId() !== null ||
-				areShortcutsDisabled(editor)
-			) {
-				return
-			}
-			preventDefault(e)
-			await handleNativeOrMenuCopy(editor)
-			editor.deleteShapes(editor.getSelectedShapeIds())
-			trackEvent('cut', { source: 'kbd' })
-		}
-
-		let disablingMiddleClickPaste = false
-		const pointerUpHandler = (e: PointerEvent) => {
-			if (e.button === 1) {
-				// middle mouse button
-				disablingMiddleClickPaste = true
-				editor.timers.requestAnimationFrame(() => {
-					disablingMiddleClickPaste = false
-				})
-			}
-		}
-
-		const paste = (e: ClipboardEvent) => {
-			if (disablingMiddleClickPaste) {
-				stopEventPropagation(e)
-				return
-			}
-
-			// If we're editing a shape, or we are focusing an editable input, then
-			// we would want the user's paste interaction to go to that element or
-			// input instead; e.g. when pasting text into a text shape's content
-			if (editor.getEditingShapeId() !== null || areShortcutsDisabled(editor)) return
-
-			// Where should the shapes go?
-			let point: Vec | undefined = undefined
-			let pasteAtCursor = false
-
-			// | Shiftkey | Paste at cursor mode | Paste at point? |
-			// |    N 		|         N            |       N 				 |
-			// |    Y 		|         N            |       Y 				 |
-			// |    N 		|         Y            |       Y 				 |
-			// |    Y 		|         Y            |       N 				 |
-			if (editor.inputs.shiftKey) pasteAtCursor = true
-			if (editor.user.getIsPasteAtCursorMode()) pasteAtCursor = !pasteAtCursor
-			if (pasteAtCursor) point = editor.inputs.currentPagePoint
-
-			const pasteFromEvent = () => {
-				if (e.clipboardData) {
-					handlePasteFromEventClipboardData(editor, e.clipboardData, point)
-				}
-			}
-
-			// if we can read from the clipboard API, we want to try using that first. that allows
-			// us to access most things, and doesn't strip out metadata added to tldraw's own
-			// copy-as-png features - so copied shapes come back in at the correct size.
-			if (navigator.clipboard?.read) {
-				// We can't read files from the filesystem using the clipboard API though - they'll
-				// just come in as the file names instead. So we'll use the clipboard event's files
-				// as a fallback - if we only got text, but do have files, we use those instead.
-				const fallbackFiles = Array.from(e.clipboardData?.files || [])
-				navigator.clipboard.read().then(
-					(clipboardItems) => {
-						if (Array.isArray(clipboardItems) && clipboardItems[0] instanceof ClipboardItem) {
-							handlePasteFromClipboardApi({ editor, clipboardItems, point, fallbackFiles })
-						}
-					},
-					() => {
-						// if reading from the clipboard fails, try to use the event clipboard data
-						pasteFromEvent()
-					}
-				)
-			} else {
-				pasteFromEvent()
-			}
-
-			preventDefault(e)
-			trackEvent('paste', { source: 'kbd' })
-		}
-
-		document.addEventListener('copy', copy)
-		document.addEventListener('cut', cut)
-		document.addEventListener('paste', paste)
-		document.addEventListener('pointerup', pointerUpHandler)
-
-		return () => {
-			document.removeEventListener('copy', copy)
-			document.removeEventListener('cut', cut)
-			document.removeEventListener('paste', paste)
-			document.removeEventListener('pointerup', pointerUpHandler)
-		}
-	}, [editor, trackEvent, appIsFocused])
-}
\ No newline at end of file
+				editor.getEditingShapeId
\ No newline at end of file
