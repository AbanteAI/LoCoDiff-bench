
index 5ea95b92f..fd556cf8c 100644
--- a/tldraw_packages_tldraw_src_lib_ui_hooks_useClipboardEvents.ts_expectedoutput.txt (expected):tmp/tmplc5pwmyt_expected.txt	
+++ b/tldraw_packages_tldraw_src_lib_ui_hooks_useClipboardEvents.ts_extracted.txt (actual):tmp/tmp4vb4fvb__actual.txt	
@@ -536,253 +536,4 @@ async function handleClipboardThings(editor: Editor, things: ClipboardThing[], p
 	// Finally, if we haven't bailed on anything yet, we can paste text content
 	for (const result of results) {
 		if (result.type === 'text' && result.subtype === 'text' && result.data.trim()) {
-			// The clipboard may include multiple text items, but we only want to paste the first one
-			handleText(editor, result.data, point, results)
-			return
-		}
-	}
-}
-
-/**
- * When the user copies, write the contents to local storage and to the clipboard
- *
- * @param editor - The editor instance.
- * @public
- */
-const handleNativeOrMenuCopy = async (editor: Editor) => {
-	const content = await editor.resolveAssetsInContent(
-		editor.getContentFromCurrentPage(editor.getSelectedShapeIds())
-	)
-	if (!content) {
-		if (navigator && navigator.clipboard) {
-			navigator.clipboard.writeText('')
-		}
-		return
-	}
-
-	const stringifiedClipboard = lz.compressToBase64(
-		JSON.stringify({
-			type: 'application/tldraw',
-			kind: 'content',
-			data: content,
-		})
-	)
-
-	if (typeof navigator === 'undefined') {
-		return
-	} else {
-		// Extract the text from the clipboard
-		const textItems = content.shapes
-			.map((shape) => {
-				const util = editor.getShapeUtil(shape)
-				return util.getText(shape)
-			})
-			.filter(isDefined)
-
-		if (navigator.clipboard?.write) {
-			const htmlBlob = new Blob([`<div data-tldraw>${stringifiedClipboard}</div>`], {
-				type: 'text/html',
-			})
-
-			let textContent = textItems.join(' ')
-
-			// This is a bug in chrome android where it won't paste content if
-			// the text/plain content is "" so we need to always add an empty
-			// space ðŸ¤¬
-			if (textContent === '') {
-				textContent = ' '
-			}
-
-			navigator.clipboard.write([
-				new ClipboardItem({
-					'text/html': htmlBlob,
-					// What is this second blob used for?
-					'text/plain': new Blob([textContent], { type: 'text/plain' }),
-				}),
-			])
-		} else if (navigator.clipboard.writeText) {
-			navigator.clipboard.writeText(`<div data-tldraw>${stringifiedClipboard}</div>`)
-		}
-	}
-}
-
-/** @public */
-export function useMenuClipboardEvents() {
-	const editor = useMaybeEditor()
-	const trackEvent = useUiEvents()
-
-	const copy = useCallback(
-		async function onCopy(source: TLUiEventSource) {
-			assert(editor, 'editor is required for copy')
-			if (editor.getSelectedShapeIds().length === 0) return
-
-			await handleNativeOrMenuCopy(editor)
-			trackEvent('copy', { source })
-		},
-		[editor, trackEvent]
-	)
-
-	const cut = useCallback(
-		async function onCut(source: TLUiEventSource) {
-			if (!editor) return
-			if (editor.getSelectedShapeIds().length === 0) return
-
-			await handleNativeOrMenuCopy(editor)
-			editor.deleteShapes(editor.getSelectedShapeIds())
-			trackEvent('cut', { source })
-		},
-		[editor, trackEvent]
-	)
-
-	const paste = useCallback(
-		async function onPaste(
-			data: DataTransfer | ClipboardItem[],
-			source: TLUiEventSource,
-			point?: VecLike
-		) {
-			if (!editor) return
-			// If we're editing a shape, or we are focusing an editable input, then
-			// we would want the user's paste interaction to go to that element or
-			// input instead; e.g. when pasting text into a text shape's content
-			if (editor.getEditingShapeId() !== null) return
-
-			if (Array.isArray(data) && data[0] instanceof ClipboardItem) {
-				handlePasteFromClipboardApi({ editor, clipboardItems: data, point })
-				trackEvent('paste', { source: 'menu' })
-			} else {
-				// Read it first and then recurse, kind of weird
-				navigator.clipboard.read().then((clipboardItems) => {
-					paste(clipboardItems, source, point)
-				})
-			}
-		},
-		[editor, trackEvent]
-	)
-
-	return {
-		copy,
-		cut,
-		paste,
-	}
-}
-
-/** @public */
-export function useNativeClipboardEvents() {
-	const editor = useEditor()
-	const trackEvent = useUiEvents()
-
-	const appIsFocused = useValue('editor.isFocused', () => editor.getInstanceState().isFocused, [
-		editor,
-	])
-
-	useEffect(() => {
-		if (!appIsFocused) return
-		const copy = async (e: ClipboardEvent) => {
-			if (
-				editor.getSelectedShapeIds().length === 0 ||
-				editor.getEditingShapeId() !== null ||
-				areShortcutsDisabled(editor)
-			) {
-				return
-			}
-
-			preventDefault(e)
-			await handleNativeOrMenuCopy(editor)
-			trackEvent('copy', { source: 'kbd' })
-		}
-
-		async function cut(e: ClipboardEvent) {
-			if (
-				editor.getSelectedShapeIds().length === 0 ||
-				editor.getEditingShapeId() !== null ||
-				areShortcutsDisabled(editor)
-			) {
-				return
-			}
-			preventDefault(e)
-			await handleNativeOrMenuCopy(editor)
-			editor.deleteShapes(editor.getSelectedShapeIds())
-			trackEvent('cut', { source: 'kbd' })
-		}
-
-		let disablingMiddleClickPaste = false
-		const pointerUpHandler = (e: PointerEvent) => {
-			if (e.button === 1) {
-				// middle mouse button
-				disablingMiddleClickPaste = true
-				editor.timers.requestAnimationFrame(() => {
-					disablingMiddleClickPaste = false
-				})
-			}
-		}
-
-		const paste = (e: ClipboardEvent) => {
-			if (disablingMiddleClickPaste) {
-				stopEventPropagation(e)
-				return
-			}
-
-			// If we're editing a shape, or we are focusing an editable input, then
-			// we would want the user's paste interaction to go to that element or
-			// input instead; e.g. when pasting text into a text shape's content
-			if (editor.getEditingShapeId() !== null || areShortcutsDisabled(editor)) return
-
-			// Where should the shapes go?
-			let point: Vec | undefined = undefined
-			let pasteAtCursor = false
-
-			// | Shiftkey | Paste at cursor mode | Paste at point? |
-			// |    N 		|         N            |       N 				 |
-			// |    Y 		|         N            |       Y 				 |
-			// |    N 		|         Y            |       Y 				 |
-			// |    Y 		|         Y            |       N 				 |
-			if (editor.inputs.shiftKey) pasteAtCursor = true
-			if (editor.user.getIsPasteAtCursorMode()) pasteAtCursor = !pasteAtCursor
-			if (pasteAtCursor) point = editor.inputs.currentPagePoint
-
-			const pasteFromEvent = () => {
-				if (e.clipboardData) {
-					handlePasteFromEventClipboardData(editor, e.clipboardData, point)
-				}
-			}
-
-			// if we can read from the clipboard API, we want to try using that first. that allows
-			// us to access most things, and doesn't strip out metadata added to tldraw's own
-			// copy-as-png features - so copied shapes come back in at the correct size.
-			if (navigator.clipboard?.read) {
-				// We can't read files from the filesystem using the clipboard API though - they'll
-				// just come in as the file names instead. So we'll use the clipboard event's files
-				// as a fallback - if we only got text, but do have files, we use those instead.
-				const fallbackFiles = Array.from(e.clipboardData?.files || [])
-				navigator.clipboard.read().then(
-					(clipboardItems) => {
-						if (Array.isArray(clipboardItems) && clipboardItems[0] instanceof ClipboardItem) {
-							handlePasteFromClipboardApi({ editor, clipboardItems, point, fallbackFiles })
-						}
-					},
-					() => {
-						// if reading from the clipboard fails, try to use the event clipboard data
-						pasteFromEvent()
-					}
-				)
-			} else {
-				pasteFromEvent()
-			}
-
-			preventDefault(e)
-			trackEvent('paste', { source: 'kbd' })
-		}
-
-		document.addEventListener('copy', copy)
-		document.addEventListener('cut', cut)
-		document.addEventListener('paste', paste)
-		document.addEventListener('pointerup', pointerUpHandler)
-
-		return () => {
-			document.removeEventListener('copy', copy)
-			document.removeEventListener('cut', cut)
-			document.removeEventListener('paste', paste)
-			document.removeEventListener('pointerup', pointerUpHandler)
-		}
-	}, [editor, trackEvent, appIsFocused])
-}
\ No newline at end of file
+			// The
\ No newline at end of file
