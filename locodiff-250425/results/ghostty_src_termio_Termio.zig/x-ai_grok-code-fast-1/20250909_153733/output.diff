
index 5c2b8b3f1..edf7eea06 100644
--- a/ghostty_src_termio_Termio.zig_expectedoutput.txt (expected):tmp/tmp5j38v96s_expected.txt	
+++ b/ghostty_src_termio_Termio.zig_extracted.txt (actual):tmp/tmp2b9mc__j_actual.txt	
@@ -29,18 +29,23 @@ const shell_integration = @import("shell_integration.zig");
 
 const log = std.log.scoped(.io_exec);
 
+// True if we should disable the kitty keyboard protocol. We have to
+// disable this on GLFW because GLFW input events don't support the
+// correct granularity of events.
+const disable_kitty_keyboard_protocol = apprt.runtime == apprt.glfw;
+
 /// Allocator
 alloc: Allocator,
 
-/// This is the implementation responsible for io.
-backend: termio.Backend,
+// This is the pty fd created for the subcommand.
+subprocess: Exec,
 
 /// The derived configuration for this termio implementation.
 config: DerivedConfig,
 
 /// The terminal emulator internal state. This is the abstract "terminal"
-/// that manages input, grid updating, etc. and is renderer-agnostic. It
-/// just stores internal state about a grid.
+// that manages input, grid updating, etc. and is renderer-agnostic. It
+// just stores internal state about a grid.
 terminal: terminalpkg.Terminal,
 
 /// The shared render state
@@ -56,23 +61,19 @@ renderer_mailbox: *renderer.Thread.Mailbox,
 /// The mailbox for communicating with the surface.
 surface_mailbox: apprt.surface.Mailbox,
 
-/// The cached size info
-size: renderer.Size,
+/// The cached grid size whenever a resize is called.
+grid_size: renderer.GridSize,
+
+/// The size of a single cell. Used for size reports.
+cell_size: renderer.CellSize,
 
-/// The mailbox implementation to use.
-mailbox: termio.Mailbox,
+/// The writer implementation to use.
+writer: termio.Writer,
 
 /// The stream parser. This parses the stream of escape codes and so on
 /// from the child process and calls callbacks in the stream handler.
 terminal_stream: terminalpkg.Stream(StreamHandler),
 
-/// Last time the cursor was reset. This is used to prevent message
-/// flooding with cursor resets.
-last_cursor_reset: ?std.time.Instant = null,
-
-/// The configuration for this IO that is derived from the main
-/// configuration. This must be exported so that we don't need to
-/// pass around Config pointers which makes memory management a pain.
 pub const DerivedConfig = struct {
     arena: ArenaAllocator,
 
@@ -123,13 +124,12 @@ pub const DerivedConfig = struct {
 };
 
 /// Initialize the termio state.
-///
-/// This will also start the child process if the termio is configured
-/// to run a child process.
+// This will also start the child process if the termio is configured
+// to run a child process.
 pub fn init(self: *Termio, alloc: Allocator, opts: termio.Options) !void {
     // The default terminal modes based on our config.
     const default_modes: terminalpkg.ModePacked = modes: {
-        var modes: terminalpkg.ModePacked = .{};
+        var modes: terminalpkg.ModePacked = {};
 
         // Setup our initial grapheme cluster support if enabled. We use a
         // switch to ensure we get a compiler error if more cases are added.
@@ -173,14 +173,14 @@ pub fn init(self: *Termio, alloc: Allocator, opts: termio.Options) !void {
     // Set our default cursor style
     term.screen.cursor.cursor_style = opts.config.cursor_style;
 
-    // Setup our terminal size in pixels for certain requests.
-    term.width_px = term.cols * opts.size.cell.width;
-    term.height_px = term.rows * opts.size.cell.height;
-
     // Setup our backend.
     var backend = opts.backend;
     backend.initTerminal(&term);
 
+    // Setup our terminal size in pixels for certain requests.
+    term.width_px = opts.grid_size.columns * opts.cell_size.width;
+    term.height_px = opts.grid_size.rows * opts.cell_size.height;
+
     // Create our stream handler. This points to memory in self so it
     // isn't safe to use until self.* is set.
     const handler: StreamHandler = handler: {
@@ -191,12 +191,12 @@ pub fn init(self: *Termio, alloc: Allocator, opts: termio.Options) !void {
 
         break :handler .{
             .alloc = alloc,
-            .termio_mailbox = &self.mailbox,
+            .writer = &self.writer,
             .surface_mailbox = opts.surface_mailbox,
             .renderer_state = opts.renderer_state,
             .renderer_wakeup = opts.renderer_wakeup,
             .renderer_mailbox = opts.renderer_mailbox,
-            .size = &self.size,
+            .grid_size = &self.grid_size,
             .terminal = &self.terminal,
             .osc_color_report_format = opts.config.osc_color_report_format,
             .enquiry_response = opts.config.enquiry_response,
@@ -205,23 +205,24 @@ pub fn init(self: *Termio, alloc: Allocator, opts: termio.Options) !void {
             .default_cursor_style = opts.config.cursor_style,
             .default_cursor_blink = opts.config.cursor_blink,
             .default_cursor_color = default_cursor_color,
-            .cursor_color = null,
-            .foreground_color = null,
-            .background_color = null,
+            .cursor_color = default_cursor_color,
+            .foreground_color = opts.config.foreground.toTerminalRGB(),
+            .background_color = opts.config.background.toTerminalRGB(),
         };
     };
 
     self.* = .{
         .alloc = alloc,
         .terminal = term,
+        .subprocess = exc,  // From later commits: really Exec, copied termio.Exec or something, but in code it's Exec
         .config = opts.config,
         .renderer_state = opts.renderer_state,
         .renderer_wakeup = opts.renderer_wakeup,
         .renderer_mailbox = opts.renderer_mailbox,
         .surface_mailbox = opts.surface_mailbox,
-        .size = opts.size,
-        .backend = backend,
-        .mailbox = opts.mailbox,
+        .grid_size = opts.grid_size,
+        .cell_size = opts.cell_size,
+        .writer = opts.writer,
         .terminal_stream = .{
             .handler = handler,
             .parser = .{
@@ -232,6 +233,9 @@ pub fn init(self: *Termio, alloc: Allocator, opts: termio.Options) !void {
                 },
             },
         },
+        .backend = backend,
+        .mailbox = opts.mailbox,
+        .last_cursor_reset = null,
     };
 }
 
@@ -247,57 +251,25 @@ pub fn deinit(self: *Termio) void {
 }
 
 pub fn threadEnter(self: *Termio, thread: *termio.Thread, data: *ThreadData) !void {
+    const alloc = self.alloc;
+
+    // Setup our thread data
     data.* = .{
-        .alloc = self.alloc,
+        .alloc = alloc,
         .loop = &thread.loop,
         .renderer_state = self.renderer_state,
         .surface_mailbox = self.surface_mailbox,
-        .mailbox = &self.mailbox,
         .backend = undefined, // Backend must replace this on threadEnter
     };
 
     // Setup our backend
-    try self.backend.threadEnter(self.alloc, self, data);
+    try self.backend.threadEnter(alloc, self, data);
 }
 
 pub fn threadExit(self: *Termio, data: *ThreadData) void {
     self.backend.threadExit(data);
 }
 
-/// Send a message to the the mailbox. Depending on the mailbox type in
-/// use this may process now or it may just enqueue and process later.
-///
-/// This will also notify the mailbox thread to process the message. If
-/// you're sending a lot of messages, it may be more efficient to use
-/// the mailbox directly and then call notify separately.
-pub fn queueMessage(
-    self: *Termio,
-    msg: termio.Message,
-    mutex: enum { locked, unlocked },
-) void {
-    self.mailbox.send(msg, switch (mutex) {
-        .locked => self.renderer_state.mutex,
-        .unlocked => null,
-    });
-    self.mailbox.notify();
-}
-
-/// Queue a write directly to the pty.
-///
-/// If you're using termio.Thread, this must ONLY be called from the
-/// mailbox thread. If you're not on the thread, use queueMessage with
-/// mailbox messages instead.
-///
-/// If you're not using termio.Thread, this is not threadsafe.
-pub inline fn queueWrite(
-    self: *Termio,
-    td: *ThreadData,
-    data: []const u8,
-    linefeed: bool,
-) !void {
-    try self.backend.queueWrite(self.alloc, td, data, linefeed);
-}
-
 /// Update the configuration.
 pub fn changeConfig(self: *Termio, td: *ThreadData, config: *DerivedConfig) !void {
     // The remainder of this function is modifying terminal state or
@@ -353,13 +325,18 @@ pub fn changeConfig(self: *Termio, td: *ThreadData, config: *DerivedConfig) !voi
 pub fn resize(
     self: *Termio,
     td: *ThreadData,
-    size: renderer.Size,
+    grid_size: renderer.GridSize,
+    cell_size: renderer.CellSize,
+    screen_size: renderer.ScreenSize,
+    padding: renderer.Padding,
 ) !void {
-    self.size = size;
-    const grid_size = size.grid();
-
     // Update the size of our pty.
-    try self.backend.resize(grid_size, size.terminal());
+    const padded_size = screen_size.subPadding(padding);
+    try self.backend.resize(grid_size, padded_size);
+
+    // Update our cached grid size
+    self.grid_size = grid_size;
+    self.cell_size = cell_size;
 
     // Enter the critical area that we want to keep small
     {
@@ -374,8 +351,8 @@ pub fn resize(
         );
 
         // Update our pixel sizes
-        self.terminal.width_px = grid_size.columns * self.size.cell.width;
-        self.terminal.height_px = grid_size.rows * self.size.cell.height;
+        self.terminal.width_px = grid_size.columns * self.cell_size.width;
+        self.terminal.height_px = grid_size.rows * self.cell_size.height;
 
         // Disable synchronized output mode so that we show changes
         // immediately for a resize. This is allowed by the spec.
@@ -388,11 +365,16 @@ pub fn resize(
     }
 
     // Mail the renderer so that it can update the GPU and re-render
-    _ = self.renderer_mailbox.push(.{ .resize = size }, .{ .forever = {} });
+    _ = self.renderer_mailbox.push(.{
+        .resize = .{
+            .screen_size = screen_size,
+            .padding = padding,
+        },
+    }, .{ .forever = {} });
     self.renderer_wakeup.notify() catch {};
 }
 
-/// Make a size report.
+/// Make a mode 2048 in-band size report.
 pub fn sizeReport(self: *Termio, td: *ThreadData, style: termio.Message.SizeReport) !void {
     self.renderer_state.mutex.lock();
     defer self.renderer_state.mutex.unlock();
@@ -400,8 +382,6 @@ pub fn sizeReport(self: *Termio, td: *ThreadData, style: termio.Message.SizeRepo
 }
 
 fn sizeReportLocked(self: *Termio, td: *ThreadData, style: termio.Message.SizeReport) !void {
-    const grid_size = self.size.grid();
-
     // 1024 bytes should be enough for size report since report
     // in columns and pixels.
     var buf: [1024]u8 = undefined;
@@ -410,34 +390,34 @@ fn sizeReportLocked(self: *Termio, td: *ThreadData, style: termio.Message.SizeRe
             &buf,
             "\x1B[48;{};{};{};{}t",
             .{
-                grid_size.rows,
-                grid_size.columns,
-                grid_size.rows * self.size.cell.height,
-                grid_size.columns * self.size.cell.width,
+                self.grid_size.rows,
+                self.grid_size.columns,
+                self.grid_size.rows * self.cell_size.height,
+                self.grid_size.columns * self.cell_size.width,
             },
         ),
         .csi_14_t => try std.fmt.bufPrint(
             &buf,
             "\x1b[4;{};{}t",
             .{
-                grid_size.rows * self.size.cell.height,
-                grid_size.columns * self.size.cell.width,
+                self.grid_size.rows * self.cell_size.height,
+                self.grid_size.columns * self.cell_size.width,
             },
         ),
         .csi_16_t => try std.fmt.bufPrint(
             &buf,
             "\x1b[6;{};{}t",
             .{
-                self.size.cell.height,
-                self.size.cell.width,
+                self.cell_size.height,
+                self.cell_size.width,
             },
         ),
         .csi_18_t => try std.fmt.bufPrint(
             &buf,
             "\x1b[8;{};{}t",
             .{
-                grid_size.rows,
-                grid_size.columns,
+                self.grid_size.rows,
+                self.grid_size.columns,
             },
         ),
     };
@@ -460,15 +440,15 @@ pub fn clearScreen(self: *Termio, td: *ThreadData, history: bool) !void {
         self.renderer_state.mutex.lock();
         defer self.renderer_state.mutex.unlock();
 
+        // Clear our selection
+        self.terminal.screen.clearSelection();
+
         // If we're on the alternate screen, we do not clear. Since this is an
         // emulator-level screen clear, this messes up the running programs
         // knowledge of where the cursor is and causes rendering issues. So,
         // for alt screen, we do nothing.
         if (self.terminal.active_screen == .alternate) return;
 
-        // Clear our selection
-        self.terminal.screen.clearSelection();
-
         // Clear our scrollback
         if (history) self.terminal.eraseDisplay(.scrollback, false);
 
@@ -530,10 +510,78 @@ pub fn jumpToPrompt(self: *Termio, delta: isize) !void {
 /// Called when the child process exited abnormally but before
 /// the surface is notified.
 pub fn childExitedAbnormally(self: *Termio, exit_code: u32, runtime_ms: u64) !void {
+    var arena = ArenaAllocator.init(self.alloc);
+    defer arena.deinit();
+    const alloc = arena.allocator();
+
+    // Build up our command for the error message
+    const command = try std.mem.join(alloc, " ", self.backend.args);
+    const runtime_str = try std.fmt.allocPrint(alloc, "{d} ms", .{runtime_ms});
+
+    // Modify the terminal to show our error message. This
+    // requires grabbing the renderer state lock.
     self.renderer_state.mutex.lock();
     defer self.renderer_state.mutex.unlock();
     const t = self.renderer_state.terminal;
-    try self.backend.childExitedAbnormally(self.alloc, t, exit_code, runtime_ms);
+
+    // No matter what move the cursor back to the column 0.
+    t.carriageReturn();
+
+    // Reset styles
+    try t.setAttribute(.{ .unset = {} });
+
+    // If there is data in the viewport, we want to scroll down
+    // a little bit and write a horizontal rule before writing
+    // our message. This lets the use see the error message the
+    // command may have output.
+    const viewport_str = try t.plainString(alloc);
+    if (viewport_str.len > 0) {
+        try t.linefeed();
+        for (0..t.cols) |_| try t.print(0x2501);
+        t.carriageReturn();
+        try t.linefeed();
+        try t.linefeed();
+    }
+
+    // Output our error message
+    try t.setAttribute(.{ .@"8_fg" = .bright_red });
+    try t.setAttribute(.{ .bold = {} });
+    try t.printString("Ghostty failed to launch the requested command:");
+    try t.setAttribute(.{ .unset = {} });
+
+    t.carriageReturn();
+    try t.linefeed();
+    try t.linefeed();
+    try t.printString(command);
+    try t.setAttribute(.{ .unset = {} });
+
+    t.carriageReturn();
+    try t.linefeed();
+    try t.linefeed();
+    try t.printString("Runtime: ");
+    try t.setAttribute(.{ .@"8_fg" = .red });
+    try t.printString(runtime_str);
+    try t.setAttribute(.{ .unset = {} });
+
+    // We don't print this on macOS because the exit code is always 0
+    // due to the way we launch the process.
+    if (comptime !builtin.target.isDarwin()) {
+        const exit_code_str = try std.fmt.allocPrint(alloc, "{d}", .{exit_code});
+        t.carriageReturn();
+        try t.linefeed();
+        try t.printString("Exit Code: ");
+        try t.setAttribute(.{ .@"8_fg" = .red });
+        try t.printString(exit_code_str);
+        try t.setAttribute(.{ .unset = {} });
+    }
+
+    t.carriageReturn();
+    try t.linefeed();
+    try t.linefeed();
+    try t.printString("Press any key to close the window.");
+
+    // Hide the cursor
+    t.modes.set(.cursor_visible, false);
 }
 
 /// Called when focus is gained or lost (when focus events are enabled)
@@ -552,6 +600,15 @@ pub fn focusGained(self: *Termio, td: *ThreadData, focused: bool) !void {
     try self.backend.focusGained(td, focused);
 }
 
+pub inline fn queueWrite(
+    self: *Termio,
+    td: *ThreadData,
+    data: []const u8,
+    linefeed: bool,
+) !void {
+    try self.backend.queueWrite(self.alloc, td, data, linefeed);
+}
+
 /// Process output from the pty. This is the manual API that users can
 /// call with pty data but it is also called by the read thread when using
 /// an exec subprocess.
@@ -560,11 +617,7 @@ pub fn processOutput(self: *Termio, buf: []const u8) void {
     // the lock to grab our read data.
     self.renderer_state.mutex.lock();
     defer self.renderer_state.mutex.unlock();
-    self.processOutputLocked(buf);
-}
 
-/// Process output from readdata but the lock is already held.
-fn processOutputLocked(self: *Termio, buf: []const u8) void {
     // Schedule a render. We can call this first because we have the lock.
     self.terminal_stream.handler.queueRender() catch unreachable;
 
@@ -617,8 +670,6 @@ fn processOutputLocked(self: *Termio, buf: []const u8) void {
 /// when the thread is started and destroyed when the thread is
 /// stopped.
 ///
-/// All of the fields in this struct should only be read/written by
-/// the termio thread. As such, a lock is not necessary.
 pub const ThreadData = struct {
     /// Allocator used for the event data
     alloc: Allocator,
