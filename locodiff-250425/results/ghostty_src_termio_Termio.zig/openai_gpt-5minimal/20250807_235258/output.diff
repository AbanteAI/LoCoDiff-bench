
index 5c2b8b3f1..40bbea7b4 100644
--- a/ghostty_src_termio_Termio.zig_expectedoutput.txt (expected):tmp/tmpm9mq11jo_expected.txt	
+++ b/ghostty_src_termio_Termio.zig_extracted.txt (actual):tmp/tmpiupzzi0f_actual.txt	
@@ -15,10 +15,11 @@ const posix = std.posix;
 const termio = @import("../termio.zig");
 const Command = @import("../Command.zig");
 const Pty = @import("../pty.zig").Pty;
+const SegmentedPool = @import("../segmented_pool.zig").SegmentedPool;
 const StreamHandler = @import("stream_handler.zig").StreamHandler;
-const terminalpkg = @import("../terminal/main.zig");
+const terminal = @import("../terminal/main.zig");
 const terminfo = @import("../terminfo/main.zig");
-const xev = @import("../global.zig").xev;
+const xev = @import("xev");
 const renderer = @import("../renderer.zig");
 const apprt = @import("../apprt.zig");
 const fastmem = @import("../fastmem.zig");
@@ -41,7 +42,7 @@ config: DerivedConfig,
 /// The terminal emulator internal state. This is the abstract "terminal"
 /// that manages input, grid updating, etc. and is renderer-agnostic. It
 /// just stores internal state about a grid.
-terminal: terminalpkg.Terminal,
+terminal: terminal.Terminal,
 
 /// The shared render state
 renderer_state: *renderer.State,
@@ -56,15 +57,15 @@ renderer_mailbox: *renderer.Thread.Mailbox,
 /// The mailbox for communicating with the surface.
 surface_mailbox: apprt.surface.Mailbox,
 
-/// The cached size info
-size: renderer.Size,
+/// The cached grid size whenever a resize is called.
+grid_size: renderer.GridSize,
 
 /// The mailbox implementation to use.
 mailbox: termio.Mailbox,
 
 /// The stream parser. This parses the stream of escape codes and so on
 /// from the child process and calls callbacks in the stream handler.
-terminal_stream: terminalpkg.Stream(StreamHandler),
+terminal_stream: terminal.Stream(StreamHandler),
 
 /// Last time the cursor was reset. This is used to prevent message
 /// flooding with cursor resets.
@@ -76,12 +77,11 @@ last_cursor_reset: ?std.time.Instant = null,
 pub const DerivedConfig = struct {
     arena: ArenaAllocator,
 
-    palette: terminalpkg.color.Palette,
+    palette: terminal.color.Palette,
     image_storage_limit: usize,
-    cursor_style: terminalpkg.CursorStyle,
+    cursor_style: terminal.CursorStyle,
     cursor_blink: ?bool,
     cursor_color: ?configpkg.Config.Color,
-    cursor_invert: bool,
     foreground: configpkg.Config.Color,
     background: configpkg.Config.Color,
     osc_color_report_format: configpkg.Config.OSCColorReportFormat,
@@ -103,7 +103,6 @@ pub const DerivedConfig = struct {
             .cursor_style = config.@"cursor-style",
             .cursor_blink = config.@"cursor-style-blink",
             .cursor_color = config.@"cursor-color",
-            .cursor_invert = config.@"cursor-invert-fg-bg",
             .foreground = config.foreground,
             .background = config.background,
             .osc_color_report_format = config.@"osc-color-report-format",
@@ -127,37 +126,23 @@ pub const DerivedConfig = struct {
 /// This will also start the child process if the termio is configured
 /// to run a child process.
 pub fn init(self: *Termio, alloc: Allocator, opts: termio.Options) !void {
-    // The default terminal modes based on our config.
-    const default_modes: terminalpkg.ModePacked = modes: {
-        var modes: terminalpkg.ModePacked = .{};
-
-        // Setup our initial grapheme cluster support if enabled. We use a
-        // switch to ensure we get a compiler error if more cases are added.
-        switch (opts.full_config.@"grapheme-width-method") {
-            .unicode => modes.grapheme_cluster = true,
-            .legacy => {},
-        }
-
-        // Set default cursor blink settings
-        modes.cursor_blinking = opts.config.cursor_blink orelse true;
-
-        break :modes modes;
-    };
-
     // Create our terminal
-    var term = try terminalpkg.Terminal.init(alloc, opts: {
-        const grid_size = opts.size.grid();
-        break :opts .{
-            .cols = grid_size.columns,
-            .rows = grid_size.rows,
-            .max_scrollback = opts.full_config.@"scrollback-limit",
-            .default_modes = default_modes,
-        };
+    var term = try terminal.Terminal.init(alloc, .{
+        .cols = opts.grid_size.columns,
+        .rows = opts.grid_size.rows,
+        .max_scrollback = opts.full_config.@"scrollback-limit",
     });
     errdefer term.deinit(alloc);
     term.default_palette = opts.config.palette;
     term.color_palette.colors = opts.config.palette;
 
+    // Setup our initial grapheme cluster support if enabled. We use a
+    // switch to ensure we get a compiler error if more cases are added.
+    switch (opts.full_config.@"grapheme-width-method") {
+        .unicode => term.modes.set(.grapheme_cluster, true),
+        .legacy => {},
+    }
+
     // Set the image size limits
     try term.screen.kitty_images.setLimit(
         alloc,
@@ -170,22 +155,29 @@ pub fn init(self: *Termio, alloc: Allocator, opts: termio.Options) !void {
         opts.config.image_storage_limit,
     );
 
+    // Set default cursor blink settings
+    term.modes.set(
+        .cursor_blinking,
+        opts.config.cursor_blink orelse true,
+    );
+
     // Set our default cursor style
     term.screen.cursor.cursor_style = opts.config.cursor_style;
 
-    // Setup our terminal size in pixels for certain requests.
-    term.width_px = term.cols * opts.size.cell.width;
-    term.height_px = term.rows * opts.size.cell.height;
-
     // Setup our backend.
     var backend = opts.backend;
     backend.initTerminal(&term);
 
+    // Setup our terminal size in pixels for certain requests.
+    const screen_size = opts.screen_size.subPadding(opts.padding);
+    term.width_px = screen_size.width;
+    term.height_px = screen_size.height;
+
     // Create our stream handler. This points to memory in self so it
     // isn't safe to use until self.* is set.
     const handler: StreamHandler = handler: {
-        const default_cursor_color = if (!opts.config.cursor_invert and opts.config.cursor_color != null)
-            opts.config.cursor_color.?.toTerminalRGB()
+        const default_cursor_color = if (opts.config.cursor_color) |col|
+            col.toTerminalRGB()
         else
             null;
 
@@ -196,7 +188,7 @@ pub fn init(self: *Termio, alloc: Allocator, opts: termio.Options) !void {
             .renderer_state = opts.renderer_state,
             .renderer_wakeup = opts.renderer_wakeup,
             .renderer_mailbox = opts.renderer_mailbox,
-            .size = &self.size,
+            .grid_size = &self.grid_size,
             .terminal = &self.terminal,
             .osc_color_report_format = opts.config.osc_color_report_format,
             .enquiry_response = opts.config.enquiry_response,
@@ -205,9 +197,9 @@ pub fn init(self: *Termio, alloc: Allocator, opts: termio.Options) !void {
             .default_cursor_style = opts.config.cursor_style,
             .default_cursor_blink = opts.config.cursor_blink,
             .default_cursor_color = default_cursor_color,
-            .cursor_color = null,
-            .foreground_color = null,
-            .background_color = null,
+            .cursor_color = default_cursor_color,
+            .foreground_color = opts.config.foreground.toTerminalRGB(),
+            .background_color = opts.config.background.toTerminalRGB(),
         };
     };
 
@@ -219,8 +211,8 @@ pub fn init(self: *Termio, alloc: Allocator, opts: termio.Options) !void {
         .renderer_wakeup = opts.renderer_wakeup,
         .renderer_mailbox = opts.renderer_mailbox,
         .surface_mailbox = opts.surface_mailbox,
-        .size = opts.size,
-        .backend = backend,
+        .grid_size = opts.grid_size,
+        .backend = opts.backend,
         .mailbox = opts.mailbox,
         .terminal_stream = .{
             .handler = handler,
@@ -353,13 +345,16 @@ pub fn changeConfig(self: *Termio, td: *ThreadData, config: *DerivedConfig) !voi
 pub fn resize(
     self: *Termio,
     td: *ThreadData,
-    size: renderer.Size,
+    grid_size: renderer.GridSize,
+    screen_size: renderer.ScreenSize,
+    padding: renderer.Padding,
 ) !void {
-    self.size = size;
-    const grid_size = size.grid();
-
     // Update the size of our pty.
-    try self.backend.resize(grid_size, size.terminal());
+    const padded_size = screen_size.subPadding(padding);
+    try self.backend.resize(grid_size, padded_size);
+
+    // Update our cached grid size
+    self.grid_size = grid_size;
 
     // Enter the critical area that we want to keep small
     {
@@ -374,75 +369,20 @@ pub fn resize(
         );
 
         // Update our pixel sizes
-        self.terminal.width_px = grid_size.columns * self.size.cell.width;
-        self.terminal.height_px = grid_size.rows * self.size.cell.height;
+        self.terminal.width_px = padded_size.width;
+        self.terminal.height_px = padded_size.height;
 
         // Disable synchronized output mode so that we show changes
         // immediately for a resize. This is allowed by the spec.
         self.terminal.modes.set(.synchronized_output, false);
 
-        // If we have size reporting enabled we need to send a report.
-        if (self.terminal.modes.get(.in_band_size_reports)) {
-            try self.sizeReportLocked(td, .mode_2048);
-        }
+        // Wake up our renderer so any changes will be shown asap
+        self.renderer_wakeup.notify() catch {};
     }
 
-    // Mail the renderer so that it can update the GPU and re-render
-    _ = self.renderer_mailbox.push(.{ .resize = size }, .{ .forever = {} });
-    self.renderer_wakeup.notify() catch {};
-}
-
-/// Make a size report.
-pub fn sizeReport(self: *Termio, td: *ThreadData, style: termio.Message.SizeReport) !void {
-    self.renderer_state.mutex.lock();
-    defer self.renderer_state.mutex.unlock();
-    try self.sizeReportLocked(td, style);
-}
-
-fn sizeReportLocked(self: *Termio, td: *ThreadData, style: termio.Message.SizeReport) !void {
-    const grid_size = self.size.grid();
-
-    // 1024 bytes should be enough for size report since report
-    // in columns and pixels.
-    var buf: [1024]u8 = undefined;
-    const message = switch (style) {
-        .mode_2048 => try std.fmt.bufPrint(
-            &buf,
-            "\x1B[48;{};{};{};{}t",
-            .{
-                grid_size.rows,
-                grid_size.columns,
-                grid_size.rows * self.size.cell.height,
-                grid_size.columns * self.size.cell.width,
-            },
-        ),
-        .csi_14_t => try std.fmt.bufPrint(
-            &buf,
-            "\x1b[4;{};{}t",
-            .{
-                grid_size.rows * self.size.cell.height,
-                grid_size.columns * self.size.cell.width,
-            },
-        ),
-        .csi_16_t => try std.fmt.bufPrint(
-            &buf,
-            "\x1b[6;{};{}t",
-            .{
-                self.size.cell.height,
-                self.size.cell.width,
-            },
-        ),
-        .csi_18_t => try std.fmt.bufPrint(
-            &buf,
-            "\x1b[8;{};{}t",
-            .{
-                grid_size.rows,
-                grid_size.columns,
-            },
-        ),
-    };
-
-    try self.queueWrite(td, message, false);
+    // This notification must be sent AFTER we resized the terminal and pty
+    // so that the reports return proper values.
+    _ = self.mailbox.push(.{ .size_changed = {} }, .{ .instant = {} });
 }
 
 /// Reset the synchronized output mode. This is usually called by timer
@@ -466,9 +406,6 @@ pub fn clearScreen(self: *Termio, td: *ThreadData, history: bool) !void {
         // for alt screen, we do nothing.
         if (self.terminal.active_screen == .alternate) return;
 
-        // Clear our selection
-        self.terminal.screen.clearSelection();
-
         // Clear our scrollback
         if (history) self.terminal.eraseDisplay(.scrollback, false);
 
@@ -481,18 +418,6 @@ pub fn clearScreen(self: *Termio, td: *ThreadData, history: bool) !void {
                 );
             }
 
-            // Clear all Kitty graphics state for this screen. This copies
-            // Kitty's behavior when Cmd+K deletes all Kitty graphics. I
-            // didn't spend time researching whether it only deletes Kitty
-            // graphics that are placed baove the cursor or if it deletes
-            // all of them. We delete all of them for now but if this behavior
-            // isn't fully correct we should fix this later.
-            self.terminal.screen.kitty_images.delete(
-                self.terminal.screen.alloc,
-                &self.terminal,
-                .{ .all = true },
-            );
-
             return;
         }
 
@@ -510,7 +435,7 @@ pub fn clearScreen(self: *Termio, td: *ThreadData, history: bool) !void {
 }
 
 /// Scroll the viewport
-pub fn scrollViewport(self: *Termio, scroll: terminalpkg.Terminal.ScrollViewport) !void {
+pub fn scrollViewport(self: *Termio, scroll: terminal.Terminal.ScrollViewport) !void {
     self.renderer_state.mutex.lock();
     defer self.renderer_state.mutex.unlock();
     try self.terminal.scrollViewport(scroll);
@@ -536,22 +461,6 @@ pub fn childExitedAbnormally(self: *Termio, exit_code: u32, runtime_ms: u64) !vo
     try self.backend.childExitedAbnormally(self.alloc, t, exit_code, runtime_ms);
 }
 
-/// Called when focus is gained or lost (when focus events are enabled)
-pub fn focusGained(self: *Termio, td: *ThreadData, focused: bool) !void {
-    self.renderer_state.mutex.lock();
-    const focus_event = self.renderer_state.terminal.modes.get(.focus_event);
-    self.renderer_state.mutex.unlock();
-
-    // If we have focus events enabled, we send the focus event.
-    if (focus_event) {
-        const seq = if (focused) "\x1b[I" else "\x1b[O";
-        try self.queueWrite(td, seq, false);
-    }
-
-    // We always notify our backend of focus changes.
-    try self.backend.focusGained(td, focused);
-}
-
 /// Process output from the pty. This is the manual API that users can
 /// call with pty data but it is also called by the read thread when using
 /// an exec subprocess.
