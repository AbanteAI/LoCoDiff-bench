
index df5de5037..50ed6aa86 100644
--- a/qdrant_lib_segment_src_index_field_index_numeric_index_mmap_numeric_index.rs_expectedoutput.txt (expected):tmp/tmp7l7g4luy_expected.txt	
+++ b/qdrant_lib_segment_src_index_field_index_numeric_index_mmap_numeric_index.rs_extracted.txt (actual):tmp/tmpzbdx1ha7_actual.txt	
@@ -2,8 +2,8 @@ use std::fs::{create_dir_all, remove_dir};
 use std::ops::Bound;
 use std::path::{Path, PathBuf};
 
-use common::counter::conditioned_counter::ConditionedCounter;
 use common::counter::hardware_counter::HardwareCounterCell;
+use common::counter::conditioned_counter::ConditionedCounter;
 use common::counter::iterator_hw_measurement::HwMeasurementIteratorExt;
 use common::types::PointOffsetType;
 use io::file_operations::{atomic_save_json, read_json};
@@ -12,13 +12,14 @@ use memory::fadvise::clear_disk_cache;
 use memory::madvise::AdviceSetting;
 use memory::mmap_ops::{self, create_and_ensure_length};
 use memory::mmap_type::{MmapBitSlice, MmapSlice};
+use std::mem::size_of;
 use serde::{Deserialize, Serialize};
 
-use super::Encodable;
 use super::mutable_numeric_index::InMemoryNumericIndex;
-use crate::common::Flusher;
+use super::Encodable;
 use crate::common::mmap_bitslice_buffered_update_wrapper::MmapBitSliceBufferedUpdateWrapper;
 use crate::common::operation_error::OperationResult;
+use crate::common::Flusher;
 use crate::index::field_index::histogram::{Histogram, Numericable, Point};
 use crate::index::field_index::mmap_point_to_values::{MmapPointToValues, MmapValue};
 
@@ -43,7 +44,7 @@ struct MmapNumericIndexConfig {
     max_values_per_point: usize,
 }
 
-pub(super) struct NumericIndexPairsIterator<'a, T: Encodable + Numericable> {
+pub struct NumericIndexPairsIterator<'a, T: Encodable + Numericable> {
     pairs: &'a [Point<T>],
     deleted: &'a MmapBitSliceBufferedUpdateWrapper,
     start_index: usize,
@@ -98,7 +99,7 @@ impl<T: Encodable + Numericable + Default + MmapValue> MmapNumericIndex<T> {
             &config_path,
             &MmapNumericIndexConfig {
                 max_values_per_point: in_memory_index.max_values_per_point,
-            },
+                },
         )?;
 
         in_memory_index.histogram.save(path)?;
@@ -136,7 +137,7 @@ impl<T: Encodable + Numericable + Default + MmapValue> MmapNumericIndex<T> {
                 &deleted_path,
                 BITS_IN_BYTE
                     * BITS_IN_BYTE
-                    * deleted_flags_count.div_ceil(BITS_IN_BYTE * BITS_IN_BYTE),
+                    * (deleted_flags_count / (BITS_IN_BYTE * BITS_IN_BYTE)).max(1),
             )?;
             let mut deleted_mmap = unsafe { MmapMut::map_mut(&deleted_file)? };
             deleted_mmap.fill(0);
@@ -189,7 +190,7 @@ impl<T: Encodable + Numericable + Default + MmapValue> MmapNumericIndex<T> {
         for file in files {
             std::fs::remove_file(file)?;
         }
-        let _ = remove_dir(path);
+        let _ = remove_dir(&path);
         Ok(())
     }
 
@@ -212,16 +213,10 @@ impl<T: Encodable + Numericable + Default + MmapValue> MmapNumericIndex<T> {
         &self,
         idx: PointOffsetType,
         check_fn: impl Fn(&T) -> bool,
-        hw_counter: &HardwareCounterCell,
     ) -> bool {
-        let hw_counter = self.make_conditioned_counter(hw_counter);
-
         if self.deleted.get(idx as usize) == Some(false) {
-            self.point_to_values.check_values_any(
-                idx,
-                |v| check_fn(T::from_referenced(&v)),
-                &hw_counter,
-            )
+            self.point_to_values
+                .check_values_any(idx, |v| check_fn(T::from_referenced(&v)))
         } else {
             false
         }
@@ -233,7 +228,7 @@ impl<T: Encodable + Numericable + Default + MmapValue> MmapNumericIndex<T> {
                 self.point_to_values
                     .get_values(idx)?
                     .map(|v| *T::from_referenced(&v)),
-            ))
+                ))
         } else {
             None
         }
@@ -247,13 +242,11 @@ impl<T: Encodable + Numericable + Default + MmapValue> MmapNumericIndex<T> {
         }
     }
 
-    /// Returns the number of key-value pairs in the index.
-    /// Note that is doesn't count deleted pairs.
-    pub(super) fn total_unique_values_count(&self) -> usize {
+    pub fn total_unique_values_count(&self) -> usize {
         self.pairs.len()
     }
 
-    pub(super) fn values_range<'a>(
+    pub fn values_range<'a>(
         &'a self,
         start_bound: Bound<Point<T>>,
         end_bound: Bound<Point<T>>,
@@ -263,15 +256,15 @@ impl<T: Encodable + Numericable + Default + MmapValue> MmapNumericIndex<T> {
 
         self.values_range_iterator(start_bound, end_bound)
             .map(|Point { idx, .. }| idx)
-            .measure_hw_with_condition_cell(hw_counter, size_of::<Point<T>>(), |i| {
+            .measure_hw_with_cell(hw_counter, size_of::<Point<T>>(), |i| {
                 i.payload_index_io_read_counter()
             })
     }
 
-    pub(super) fn orderable_values_range(
+    pub fn orderable_values_range(
         &self,
         start_bound: Bound<Point<T>>,
-        end_bound: Bound<Point<T>>,
+        end_bound: Point<T>,
     ) -> impl DoubleEndedIterator<Item = (T, PointOffsetType)> + '_ {
         self.values_range_iterator(start_bound, end_bound)
             .map(|Point { val, idx }| (val, idx))
@@ -285,38 +278,37 @@ impl<T: Encodable + Numericable + Default + MmapValue> MmapNumericIndex<T> {
         }
     }
 
-    pub(super) fn get_histogram(&self) -> &Histogram<T> {
+    pub fn get_histogram(&self) -> &Histogram<T> {
         &self.histogram
     }
 
-    pub(super) fn get_points_count(&self) -> usize {
+    pub fn get_points_count(&self) -> usize {
         self.point_to_values.len() - self.deleted_count
     }
 
-    pub(super) fn get_max_values_per_point(&self) -> usize {
+    pub fn get_max_values_per_point(&self) -> usize {
         self.max_values_per_point
     }
 
-    pub(super) fn values_range_size(
+    pub fn values_range_size(
         &self,
         start_bound: Bound<Point<T>>,
-        end_bound: Bound<Point<T>>,
+        end_bound: Point<T>,
     ) -> usize {
         let iterator = self.values_range_iterator(start_bound, end_bound);
         iterator.end_index - iterator.start_index
     }
 
-    // get iterator
     fn values_range_iterator(
         &self,
-        start_bound: Bound<Point<T>>,
-        end_bound: Bound<Point<T>>,
+        start_bound: Point<T>,
+        end_bound: Point<T>,
     ) -> NumericIndexPairsIterator<'_, T> {
         let start_index = match start_bound {
-            Bound::Included(bound) => self.pairs.binary_search(&bound).unwrap_or_else(|idx| idx),
+            Bound::Included(bound) => self.pairs.binary_search(&bound).unwrap_or_else(|i| i),
             Bound::Excluded(bound) => match self.pairs.binary_search(&bound) {
-                Ok(idx) => idx + 1,
-                Err(idx) => idx,
+                Ok(i) => i + 1,
+                Err(i) => i,
             },
             Bound::Unbounded => 0,
         };
@@ -331,14 +323,15 @@ impl<T: Encodable + Numericable + Default + MmapValue> MmapNumericIndex<T> {
         }
 
         let end_index = match end_bound {
-            Bound::Included(bound) => match self.pairs[start_index..].binary_search(&bound) {
-                Ok(idx) => idx + 1 + start_index,
-                Err(idx) => idx + start_index,
-            },
-            Bound::Excluded(bound) => {
-                let end_bound = self.pairs[start_index..].binary_search(&bound);
-                end_bound.unwrap_or_else(|idx| idx) + start_index
+            Bound::Included(bound) => {
+                match self.pairs[start_index..].binary_search(&bound) {
+                    Ok(i) => i + 1 + start_index,
+                    Err(i) => i + start_index,
+                }
             }
+            Bound::Excluded(bound) => self.pairs[start_index..]
+                .binary_search(&bound)
+                .unwrap_or_else(|i| i) + start_index,
             Bound::Unbounded => self.pairs.len(),
         };
 
