
index df5de5037..7ba24ef14 100644
--- a/qdrant_lib_segment_src_index_field_index_numeric_index_mmap_numeric_index.rs_expectedoutput.txt (expected):tmp/tmpysy55zso_expected.txt	
+++ b/qdrant_lib_segment_src_index_field_index_numeric_index_mmap_numeric_index.rs_extracted.txt (actual):tmp/tmpepxmjnan_actual.txt	
@@ -268,117 +268,6 @@ impl<T: Encodable + Numericable + Default + MmapValue> MmapNumericIndex<T> {
             })
     }
 
-    pub(super) fn orderable_values_range(
-        &self,
-        start_bound: Bound<Point<T>>,
-        end_bound: Bound<Point<T>>,
-    ) -> impl DoubleEndedIterator<Item = (T, PointOffsetType)> + '_ {
-        self.values_range_iterator(start_bound, end_bound)
-            .map(|Point { val, idx }| (val, idx))
-    }
-
-    pub fn remove_point(&mut self, idx: PointOffsetType) {
-        let idx = idx as usize;
-        if idx < self.deleted.len() && !self.deleted.get(idx).unwrap_or(true) {
-            self.deleted.set(idx, true);
-            self.deleted_count += 1;
-        }
-    }
-
-    pub(super) fn get_histogram(&self) -> &Histogram<T> {
-        &self.histogram
-    }
-
-    pub(super) fn get_points_count(&self) -> usize {
-        self.point_to_values.len() - self.deleted_count
-    }
-
-    pub(super) fn get_max_values_per_point(&self) -> usize {
-        self.max_values_per_point
-    }
-
-    pub(super) fn values_range_size(
-        &self,
-        start_bound: Bound<Point<T>>,
-        end_bound: Bound<Point<T>>,
-    ) -> usize {
-        let iterator = self.values_range_iterator(start_bound, end_bound);
-        iterator.end_index - iterator.start_index
-    }
-
-    // get iterator
-    fn values_range_iterator(
-        &self,
-        start_bound: Bound<Point<T>>,
-        end_bound: Bound<Point<T>>,
-    ) -> NumericIndexPairsIterator<'_, T> {
-        let start_index = match start_bound {
-            Bound::Included(bound) => self.pairs.binary_search(&bound).unwrap_or_else(|idx| idx),
-            Bound::Excluded(bound) => match self.pairs.binary_search(&bound) {
-                Ok(idx) => idx + 1,
-                Err(idx) => idx,
-            },
-            Bound::Unbounded => 0,
-        };
-
-        if start_index >= self.pairs.len() {
-            return NumericIndexPairsIterator {
-                pairs: &self.pairs,
-                deleted: &self.deleted,
-                start_index: self.pairs.len(),
-                end_index: self.pairs.len(),
-            };
-        }
-
-        let end_index = match end_bound {
-            Bound::Included(bound) => match self.pairs[start_index..].binary_search(&bound) {
-                Ok(idx) => idx + 1 + start_index,
-                Err(idx) => idx + start_index,
-            },
-            Bound::Excluded(bound) => {
-                let end_bound = self.pairs[start_index..].binary_search(&bound);
-                end_bound.unwrap_or_else(|idx| idx) + start_index
-            }
-            Bound::Unbounded => self.pairs.len(),
-        };
-
-        NumericIndexPairsIterator {
-            pairs: &self.pairs,
-            deleted: &self.deleted,
-            start_index,
-            end_index,
-        }
-    }
-
-    fn make_conditioned_counter<'a>(
-        &self,
-        hw_counter: &'a HardwareCounterCell,
-    ) -> ConditionedCounter<'a> {
-        ConditionedCounter::new(self.is_on_disk, hw_counter)
-    }
-
-    pub fn is_on_disk(&self) -> bool {
-        self.is_on_disk
-    }
-
-    /// Populate all pages in the mmap.
-    /// Block until all pages are populated.
-    pub fn populate(&self) -> OperationResult<()> {
-        self.pairs.populate()?;
-        self.point_to_values.populate();
-        Ok(())
-    }
-
-    /// Drop disk cache.
-    pub fn clear_cache(&self) -> OperationResult<()> {
-        let pairs_path = self.path.join(PAIRS_PATH);
-        let deleted_path = self.path.join(DELETED_PATH);
-
-        clear_disk_cache(&pairs_path)?;
-        clear_disk_cache(&deleted_path)?;
-
-        self.point_to_values.clear_cache()?;
-
-        Ok(())
-    }
-}
\ No newline at end of file
+    pub(super) fn orderable_values_range<'a>(
+        &'a self,
+        start_bound: Bound<Point
\ No newline at end of file
