
index 1529ad147..fe5d37f76 100644
--- a/tldraw_packages_tldraw_src_lib_shapes_line_LineShapeUtil.tsx_expectedoutput.txt (expected):tmp/tmpt6iu6us__expected.txt	
+++ b/tldraw_packages_tldraw_src_lib_shapes_line_LineShapeUtil.tsx_extracted.txt (actual):tmp/tmpkgbn4r06_actual.txt	
@@ -1,3 +1,4 @@
+/* eslint-disable react-hooks/rules-of-hooks */
 import {
 	CubicSpline2d,
 	Group2d,
@@ -6,10 +7,10 @@ import {
 	SVGContainer,
 	ShapeUtil,
 	TLHandle,
-	TLHandleDragInfo,
 	TLLineShape,
 	TLLineShapePoint,
 	TLResizeInfo,
+	TLHandleDragInfo,
 	Vec,
 	WeakCache,
 	ZERO_INDEX_KEY,
@@ -24,20 +25,19 @@ import {
 	maybeSnapToGrid,
 	sortByIndex,
 } from '@tldraw/editor'
-
-import { STROKE_SIZES } from '../arrow/shared'
-import { useDefaultColorTheme } from '../shared/useDefaultColorTheme'
 import { getLineDrawPath, getLineIndicatorPath } from './components/getLinePath'
 import { getDrawLinePathData } from './line-helpers'
+import { useDefaultColorTheme } from '../shared/useDefaultColorTheme'
+import { STROKE_SIZES } from '../arrow/shared'
 
 const handlesCache = new WeakCache<TLLineShape['props'], TLHandle[]>()
 
-/** @public */
 export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 	static override type = 'line' as const
 	static override props = lineShapeProps
 	static override migrations = lineShapeMigrations
 
+	// Accessibility – line shapes are not tab‑navigable
 	override canTabTo() {
 		return false
 	}
@@ -55,6 +55,7 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 	}
 
 	override getDefaultProps(): TLLineShape['props'] {
+		// two initial points, with fractional indexes for stability
 		const [start, end] = getIndices(2)
 		return {
 			dash: 'draw',
@@ -64,39 +65,99 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 			points: {
 				[start]: { id: start, index: start, x: 0, y: 0 },
 				[end]: { id: end, index: end, x: 0.1, y: 0.1 },
-			},
+				},
+			// scaling factor: 1 = screen‑pixel‑size
 			scale: 1,
 		}
 	}
 
-	getGeometry(shape: TLLineShape) {
-		// todo: should we have min size?
-		return getGeometryForLineShape(shape)
+	/** Returns interpolated props for animated transitions */
+	override getInterpolatedProps(
+		startShape: TLLineShape,
+		endShape: TLLineShape,
+		t: number,
+	): TLLineShape['props'] {
+		const startPoints = linePointsToArray(startShape)
+		const endPoints = linePointsToArray(endShape)
+
+		const pointsStart: TLLineShapePoint[] = []
+		const pointsEnd: TLLineShapePoint[] = []
+
+		let index = ZERO_INDEX_KEY
+
+		// equalise point counts, then interpolate each point
+		if (startPoints.length > endPoints.length) {
+			for (let i = 0; i < startPoints.length; i++) {
+				pointsStart[i] = { ...startPoints[i] }
+				if (!endPoints[i]) {
+					pointsEnd[i] = { ...endPoints[endPoints.length - 1], id: index }
+				} else {
+					pointsEnd[i] = { ...endPoints[i], id: index }
+				}
+				index = getIndexAbove(index)
+			}
+		} else if (endPoints.length > startPoints.length) {
+			for (let i = 0; i < endPoints.length; i++) {
+				pointsEnd[i] = { ...endPoints[i] }
+				if (!startPoints[i]) {
+					pointsStart[i] = { ...startPoints[startPoints.length - 1], id: index }
+				} else {
+					pointsStart[i] = { ...startPoints[i], id: index }
+				}
+				index = getIndexAbove(index)
+			}
+		} else {
+			for (let i = 0; i < endPoints.length; i++) {
+				pointsStart[i] = startPoints[i]
+				pointsEnd[i] = endPoints[i]
+			}
+		}
+
+		return {
+			...(t > 0.5 ? endShape.props : startShape.props),
+			points: Object.fromEntries(
+				pointsStart.map((p, i) => [
+					p.id,
+					{
+						...p,
+						x: lerp(p.x, pointsEnd[i].x, t),
+						y: lerp(p.y, pointsEnd[i].y, t),
+					},
+				]),
+			),
+			// scale interpolates linearly between start & end
+			scale: lerp(startShape.props.scale, endShape.props.scale, t),
+		}
 	}
 
+	/** Returns vertex + create handles for the shape */
 	override getHandles(shape: TLLineShape) {
 		return handlesCache.get(shape.props, () => {
 			const spline = getGeometryForLineShape(shape)
-
 			const points = linePointsToArray(shape)
-			const results: TLHandle[] = points.map((point) => ({
-				...point,
-				id: point.index,
+
+			// vertex handles
+			const results: TLHandle[] = points.map((pt) => ({
+				...pt,
+				id: pt.index,
 				type: 'vertex',
 				canSnap: true,
+				canBind: false,
 			}))
 
+			// create handles between vertex handles
 			for (let i = 0; i < points.length - 1; i++) {
-				const index = getIndexBetween(points[i].index, points[i + 1].index)
-				const segment = spline.segments[i]
-				const point = segment.midPoint()
+				const idx = getIndexBetween(points[i].index, points[i + 1].index)
+				const seg = spline.segments[i]
+				const mid = seg.midPoint()
 				results.push({
-					id: index,
+					id: idx,
 					type: 'create',
-					index,
-					x: point.x,
-					y: point.y,
+					index: idx,
+					x: mid.x,
+					y: mid.y,
 					canSnap: true,
+					canBind: false,
 				})
 			}
 
@@ -104,11 +165,9 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 		})
 	}
 
-	//   Events
-
+	/** Resize scales all points */
 	override onResize(shape: TLLineShape, info: TLResizeInfo<TLLineShape>) {
 		const { scaleX, scaleY } = info
-
 		return {
 			props: {
 				points: mapObjectMapValues(shape.props.points, (_, { id, index, x, y }) => ({
@@ -121,57 +180,38 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 		}
 	}
 
-	override onBeforeCreate(next: TLLineShape): void | TLLineShape {
-		const {
-			props: { points },
-		} = next
-		const pointKeys = Object.keys(points)
-
-		if (pointKeys.length < 2) {
-			return
-		}
-
-		const firstPoint = points[pointKeys[0]]
-		const allSame = pointKeys.every((key) => {
-			const point = points[key]
-			return point.x === firstPoint.x && point.y === firstPoint.y
-		})
-		if (allSame) {
-			const lastKey = pointKeys[pointKeys.length - 1]
-			points[lastKey] = {
-				...points[lastKey],
-				x: points[lastKey].x + 0.1,
-				y: points[lastKey].y + 0.1,
-			}
-			return next
-		}
-		return
-	}
-
+	/** Dragging a vertex point */
 	override onHandleDrag(shape: TLLineShape, { handle }: TLHandleDragInfo<TLLineShape>) {
-		// we should only ever be dragging vertex handles
 		if (handle.type !== 'vertex') return
-		const newPoint = maybeSnapToGrid(new Vec(handle.x, handle.y), this.editor)
+
+		const snapped = maybeSnapToGrid(new Vec(handle.x, handle.y), this.editor)
 		return {
 			...shape,
 			props: {
 				...shape.props,
 				points: {
 					...shape.props.points,
-					[handle.id]: { id: handle.id, index: handle.index, x: newPoint.x, y: newPoint.y },
+					[handle.id]: {
+						id: handle.id,
+						index: handle.index,
+						x: snapped.x,
+						y: snapped.y,
+					},
 				},
 			},
 		}
 	}
 
+	/** Render for the canvas */
 	component(shape: TLLineShape) {
 		return (
-			<SVGContainer style={{ minWidth: 50, minHeight: 50 }}>
+			<SVGContainer>
 				<LineShapeSvg shape={shape} />
 			</SVGContainer>
 		)
 	}
 
+	/** Indicator (used for selection outlines) */
 	indicator(shape: TLLineShape) {
 		const strokeWidth = STROKE_SIZES[shape.props.size] * shape.props.scale
 		const spline = getGeometryForLineShape(shape)
@@ -184,8 +224,8 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 			if (dash === 'solid' || dash === 'dotted' || dash === 'dashed') {
 				path = 'M' + outline[0] + 'L' + outline.slice(1)
 			} else {
-				const [innerPathData] = getDrawLinePathData(shape.id, outline, strokeWidth)
-				path = innerPathData
+				const [innerPath] = getDrawLinePathData(shape.id, outline, strokeWidth)
+				path = innerPath
 			}
 		} else {
 			path = getLineIndicatorPath(shape, spline, strokeWidth)
@@ -194,125 +234,56 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 		return <path d={path} />
 	}
 
+	/** Returns SVG JSX for exporting */
 	override toSvg(shape: TLLineShape) {
-		return <LineShapeSvg shouldScale shape={shape} />
+		return <LineSvg shouldScale shape={shape} />
 	}
 
+	/** Snapping geometry for the line's handles */
 	override getHandleSnapGeometry(shape: TLLineShape): HandleSnapGeometry {
-		const points = linePointsToArray(shape)
+		const pts = linePointsToArray(shape)
 		return {
-			points,
+			points: pts,
 			getSelfSnapPoints: (handle) => {
-				const index = this.getHandles(shape)
+				const idx = this.getHandles(shape)
 					.filter((h) => h.type === 'vertex')
 					.findIndex((h) => h.id === handle.id)!
 
-				// We want to skip the current and adjacent handles
-				return points.filter((_, i) => Math.abs(i - index) > 1).map(Vec.From)
-			},
-			getSelfSnapOutline: (handle) => {
-				// We want to skip the segments that include the handle, so
-				// find the index of the handle that shares the same index property
-				// as the initial dragging handle; this catches a quirk of create handles
-				const index = this.getHandles(shape)
-					.filter((h) => h.type === 'vertex')
-					.findIndex((h) => h.id === handle.id)!
-
-				// Get all the outline segments from the shape that don't include the handle
-				const segments = getGeometryForLineShape(shape).segments.filter(
-					(_, i) => i !== index - 1 && i !== index
-				)
-
-				if (!segments.length) return null
-				return new Group2d({ children: segments })
-			},
-		}
-	}
-	override getInterpolatedProps(
-		startShape: TLLineShape,
-		endShape: TLLineShape,
-		t: number
-	): TLLineShape['props'] {
-		const startPoints = linePointsToArray(startShape)
-		const endPoints = linePointsToArray(endShape)
-
-		const pointsToUseStart: TLLineShapePoint[] = []
-		const pointsToUseEnd: TLLineShapePoint[] = []
-
-		let index = ZERO_INDEX_KEY
-
-		if (startPoints.length > endPoints.length) {
-			// we'll need to expand points
-			for (let i = 0; i < startPoints.length; i++) {
-				pointsToUseStart[i] = { ...startPoints[i] }
-				if (endPoints[i] === undefined) {
-					pointsToUseEnd[i] = { ...endPoints[endPoints.length - 1], id: index }
-				} else {
-					pointsToUseEnd[i] = { ...endPoints[i], id: index }
-				}
-				index = getIndexAbove(index)
-			}
-		} else if (endPoints.length > startPoints.length) {
-			// we'll need to converge points
-			for (let i = 0; i < endPoints.length; i++) {
-				pointsToUseEnd[i] = { ...endPoints[i] }
-				if (startPoints[i] === undefined) {
-					pointsToUseStart[i] = {
-						...startPoints[startPoints.length - 1],
-						id: index,
-					}
-				} else {
-					pointsToUseStart[i] = { ...startPoints[i], id: index }
-				}
-				index = getIndexAbove(index)
-			}
-		} else {
-			// noop, easy
-			for (let i = 0; i < endPoints.length; i++) {
-				pointsToUseStart[i] = startPoints[i]
-				pointsToUseEnd[i] = endPoints[i]
+					const points = linePointsToArray(shape)
+					return points.filter((_, i) => Math.abs(i - idx) > 1).map(Vec.From)
+				},
+				getSelfSnapOutline: (handle) => {
+					const idx = this.getHandles(shape)
+						.filter((h) => h.type === 'vertex')
+						.findIndex((h) => h.id === handle.id)!
+
+					const segs = getGeometryForLineShape(shape).segments.filter(
+						(_, i) => i !== idx - 1 && i !== idx,
+					)
+					if (!segs.length) return null
+					return new Group2d({ children: segs })
+				},
 			}
 		}
-
-		return {
-			...(t > 0.5 ? endShape.props : startShape.props),
-			points: Object.fromEntries(
-				pointsToUseStart.map((point, i) => {
-					const endPoint = pointsToUseEnd[i]
-					return [
-						point.id,
-						{
-							...point,
-							x: lerp(point.x, endPoint.x, t),
-							y: lerp(point.y, endPoint.y, t),
-						},
-					]
-				})
-			),
-			scale: lerp(startShape.props.scale, endShape.props.scale, t),
-		}
 	}
 }
 
-function linePointsToArray(shape: TLLineShape) {
+/** Convert points map to array sorted by index */
+function linePointsToArray(shape: TLLineShape): TLLineShapePoint[] {
 	return Object.values(shape.props.points).sort(sortByIndex)
 }
 
-/** @public */
-export function getGeometryForLineShape(shape: TLLineShape): CubicSpline2d | Polyline2d {
-	const points = linePointsToArray(shape).map(Vec.From)
+/** Build geometry (Cubic spline or polyline) for a line shape */
+function getGeometryForLineShape(shape: TLLineShape): CubicSpline2d | Polyline2d {
+	const pts = linePointsToArray(shape).map(Vec.From)
 
-	switch (shape.props.spline) {
-		case 'cubic': {
-			return new CubicSpline2d({ points })
-		}
-		case 'line': {
-			return new Polyline2d({ points })
-		}
-	}
+	return shape.props.spline === 'cubic'
+		? new CubicSpline2d({ points: pts })
+		: new Polyline2d({ points: pts })
 }
 
-function LineShapeSvg({
+/** Render the SVG for a line shape */
+function LineSvg({
 	shape,
 	shouldScale = false,
 	forceSolid = false,
@@ -322,27 +293,23 @@ function LineShapeSvg({
 	forceSolid?: boolean
 }) {
 	const theme = useDefaultColorTheme()
-
 	const spline = getGeometryForLineShape(shape)
 	const { dash, color, size } = shape.props
 
-	const scaleFactor = 1 / shape.props.scale
-
-	const scale = shouldScale ? scaleFactor : 1
+	const baseStroke = STROKE_SIZES[size] * shape.props.scale
+	const scale = shouldScale ? 1 / shape.props.scale : 1
 
-	const strokeWidth = STROKE_SIZES[size] * shape.props.scale
-
-	// Line style lines
+	// --------------------------------------------------------------
+	// Straight line style
+	// --------------------------------------------------------------
 	if (shape.props.spline === 'line') {
 		if (dash === 'solid') {
-			const outline = spline.points
-			const pathData = 'M' + outline[0] + 'L' + outline.slice(1)
-
+			const d = 'M' + spline.points[0] + 'L' + spline.points.slice(1)
 			return (
 				<path
-					d={pathData}
+					d={d}
 					stroke={theme[color].solid}
-					strokeWidth={strokeWidth}
+					strokeWidth={baseStroke}
 					fill="none"
 					transform={`scale(${scale})`}
 				/>
@@ -351,16 +318,19 @@ function LineShapeSvg({
 
 		if (dash === 'dashed' || dash === 'dotted') {
 			return (
-				<g stroke={theme[color].solid} strokeWidth={strokeWidth} transform={`scale(${scale})`}>
+				<g
+					stroke={theme[color].solid}
+					strokeWidth={baseStroke}
+					transform={`scale(${scale})`}
+				>
 					{spline.segments.map((segment, i) => {
 						const { strokeDasharray, strokeDashoffset } = forceSolid
 							? { strokeDasharray: 'none', strokeDashoffset: 'none' }
-							: getPerfectDashProps(segment.length, strokeWidth, {
+							: getPerfectDashProps(segment.length, baseStroke, {
 									style: dash,
 									start: i > 0 ? 'outset' : 'none',
 									end: i < spline.segments.length - 1 ? 'outset' : 'none',
-								})
-
+							  })
 						return (
 							<path
 								key={i}
@@ -376,30 +346,31 @@ function LineShapeSvg({
 		}
 
 		if (dash === 'draw') {
-			const outline = spline.points
-			const [_, outerPathData] = getDrawLinePathData(shape.id, outline, strokeWidth)
-
+			const [, outer] = getDrawLinePathData(shape.id, spline.points, baseStroke)
 			return (
 				<path
-					d={outerPathData}
+					d={outer}
 					stroke={theme[color].solid}
-					strokeWidth={strokeWidth}
+					strokeWidth={baseStroke}
 					fill="none"
 					transform={`scale(${scale})`}
 				/>
 			)
 		}
 	}
-	// Cubic style spline
+
+	// --------------------------------------------------------------
+	// Cubic spline style
+	// --------------------------------------------------------------
 	if (shape.props.spline === 'cubic') {
-		const splinePath = spline.getSvgPathData()
+		const path = spline.getSvgPathData()
 		if (dash === 'solid') {
 			return (
 				<path
-					strokeWidth={strokeWidth}
+					d={path}
+					strokeWidth={baseStroke}
 					stroke={theme[color].solid}
 					fill="none"
-					d={splinePath}
 					transform={`scale(${scale})`}
 				/>
 			)
@@ -407,19 +378,19 @@ function LineShapeSvg({
 
 		if (dash === 'dashed' || dash === 'dotted') {
 			return (
-				<g stroke={theme[color].solid} strokeWidth={strokeWidth} transform={`scale(${scale})`}>
+				<g
+					stroke={theme[color].solid}
+					strokeWidth={baseStroke}
+					transform={`scale(${scale})`}
+				>
 					{spline.segments.map((segment, i) => {
-						const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
-							segment.length,
-							strokeWidth,
-							{
-								style: dash,
-								start: i > 0 ? 'outset' : 'none',
-								end: i < spline.segments.length - 1 ? 'outset' : 'none',
-								forceSolid,
-							}
-						)
-
+						const { strokeDasharray, strokeDashoffset } = forceSolid
+							? { strokeDasharray: 'none', strokeDashoffset: 'none' }
+							: getPerfectDashProps(segment.length, baseStroke, {
+									style: dash,
+									start: i > 0 ? 'outset' : 'none',
+									end: i < spline.segments.length - 1 ? 'outset' : 'none',
+							  })
 						return (
 							<path
 								key={i}
@@ -435,9 +406,10 @@ function LineShapeSvg({
 		}
 
 		if (dash === 'draw') {
+			// NOTE: getLineDrawPath returns a solid fill path.
 			return (
 				<path
-					d={getLineDrawPath(shape, spline, strokeWidth)}
+					d={getLineDrawPath(shape, spline, baseStroke)}
 					strokeWidth={1}
 					stroke={theme[color].solid}
 					fill={theme[color].solid}
@@ -446,4 +418,5 @@ function LineShapeSvg({
 			)
 		}
 	}
+	return null
 }
\ No newline at end of file
