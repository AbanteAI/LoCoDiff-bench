--- tldraw_packages_tldraw_src_lib_shapes_line_LineShapeUtil.tsx_expectedoutput.txt (expected)+++ tldraw_packages_tldraw_src_lib_shapes_line_LineShapeUtil.tsx_extracted.txt (actual)@@ -6,9 +6,9 @@ 	SVGContainer,
 	ShapeUtil,
 	TLHandle,
-	TLHandleDragInfo,
 	TLLineShape,
 	TLLineShapePoint,
+	TLHandleDragInfo,
 	TLResizeInfo,
 	Vec,
 	WeakCache,
@@ -24,7 +24,6 @@ 	maybeSnapToGrid,
 	sortByIndex,
 } from '@tldraw/editor'
-
 import { STROKE_SIZES } from '../arrow/shared'
 import { useDefaultColorTheme } from '../shared/useDefaultColorTheme'
 import { getLineDrawPath, getLineIndicatorPath } from './components/getLinePath'
@@ -69,68 +68,12 @@ 		}
 	}
 
-	getGeometry(shape: TLLineShape) {
-		// todo: should we have min size?
-		return getGeometryForLineShape(shape)
-	}
-
-	override getHandles(shape: TLLineShape) {
-		return handlesCache.get(shape.props, () => {
-			const spline = getGeometryForLineShape(shape)
-
-			const points = linePointsToArray(shape)
-			const results: TLHandle[] = points.map((point) => ({
-				...point,
-				id: point.index,
-				type: 'vertex',
-				canSnap: true,
-			}))
-
-			for (let i = 0; i < points.length - 1; i++) {
-				const index = getIndexBetween(points[i].index, points[i + 1].index)
-				const segment = spline.segments[i]
-				const point = segment.midPoint()
-				results.push({
-					id: index,
-					type: 'create',
-					index,
-					x: point.x,
-					y: point.y,
-					canSnap: true,
-				})
-			}
-
-			return results.sort(sortByIndex)
-		})
-	}
-
-	//   Events
-
-	override onResize(shape: TLLineShape, info: TLResizeInfo<TLLineShape>) {
-		const { scaleX, scaleY } = info
-
-		return {
-			props: {
-				points: mapObjectMapValues(shape.props.points, (_, { id, index, x, y }) => ({
-					id,
-					index,
-					x: x * scaleX,
-					y: y * scaleY,
-				})),
-			},
-		}
-	}
-
 	override onBeforeCreate(next: TLLineShape): void | TLLineShape {
 		const {
 			props: { points },
 		} = next
 		const pointKeys = Object.keys(points)
-
-		if (pointKeys.length < 2) {
-			return
-		}
-
+		if (pointKeys.length < 2) return
 		const firstPoint = points[pointKeys[0]]
 		const allSame = pointKeys.every((key) => {
 			const point = points[key]
@@ -145,12 +88,55 @@ 			}
 			return next
 		}
-		return
+	}
+
+	override getHandles(shape: TLLineShape) {
+		return handlesCache.get(shape.props, () => {
+			const spline = getGeometryForLineShape(shape)
+			const points = linePointsToArray(shape)
+			const results: TLHandle[] = points.map((point) => ({
+				id: point.index,
+				index: point.index,
+				x: point.x,
+				y: point.y,
+				type: 'vertex',
+				canBind: false,
+				canSnap: true,
+			}))
+			for (let i = 0; i < points.length - 1; i++) {
+				const index = getIndexBetween(points[i].index, points[i + 1].index)
+				const segment = spline.segments[i]
+				const mid = segment.midPoint()
+				results.push({
+					id: index,
+					index,
+					x: mid.x,
+					y: mid.y,
+					type: 'create',
+					canBind: false,
+					canSnap: true,
+				})
+			}
+			return results.sort(sortByIndex)
+		})
+	}
+
+	override onResize(shape: TLLineShape, info: TLResizeInfo<TLLineShape>) {
+		const { scaleX, scaleY } = info
+		return {
+			props: {
+				points: mapObjectMapValues(shape.props.points, (_, { id, index, x, y }) => ({
+					id,
+					index,
+					x: x * scaleX,
+					y: y * scaleY,
+				})),
+			},
+		}
 	}
 
 	override onHandleDrag(shape: TLLineShape, { handle }: TLHandleDragInfo<TLLineShape>) {
-		// we should only ever be dragging vertex handles
-		if (handle.type !== 'vertex') return
+		if (handle.type !== 'vertex') return shape
 		const newPoint = maybeSnapToGrid(new Vec(handle.x, handle.y), this.editor)
 		return {
 			...shape,
@@ -158,13 +144,18 @@ 				...shape.props,
 				points: {
 					...shape.props.points,
-					[handle.id]: { id: handle.id, index: handle.index, x: newPoint.x, y: newPoint.y },
+					[handle.id]: {
+						id: handle.id,
+						index: handle.index,
+						x: newPoint.x,
+						y: newPoint.y,
+					},
 				},
 			},
 		}
 	}
 
-	component(shape: TLLineShape) {
+	override component(shape: TLLineShape) {
 		return (
 			<SVGContainer style={{ minWidth: 50, minHeight: 50 }}>
 				<LineShapeSvg shape={shape} />
@@ -172,7 +163,7 @@ 		)
 	}
 
-	indicator(shape: TLLineShape) {
+	override indicator(shape: TLLineShape) {
 		const strokeWidth = STROKE_SIZES[shape.props.size] * shape.props.scale
 		const spline = getGeometryForLineShape(shape)
 		const { dash } = shape.props
@@ -206,28 +197,21 @@ 				const index = this.getHandles(shape)
 					.filter((h) => h.type === 'vertex')
 					.findIndex((h) => h.id === handle.id)!
-
-				// We want to skip the current and adjacent handles
 				return points.filter((_, i) => Math.abs(i - index) > 1).map(Vec.From)
 			},
 			getSelfSnapOutline: (handle) => {
-				// We want to skip the segments that include the handle, so
-				// find the index of the handle that shares the same index property
-				// as the initial dragging handle; this catches a quirk of create handles
 				const index = this.getHandles(shape)
 					.filter((h) => h.type === 'vertex')
 					.findIndex((h) => h.id === handle.id)!
-
-				// Get all the outline segments from the shape that don't include the handle
 				const segments = getGeometryForLineShape(shape).segments.filter(
 					(_, i) => i !== index - 1 && i !== index
 				)
-
 				if (!segments.length) return null
 				return new Group2d({ children: segments })
 			},
 		}
 	}
+
 	override getInterpolatedProps(
 		startShape: TLLineShape,
 		endShape: TLLineShape,
@@ -238,36 +222,32 @@ 
 		const pointsToUseStart: TLLineShapePoint[] = []
 		const pointsToUseEnd: TLLineShapePoint[] = []
-
-		let index = ZERO_INDEX_KEY
+		let idx = ZERO_INDEX_KEY
 
 		if (startPoints.length > endPoints.length) {
-			// we'll need to expand points
 			for (let i = 0; i < startPoints.length; i++) {
 				pointsToUseStart[i] = { ...startPoints[i] }
 				if (endPoints[i] === undefined) {
-					pointsToUseEnd[i] = { ...endPoints[endPoints.length - 1], id: index }
+					pointsToUseEnd[i] = { ...endPoints[endPoints.length - 1], id: idx }
 				} else {
-					pointsToUseEnd[i] = { ...endPoints[i], id: index }
+					pointsToUseEnd[i] = { ...endPoints[i], id: idx }
 				}
-				index = getIndexAbove(index)
+				idx = getIndexAbove(idx)
 			}
 		} else if (endPoints.length > startPoints.length) {
-			// we'll need to converge points
 			for (let i = 0; i < endPoints.length; i++) {
 				pointsToUseEnd[i] = { ...endPoints[i] }
 				if (startPoints[i] === undefined) {
 					pointsToUseStart[i] = {
 						...startPoints[startPoints.length - 1],
-						id: index,
+						id: idx,
 					}
 				} else {
-					pointsToUseStart[i] = { ...startPoints[i], id: index }
+					pointsToUseStart[i] = { ...startPoints[i], id: idx }
 				}
-				index = getIndexAbove(index)
+				idx = getIndexAbove(idx)
 			}
 		} else {
-			// noop, easy
 			for (let i = 0; i < endPoints.length; i++) {
 				pointsToUseStart[i] = startPoints[i]
 				pointsToUseEnd[i] = endPoints[i]
@@ -278,13 +258,13 @@ 			...(t > 0.5 ? endShape.props : startShape.props),
 			points: Object.fromEntries(
 				pointsToUseStart.map((point, i) => {
-					const endPoint = pointsToUseEnd[i]
+					const endP = pointsToUseEnd[i]
 					return [
 						point.id,
 						{
 							...point,
-							x: lerp(point.x, endPoint.x, t),
-							y: lerp(point.y, endPoint.y, t),
+							x: lerp(point.x, endP.x, t),
+							y: lerp(point.y, endP.y, t),
 						},
 					]
 				})
@@ -301,149 +281,10 @@ /** @public */
 export function getGeometryForLineShape(shape: TLLineShape): CubicSpline2d | Polyline2d {
 	const points = linePointsToArray(shape).map(Vec.From)
-
 	switch (shape.props.spline) {
-		case 'cubic': {
+		case 'cubic':
 			return new CubicSpline2d({ points })
-		}
-		case 'line': {
+		case 'line':
 			return new Polyline2d({ points })
-		}
-	}
-}
-
-function LineShapeSvg({
-	shape,
-	shouldScale = false,
-	forceSolid = false,
-}: {
-	shape: TLLineShape
-	shouldScale?: boolean
-	forceSolid?: boolean
-}) {
-	const theme = useDefaultColorTheme()
-
-	const spline = getGeometryForLineShape(shape)
-	const { dash, color, size } = shape.props
-
-	const scaleFactor = 1 / shape.props.scale
-
-	const scale = shouldScale ? scaleFactor : 1
-
-	const strokeWidth = STROKE_SIZES[size] * shape.props.scale
-
-	// Line style lines
-	if (shape.props.spline === 'line') {
-		if (dash === 'solid') {
-			const outline = spline.points
-			const pathData = 'M' + outline[0] + 'L' + outline.slice(1)
-
-			return (
-				<path
-					d={pathData}
-					stroke={theme[color].solid}
-					strokeWidth={strokeWidth}
-					fill="none"
-					transform={`scale(${scale})`}
-				/>
-			)
-		}
-
-		if (dash === 'dashed' || dash === 'dotted') {
-			return (
-				<g stroke={theme[color].solid} strokeWidth={strokeWidth} transform={`scale(${scale})`}>
-					{spline.segments.map((segment, i) => {
-						const { strokeDasharray, strokeDashoffset } = forceSolid
-							? { strokeDasharray: 'none', strokeDashoffset: 'none' }
-							: getPerfectDashProps(segment.length, strokeWidth, {
-									style: dash,
-									start: i > 0 ? 'outset' : 'none',
-									end: i < spline.segments.length - 1 ? 'outset' : 'none',
-								})
-
-						return (
-							<path
-								key={i}
-								strokeDasharray={strokeDasharray}
-								strokeDashoffset={strokeDashoffset}
-								d={segment.getSvgPathData(true)}
-								fill="none"
-							/>
-						)
-					})}
-				</g>
-			)
-		}
-
-		if (dash === 'draw') {
-			const outline = spline.points
-			const [_, outerPathData] = getDrawLinePathData(shape.id, outline, strokeWidth)
-
-			return (
-				<path
-					d={outerPathData}
-					stroke={theme[color].solid}
-					strokeWidth={strokeWidth}
-					fill="none"
-					transform={`scale(${scale})`}
-				/>
-			)
-		}
-	}
-	// Cubic style spline
-	if (shape.props.spline === 'cubic') {
-		const splinePath = spline.getSvgPathData()
-		if (dash === 'solid') {
-			return (
-				<path
-					strokeWidth={strokeWidth}
-					stroke={theme[color].solid}
-					fill="none"
-					d={splinePath}
-					transform={`scale(${scale})`}
-				/>
-			)
-		}
-
-		if (dash === 'dashed' || dash === 'dotted') {
-			return (
-				<g stroke={theme[color].solid} strokeWidth={strokeWidth} transform={`scale(${scale})`}>
-					{spline.segments.map((segment, i) => {
-						const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
-							segment.length,
-							strokeWidth,
-							{
-								style: dash,
-								start: i > 0 ? 'outset' : 'none',
-								end: i < spline.segments.length - 1 ? 'outset' : 'none',
-								forceSolid,
-							}
-						)
-
-						return (
-							<path
-								key={i}
-								strokeDasharray={strokeDasharray}
-								strokeDashoffset={strokeDashoffset}
-								d={segment.getSvgPathData()}
-								fill="none"
-							/>
-						)
-					})}
-				</g>
-			)
-		}
-
-		if (dash === 'draw') {
-			return (
-				<path
-					d={getLineDrawPath(shape, spline, strokeWidth)}
-					strokeWidth={1}
-					stroke={theme[color].solid}
-					fill={theme[color].solid}
-					transform={`scale(${scale})`}
-				/>
-			)
-		}
 	}
 }