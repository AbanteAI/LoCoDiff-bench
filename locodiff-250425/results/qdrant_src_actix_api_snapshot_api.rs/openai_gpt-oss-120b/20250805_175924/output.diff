
index 85547d95e..4a426216c 100644
--- a/qdrant_src_actix_api_snapshot_api.rs_expectedoutput.txt (expected):tmp/tmpp4mpwda1_expected.txt	
+++ b/qdrant_src_actix_api_snapshot_api.rs_extracted.txt (actual):tmp/tmpxeh7dcxa_actual.txt	
@@ -1,14 +1,14 @@
 use std::path::Path;
 
-use actix_multipart::form::MultipartForm;
 use actix_multipart::form::tempfile::TempFile;
+use actix_multipart::form::MultipartForm;
 use actix_web::{Responder, Result, delete, get, post, put, web};
 use actix_web_validator as valid;
 use collection::common::file_utils::move_file;
 use collection::common::sha_256::{hash_file, hashes_equal};
 use collection::common::snapshot_stream::SnapshotStream;
 use collection::operations::snapshot_ops::{
-    ShardSnapshotRecover, SnapshotPriority, SnapshotRecover,
+    ShardSnapshotLocation, ShardSnapshotRecover, SnapshotPriority, SnapshotRecover,
 };
 use collection::operations::verification::new_unchecked_verification_pass;
 use collection::shards::shard::ShardId;
@@ -64,8 +64,8 @@ pub async fn do_get_full_snapshot(
 ) -> Result<SnapshotStream, HttpError> {
     access.check_global_access(AccessRequirements::new())?;
     let snapshots_storage_manager = toc.get_snapshots_storage_manager()?;
-    let snapshot_path =
-        snapshots_storage_manager.get_full_snapshot_path(toc.snapshots_path(), snapshot_name)?;
+    let snapshot_path = snapshots_storage_manager
+        .get_full_snapshot_path(toc.snapshots_path(), snapshot_name)?;
     let snapshot_stream = snapshots_storage_manager
         .get_snapshot_stream(&snapshot_path)
         .await?;
@@ -91,7 +91,9 @@ pub async fn do_save_uploaded_snapshot(
         .unwrap_or_else(|| Uuid::new_v4().to_string());
     let collection_snapshot_path = toc.snapshots_path_for_collection(collection_name);
     if !collection_snapshot_path.exists() {
-        log::debug!("Creating missing collection snapshots directory for {collection_name}");
+        log::debug!(
+            "Creating missing collection snapshots directory for {collection_name}"
+        );
         toc.create_snapshots_path(collection_name).await?;
     }
 
@@ -123,8 +125,8 @@ pub async fn do_get_snapshot(
     let collection: tokio::sync::RwLockReadGuard<collection::collection::Collection> =
         toc.get_collection(&collection_pass).await?;
     let snapshot_storage_manager = collection.get_snapshots_storage_manager()?;
-    let snapshot_path =
-        snapshot_storage_manager.get_snapshot_path(collection.snapshots_path(), snapshot_name)?;
+    let snapshot_path = snapshot_storage_manager
+        .get_snapshot_path(collection.snapshots_path(), snapshot_name)?;
     let snapshot_stream = snapshot_storage_manager
         .get_snapshot_stream(&snapshot_path)
         .await?;
@@ -137,9 +139,7 @@ async fn list_snapshots(
     path: web::Path<String>,
     ActixAccess(access): ActixAccess,
 ) -> impl Responder {
-    // Nothing to verify.
     let pass = new_unchecked_verification_pass();
-
     helpers::time(do_list_snapshots(
         dispatcher.toc(&access, &pass),
         access,
@@ -155,11 +155,9 @@ async fn create_snapshot(
     params: valid::Query<SnapshottingParam>,
     ActixAccess(access): ActixAccess,
 ) -> impl Responder {
-    // Nothing to verify.
-    let pass = new_unchecked_verification_pass();
-
     let collection_name = path.into_inner();
-
+    let wait = params.wait.unwrap_or(true);
+    let pass = new_unchecked_verification_pass();
     let future = async move {
         do_create_snapshot(
             dispatcher.toc(&access, &pass).clone(),
@@ -168,8 +166,7 @@ async fn create_snapshot(
         )
         .await
     };
-
-    helpers::time_or_accept(future, params.wait.unwrap_or(true)).await
+    helpers::time_or_accept(future, wait).await
 }
 
 #[post("/collections/{name}/snapshots/upload")]
@@ -182,36 +179,29 @@ async fn upload_snapshot(
     ActixAccess(access): ActixAccess,
 ) -> impl Responder {
     let wait = params.wait;
-
-    // Nothing to verify.
     let pass = new_unchecked_verification_pass();
-
     let future = async move {
         let snapshot = form.snapshot;
-
         access.check_global_access(AccessRequirements::new().manage())?;
-
         if let Some(checksum) = &params.checksum {
             let snapshot_checksum = hash_file(snapshot.file.path()).await?;
             if !hashes_equal(snapshot_checksum.as_str(), checksum.as_str()) {
                 return Err(StorageError::checksum_mismatch(snapshot_checksum, checksum));
             }
         }
-
-        let snapshot_location =
-            do_save_uploaded_snapshot(dispatcher.toc(&access, &pass), &collection.name, snapshot)
-                .await?;
-
-        // Snapshot is a local file, we do not need an API key for that
+        let snapshot_location = do_save_uploaded_snapshot(
+            dispatcher.toc(&access, &pass),
+            &collection.name,
+            snapshot,
+        )
+        .await?;
         let http_client = http_client.client(None)?;
-
         let snapshot_recover = SnapshotRecover {
             location: snapshot_location,
             priority: params.priority,
             checksum: None,
             api_key: None,
         };
-
         do_recover_from_snapshot(
             dispatcher.get_ref(),
             &collection.name,
@@ -221,7 +211,6 @@ async fn upload_snapshot(
         )
         .await
     };
-
     helpers::time_or_accept(future, wait.unwrap_or(true)).await
 }
 
@@ -229,7 +218,7 @@ async fn upload_snapshot(
 async fn recover_from_snapshot(
     dispatcher: web::Data<Dispatcher>,
     http_client: web::Data<HttpClient>,
-    collection: valid::Path<CollectionPath>,
+    collection: valid::Path<StrictCollectionPath>,
     request: valid::Json<SnapshotRecover>,
     params: valid::Query<SnapshottingParam>,
     ActixAccess(access): ActixAccess,
@@ -237,7 +226,6 @@ async fn recover_from_snapshot(
     let future = async move {
         let snapshot_recover = request.into_inner();
         let http_client = http_client.client(snapshot_recover.api_key.as_deref())?;
-
         do_recover_from_snapshot(
             dispatcher.get_ref(),
             &collection.name,
@@ -247,7 +235,6 @@ async fn recover_from_snapshot(
         )
         .await
     };
-
     helpers::time_or_accept(future, params.wait.unwrap_or(true)).await
 }
 
@@ -257,12 +244,9 @@ async fn get_snapshot(
     path: web::Path<(String, String)>,
     ActixAccess(access): ActixAccess,
 ) -> impl Responder {
-    // Nothing to verify.
-    let pass = new_unchecked_verification_pass();
-
     let (collection_name, snapshot_name) = path.into_inner();
     do_get_snapshot(
-        dispatcher.toc(&access, &pass),
+        dispatcher.toc(&access, &new_unchecked_verification_pass()),
         access,
         &collection_name,
         &snapshot_name,
@@ -275,9 +259,7 @@ async fn list_full_snapshots(
     dispatcher: web::Data<Dispatcher>,
     ActixAccess(access): ActixAccess,
 ) -> impl Responder {
-    // nothing to verify.
     let pass = new_unchecked_verification_pass();
-
     helpers::time(do_list_full_snapshots(
         dispatcher.toc(&access, &pass),
         access,
@@ -291,8 +273,9 @@ async fn create_full_snapshot(
     params: valid::Query<SnapshottingParam>,
     ActixAccess(access): ActixAccess,
 ) -> impl Responder {
+    let wait = params.wait.unwrap_or(true);
     let future = async move { do_create_full_snapshot(dispatcher.get_ref(), access).await };
-    helpers::time_or_accept(future, params.wait.unwrap_or(true)).await
+    helpers::time_or_accept(future, wait).await
 }
 
 #[get("/snapshots/{snapshot_name}")]
@@ -301,11 +284,14 @@ async fn get_full_snapshot(
     path: web::Path<String>,
     ActixAccess(access): ActixAccess,
 ) -> impl Responder {
-    // nothing to verify.
-    let pass = new_unchecked_verification_pass();
-
     let snapshot_name = path.into_inner();
-    do_get_full_snapshot(dispatcher.toc(&access, &pass), access, &snapshot_name).await
+    let pass = new_unchecked_verification_pass();
+    do_get_full_snapshot(
+        dispatcher.toc(&access, &pass),
+        access,
+        &snapshot_name,
+    )
+    .await
 }
 
 #[delete("/snapshots/{snapshot_name}")]
@@ -315,12 +301,12 @@ async fn delete_full_snapshot(
     params: valid::Query<SnapshottingParam>,
     ActixAccess(access): ActixAccess,
 ) -> impl Responder {
+    let wait = params.wait.unwrap_or(true);
     let future = async move {
         let snapshot_name = path.into_inner();
         do_delete_full_snapshot(dispatcher.get_ref(), access, &snapshot_name).await
     };
-
-    helpers::time_or_accept(future, params.wait.unwrap_or(true)).await
+    helpers::time_or_accept(future, wait).await
 }
 
 #[delete("/collections/{name}/snapshots/{snapshot_name}")]
@@ -330,9 +316,9 @@ async fn delete_collection_snapshot(
     params: valid::Query<SnapshottingParam>,
     ActixAccess(access): ActixAccess,
 ) -> impl Responder {
+    let wait = params.wait.unwrap_or(true);
     let future = async move {
         let (collection_name, snapshot_name) = path.into_inner();
-
         do_delete_collection_snapshot(
             dispatcher.get_ref(),
             access,
@@ -341,8 +327,7 @@ async fn delete_collection_snapshot(
         )
         .await
     };
-
-    helpers::time_or_accept(future, params.wait.unwrap_or(true)).await
+    helpers::time_or_accept(future, wait).await
 }
 
 #[get("/collections/{collection}/shards/{shard}/snapshots")]
@@ -351,19 +336,14 @@ async fn list_shard_snapshots(
     path: web::Path<(String, ShardId)>,
     ActixAccess(access): ActixAccess,
 ) -> impl Responder {
-    // nothing to verify.
-    let pass = new_unchecked_verification_pass();
-
     let (collection, shard) = path.into_inner();
-
+    let pass = new_unchecked_verification_pass();
     let future = common::snapshots::list_shard_snapshots(
         dispatcher.toc(&access, &pass).clone(),
         access,
         collection,
         shard,
-    )
-    .map_err(Into::into);
-
+    );
     helpers::time(future).await
 }
 
@@ -374,75 +354,40 @@ async fn create_shard_snapshot(
     query: web::Query<SnapshottingParam>,
     ActixAccess(access): ActixAccess,
 ) -> impl Responder {
-    // nothing to verify.
-    let pass = new_unchecked_verification_pass();
-
     let (collection, shard) = path.into_inner();
     let future = common::snapshots::create_shard_snapshot(
-        dispatcher.toc(&access, &pass).clone(),
+        dispatcher.toc(&access, &new_unchecked_verification_pass()).clone(),
         access,
         collection,
         shard,
     );
-
     helpers::time_or_accept(future, query.wait.unwrap_or(true)).await
 }
 
-#[get("/collections/{collection}/shards/{shard}/snapshot")]
-async fn stream_shard_snapshot(
-    dispatcher: web::Data<Dispatcher>,
-    path: web::Path<(String, ShardId)>,
-    ActixAccess(access): ActixAccess,
-) -> Result<SnapshotStream, HttpError> {
-    // nothing to verify.
-    let pass = new_unchecked_verification_pass();
-
-    let (collection, shard) = path.into_inner();
-    Ok(common::snapshots::stream_shard_snapshot(
-        dispatcher.toc(&access, &pass).clone(),
-        access,
-        collection,
-        shard,
-    )
-    .await?)
-}
-
-// TODO: `PUT` (same as `recover_from_snapshot`) or `POST`!?
 #[put("/collections/{collection}/shards/{shard}/snapshots/recover")]
 async fn recover_shard_snapshot(
     dispatcher: web::Data<Dispatcher>,
-    http_client: web::Data<HttpClient>,
     path: web::Path<(String, ShardId)>,
     query: web::Query<SnapshottingParam>,
-    web::Json(request): web::Json<ShardSnapshotRecover>,
+    request: web::Json<ShardSnapshotRecover>,
     ActixAccess(access): ActixAccess,
 ) -> impl Responder {
-    // nothing to verify.
-    let pass = new_unchecked_verification_pass();
-
     let future = async move {
         let (collection, shard) = path.into_inner();
-
         common::snapshots::recover_shard_snapshot(
-            dispatcher.toc(&access, &pass).clone(),
+            dispatcher.toc(&access, &new_unchecked_verification_pass()).clone(),
             access,
             collection,
             shard,
             request.location,
             request.priority.unwrap_or_default(),
-            request.checksum,
-            http_client.as_ref().clone(),
-            request.api_key,
         )
         .await?;
-
-        Ok(true)
+        Ok(())
     };
-
     helpers::time_or_accept(future, query.wait.unwrap_or(true)).await
 }
 
-// TODO: `POST` (same as `upload_snapshot`) or `PUT`!?
 #[post("/collections/{collection}/shards/{shard}/snapshots/upload")]
 async fn upload_shard_snapshot(
     dispatcher: web::Data<Dispatcher>,
@@ -451,9 +396,6 @@ async fn upload_shard_snapshot(
     MultipartForm(form): MultipartForm<SnapshottingForm>,
     ActixAccess(access): ActixAccess,
 ) -> impl Responder {
-    // nothing to verify.
-    let pass = new_unchecked_verification_pass();
-
     let (collection, shard) = path.into_inner();
     let SnapshotUploadingParam {
         wait,
@@ -466,24 +408,25 @@ async fn upload_shard_snapshot(
 
     let future = cancel::future::spawn_cancel_on_drop(move |cancel| async move {
         // TODO: Run this check before the multipart blob is uploaded
-        let collection_pass = access
-            .check_global_access(AccessRequirements::new().manage())?
-            .issue_pass(&collection);
+        let multipass = access.check_global_access(AccessRequirements::new().manage())?;
 
         if let Some(checksum) = checksum {
             let snapshot_checksum = hash_file(form.snapshot.file.path()).await?;
             if !hashes_equal(snapshot_checksum.as_str(), checksum.as_str()) {
-                return Err(StorageError::checksum_mismatch(snapshot_checksum, checksum));
+                return Result::<_, HttpError>::Err(StorageError::checksum_mismatch(
+                    snapshot_checksum,
+                    checksum,
+                )
+                .into());
             }
         }
 
         let future = async {
             let collection = dispatcher
-                .toc(&access, &pass)
-                .get_collection(&collection_pass)
+                .toc(&access, &new_unchecked_verification_pass())
+                .get_collection(&multipass.issue_pass(&collection))
                 .await?;
             collection.assert_shard_exists(shard).await?;
-
             Result::<_, StorageError>::Ok(collection)
         };
 
@@ -491,7 +434,7 @@ async fn upload_shard_snapshot(
 
         // `recover_shard_snapshot_impl` is *not* cancel safe
         common::snapshots::recover_shard_snapshot_impl(
-            dispatcher.toc(&access, &pass),
+            dispatcher.toc(&access, &new_unchecked_verification_pass()),
             &collection,
             shard,
             form.snapshot.file.path(),
@@ -500,27 +443,25 @@ async fn upload_shard_snapshot(
         )
         .await?;
 
-        Ok(())
+        Result::<_, HttpError>::Ok(())
     })
-    .map(|x| x.map_err(Into::into).and_then(|x| x));
+    .map_err(Into::into)
+    .map(|res| res.and_then(|res| res));
 
     helpers::time_or_accept(future, wait.unwrap_or(true)).await
 }
 
-#[get("/collections/{collection}/shards/{shard}/snapshots/{snapshot}")]
+#[get("/collections/{collection}/shards/{shard}/snapshots")]
 async fn download_shard_snapshot(
     dispatcher: web::Data<Dispatcher>,
     path: web::Path<(String, ShardId, String)>,
     ActixAccess(access): ActixAccess,
 ) -> Result<impl Responder, HttpError> {
-    // nothing to verify.
-    let pass = new_unchecked_verification_pass();
-
     let (collection, shard, snapshot) = path.into_inner();
     let collection_pass =
-        access.check_collection_access(&collection, AccessRequirements::new().whole().extras())?;
+        access.check_collection_access(&collection, AccessRequirements::new().whole())?;
     let collection = dispatcher
-        .toc(&access, &pass)
+        .toc(&access, &new_unchecked_verification_pass())
         .get_collection(&collection_pass)
         .await?;
     let snapshots_storage_manager = collection.get_snapshots_storage_manager()?;
@@ -543,12 +484,9 @@ async fn delete_shard_snapshot(
     query: web::Query<SnapshottingParam>,
     ActixAccess(access): ActixAccess,
 ) -> impl Responder {
-    // nothing to verify.
-    let pass = new_unchecked_verification_pass();
-
     let (collection, shard, snapshot) = path.into_inner();
     let future = common::snapshots::delete_shard_snapshot(
-        dispatcher.toc(&access, &pass).clone(),
+        dispatcher.toc(&access, &new_unchecked_verification_pass()).clone(),
         access,
         collection,
         shard,
@@ -556,15 +494,33 @@ async fn delete_shard_snapshot(
     )
     .map_ok(|_| true)
     .map_err(Into::into);
-
     helpers::time_or_accept(future, query.wait.unwrap_or(true)).await
 }
 
+#[get("/collections/{collection}/shards/{shard}/snapshot")]
+async fn stream_shard_snapshot(
+    dispatcher: web::Data<Dispatcher>,
+    path: web::Path<(String, ShardId)>,
+    ActixAccess(access): ActixAccess,
+) -> Result<SnapshotStream, HttpError> {
+    // nothing to verify.
+    let pass = new_unchecked_verification_pass();
+
+    let (collection, shard) = path.into_inner();
+    let stream = common::snapshots::stream_shard_snapshot(
+        dispatcher.toc(&access, &pass).clone(),
+        access,
+        collection,
+        shard,
+    )
+    .await?;
+    Ok(stream)
+}
+
 // Configure services
 pub fn config_snapshots_api(cfg: &mut web::ServiceConfig) {
     cfg.service(list_snapshots)
         .service(create_snapshot)
-        .service(upload_snapshot)
         .service(recover_from_snapshot)
         .service(get_snapshot)
         .service(list_full_snapshots)
