
index 54a872a6e..cc4b30ea5 100644
--- a/react_packages_react-reconciler_src_ReactFiberLane.js_expectedoutput.txt (expected):tmp/tmpa2duo4sj_expected.txt	
+++ b/react_packages_react-reconciler_src_ReactFiberLane.js_extracted.txt (actual):tmp/tmpjjqbld5x_actual.txt	
@@ -11,27 +11,23 @@ import type {Fiber, FiberRoot} from './ReactInternalTypes';
 import type {Transition} from 'react/src/ReactStartTransition';
 import type {ConcurrentUpdate} from './ReactFiberConcurrentUpdates';
 
-// TODO: Ideally these types would be opaque but that doesn't work well with
-// our reconciler fork infra, since these leak into non-reconciler packages.
-
-export type Lanes = number;
-export type Lane = number;
-export type LaneMap<T> = Array<T>;
-
 import {
-  enableRetryLaneExpiration,
   enableSchedulingProfiler,
-  enableTransitionTracing,
   enableUpdaterTracking,
-  syncLaneExpirationMs,
-  transitionLaneExpirationMs,
-  retryLaneExpirationMs,
-  disableLegacyMode,
-  enableSiblingPrerendering,
+  allowConcurrentByDefault,
+  enableTransitionTracing,
+  enableUnifiedSyncLane,
 } from 'shared/ReactFeatureFlags';
 import {isDevToolsPresent} from './ReactFiberDevToolsHook';
+import {ConcurrentUpdatesByDefaultMode, NoMode} from './ReactTypeOfMode';
 import {clz32} from './clz32';
-import {LegacyRoot} from './ReactRootTags';
+
+// TODO: Ideally these types would be opaque but that doesn't work well with
+// our reconciler fork infra, since these leak into non-reconciler packages.
+
+export type Lanes = number;
+export type Lane = number;
+export type LaneMap<T> = Array<T>;
 
 // Lane values below should be kept in sync with getLabelForLane(), used by react-devtools-timeline.
 // If those values are changed that package should be rebuilt and redeployed.
@@ -43,7 +39,6 @@ export const NoLane: Lane = /*                          */ 0b0000000000000000000
 
 export const SyncHydrationLane: Lane = /*               */ 0b0000000000000000000000000000001;
 export const SyncLane: Lane = /*                        */ 0b0000000000000000000000000000010;
-export const SyncLaneIndex: number = 1;
 
 export const InputContinuousHydrationLane: Lane = /*    */ 0b0000000000000000000000000000100;
 export const InputContinuousLane: Lane = /*             */ 0b0000000000000000000000000001000;
@@ -51,59 +46,51 @@ export const InputContinuousLane: Lane = /*             */ 0b0000000000000000000
 export const DefaultHydrationLane: Lane = /*            */ 0b0000000000000000000000000010000;
 export const DefaultLane: Lane = /*                     */ 0b0000000000000000000000000100000;
 
-export const SyncUpdateLanes: Lane =
-  SyncLane | InputContinuousLane | DefaultLane;
-
-export const GestureLane: Lane = /*                     */ 0b0000000000000000000000001000000;
-
-const TransitionHydrationLane: Lane = /*                */ 0b0000000000000000000000010000000;
-const TransitionLanes: Lanes = /*                       */ 0b0000000001111111111111100000000;
-const TransitionLane1: Lane = /*                        */ 0b0000000000000000000000100000000;
-const TransitionLane2: Lane = /*                        */ 0b0000000000000000000001000000000;
-const TransitionLane3: Lane = /*                        */ 0b0000000000000000000010000000000;
-const TransitionLane4: Lane = /*                        */ 0b0000000000000000000100000000000;
-const TransitionLane5: Lane = /*                        */ 0b0000000000000000001000000000000;
-const TransitionLane6: Lane = /*                        */ 0b0000000000000000010000000000000;
-const TransitionLane7: Lane = /*                        */ 0b0000000000000000100000000000000;
-const TransitionLane8: Lane = /*                        */ 0b0000000000000001000000000000000;
-const TransitionLane9: Lane = /*                        */ 0b0000000000000010000000000000000;
-const TransitionLane10: Lane = /*                       */ 0b0000000000000100000000000000000;
-const TransitionLane11: Lane = /*                       */ 0b0000000000001000000000000000000;
-const TransitionLane12: Lane = /*                       */ 0b0000000000010000000000000000000;
-const TransitionLane13: Lane = /*                       */ 0b0000000000100000000000000000000;
-const TransitionLane14: Lane = /*                       */ 0b0000000001000000000000000000000;
-
-const RetryLanes: Lanes = /*                            */ 0b0000011110000000000000000000000;
-const RetryLane1: Lane = /*                             */ 0b0000000010000000000000000000000;
-const RetryLane2: Lane = /*                             */ 0b0000000100000000000000000000000;
-const RetryLane3: Lane = /*                             */ 0b0000001000000000000000000000000;
-const RetryLane4: Lane = /*                             */ 0b0000010000000000000000000000000;
+export const SyncUpdateLanes: Lane = enableUnifiedSyncLane
+  ? SyncLane | InputContinuousLane | DefaultLane
+  : SyncLane;
+
+const TransitionHydrationLane: Lane = /*                */ 0b0000000000000000000000001000000;
+const TransitionLanes: Lanes = /*                       */ 0b0000000011111111111111110000000;
+const TransitionLane1: Lane = /*                        */ 0b0000000000000000000000010000000;
+const TransitionLane2: Lane = /*                        */ 0b0000000000000000000000100000000;
+const TransitionLane3: Lane = /*                        */ 0b0000000000000000000001000000000;
+const TransitionLane4: Lane = /*                        */ 0b0000000000000000000010000000000;
+const TransitionLane5: Lane = /*                        */ 0b0000000000000000000100000000000;
+const TransitionLane6: Lane = /*                        */ 0b0000000000000000001000000000000;
+const TransitionLane7: Lane = /*                        */ 0b0000000000000000010000000000000;
+const TransitionLane8: Lane = /*                        */ 0b0000000000000000100000000000000;
+const TransitionLane9: Lane = /*                        */ 0b0000000000000001000000000000000;
+const TransitionLane10: Lane = /*                       */ 0b0000000000000010000000000000000;
+const TransitionLane11: Lane = /*                       */ 0b0000000000000100000000000000000;
+const TransitionLane12: Lane = /*                       */ 0b0000000000001000000000000000000;
+const TransitionLane13: Lane = /*                       */ 0b0000000000010000000000000000000;
+const TransitionLane14: Lane = /*                       */ 0b0000000000100000000000000000000;
+const TransitionLane15: Lane = /*                       */ 0b0000000001000000000000000000000;
+const TransitionLane16: Lane = /*                       */ 0b0000000010000000000000000000000;
+
+const RetryLanes: Lanes = /*                            */ 0b0000111100000000000000000000000;
+const RetryLane1: Lane = /*                             */ 0b0000000100000000000000000000000;
+const RetryLane2: Lane = /*                             */ 0b0000001000000000000000000000000;
+const RetryLane3: Lane = /*                             */ 0b0000010000000000000000000000000;
+const RetryLane4: Lane = /*                             */ 0b0000100000000000000000000000000;
 
 export const SomeRetryLane: Lane = RetryLane1;
 
-export const SelectiveHydrationLane: Lane = /*          */ 0b0000100000000000000000000000000;
+export const SelectiveHydrationLane: Lane = /*          */ 0b0001000000000000000000000000000;
 
-const NonIdleLanes: Lanes = /*                          */ 0b0000111111111111111111111111111;
+const NonIdleLanes: Lanes = /*                          */ 0b0001111111111111111111111111111;
 
-export const IdleHydrationLane: Lane = /*               */ 0b0001000000000000000000000000000;
-export const IdleLane: Lane = /*                        */ 0b0010000000000000000000000000000;
+export const IdleHydrationLane: Lane = /*               */ 0b0010000000000000000000000000000;
+export const IdleLane: Lane = /*                        */ 0b0100000000000000000000000000000;
 
-export const OffscreenLane: Lane = /*                   */ 0b0100000000000000000000000000000;
-export const DeferredLane: Lane = /*                    */ 0b1000000000000000000000000000000;
+export const OffscreenLane: Lane = /*                   */ 0b1000000000000000000000000000000;
 
 // Any lane that might schedule an update. This is used to detect infinite
 // update loops, so it doesn't include hydration lanes or retries.
 export const UpdateLanes: Lanes =
   SyncLane | InputContinuousLane | DefaultLane | TransitionLanes;
 
-export const HydrationLanes =
-  SyncHydrationLane |
-  InputContinuousHydrationLane |
-  DefaultHydrationLane |
-  TransitionHydrationLane |
-  SelectiveHydrationLane |
-  IdleHydrationLane;
-
 // This function is used for the experimental timeline (react-devtools-timeline)
 // It should be kept in sync with the Lanes values above.
 export function getLabelForLane(lane: Lane): string | void {
@@ -147,21 +134,22 @@ export function getLabelForLane(lane: Lane): string | void {
     if (lane & OffscreenLane) {
       return 'Offscreen';
     }
-    if (lane & DeferredLane) {
-      return 'Deferred';
-    }
   }
 }
 
 export const NoTimestamp = -1;
 
+// "Registers" used to "return" multiple values
+// Used by getHighestPriorityLanes and getNextLanes:
 let nextTransitionLane: Lane = TransitionLane1;
 let nextRetryLane: Lane = RetryLane1;
 
 function getHighestPriorityLanes(lanes: Lanes | Lane): Lanes {
-  const pendingSyncLanes = lanes & SyncUpdateLanes;
-  if (pendingSyncLanes !== 0) {
-    return pendingSyncLanes;
+  if (enableUnifiedSyncLane) {
+    const pendingSyncLanes = lanes & SyncUpdateLanes;
+    if (pendingSyncLanes !== 0) {
+      return pendingSyncLanes;
+    }
   }
   switch (getHighestPriorityLane(lanes)) {
     case SyncHydrationLane:
@@ -176,8 +164,6 @@ function getHighestPriorityLanes(lanes: Lanes | Lane): Lanes {
       return DefaultHydrationLane;
     case DefaultLane:
       return DefaultLane;
-    case GestureLane:
-      return GestureLane;
     case TransitionHydrationLane:
       return TransitionHydrationLane;
     case TransitionLane1:
@@ -194,6 +180,8 @@ function getHighestPriorityLanes(lanes: Lanes | Lane): Lanes {
     case TransitionLane12:
     case TransitionLane13:
     case TransitionLane14:
+    case TransitionLane15:
+    case TransitionLane16:
       return lanes & TransitionLanes;
     case RetryLane1:
     case RetryLane2:
@@ -208,10 +196,6 @@ function getHighestPriorityLanes(lanes: Lanes | Lane): Lanes {
       return IdleLane;
     case OffscreenLane:
       return OffscreenLane;
-    case DeferredLane:
-      // This shouldn't be reachable because deferred work is always entangled
-      // with something else.
-      return NoLanes;
     default:
       if (__DEV__) {
         console.error(
@@ -223,85 +207,39 @@ function getHighestPriorityLanes(lanes: Lanes | Lane): Lanes {
   }
 }
 
-export function getNextLanes(
-  root: FiberRoot,
-  wipLanes: Lanes,
-  rootHasPendingCommit: boolean,
-): Lanes {
+export function getNextLanes(root: FiberRoot, wipLanes: Lanes): Lanes {
   // Early bailout if there's no pending work left.
   const pendingLanes = root.pendingLanes;
   if (pendingLanes === NoLanes) {
     return NoLanes;
   }
 
-  let nextLanes: Lanes = NoLanes;
+  let nextLanes = NoLanes;
 
   const suspendedLanes = root.suspendedLanes;
   const pingedLanes = root.pingedLanes;
-  const warmLanes = root.warmLanes;
-
-  // finishedLanes represents a completed tree that is ready to commit.
-  //
-  // It's not worth doing discarding the completed tree in favor of performing
-  // speculative work. So always check this before deciding to warm up
-  // the siblings.
-  //
-  // Note that this is not set in a "suspend indefinitely" scenario, like when
-  // suspending outside of a Suspense boundary, or in the shell during a
-  // transition — only in cases where we are very likely to commit the tree in
-  // a brief amount of time (i.e. below the "Just Noticeable Difference"
-  // threshold).
-  //
 
   // Do not work on any idle work until all the non-idle work has finished,
   // even if the work is suspended.
   const nonIdlePendingLanes = pendingLanes & NonIdleLanes;
   if (nonIdlePendingLanes !== NoLanes) {
-    // First check for fresh updates.
     const nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;
     if (nonIdleUnblockedLanes !== NoLanes) {
       nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);
     } else {
-      // No fresh updates. Check if suspended work has been pinged.
       const nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;
       if (nonIdlePingedLanes !== NoLanes) {
         nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);
-      } else {
-        if (enableSiblingPrerendering) {
-          // Nothing has been pinged. Check for lanes that need to be prewarmed.
-          if (!rootHasPendingCommit) {
-            const lanesToPrewarm = nonIdlePendingLanes & ~warmLanes;
-            if (lanesToPrewarm !== NoLanes) {
-              nextLanes = getHighestPriorityLanes(lanesToPrewarm);
-            }
-          }
-        }
       }
     }
   } else {
     // The only remaining work is Idle.
-    // TODO: Idle isn't really used anywhere, and the thinking around
-    // speculative rendering has evolved since this was implemented. Consider
-    // removing until we've thought about this again.
-
-    // First check for fresh updates.
     const unblockedLanes = pendingLanes & ~suspendedLanes;
     if (unblockedLanes !== NoLanes) {
       nextLanes = getHighestPriorityLanes(unblockedLanes);
     } else {
-      // No fresh updates. Check if suspended work has been pinged.
       if (pingedLanes !== NoLanes) {
         nextLanes = getHighestPriorityLanes(pingedLanes);
-      } else {
-        if (enableSiblingPrerendering) {
-          // Nothing has been pinged. Check for lanes that need to be prewarmed.
-          if (!rootHasPendingCommit) {
-            const lanesToPrewarm = pendingLanes & ~warmLanes;
-            if (lanesToPrewarm !== NoLanes) {
-              nextLanes = getHighestPriorityLanes(lanesToPrewarm);
-            }
-          }
-        }
       }
     }
   }
@@ -338,82 +276,17 @@ export function getNextLanes(
     }
   }
 
-  return nextLanes;
-}
-
-export function getNextLanesToFlushSync(
-  root: FiberRoot,
-  extraLanesToForceSync: Lane | Lanes,
-): Lanes {
-  // Similar to getNextLanes, except instead of choosing the next lanes to work
-  // on based on their priority, it selects all the lanes that have equal or
-  // higher priority than those are given. That way they can be synchronously
-  // rendered in a single batch.
-  //
-  // The main use case is updates scheduled by popstate events, which are
-  // flushed synchronously even though they are transitions.
-  // Note that we intentionally treat this as a sync flush to include any
-  // sync updates in a single pass but also intentionally disables View Transitions
-  // inside popstate. Because they can start synchronously before scroll restoration
-  // happens.
-  const lanesToFlush = SyncUpdateLanes | extraLanesToForceSync;
-
-  // Early bailout if there's no pending work left.
-  const pendingLanes = root.pendingLanes;
-  if (pendingLanes === NoLanes) {
-    return NoLanes;
-  }
-
-  const suspendedLanes = root.suspendedLanes;
-  const pingedLanes = root.pingedLanes;
-
-  // Remove lanes that are suspended (but not pinged)
-  const unblockedLanes = pendingLanes & ~(suspendedLanes & ~pingedLanes);
-  const unblockedLanesWithMatchingPriority =
-    unblockedLanes & getLanesOfEqualOrHigherPriority(lanesToFlush);
-
-  // If there are matching hydration lanes, we should do those by themselves.
-  // Hydration lanes must never include updates.
-  if (unblockedLanesWithMatchingPriority & HydrationLanes) {
-    return (
-      (unblockedLanesWithMatchingPriority & HydrationLanes) | SyncHydrationLane
-    );
-  }
-
-  if (unblockedLanesWithMatchingPriority) {
-    // Always include the SyncLane as part of the result, even if there's no
-    // pending sync work, to indicate the priority of the entire batch of work
-    // is considered Sync.
-    return unblockedLanesWithMatchingPriority | SyncLane;
-  }
-
-  return NoLanes;
-}
-
-export function checkIfRootIsPrerendering(
-  root: FiberRoot,
-  renderLanes: Lanes,
-): boolean {
-  const pendingLanes = root.pendingLanes;
-  const suspendedLanes = root.suspendedLanes;
-  const pingedLanes = root.pingedLanes;
-  // Remove lanes that are suspended (but not pinged)
-  const unblockedLanes = pendingLanes & ~(suspendedLanes & ~pingedLanes);
-
-  // If there are no unsuspended or pinged lanes, that implies that we're
-  // performing a prerender.
-  return (unblockedLanes & renderLanes) === 0;
-}
-
-export function getEntangledLanes(root: FiberRoot, renderLanes: Lanes): Lanes {
-  let entangledLanes = renderLanes;
-
-  if ((entangledLanes & InputContinuousLane) !== NoLanes) {
+  if (
+    allowConcurrentByDefault &&
+    (root.current.mode & ConcurrentUpdatesByDefaultMode) !== NoMode
+  ) {
+    // Do nothing, use the lanes as they were assigned.
+  } else if ((nextLanes & InputContinuousLane) !== NoLanes) {
     // When updates are sync by default, we entangle continuous priority updates
     // and default updates, so they render in the same batch. The only reason
     // they use separate lanes is because continuous updates should interrupt
     // transitions, but default updates should not.
-    entangledLanes |= entangledLanes & DefaultLane;
+    nextLanes |= pendingLanes & DefaultLane;
   }
 
   // Check for entangled lanes and add them to the batch.
@@ -429,30 +302,21 @@ export function getEntangledLanes(root: FiberRoot, renderLanes: Lanes): Lanes {
   // entanglement is usually "best effort": we'll try our best to render the
   // lanes in the same batch, but it's not worth throwing out partially
   // completed work in order to do it.
-  // TODO: Reconsider this. The counter-argument is that the partial work
-  // represents an intermediate state, which we don't want to show to the user.
-  // And by spending extra time finishing it, we're increasing the amount of
-  // time it takes to show the final state, which is what they are actually
-  // waiting for.
-  //
-  // For those exceptions where entanglement is semantically important,
-  // we should ensure that there is no partial work at the
-  // time we apply the entanglement.
-  const allEntangledLanes = root.entangledLanes;
-  if (allEntangledLanes !== NoLanes) {
+  const entangledLanes = root.entangledLanes;
+  if (entangledLanes !== NoLanes) {
     const entanglements = root.entanglements;
-    let lanes = entangledLanes & allEntangledLanes;
+    let lanes = nextLanes & entangledLanes;
     while (lanes > 0) {
       const index = pickArbitraryLaneIndex(lanes);
       const lane = 1 << index;
 
-      entangledLanes |= entanglements[index];
+      nextLanes |= entanglements[index];
 
       lanes &= ~lane;
     }
   }
 
-  return entangledLanes;
+  return nextLanes;
 }
 
 function computeExpirationTime(lane: Lane, currentTime: number) {
@@ -461,17 +325,8 @@ function computeExpirationTime(lane: Lane, currentTime: number) {
     case SyncLane:
     case InputContinuousHydrationLane:
     case InputContinuousLane:
-    case GestureLane:
       // User interactions should expire slightly more quickly.
-      //
-      // NOTE: This is set to the corresponding constant as in Scheduler.js.
-      // When we made it larger, a product metric in www regressed, suggesting
-      // there's a user interaction that's being starved by a series of
-      // synchronous updates. If that theory is correct, the proper solution is
-      // to fix the starvation. However, this scenario supports the idea that
-      // expiration times are an important safeguard when starvation
-      // does happen.
-      return currentTime + syncLaneExpirationMs;
+      return currentTime + 250;
     case DefaultHydrationLane:
     case DefaultLane:
     case TransitionHydrationLane:
@@ -489,7 +344,9 @@ function computeExpirationTime(lane: Lane, currentTime: number) {
     case TransitionLane12:
     case TransitionLane13:
     case TransitionLane14:
-      return currentTime + transitionLaneExpirationMs;
+    case TransitionLane15:
+    case TransitionLane16:
+      return currentTime + 5000;
     case RetryLane1:
     case RetryLane2:
     case RetryLane3:
@@ -499,14 +356,11 @@ function computeExpirationTime(lane: Lane, currentTime: number) {
       // crashes. There must be some other underlying bug; not super urgent but
       // ideally should figure out why and fix it. Unfortunately we don't have
       // a repro for the crashes, only detected via production metrics.
-      return enableRetryLaneExpiration
-        ? currentTime + retryLaneExpirationMs
-        : NoTimestamp;
+      return NoTimestamp;
     case SelectiveHydrationLane:
     case IdleHydrationLane:
     case IdleLane:
     case OffscreenLane:
-    case DeferredLane:
       // Anything idle priority or lower should never expire.
       return NoTimestamp;
     default:
@@ -535,14 +389,7 @@ export function markStarvedLanesAsExpired(
   // Iterate through the pending lanes and check if we've reached their
   // expiration time. If so, we'll assume the update is being starved and mark
   // it as expired to force it to finish.
-  // TODO: We should be able to replace this with upgradePendingLanesToSync
-  //
-  // We exclude retry lanes because those must always be time sliced, in order
-  // to unwrap uncached promises.
-  // TODO: Write a test for this
-  let lanes = enableRetryLaneExpiration
-    ? pendingLanes
-    : pendingLanes & ~RetryLanes;
+  let lanes = pendingLanes;
   while (lanes > 0) {
     const index = pickArbitraryLaneIndex(lanes);
     const lane = 1 << index;
@@ -578,11 +425,6 @@ export function getLanesToRetrySynchronouslyOnError(
   root: FiberRoot,
   originallyAttemptedLanes: Lanes,
 ): Lanes {
-  if (root.errorRecoveryDisabledLanes & originallyAttemptedLanes) {
-    // The error recovery mechanism is disabled until these lanes are cleared.
-    return NoLanes;
-  }
-
   const everythingButOffscreen = root.pendingLanes & ~OffscreenLane;
   if (everythingButOffscreen !== NoLanes) {
     return everythingButOffscreen;
@@ -597,10 +439,6 @@ export function includesSyncLane(lanes: Lanes): boolean {
   return (lanes & (SyncLane | SyncHydrationLane)) !== NoLanes;
 }
 
-export function isSyncLane(lanes: Lanes): boolean {
-  return (lanes & (SyncLane | SyncHydrationLane)) !== NoLanes;
-}
-
 export function includesNonIdleWork(lanes: Lanes): boolean {
   return (lanes & NonIdleLanes) !== NoLanes;
 }
@@ -608,8 +446,6 @@ export function includesOnlyRetries(lanes: Lanes): boolean {
   return (lanes & RetryLanes) === lanes;
 }
 export function includesOnlyNonUrgentLanes(lanes: Lanes): boolean {
-  // TODO: Should hydration lanes be included here? This function is only
-  // used in `updateDeferredValueImpl`.
   const UrgentLanes = SyncLane | InputContinuousLane | DefaultLane;
   return (lanes & UrgentLanes) === NoLanes;
 }
@@ -617,10 +453,6 @@ export function includesOnlyTransitions(lanes: Lanes): boolean {
   return (lanes & TransitionLanes) === lanes;
 }
 
-export function includesTransitionLane(lanes: Lanes): boolean {
-  return (lanes & TransitionLanes) !== NoLanes;
-}
-
 export function includesOnlyHydrationLanes(lanes: Lanes): boolean {
   return (lanes & HydrationLanes) === lanes;
 }
@@ -637,48 +469,23 @@ export function includesOnlyViewTransitionEligibleLanes(lanes: Lanes): boolean {
   return (lanes & (TransitionLanes | RetryLanes | IdleLane)) === lanes;
 }
 
-export function includesOnlySuspenseyCommitEligibleLanes(
-  lanes: Lanes,
-): boolean {
-  return (
-    (lanes & (TransitionLanes | RetryLanes | IdleLane | GestureLane)) === lanes
-  );
-}
-
 export function includesBlockingLane(lanes: Lanes): boolean {
   const SyncDefaultLanes =
     InputContinuousHydrationLane |
     InputContinuousLane |
     DefaultHydrationLane |
-    DefaultLane |
-    GestureLane;
+    DefaultLane;
   return (lanes & SyncDefaultLanes) !== NoLanes;
 }
 
 export function includesExpiredLane(root: FiberRoot, lanes: Lanes): boolean {
-  // This is a separate check from includesBlockingLane because a lane can
-  // expire after a render has already started.
   return (lanes & root.expiredLanes) !== NoLanes;
 }
 
-export function isBlockingLane(lane: Lane): boolean {
-  const SyncDefaultLanes =
-    InputContinuousHydrationLane |
-    InputContinuousLane |
-    DefaultHydrationLane |
-    DefaultLane;
-  return (lane & SyncDefaultLanes) !== NoLanes;
-}
-
 export function isTransitionLane(lane: Lane): boolean {
   return (lane & TransitionLanes) !== NoLanes;
 }
 
-export function isGestureRender(lanes: Lanes): boolean {
-  // This should render only the one lane.
-  return lanes === GestureLane;
-}
-
 export function claimNextTransitionLane(): Lane {
   // Cycle through the lanes, assigning each new transition to the next lane.
   // In most cases, this means every transition gets its own lane, until we
@@ -704,14 +511,6 @@ export function getHighestPriorityLane(lanes: Lanes): Lane {
   return lanes & -lanes;
 }
 
-function getLanesOfEqualOrHigherPriority(lanes: Lane | Lanes): Lanes {
-  // Create a mask with all bits to the right or same as the highest bit.
-  // So if lanes is 0b100, the result would be 0b111.
-  // If lanes is 0b101, the result would be 0b111.
-  const lowestPriorityLaneIndex = 31 - clz32(lanes);
-  return (1 << (lowestPriorityLaneIndex + 1)) - 1;
-}
-
 export function pickArbitraryLane(lanes: Lanes): Lane {
   // This wrapper function gets inlined. Only exists so to communicate that it
   // doesn't matter which bit is selected; you can pick any bit without
@@ -744,17 +543,13 @@ export function removeLanes(set: Lanes, subset: Lanes | Lane): Lanes {
   return set & ~subset;
 }
 
-export function intersectLanes(a: Lanes | Lane, b: Lanes | Lane): Lanes {
-  return a & b;
-}
-
 // Seems redundant, but it changes the type from a single lane (used for
 // updates) to a group of lanes (used for flushing work).
 export function laneToLanes(lane: Lane): Lanes {
   return lane;
 }
 
-export function higherPriorityLane(a: Lane, b: Lane): Lane {
+export function higherPriorityLane(a: Lane, b: Lane) {
   // This works because the bit ranges decrease in priority as you go left.
   return a !== NoLane && a < b ? a : b;
 }
@@ -787,7 +582,6 @@ export function markRootUpdated(root: FiberRoot, updateLane: Lane) {
   if (updateLane !== IdleLane) {
     root.suspendedLanes = NoLanes;
     root.pingedLanes = NoLanes;
-    root.warmLanes = NoLanes;
   }
 }
 
@@ -795,21 +589,10 @@ export function markRootSuspended(
   root: FiberRoot,
   suspendedLanes: Lanes,
   spawnedLane: Lane,
-  didAttemptEntireTree: boolean,
 ) {
-  // TODO: Split this into separate functions for marking the root at the end of
-  // a render attempt versus suspending while the root is still in progress.
   root.suspendedLanes |= suspendedLanes;
   root.pingedLanes &= ~suspendedLanes;
 
-  if (enableSiblingPrerendering && didAttemptEntireTree) {
-    // Mark these lanes as warm so we know there's nothing else to work on.
-    root.warmLanes |= suspendedLanes;
-  } else {
-    // Render unwound without attempting all the siblings. Do no mark the lanes
-    // as warm. This will cause a prewarm render to be scheduled.
-  }
-
   // The suspended lanes are no longer CPU-bound. Clear their expiration times.
   const expirationTimes = root.expirationTimes;
   let lanes = suspendedLanes;
@@ -821,45 +604,25 @@ export function markRootSuspended(
 
     lanes &= ~lane;
   }
-
-  if (spawnedLane !== NoLane) {
-    markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);
-  }
 }
 
 export function markRootPinged(root: FiberRoot, pingedLanes: Lanes) {
   root.pingedLanes |= root.suspendedLanes & pingedLanes;
-  // The data that just resolved could have unblocked additional children, which
-  // will also need to be prewarmed if something suspends again.
-  root.warmLanes &= ~pingedLanes;
 }
 
-export function markRootFinished(
-  root: FiberRoot,
-  finishedLanes: Lanes,
-  remainingLanes: Lanes,
-  spawnedLane: Lane,
-  updatedLanes: Lanes,
-  suspendedRetryLanes: Lanes,
-) {
-  const previouslyPendingLanes = root.pendingLanes;
-  const noLongerPendingLanes = previouslyPendingLanes & ~remainingLanes;
+export function markRootFinished(root: FiberRoot, remainingLanes: Lanes) {
+  const noLongerPendingLanes = root.pendingLanes & ~remainingLanes;
 
   root.pendingLanes = remainingLanes;
 
   // Let's try everything again
   root.suspendedLanes = NoLanes;
   root.pingedLanes = NoLanes;
-  root.warmLanes = NoLanes;
 
   root.expiredLanes &= remainingLanes;
 
-  root.entangledLanes &= remainingLanes;
-
-  root.errorRecoveryDisabledLanes &= remainingLanes;
-  root.shellSuspendCounter = 0;
-
   const entanglements = root.entanglements;
+  const eventTimes = root.eventTimes;
   const expirationTimes = root.expirationTimes;
   const hiddenUpdates = root.hiddenUpdates;
 
@@ -870,6 +633,7 @@ export function markRootFinished(
     const lane = 1 << index;
 
     entanglements[index] = NoLanes;
+    eventTimes[index] = NoTimestamp;
     expirationTimes[index] = NoTimestamp;
 
     const hiddenUpdatesForLane = hiddenUpdates[index];
@@ -889,71 +653,6 @@ export function markRootFinished(
 
     lanes &= ~lane;
   }
-
-  if (spawnedLane !== NoLane) {
-    markSpawnedDeferredLane(
-      root,
-      spawnedLane,
-      // This render finished successfully without suspending, so we don't need
-      // to entangle the spawned task with the parent task.
-      NoLanes,
-    );
-  }
-
-  // suspendedRetryLanes represents the retry lanes spawned by new Suspense
-  // boundaries during this render that were not later pinged.
-  //
-  // These lanes were marked as pending on their associated Suspense boundary
-  // fiber during the render phase so that we could start rendering them
-  // before new data streams in. As soon as the fallback commits, we can try
-  // to render them again.
-  //
-  // But since we know they're still suspended, we can skip straight to the
-  // "prerender" mode (i.e. don't skip over siblings after something
-  // suspended) instead of the regular mode (i.e. unwind and skip the siblings
-  // as soon as something suspends to unblock the rest of the update).
-  if (
-    enableSiblingPrerendering &&
-    suspendedRetryLanes !== NoLanes &&
-    // Note that we only do this if there were no updates since we started
-    // rendering. This mirrors the logic in markRootUpdated — whenever we
-    // receive an update, we reset all the suspended and pinged lanes.
-    updatedLanes === NoLanes &&
-    !(disableLegacyMode && root.tag === LegacyRoot)
-  ) {
-    // We also need to avoid marking a retry lane as suspended if it was already
-    // pending before this render. We can't say these are now suspended if they
-    // weren't included in our attempt.
-    const freshlySpawnedRetryLanes =
-      suspendedRetryLanes &
-      // Remove any retry lane that was already pending before our just-finished
-      // attempt, and also wasn't included in that attempt.
-      ~(previouslyPendingLanes & ~finishedLanes);
-    root.suspendedLanes |= freshlySpawnedRetryLanes;
-  }
-}
-
-function markSpawnedDeferredLane(
-  root: FiberRoot,
-  spawnedLane: Lane,
-  entangledLanes: Lanes,
-) {
-  // This render spawned a deferred task. Mark it as pending.
-  root.pendingLanes |= spawnedLane;
-  root.suspendedLanes &= ~spawnedLane;
-
-  // Entangle the spawned lane with the DeferredLane bit so that we know it
-  // was the result of another render. This lets us avoid a useDeferredValue
-  // waterfall — only the first level will defer.
-  const spawnedLaneIndex = laneToIndex(spawnedLane);
-  root.entangledLanes |= spawnedLane;
-  root.entanglements[spawnedLaneIndex] |=
-    DeferredLane |
-    // If the parent render task suspended, we must also entangle those lanes
-    // with the spawned task, so that the deferred task includes all the same
-    // updates that the parent task did. We can exclude any lane that is not
-    // used for updates (e.g. Offscreen).
-    (entangledLanes & UpdateLanes);
 }
 
 export function markRootEntangled(root: FiberRoot, entangledLanes: Lanes) {
@@ -987,106 +686,6 @@ export function markRootEntangled(root: FiberRoot, entangledLanes: Lanes) {
   }
 }
 
-export function upgradePendingLanesToSync(
-  root: FiberRoot,
-  lanesToUpgrade: Lanes,
-) {
-  // Same as upgradePendingLaneToSync but accepts multiple lanes, so it's a
-  // bit slower.
-  root.pendingLanes |= SyncLane;
-  root.entangledLanes |= SyncLane;
-  let lanes = lanesToUpgrade;
-  while (lanes) {
-    const index = pickArbitraryLaneIndex(lanes);
-    const lane = 1 << index;
-    root.entanglements[SyncLaneIndex] |= lane;
-    lanes &= ~lane;
-  }
-}
-
-export function markHiddenUpdate(
-  root: FiberRoot,
-  update: ConcurrentUpdate,
-  lane: Lane,
-) {
-  const index = laneToIndex(lane);
-  const hiddenUpdates = root.hiddenUpdates;
-  const hiddenUpdatesForLane = hiddenUpdates[index];
-  if (hiddenUpdatesForLane === null) {
-    hiddenUpdates[index] = [update];
-  } else {
-    hiddenUpdatesForLane.push(update);
-  }
-  update.lane = lane | OffscreenLane;
-}
-
-export function getBumpedLaneForHydration(
-  root: FiberRoot,
-  renderLanes: Lanes,
-): Lane {
-  const renderLane = getHighestPriorityLane(renderLanes);
-  const bumpedLane =
-    (renderLane & SyncUpdateLanes) !== NoLane
-      ? // Unify sync lanes. We don't do this inside getBumpedLaneForHydrationByLane
-        // because that causes things to flush synchronously when they shouldn't.
-        // TODO: This is not coherent but that's beacuse the unification is not coherent.
-        // We need to get merge these into an actual single lane.
-        SyncHydrationLane
-      : getBumpedLaneForHydrationByLane(renderLane);
-  // Check if the lane we chose is suspended. If so, that indicates that we
-  // already attempted and failed to hydrate at that level. Also check if we're
-  // already rendering that lane, which is rare but could happen.
-  // TODO: This should move into the caller to decide whether giving up is valid.
-  if ((bumpedLane & (root.suspendedLanes | renderLanes)) !== NoLane) {
-    // Give up trying to hydrate and fall back to client render.
-    return NoLane;
-  }
-  return bumpedLane;
-}
-
-export function getBumpedLaneForHydrationByLane(lane: Lane): Lane {
-  switch (lane) {
-    case SyncLane:
-      lane = SyncHydrationLane;
-      break;
-    case InputContinuousLane:
-      lane = InputContinuousHydrationLane;
-      break;
-    case DefaultLane:
-      lane = DefaultHydrationLane;
-      break;
-    case TransitionLane1:
-    case TransitionLane2:
-    case TransitionLane3:
-    case TransitionLane4:
-    case TransitionLane5:
-    case TransitionLane6:
-    case TransitionLane7:
-    case TransitionLane8:
-    case TransitionLane9:
-    case TransitionLane10:
-    case TransitionLane11:
-    case TransitionLane12:
-    case TransitionLane13:
-    case TransitionLane14:
-    case RetryLane1:
-    case RetryLane2:
-    case RetryLane3:
-    case RetryLane4:
-      lane = TransitionHydrationLane;
-      break;
-    case IdleLane:
-      lane = IdleHydrationLane;
-      break;
-    default:
-      // Everything else is already either a hydration lane, or shouldn't
-      // be retried at a hydration lane.
-      lane = NoLane;
-      break;
-  }
-  return lane;
-}
-
 export function addFiberToLanesMap(
   root: FiberRoot,
   fiber: Fiber,
@@ -1212,8 +811,7 @@ export function getGroupNameOfHighestPriorityLane(lanes: Lanes): string {
       InputContinuousHydrationLane |
       InputContinuousLane |
       DefaultHydrationLane |
-      DefaultLane |
-      GestureLane)
+      DefaultLane)
   ) {
     return 'Blocking';
   }
@@ -1228,8 +826,7 @@ export function getGroupNameOfHighestPriorityLane(lanes: Lanes): string {
     (SelectiveHydrationLane |
       IdleHydrationLane |
       IdleLane |
-      OffscreenLane |
-      DeferredLane)
+      OffscreenLane)
   ) {
     return 'Idle';
   }
