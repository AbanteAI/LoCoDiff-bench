
index 54a872a6e..b4f5395d4 100644
--- a/react_packages_react-reconciler_src_ReactFiberLane.js_expectedoutput.txt (expected):tmp/tmp13zrthgn_expected.txt	
+++ b/react_packages_react-reconciler_src_ReactFiberLane.js_extracted.txt (actual):tmp/tmpzq77a7_4_actual.txt	
@@ -8,7 +8,7 @@
  */
 
 import type {Fiber, FiberRoot} from './ReactInternalTypes';
-import type {Transition} from 'react/src/ReactStartTransition';
+import type {Transition} from './ReactFiberTracingMarkerComponent';
 import type {ConcurrentUpdate} from './ReactFiberConcurrentUpdates';
 
 // TODO: Ideally these types would be opaque but that doesn't work well with
@@ -27,15 +27,12 @@ import {
   transitionLaneExpirationMs,
   retryLaneExpirationMs,
   disableLegacyMode,
-  enableSiblingPrerendering,
 } from 'shared/ReactFeatureFlags';
 import {isDevToolsPresent} from './ReactFiberDevToolsHook';
 import {clz32} from './clz32';
 import {LegacyRoot} from './ReactRootTags';
 
 // Lane values below should be kept in sync with getLabelForLane(), used by react-devtools-timeline.
-// If those values are changed that package should be rebuilt and redeployed.
-
 export const TotalLanes = 31;
 
 export const NoLanes: Lanes = /*                        */ 0b0000000000000000000000000000000;
@@ -54,24 +51,23 @@ export const DefaultLane: Lane = /*                     */ 0b0000000000000000000
 export const SyncUpdateLanes: Lane =
   SyncLane | InputContinuousLane | DefaultLane;
 
-export const GestureLane: Lane = /*                     */ 0b0000000000000000000000001000000;
-
-const TransitionHydrationLane: Lane = /*                */ 0b0000000000000000000000010000000;
-const TransitionLanes: Lanes = /*                       */ 0b0000000001111111111111100000000;
-const TransitionLane1: Lane = /*                        */ 0b0000000000000000000000100000000;
-const TransitionLane2: Lane = /*                        */ 0b0000000000000000000001000000000;
-const TransitionLane3: Lane = /*                        */ 0b0000000000000000000010000000000;
-const TransitionLane4: Lane = /*                        */ 0b0000000000000000000100000000000;
-const TransitionLane5: Lane = /*                        */ 0b0000000000000000001000000000000;
-const TransitionLane6: Lane = /*                        */ 0b0000000000000000010000000000000;
-const TransitionLane7: Lane = /*                        */ 0b0000000000000000100000000000000;
-const TransitionLane8: Lane = /*                        */ 0b0000000000000001000000000000000;
-const TransitionLane9: Lane = /*                        */ 0b0000000000000010000000000000000;
-const TransitionLane10: Lane = /*                       */ 0b0000000000000100000000000000000;
-const TransitionLane11: Lane = /*                       */ 0b0000000000001000000000000000000;
-const TransitionLane12: Lane = /*                       */ 0b0000000000010000000000000000000;
-const TransitionLane13: Lane = /*                       */ 0b0000000000100000000000000000000;
-const TransitionLane14: Lane = /*                       */ 0b0000000001000000000000000000000;
+const TransitionHydrationLane: Lane = /*                */ 0b0000000000000000000000001000000;
+const TransitionLanes: Lanes = /*                       */ 0b0000000001111111111111110000000;
+const TransitionLane1: Lane = /*                        */ 0b0000000000000000000000010000000;
+const TransitionLane2: Lane = /*                        */ 0b0000000000000000000000100000000;
+const TransitionLane3: Lane = /*                        */ 0b0000000000000000000001000000000;
+const TransitionLane4: Lane = /*                        */ 0b0000000000000000000010000000000;
+const TransitionLane5: Lane = /*                        */ 0b0000000000000000000100000000000;
+const TransitionLane6: Lane = /*                        */ 0b0000000000000000001000000000000;
+const TransitionLane7: Lane = /*                        */ 0b0000000000000000010000000000000;
+const TransitionLane8: Lane = /*                        */ 0b0000000000000000100000000000000;
+const TransitionLane9: Lane = /*                        */ 0b0000000000000001000000000000000;
+const TransitionLane10: Lane = /*                       */ 0b0000000000000010000000000000000;
+const TransitionLane11: Lane = /*                       */ 0b0000000000000100000000000000000;
+const TransitionLane12: Lane = /*                       */ 0b0000000000001000000000000000000;
+const TransitionLane13: Lane = /*                       */ 0b0000000000010000000000000000000;
+const TransitionLane14: Lane = /*                       */ 0b0000000000100000000000000000000;
+const TransitionLane15: Lane = /*                       */ 0b0000000001000000000000000000000;
 
 const RetryLanes: Lanes = /*                            */ 0b0000011110000000000000000000000;
 const RetryLane1: Lane = /*                             */ 0b0000000010000000000000000000000;
@@ -105,7 +101,6 @@ export const HydrationLanes =
   IdleHydrationLane;
 
 // This function is used for the experimental timeline (react-devtools-timeline)
-// It should be kept in sync with the Lanes values above.
 export function getLabelForLane(lane: Lane): string | void {
   if (enableSchedulingProfiler) {
     if (lane & SyncHydrationLane) {
@@ -176,8 +171,6 @@ function getHighestPriorityLanes(lanes: Lanes | Lane): Lanes {
       return DefaultHydrationLane;
     case DefaultLane:
       return DefaultLane;
-    case GestureLane:
-      return GestureLane;
     case TransitionHydrationLane:
       return TransitionHydrationLane;
     case TransitionLane1:
@@ -194,6 +187,7 @@ function getHighestPriorityLanes(lanes: Lanes | Lane): Lanes {
     case TransitionLane12:
     case TransitionLane13:
     case TransitionLane14:
+    case TransitionLane15:
       return lanes & TransitionLanes;
     case RetryLane1:
     case RetryLane2:
@@ -223,11 +217,7 @@ function getHighestPriorityLanes(lanes: Lanes | Lane): Lanes {
   }
 }
 
-export function getNextLanes(
-  root: FiberRoot,
-  wipLanes: Lanes,
-  rootHasPendingCommit: boolean,
-): Lanes {
+export function getNextLanes(root: FiberRoot, wipLanes: Lanes): Lanes {
   // Early bailout if there's no pending work left.
   const pendingLanes = root.pendingLanes;
   if (pendingLanes === NoLanes) {
@@ -252,6 +242,16 @@ export function getNextLanes(
   // a brief amount of time (i.e. below the "Just Noticeable Difference"
   // threshold).
   //
+  // TODO: finishedLanes is also set when a Suspensey resource, like CSS or
+  // images, suspends during the commit phase. (We could detect that here by
+  // checking for root.cancelPendingCommit.) These are also expected to resolve
+  // quickly, because of preloading, but theoretically they could block forever
+  // like in a normal "suspend indefinitely" scenario. In the future, we should
+  // consider only blocking for up to some time limit before discarding the
+  // commit in favor of prerendering. If we do discard a pending commit, then
+  // the commit phase callback should act as a ping to try the original
+  // render again.
+  const rootHasPendingCommit = root.finishedLanes !== NoLanes;
 
   // Do not work on any idle work until all the non-idle work has finished,
   // even if the work is suspended.
@@ -267,13 +267,11 @@ export function getNextLanes(
       if (nonIdlePingedLanes !== NoLanes) {
         nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);
       } else {
-        if (enableSiblingPrerendering) {
-          // Nothing has been pinged. Check for lanes that need to be prewarmed.
-          if (!rootHasPendingCommit) {
-            const lanesToPrewarm = nonIdlePendingLanes & ~warmLanes;
-            if (lanesToPrewarm !== NoLanes) {
-              nextLanes = getHighestPriorityLanes(lanesToPrewarm);
-            }
+        // Nothing has been pinged. Check for lanes that need to be prewarmed.
+        if (!rootHasPendingCommit) {
+          const lanesToPrewarm = nonIdlePendingLanes & ~warmLanes;
+          if (lanesToPrewarm !== NoLanes) {
+            nextLanes = getHighestPriorityLanes(lanesToPrewarm);
           }
         }
       }
@@ -293,13 +291,11 @@ export function getNextLanes(
       if (pingedLanes !== NoLanes) {
         nextLanes = getHighestPriorityLanes(pingedLanes);
       } else {
-        if (enableSiblingPrerendering) {
-          // Nothing has been pinged. Check for lanes that need to be prewarmed.
-          if (!rootHasPendingCommit) {
-            const lanesToPrewarm = pendingLanes & ~warmLanes;
-            if (lanesToPrewarm !== NoLanes) {
-              nextLanes = getHighestPriorityLanes(lanesToPrewarm);
-            }
+        // Nothing has been pinged. Check for lanes that need to be prewarmed.
+        if (!rootHasPendingCommit) {
+          const lanesToPrewarm = pendingLanes & ~warmLanes;
+          if (lanesToPrewarm !== NoLanes) {
+            nextLanes = getHighestPriorityLanes(lanesToPrewarm);
           }
         }
       }
@@ -352,10 +348,6 @@ export function getNextLanesToFlushSync(
   //
   // The main use case is updates scheduled by popstate events, which are
   // flushed synchronously even though they are transitions.
-  // Note that we intentionally treat this as a sync flush to include any
-  // sync updates in a single pass but also intentionally disables View Transitions
-  // inside popstate. Because they can start synchronously before scroll restoration
-  // happens.
   const lanesToFlush = SyncUpdateLanes | extraLanesToForceSync;
 
   // Early bailout if there's no pending work left.
@@ -461,7 +453,6 @@ function computeExpirationTime(lane: Lane, currentTime: number) {
     case SyncLane:
     case InputContinuousHydrationLane:
     case InputContinuousLane:
-    case GestureLane:
       // User interactions should expire slightly more quickly.
       //
       // NOTE: This is set to the corresponding constant as in Scheduler.js.
@@ -489,6 +480,7 @@ function computeExpirationTime(lane: Lane, currentTime: number) {
     case TransitionLane12:
     case TransitionLane13:
     case TransitionLane14:
+    case TransitionLane15:
       return currentTime + transitionLaneExpirationMs;
     case RetryLane1:
     case RetryLane2:
@@ -621,37 +613,12 @@ export function includesTransitionLane(lanes: Lanes): boolean {
   return (lanes & TransitionLanes) !== NoLanes;
 }
 
-export function includesOnlyHydrationLanes(lanes: Lanes): boolean {
-  return (lanes & HydrationLanes) === lanes;
-}
-
-export function includesOnlyOffscreenLanes(lanes: Lanes): boolean {
-  return (lanes & OffscreenLane) === lanes;
-}
-
-export function includesOnlyHydrationOrOffscreenLanes(lanes: Lanes): boolean {
-  return (lanes & (HydrationLanes | OffscreenLane)) === lanes;
-}
-
-export function includesOnlyViewTransitionEligibleLanes(lanes: Lanes): boolean {
-  return (lanes & (TransitionLanes | RetryLanes | IdleLane)) === lanes;
-}
-
-export function includesOnlySuspenseyCommitEligibleLanes(
-  lanes: Lanes,
-): boolean {
-  return (
-    (lanes & (TransitionLanes | RetryLanes | IdleLane | GestureLane)) === lanes
-  );
-}
-
 export function includesBlockingLane(lanes: Lanes): boolean {
   const SyncDefaultLanes =
     InputContinuousHydrationLane |
     InputContinuousLane |
     DefaultHydrationLane |
-    DefaultLane |
-    GestureLane;
+    DefaultLane;
   return (lanes & SyncDefaultLanes) !== NoLanes;
 }
 
@@ -674,11 +641,6 @@ export function isTransitionLane(lane: Lane): boolean {
   return (lane & TransitionLanes) !== NoLanes;
 }
 
-export function isGestureRender(lanes: Lanes): boolean {
-  // This should render only the one lane.
-  return lanes === GestureLane;
-}
-
 export function claimNextTransitionLane(): Lane {
   // Cycle through the lanes, assigning each new transition to the next lane.
   // In most cases, this means every transition gets its own lane, until we
@@ -795,14 +757,12 @@ export function markRootSuspended(
   root: FiberRoot,
   suspendedLanes: Lanes,
   spawnedLane: Lane,
-  didAttemptEntireTree: boolean,
+  didSkipSuspendedSiblings: boolean,
 ) {
-  // TODO: Split this into separate functions for marking the root at the end of
-  // a render attempt versus suspending while the root is still in progress.
   root.suspendedLanes |= suspendedLanes;
   root.pingedLanes &= ~suspendedLanes;
 
-  if (enableSiblingPrerendering && didAttemptEntireTree) {
+  if (!didSkipSuspendedSiblings) {
     // Mark these lanes as warm so we know there's nothing else to work on.
     root.warmLanes |= suspendedLanes;
   } else {
@@ -913,7 +873,6 @@ export function markRootFinished(
   // suspended) instead of the regular mode (i.e. unwind and skip the siblings
   // as soon as something suspends to unblock the rest of the update).
   if (
-    enableSiblingPrerendering &&
     suspendedRetryLanes !== NoLanes &&
     // Note that we only do this if there were no updates since we started
     // rendering. This mirrors the logic in markRootUpdated — whenever we
@@ -1025,65 +984,61 @@ export function getBumpedLaneForHydration(
   renderLanes: Lanes,
 ): Lane {
   const renderLane = getHighestPriorityLane(renderLanes);
-  const bumpedLane =
-    (renderLane & SyncUpdateLanes) !== NoLane
-      ? // Unify sync lanes. We don't do this inside getBumpedLaneForHydrationByLane
-        // because that causes things to flush synchronously when they shouldn't.
-        // TODO: This is not coherent but that's beacuse the unification is not coherent.
-        // We need to get merge these into an actual single lane.
-        SyncHydrationLane
-      : getBumpedLaneForHydrationByLane(renderLane);
+
+  let lane;
+  if ((renderLane & SyncUpdateLanes) !== NoLane) {
+    lane = SyncHydrationLane;
+  } else {
+    switch (renderLane) {
+      case SyncLane:
+        lane = SyncHydrationLane;
+        break;
+      case InputContinuousLane:
+        lane = InputContinuousHydrationLane;
+        break;
+      case DefaultLane:
+        lane = DefaultHydrationLane;
+        break;
+      case TransitionLane1:
+      case TransitionLane2:
+      case TransitionLane3:
+      case TransitionLane4:
+      case TransitionLane5:
+      case TransitionLane6:
+      case TransitionLane7:
+      case TransitionLane8:
+      case TransitionLane9:
+      case TransitionLane10:
+      case TransitionLane11:
+      case TransitionLane12:
+      case TransitionLane13:
+      case TransitionLane14:
+      case TransitionLane15:
+      case RetryLane1:
+      case RetryLane2:
+      case RetryLane3:
+      case RetryLane4:
+        lane = TransitionHydrationLane;
+        break;
+      case IdleLane:
+        lane = IdleHydrationLane;
+        break;
+      default:
+        // Everything else is already either a hydration lane, or shouldn't
+        // be retried at a hydration lane.
+        lane = NoLane;
+        break;
+    }
+  }
+
   // Check if the lane we chose is suspended. If so, that indicates that we
   // already attempted and failed to hydrate at that level. Also check if we're
   // already rendering that lane, which is rare but could happen.
-  // TODO: This should move into the caller to decide whether giving up is valid.
-  if ((bumpedLane & (root.suspendedLanes | renderLanes)) !== NoLane) {
+  if ((lane & (root.suspendedLanes | renderLanes)) !== NoLane) {
     // Give up trying to hydrate and fall back to client render.
     return NoLane;
   }
-  return bumpedLane;
-}
 
-export function getBumpedLaneForHydrationByLane(lane: Lane): Lane {
-  switch (lane) {
-    case SyncLane:
-      lane = SyncHydrationLane;
-      break;
-    case InputContinuousLane:
-      lane = InputContinuousHydrationLane;
-      break;
-    case DefaultLane:
-      lane = DefaultHydrationLane;
-      break;
-    case TransitionLane1:
-    case TransitionLane2:
-    case TransitionLane3:
-    case TransitionLane4:
-    case TransitionLane5:
-    case TransitionLane6:
-    case TransitionLane7:
-    case TransitionLane8:
-    case TransitionLane9:
-    case TransitionLane10:
-    case TransitionLane11:
-    case TransitionLane12:
-    case TransitionLane13:
-    case TransitionLane14:
-    case RetryLane1:
-    case RetryLane2:
-    case RetryLane3:
-    case RetryLane4:
-      lane = TransitionHydrationLane;
-      break;
-    case IdleLane:
-      lane = IdleHydrationLane;
-      break;
-    default:
-      // Everything else is already either a hydration lane, or shouldn't
-      // be retried at a hydration lane.
-      lane = NoLane;
-      break;
-  }
   return lane;
 }
 
@@ -1212,8 +1167,7 @@ export function getGroupNameOfHighestPriorityLane(lanes: Lanes): string {
       InputContinuousHydrationLane |
       InputContinuousLane |
       DefaultHydrationLane |
-      DefaultLane |
-      GestureLane)
+      DefaultLane)
   ) {
     return 'Blocking';
   }
