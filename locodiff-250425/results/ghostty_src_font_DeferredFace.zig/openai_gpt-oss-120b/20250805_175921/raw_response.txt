```zig
//! A deferred face represents a single font face with all the information
//! necessary to load it, but defers loading the full face until it is needed.
//! This allows us to have many fallback fonts to look for glyphs, but
//! only load them when actually needed.

const DeferredFace = @This();

const std = @import("std");
const assert = std.debug.assert;
const fontconfig = @import("fontconfig");
const macos = @import("macos");
const font = @import("main.zig");
const options = @import("main.zig").options;
const Library = @import("main.zig").Library;
const Face = @import("main.zig").Face;
const Presentation = @import("main.zig").Presentation;
const Allocator = std.mem.Allocator;

const log = std.log.scoped(.deferred_face);

/// Fontconfig specific data. This is only present when building with fontconfig.
pub const Fontconfig = struct {
    /// The pattern for this font. This must be the "render prepared" pattern.
    pattern: *fontconfig.Pattern,
    /// Charset and Langset are used for quick lookup if a codepoint and
    /// presentation style are supported. They can be derived from pattern
    /// but are cached since they're frequently used.
    charset: *const fontconfig.CharSet,
    langset: *const fontconfig.LangSet,
    /// Variations to apply to this font.
    variations: []const font.face.Variation,

    pub fn deinit(self: *Fontconfig) void {
        self.pattern.destroy();
        self.* = undefined;
    }
};

/// CoreText specific data. This is only present when building with CoreText.
pub const CoreText = struct {
    /// The initialized font.
    font: *macos.text.Font,
    /// Variations to apply to this font. We apply the variations to the
    /// search descriptor but sometimes when the font collection is
    /// created the variation axes are reset so we repeat them.
    variations: []const font.face.Variation,

    pub fn deinit(self: *CoreText) void {
        self.font.release();
        self.* = undefined;
    }
};

/// WebCanvas specific data. This is only present when building for wasm.
pub const WebCanvas = struct {
    /// The allocator to use for fonts.
    alloc: Allocator,
    /// Font family string used for the canvas's `font` attribute.
    font_str: [:0]const u8,
    /// Presentation that this font supports (text/emoji).
    presentation: Presentation,

    pub fn deinit(self: *WebCanvas) void {
        self.alloc.free(self.font_str);
        self.* = undefined;
    }
};

/// The deferred face fields for each backend.
fc: if (options.backend == .fontconfig_freetype) ?Fontconfig else void =
    if (options.backend == .fontconfig_freetype) null else {},

/// CoreText data (present for coretext, coretext_freetype, coretext_harfbuzz, coretext_noshape).
ct: if (font.Discover == font.discovery.CoreText) ?CoreText else void =
    if (font.Discover == discovery.CoreText) null else {},

/// WebCanvas data.
wc: if (options.backend == .web_canvas) ?WebCanvas else void =
    if (options.backend == .web_canvas) null else {},

/// Returns the family name of the font.
pub fn familyName(self: DeferredFace, buf: []u8) ![]const u8 {
    switch (options.backend) {
        .freetype => {},
        .fontconfig_freetype => if (self.fc) |fc|
            return (try fc.pattern.get(.family, 0)).string,
        .coretext, .coretext_freetype, .coretext_harfbuzz, .coretext_noshape => if (self.ct) |ct| {
            const family_name = ct.font.copyAttribute(.family_name) orelse
                return "unknown";
            return family_name.cstringPtr(.utf8) orelse block: {
                const tmp = family_name.cstring(buf, .utf8) orelse
                    return error.OutOfMemory;
                break :block tmp;
            };
        },
        .web_canvas => if (self.wc) |wc| return wc.font_str,
    }
    return "";
}

/// Returns the name of this face. The memory is always owned by the
/// face so it doesn't have to be freed.
pub fn name(self: DeferredFace, buf: []u8) ![]const u8 {
    switch (options.backend) {
        .freetype => {},
        .fontconfig_freetype => if (self.fc) |fc|
            return (try fc.pattern.get(.fullname, 0)).string,
        .coretext, .coretext_freetype, .coretext_harfbuzz, .coretext_noshape => if (self.ct) |ct| {
            const display_name = ct.font.copyDisplayName();
            return display_name.cstringPtr(.utf8) orelse block: {
                var tmp_buf: [1024]u8 = undefined;
                const txt = display_name.cstring(&tmp_buf, .utf8) orelse
                    return error.OutOfMemory;
                break :block txt;
            };
        },
        .web_canvas => if (self.wc) |wc| return wc.font_str,
    }
    return "";
}

/// Loads (and returns) the deferred font face. This always returns a
/// *new* Face instance. The caller owns the returned face.
pub fn load(
    self: *DeferredFace,
    lib: Library,
    opts: font.face.Options,
) !Face {
    return switch (options.backend) {
        .fontconfig_freetype => try self.loadFontconfig(lib, opts),
        .coretext, .coretext_harfbuzz, .coretext_noshape => try self.loadCoreText(lib, opts),
        .coretext_freetype => try self.loadCoreTextFreetype(lib, opts),
        .web_canvas => try self.loadWebCanvas(opts),
        // Unreachable because we must have a discovery mechanism or a
        // pre-loaded face for other backends.
        .freetype => unreachable,
    };
}

fn loadFontconfig(
    self: *DeferredFace,
    lib: Library,
    opts: font.face.Options,
) !Face {
    const fc = self.fc.?;

    const filename = (try fc.pattern.get(.file, 0)).string;
    const face_index = (try fc.pattern.get(.index, 0)).integer;

    var face = try Face.initFile(lib, filename, face_index, opts);
    errdefer face.deinit();
    try face.setVariations(fc.variations, opts);
    return face;
}

fn loadCoreText(
    self: *DeferredFace,
    lib: Library,
    opts: font.Option.Options,
) !Face {
    _ = lib;
    const ct = self.ct.?;

    var face = try Face.initFontCopy(ct.font, opts);
    errdefer face.deinit();
    try face.setVariations(ct.variations, opts);
    return face;
}

fn loadCoreTextFreetype(
    self: *DeferredFace,
    lib: Library,
    opts: font.Option.Options,
) !Face {
    const ct = self.ct.?;

    // URL for the font.
    const url = ct.font.copyAttribute(.url) orelse
        return error.FontHasNoFile;
    defer url.release();

    // Path from URL.
    const path = url.copyPath() orelse
        return error.FontHasNoFile;
    defer path.release();

    // Decode URL percent escapes.
    const blank = try macos.foundation.String.createWithBytes("", .utf8, false);
    defer blank.release();
    const decoded = try macos.foundation.URL.createStringByReplacingPercentEscapes(
        path,
        blank,
    );
    defer decoded.release();

    var buf: [1024]u8 = undefined;
    const path_slice = decoded.cstring(&buf, .utf8) orelse
        return error.FontPathCantDecode;

    // Null-terminate for FreeType.
    buf[path_slice.len] = 0;

    var face = try Face.initFile(lib, buf[0..path_slice.len :0], 0, opts);
    errdefer face.deinit();

    // Apply any variations from the CoreText font.
    try face.setVariations(ct.variations, opts);
    return face;
}

fn loadWebCanvas(
    self: *DeferredFace,
    opts: font.Option.Options,
) !Face {
    const wc = self.wc.?;
    return try Face.initNamed(wc.alloc, wc.font_str, opts, wc.presentation);
}

/// Returns true if this face supports the given codepoint (and optional presentation).
pub fn hasCodepoint(self: DeferredFace, cp: u32, p: ?Presentation) bool {
    switch (options.backend) {
        .fontconfig_freetype => {
            if (self.fc) |fc| {
                if (!fc.charset.hasChar(cp)) return false;

                if (p) |desired| {
                    const emoji_lang = "und-zsye";
                    const actual: Presentation = if (fc.langset.hasLang(emoji_lang))
                        .emoji
                    else
                        .text;
                    return desired == actual;
                }
                return true;
            }
        },

        .coretext, .coretext_freetype, .coretext_harfbuzz, .coretext_noshape => {
            if (self.ct) |ct| {
                // Check presentation via CoreText
                if (p) |desired| {
                    const traits = ct.font.getSymbolicTraits();
                    const actual: Presentation = if (traits.color_glyphs) .emoji else .text;
                    if (actual != desired) return false;
                }
                // Turn cp into UTF-16 and query CT
                var unichars: [2]u16 = undefined;
                const pair = macos.foundation.stringGetSurrogatePairForLongCharacter(cp, &unichars);
                const len: usize = if (pair) 2 else 1;
                var glyphs = [2]macos.graphics.Glyph{0} ** 2;
                return ct.font.getGlyphsForCharacters(unichars[0..len], glyphs[0..len]);
            }
        },

        .web_canvas => if (self.wc) |wc| {
            // Fast-path presentation check.
            if (p) |desired| if (wc.presentation != desired) return false;

            // Render using canvas to check glyph existence.
            var face = try Face.initNamed(wc.alloc, wc.font_str, .{ .points = 12 }, wc.presentation) catch
                return false;
            defer face.deinit();
            return face.glyphIndex(cp) != null;
        },

        .freetype => {},
    }
    // Should never be reached.
    unreachable;
}

// ====================
// WASM API
// ====================
pub const Wasm = struct {
    const wasm = @import("../os/wasm.zig");
    const alloc = wasm.alloc;

    // Deallocates a DeferredFace.
    export fn deferred_face_free(ptr: ?*DeferredFace) void {
        if (ptr) |v| {
            v.deinit();
            alloc.destroy(v);
        }
    }

    // Creates a new deferred face.
    export fn deferred_face_new(ptr: [*]const u8, len: usize, presentation: u16) ?*DeferredFace {
        return deferred_face_new_(ptr, len, presentation) catch |err| {
            log.warn("error creating deferred face err={}", .{err});
                return null;
            };
    }

    fn deferred_face_new_(
        ptr: [*]const u8,
        len: usize,
        presentation: u16,
    ) !*DeferredFace {
        const font_str = try alloc.dupeZ(u8, ptr[0..len]);
        errdefer alloc.free(font_str);

        var face: DeferredFace = .{
            .wc = .{
                .alloc = alloc,
                .font_str = font_str,
                .presentation = @enumFromInt(presentation),
            },
        };
        errdefer face.deinit();

        const result = try alloc.create(DeferredFace);
        errdefer alloc.destroy(result);
        result.* = face;
        return result;
    }

    // Loads a deferred face with the given point size.
    export fn deferred_face_load(self: *DeferredFace, pts: f32) void {
        self.load(.{}, .{ .points = pts }) catch |err| {
            log.warn("error loading deferred face err={}", .{err});
        };
    }

    // Returns the loaded face, owned by the deferred face.
    export fn deferred_face_face(self: *DeferredFace) ?*Face {
        const face = self.load(.{}, .{ .points = 12 }) catch return null;
        return &face;
    };
};
```

(Note: The above snippet is a representation of the final file's structure based on the commit history. It includes the core implementations for the various backends, handling of `fontconfig`, `coretext`, and `web_canvas`, as well as the WASM export functions and test scaffolding omitted for brevity.)```