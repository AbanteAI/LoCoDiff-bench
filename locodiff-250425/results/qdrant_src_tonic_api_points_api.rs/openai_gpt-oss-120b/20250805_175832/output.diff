
index 78b27a3ba..8d458b8da 100644
--- a/qdrant_src_tonic_api_points_api.rs_expectedoutput.txt (expected):tmp/tmpf039pn9w_expected.txt	
+++ b/qdrant_src_tonic_api_points_api.rs_extracted.txt (actual):tmp/tmpxokxwzcr_actual.txt	
@@ -3,39 +3,83 @@ use std::time::{Duration, Instant};
 
 use api::grpc::qdrant::points_server::Points;
 use api::grpc::qdrant::{
-    ClearPayloadPoints, CountPoints, CountResponse, CreateFieldIndexCollection,
-    DeleteFieldIndexCollection, DeletePayloadPoints, DeletePointVectors, DeletePoints,
-    DiscoverBatchPoints, DiscoverBatchResponse, DiscoverPoints, DiscoverResponse, FacetCounts,
-    FacetResponse, GetPoints, GetResponse, PointsOperationResponse, QueryBatchPoints,
-    QueryBatchResponse, QueryGroupsResponse, QueryPointGroups, QueryPoints, QueryResponse,
-    RecommendBatchPoints, RecommendBatchResponse, RecommendGroupsResponse, RecommendPointGroups,
-    RecommendPoints, RecommendResponse, ScrollPoints, ScrollResponse, SearchBatchPoints,
-    SearchBatchResponse, SearchGroupsResponse, SearchMatrixOffsets, SearchMatrixOffsetsResponse,
-    SearchMatrixPairs, SearchMatrixPairsResponse, SearchMatrixPoints, SearchPointGroups,
-    SearchPoints, SearchResponse, SetPayloadPoints, UpdateBatchPoints, UpdateBatchResponse,
-    UpdatePointVectors, UpsertPoints,
+    ClearPayloadPoints,
+    CountPoints,
+    CountResponse,
+    CreateFieldIndexCollection,
+    DeleteFieldIndexCollection,
+    DeletePayloadPoints,
+    DeletePointVectors,
+    DeletePoints,
+    DiscoverBatchPoints,
+    DiscoverBatchResponse,
+    DiscoverPoints,
+    DiscoverResponse,
+    FacetCounts,
+    FacetResponse,
+    GetPoints,
+    GetResponse,
+    HardwareUsage,
+    PointsOperationResponse,
+    QueryBatchPoints,
+    QueryBatchResponse,
+    QueryGroupsResponse,
+    QueryPointGroups,
+    QueryPoints,
+    QueryResponse,
+    RecommendBatchPoints,
+    RecommendBatchResponse,
+    RecommendGroupsResponse,
+    RecommendPointGroups,
+    RecommendPoints,
+    RecommendResponse,
+    ScrollPoints,
+    ScrollResponse,
+    SearchBatchPoints,
+    SearchBatchResponse,
+    SearchGroupsResponse,
+    SearchMatrixOffsets,
+    SearchMatrixOffsetsResponse,
+    SearchMatrixPairs,
+    SearchMatrixPairsResponse,
+    SearchMatrixPoints,
+    SearchPointGroups,
+    SearchPoints,
+    SearchResponse,
+    SetPayloadPoints,
+    UpdateBatchPoints,
+    UpdateBatchResponse,
+    UpdatePointVectors,
+    UpsertPoints,
+    // The following types are required for the hardware usage reporting
+    // and are part of the Qdrant gRPC API.
+    // Note that some of these have been introduced over time.
 };
+
 use collection::operations::types::CoreSearchRequest;
 use common::counter::hardware_accumulator::HwMeasurementAcc;
 use storage::content_manager::toc::request_hw_counter::RequestHwCounter;
 use storage::dispatcher::Dispatcher;
 use tonic::{Request, Response, Status};
 
-use super::query_common::*;
-use super::update_common::*;
-use super::validate;
 use crate::common::inference::extract_token;
 use crate::common::update::InternalUpdateParams;
 use crate::settings::ServiceConfig;
 use crate::tonic::auth::extract_access;
 use crate::tonic::verification::StrictModeCheckedTocProvider;
 
+use super::query_common::*;
+use super::update_common::*;
+use super::validate;
+
+/// Service struct containing the dispatcher and service configuration.
 pub struct PointsService {
     dispatcher: Arc<Dispatcher>,
     service_config: ServiceConfig,
 }
 
 impl PointsService {
+    /// Constructs the gRPC service layer.
     pub fn new(dispatcher: Arc<Dispatcher>, service_config: ServiceConfig) -> Self {
         Self {
             dispatcher,
@@ -43,15 +87,20 @@ impl PointsService {
         }
     }
 
+    /// Helper for request-local hardware usage counter.
     fn get_request_collection_hw_usage_counter(
         &self,
         collection_name: String,
         wait: Option<bool>,
     ) -> RequestHwCounter {
+        // Init a new accumulator that will drain into the collection's metric (if any).
         let counter = HwMeasurementAcc::new_with_metrics_drain(
             self.dispatcher.get_collection_hw_metrics(collection_name),
         );
 
+        // Wait has to be true to record usage. The default `wait = true` case
+        // is unchanged and the `None` case is treated as `true`.
+        // The `wait = false` case is reported later to `HardwareMetrics`.
         let waiting = wait != Some(false);
         RequestHwCounter::new(counter, self.service_config.hardware_reporting() && waiting)
     }
@@ -64,13 +113,14 @@ impl Points for PointsService {
         mut request: Request<UpsertPoints>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
-
         let access = extract_access(&mut request);
         let inference_token = extract_token(&request);
-
         let collection_name = request.get_ref().collection_name.clone();
         let wait = Some(request.get_ref().wait.unwrap_or(false));
-        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name, wait);
+        let hw_metrics = self.get_request_collection_hw_usage_counter(
+            collection_name,
+            wait,
+        );
 
         upsert(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
@@ -89,13 +139,14 @@ impl Points for PointsService {
         mut request: Request<DeletePoints>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
-
         let access = extract_access(&mut request);
         let inference_token = extract_token(&request);
-
         let collection_name = request.get_ref().collection_name.clone();
         let wait = Some(request.get_ref().wait.unwrap_or(false));
-        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name, wait);
+        let hw_metrics = self.get_request_collection_hw_usage_counter(
+            collection_name,
+            wait,
+        );
 
         delete(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
@@ -111,17 +162,16 @@ impl Points for PointsService {
 
     async fn get(&self, mut request: Request<GetPoints>) -> Result<Response<GetResponse>, Status> {
         validate(request.get_ref())?;
-
         let access = extract_access(&mut request);
-
-        let inner_request = request.into_inner();
-
-        let hw_metrics = self
-            .get_request_collection_hw_usage_counter(inner_request.collection_name.clone(), None);
+        let collection_name = request.get_ref().collection_name.clone();
+        let hw_metrics = self.get_request_collection_hw_usage_counter(
+            collection_name,
+            None,
+        );
 
         get(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
-            inner_request,
+            request.into_inner(),
             None,
             access,
             hw_metrics,
@@ -134,15 +184,14 @@ impl Points for PointsService {
         mut request: Request<UpdatePointVectors>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
-
-        // Nothing to verify here.
-
         let access = extract_access(&mut request);
         let inference_token = extract_token(&request);
-
         let collection_name = request.get_ref().collection_name.clone();
         let wait = Some(request.get_ref().wait.unwrap_or(false));
-        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name, wait);
+        let hw_metrics = self.get_request_collection_hw_usage_counter(
+            collection_name,
+            wait,
+        );
 
         update_vectors(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
@@ -161,11 +210,10 @@ impl Points for PointsService {
         mut request: Request<DeletePointVectors>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
-
         let access = extract_access(&mut request);
-
+        let collection_name = request.get_ref().collection_name.clone();
         let hw_metrics = self.get_request_collection_hw_usage_counter(
-            request.get_ref().collection_name.clone(),
+            collection_name,
             None,
         );
 
@@ -185,12 +233,13 @@ impl Points for PointsService {
         mut request: Request<SetPayloadPoints>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
-
         let access = extract_access(&mut request);
-
         let collection_name = request.get_ref().collection_name.clone();
         let wait = Some(request.get_ref().wait.unwrap_or(false));
-        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name, wait);
+        let hw_metrics = self.get_request_collection_hw_usage_counter(
+            collection_name,
+            wait,
+        );
 
         set_payload(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
@@ -208,12 +257,13 @@ impl Points for PointsService {
         mut request: Request<SetPayloadPoints>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
-
         let access = extract_access(&mut request);
-
         let collection_name = request.get_ref().collection_name.clone();
         let wait = Some(request.get_ref().wait.unwrap_or(false));
-        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name, wait);
+        let hw_metrics = self.get_request_collection_hw_usage_counter(
+            collection_name,
+            wait,
+        );
 
         overwrite_payload(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
@@ -231,12 +281,13 @@ impl Points for PointsService {
         mut request: Request<DeletePayloadPoints>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
-
         let access = extract_access(&mut request);
-
         let collection_name = request.get_ref().collection_name.clone();
         let wait = Some(request.get_ref().wait.unwrap_or(false));
-        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name, wait);
+        let hw_metrics = self.get_request_collection_hw_usage_counter(
+            collection_name,
+            wait,
+        );
 
         delete_payload(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
@@ -254,12 +305,13 @@ impl Points for PointsService {
         mut request: Request<ClearPayloadPoints>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
-
         let access = extract_access(&mut request);
-
         let collection_name = request.get_ref().collection_name.clone();
         let wait = Some(request.get_ref().wait.unwrap_or(false));
-        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name, wait);
+        let hw_metrics = self.get_request_collection_hw_usage_counter(
+            collection_name,
+            wait,
+        );
 
         clear_payload(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
@@ -277,13 +329,14 @@ impl Points for PointsService {
         mut request: Request<UpdateBatchPoints>,
     ) -> Result<Response<UpdateBatchResponse>, Status> {
         validate(request.get_ref())?;
-
         let access = extract_access(&mut request);
         let inference_token = extract_token(&request);
-
         let collection_name = request.get_ref().collection_name.clone();
         let wait = Some(request.get_ref().wait.unwrap_or(false));
-        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name, wait);
+        let hw_metrics = self.get_request_collection_hw_usage_counter(
+            collection_name,
+            wait,
+        );
 
         update_batch(
             &self.dispatcher,
@@ -298,14 +351,15 @@ impl Points for PointsService {
 
     async fn create_field_index(
         &self,
-        mut request: Request<CreateFieldIndexCollection>,
+        request: Request<CreateFieldIndexCollection>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
-
         let access = extract_access(&mut request);
         let collection_name = request.get_ref().collection_name.clone();
-        let wait = Some(request.get_ref().wait.unwrap_or(false));
-        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name, wait);
+        let hw_metrics = self.get_request_collection_hw_usage_counter(
+            collection_name,
+            None,
+        );
 
         create_field_index(
             self.dispatcher.clone(),
@@ -320,17 +374,22 @@ impl Points for PointsService {
 
     async fn delete_field_index(
         &self,
-        mut request: Request<DeleteFieldIndexCollection>,
+        request: Request<DeleteFieldIndexCollection>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
-
         let access = extract_access(&mut request);
+        let collection_name = request.get_ref().collection_name.clone();
+        let hw_metrics = self.get_request_collection_hw_usage_counter(
+            collection_name,
+            None,
+        );
 
         delete_field_index(
             self.dispatcher.clone(),
             request.into_inner(),
             InternalUpdateParams::default(),
             access,
+            hw_metrics,
         )
         .await
         .map(|resp| resp.map(Into::into))
@@ -342,53 +401,48 @@ impl Points for PointsService {
     ) -> Result<Response<SearchResponse>, Status> {
         validate(request.get_ref())?;
         let access = extract_access(&mut request);
-
         let collection_name = request.get_ref().collection_name.clone();
-        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name, None);
+        let hw_metrics = self.get_request_collection_hw_usage_counter(
+            collection_name,
+            None,
+        );
 
-        let res = search(
+        search(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
             None,
             access,
             hw_metrics,
         )
-        .await?;
-
-        Ok(res)
+        .await
     }
 
     async fn search_batch(
         &self,
-        mut request: Request<SearchBatchPoints>,
+        request: Request<SearchBatchPoints>,
     ) -> Result<Response<SearchBatchResponse>, Status> {
         validate(request.get_ref())?;
-
         let access = extract_access(&mut request);
-
         let SearchBatchPoints {
             collection_name,
             search_points,
             read_consistency,
             timeout,
         } = request.into_inner();
-
         let timeout = timeout.map(Duration::from_secs);
 
-        let mut requests = Vec::new();
+        let collection_hw_counter =
+            self.get_request_collection_hw_usage_counter(collection_name.clone(), None);
 
+        // Build a core search request for each batch point.
+        let mut requests = Vec::new();
         for mut search_point in search_points {
             let shard_key = search_point.shard_key_selector.take();
-
             let shard_selector = convert_shard_selector_for_read(None, shard_key);
             let core_search_request = CoreSearchRequest::try_from(search_point)?;
-
             requests.push((core_search_request, shard_selector));
         }
 
-        let hw_metrics =
-            self.get_request_collection_hw_usage_counter(collection_name.clone(), None);
-
         let res = core_search_batch(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             &collection_name,
@@ -396,31 +450,29 @@ impl Points for PointsService {
             read_consistency,
             access,
             timeout,
-            hw_metrics,
+            collection_hw_counter,
         )
         .await?;
-
-        Ok(res)
+        Ok(Response::new(res))
     }
 
     async fn search_groups(
         &self,
-        mut request: Request<SearchPointGroups>,
+        request: Request<SearchPointGroups>,
     ) -> Result<Response<SearchGroupsResponse>, Status> {
         validate(request.get_ref())?;
         let access = extract_access(&mut request);
         let collection_name = request.get_ref().collection_name.clone();
-        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name, None);
-        let res = search_groups(
+        let hw_metrics =
+            self.get_request_collection_hw_usage_counter(collection_name.clone(), None);
+        search_groups(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
             None,
             access,
             hw_metrics,
         )
-        .await?;
-
-        Ok(res)
+        .await
     }
 
     async fn scroll(
@@ -428,17 +480,15 @@ impl Points for PointsService {
         mut request: Request<ScrollPoints>,
     ) -> Result<Response<ScrollResponse>, Status> {
         validate(request.get_ref())?;
-
         let access = extract_access(&mut request);
-
-        let inner_request = request.into_inner();
-
-        let hw_metrics = self
-            .get_request_collection_hw_usage_counter(inner_request.collection_name.clone(), None);
-
+        let collection_name = request.get_ref().collection_name.clone();
+        let hw_metrics = self.get_request_collection_hw_usage_counter(
+            collection_name,
+            None,
+        );
         scroll(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
-            inner_request,
+            request.into_inner(),
             None,
             access,
             hw_metrics,
@@ -453,21 +503,23 @@ impl Points for PointsService {
         validate(request.get_ref())?;
         let access = extract_access(&mut request);
         let collection_name = request.get_ref().collection_name.clone();
-        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name, None);
-        let res = recommend(
+        let hw_metrics = self.get_request_collection_hw_usage_counter(
+            collection_name,
+            None,
+        );
+
+        recommend(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
             access,
             hw_metrics,
         )
-        .await?;
-
-        Ok(res)
+        .await
     }
 
     async fn recommend_batch(
         &self,
-        mut request: Request<RecommendBatchPoints>,
+        request: Request<RecommendBatchPoints>,
     ) -> Result<Response<RecommendBatchResponse>, Status> {
         validate(request.get_ref())?;
         let access = extract_access(&mut request);
@@ -480,7 +532,6 @@ impl Points for PointsService {
 
         let hw_metrics =
             self.get_request_collection_hw_usage_counter(collection_name.clone(), None);
-
         let res = recommend_batch(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             &collection_name,
@@ -491,8 +542,7 @@ impl Points for PointsService {
             hw_metrics,
         )
         .await?;
-
-        Ok(res)
+        Ok(Response::new(res))
     }
 
     async fn recommend_groups(
@@ -502,17 +552,18 @@ impl Points for PointsService {
         validate(request.get_ref())?;
         let access = extract_access(&mut request);
         let collection_name = request.get_ref().collection_name.clone();
-        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name, None);
+        let hw_metrics = self.get_request_collection_hw_usage_counter(
+            collection_name,
+            None,
+        );
 
-        let res = recommend_groups(
+        recommend_groups(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
             access,
             hw_metrics,
         )
-        .await?;
-
-        Ok(res)
+        .await
     }
 
     async fn discover(
@@ -522,37 +573,34 @@ impl Points for PointsService {
         validate(request.get_ref())?;
         let access = extract_access(&mut request);
         let collection_name = request.get_ref().collection_name.clone();
+        let hw_metrics =
+            self.get_request_collection_hw_usage_counter(collection_name, None);
 
-        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name, None);
-        let res = discover(
+        discover(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
             access,
             hw_metrics,
         )
-        .await?;
-
-        Ok(res)
+        .await
     }
 
     async fn discover_batch(
         &self,
-        mut request: Request<DiscoverBatchPoints>,
+        request: Request<DiscoverBatchPoints>,
     ) -> Result<Response<DiscoverBatchResponse>, Status> {
-        validate(request.get_ref())?;
-        let access = extract_access(&mut request);
         let DiscoverBatchPoints {
             collection_name,
             discover_points,
             read_consistency,
             timeout,
         } = request.into_inner();
-
         let hw_metrics =
             self.get_request_collection_hw_usage_counter(collection_name.clone(), None);
+
         let res = discover_batch(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
-            &collection_name,
+            collection_name,
             discover_points,
             read_consistency,
             access,
@@ -560,68 +608,61 @@ impl Points for PointsService {
             hw_metrics,
         )
         .await?;
-
-        Ok(res)
+        Ok(Response::new(res))
     }
 
     async fn count(
         &self,
-        mut request: Request<CountPoints>,
+        request: Request<CountPoints>,
     ) -> Result<Response<CountResponse>, Status> {
         validate(request.get_ref())?;
-
         let access = extract_access(&mut request);
         let collection_name = request.get_ref().collection_name.clone();
-        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name, None);
-        let res = count(
+        let hw_metrics = self.get_request_collection_hw_usage_counter(
+            collection_name,
+            None,
+        );
+
+        count(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
             None,
             &access,
             hw_metrics,
         )
-        .await?;
-
-        Ok(res)
+        .await
     }
 
     async fn query(
         &self,
-        mut request: Request<QueryPoints>,
+        request: Request<QueryPoints>,
     ) -> Result<Response<QueryResponse>, Status> {
         validate(request.get_ref())?;
         let access = extract_access(&mut request);
-        let inference_token = extract_token(&request);
         let collection_name = request.get_ref().collection_name.clone();
-        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name, None);
-
+        let hw_metrics =
+            self.get_request_collection_hw_usage_counter(collection_name, None);
         let res = query(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
             None,
             access,
             hw_metrics,
-            inference_token,
         )
         .await?;
-
-        Ok(res)
+        Ok(Response::new(res))
     }
 
     async fn query_batch(
         &self,
-        mut request: Request<QueryBatchPoints>,
+        request: Request<QueryBatchPoints>,
     ) -> Result<Response<QueryBatchResponse>, Status> {
-        validate(request.get_ref())?;
-        let access = extract_access(&mut request);
-        let inference_token = extract_token(&request);
-        let request = request.into_inner();
         let QueryBatchPoints {
             collection_name,
             query_points,
             read_consistency,
             timeout,
-        } = request;
+        } = request.into_inner();
         let timeout = timeout.map(Duration::from_secs);
         let hw_metrics =
             self.get_request_collection_hw_usage_counter(collection_name.clone(), None);
@@ -633,44 +674,43 @@ impl Points for PointsService {
             access,
             timeout,
             hw_metrics,
-            inference_token,
         )
         .await?;
-
-        Ok(res)
+        Ok(Response::new(res))
     }
 
     async fn query_groups(
         &self,
-        mut request: Request<QueryPointGroups>,
+        request: Request<QueryPointGroups>,
     ) -> Result<Response<QueryGroupsResponse>, Status> {
-        let access = extract_access(&mut request);
-        let inference_token = extract_token(&request);
         let collection_name = request.get_ref().collection_name.clone();
-        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name, None);
-
+        let hw_metrics = self.get_request_collection_hw_usage_counter(
+            collection_name,
+            None,
+        );
         let res = query_groups(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
             None,
             access,
             hw_metrics,
-            inference_token,
         )
         .await?;
-
-        Ok(res)
+        Ok(Response::new(res))
     }
+
     async fn facet(
         &self,
         mut request: Request<FacetCounts>,
     ) -> Result<Response<FacetResponse>, Status> {
         validate(request.get_ref())?;
         let access = extract_access(&mut request);
+        let collection_name = request.get_ref().collection_name.clone();
         let hw_metrics = self.get_request_collection_hw_usage_counter(
-            request.get_ref().collection_name.clone(),
+            collection_name,
             None,
         );
+
         facet(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
@@ -686,24 +726,27 @@ impl Points for PointsService {
     ) -> Result<Response<SearchMatrixPairsResponse>, Status> {
         validate(request.get_ref())?;
         let access = extract_access(&mut request);
-        let timing = Instant::now();
         let collection_name = request.get_ref().collection_name.clone();
-        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name, None);
+        let hw_metrics =
+            self.get_request_collection_hw_usage_counter(
+                collection_name,
+                None,
+            );
+
+        let timing = Instant::now();
         let search_matrix_response = search_points_matrix(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
             access,
-            hw_metrics.get_counter(),
+            hw_metrics,
         )
         .await?;
-
-        let pairs_response = SearchMatrixPairsResponse {
+        let response = SearchMatrixPairsResponse {
             result: Some(SearchMatrixPairs::from(search_matrix_response)),
             time: timing.elapsed().as_secs_f64(),
-            usage: hw_metrics.to_grpc_api(),
+            usage: None,
         };
-
-        Ok(Response::new(pairs_response))
+        Ok(Response::new(response))
     }
 
     async fn search_matrix_offsets(
@@ -712,23 +755,26 @@ impl Points for PointsService {
     ) -> Result<Response<SearchMatrixOffsetsResponse>, Status> {
         validate(request.get_ref())?;
         let access = extract_access(&mut request);
-        let timing = Instant::now();
         let collection_name = request.get_ref().collection_name.clone();
-        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name, None);
+        let hw_metrics =
+            self.get_request_collection_hw_usage_counter(
+                collection_name,
+                None,
+            );
+
+        let timing = Instant::now();
         let search_matrix_response = search_points_matrix(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
             access,
-            hw_metrics.get_counter(),
+            hw_metrics,
         )
         .await?;
-
-        let offsets_response = SearchMatrixOffsetsResponse {
+        let response = SearchMatrixOffsetsResponse {
             result: Some(SearchMatrixOffsets::from(search_matrix_response)),
             time: timing.elapsed().as_secs_f64(),
-            usage: hw_metrics.to_grpc_api(),
+            usage: None,
         };
-
-        Ok(Response::new(offsets_response))
+        Ok(Response::new(response))
     }
 }
\ No newline at end of file
