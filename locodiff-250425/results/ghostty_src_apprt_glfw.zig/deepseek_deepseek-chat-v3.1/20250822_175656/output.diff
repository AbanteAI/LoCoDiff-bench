
index afd17d617..5da012f0f 100644
--- a/ghostty_src_apprt_glfw.zig_expectedoutput.txt (expected):tmp/tmpl_otknv7_expected.txt	
+++ b/ghostty_src_apprt_glfw.zig_extracted.txt (actual):tmp/tmpc7z19q6i_actual.txt	
@@ -23,7 +23,7 @@ const CoreSurface = @import("../Surface.zig");
 const configpkg = @import("../config.zig");
 const Config = @import("../config.zig").Config;
 
-// Get native API access on certain platforms so we can do more customization.
+// Get native API access on certain platforms so we can more customization.
 const glfwNative = glfw.Native(.{
     .cocoa = builtin.target.os.tag.isDarwin(),
     .x11 = builtin.os.tag == .linux,
@@ -420,6 +420,13 @@ pub const App = struct {
         // GLFW doesn't support the inspector
     }
 
+    pub fn keyboardLayout(self: *const App) input.KeyboardLayout {
+        _ = self;
+
+        // Not supported by glfw
+        return .unknown;
+    }
+
     fn glfwErrorCallback(code: glfw.ErrorCode, desc: [:0]const u8) void {
         std.log.warn("glfw error={} message={s}", .{ code, desc });
 
@@ -434,13 +441,6 @@ pub const App = struct {
         }
     }
 
-    pub fn keyboardLayout(self: *const App) input.KeyboardLayout {
-        _ = self;
-
-        // Not supported by glfw
-        return .unknown;
-    }
-
     /// Mac-specific settings. This is only enabled when the target is
     /// Mac and the artifact is a standalone exe. We don't target libs because
     /// the embedded API doesn't do windowing.
@@ -619,7 +619,6 @@ pub const Surface = struct {
             app.app.alloc,
             &config,
             app.app,
-            app,
             self,
         );
         errdefer self.core_surface.deinit();
@@ -708,7 +707,7 @@ pub const Surface = struct {
     /// Note: this interface is not good, we should redo it if we plan
     /// to use this more. i.e. you can't set max width but no max height,
     /// or no mins.
-    fn setSizeLimits(self: *Surface, min: apprt.SurfaceSize, max_: ?apprt.SurfaceSize) !void {
+    fn setSizeLimits(self: *Surface, min: apprt.SurfaceSize, max_: ?apprt.Surfaceize) !void {
         self.window.setSizeLimits(.{
             .width = min.width,
             .height = min.height,
@@ -955,306 +954,4 @@ pub const Surface = struct {
         // Convert our glfw types into our input types
         const mods: input.Mods = .{
             .shift = glfw_mods.shift,
-            .ctrl = glfw_mods.control,
-            .alt = glfw_mods.alt,
-            .super = glfw_mods.super,
-        };
-        const action: input.Action = switch (glfw_action) {
-            .release => .release,
-            .press => .press,
-            .repeat => .repeat,
-        };
-        const key: input.Key = switch (glfw_key) {
-            .a => .a,
-            .b => .b,
-            .c => .c,
-            .d => .d,
-            .e => .e,
-            .f => .f,
-            .g => .g,
-            .h => .h,
-            .i => .i,
-            .j => .j,
-            .k => .k,
-            .l => .l,
-            .m => .m,
-            .n => .n,
-            .o => .o,
-            .p => .p,
-            .q => .q,
-            .r => .r,
-            .s => .s,
-            .t => .t,
-            .u => .u,
-            .v => .v,
-            .w => .w,
-            .x => .x,
-            .y => .y,
-            .z => .z,
-            .zero => .zero,
-            .one => .one,
-            .two => .two,
-            .three => .three,
-            .four => .four,
-            .five => .five,
-            .six => .six,
-            .seven => .seven,
-            .eight => .eight,
-            .nine => .nine,
-            .up => .up,
-            .down => .down,
-            .right => .right,
-            .left => .left,
-            .home => .home,
-            .end => .end,
-            .page_up => .page_up,
-            .page_down => .page_down,
-            .escape => .escape,
-            .F1 => .f1,
-            .F2 => .f2,
-            .F3 => .f3,
-            .F4 => .f4,
-            .F5 => .f5,
-            .F6 => .f6,
-            .F7 => .f7,
-            .F8 => .f8,
-            .F9 => .f9,
-            .F10 => .f10,
-            .F11 => .f11,
-            .F12 => .f12,
-            .F13 => .f13,
-            .F14 => .f14,
-            .F15 => .f15,
-            .F16 => .f16,
-            .F17 => .f17,
-            .F18 => .f18,
-            .F19 => .f19,
-            .F20 => .f20,
-            .F21 => .f21,
-            .F22 => .f22,
-            .F23 => .f23,
-            .F24 => .f24,
-            .F25 => .f25,
-            .kp_0 => .kp_0,
-            .kp_1 => .kp_1,
-            .kp_2 => .kp_2,
-            .kp_3 => .kp_3,
-            .kp_4 => .kp_4,
-            .kp_5 => .kp_5,
-            .kp_6 => .kp_6,
-            .kp_7 => .kp_7,
-            .kp_8 => .kp_8,
-            .kp_9 => .kp_9,
-            .kp_decimal => .kp_decimal,
-            .kp_divide => .kp_divide,
-            .kp_multiply => .kp_multiply,
-            .kp_subtract => .kp_subtract,
-            .kp_add => .kp_add,
-            .kp_enter => .kp_enter,
-            .kp_equal => .kp_equal,
-            .grave_accent => .grave_accent,
-            .minus => .minus,
-            .equal => .equal,
-            .space => .space,
-            .semicolon => .semicolon,
-            .apostrophe => .apostrophe,
-            .comma => .comma,
-            .period => .period,
-            .slash => .slash,
-            .left_bracket => .left_bracket,
-            .right_bracket => .right_bracket,
-            .backslash => .backslash,
-            .enter => .enter,
-            .tab => .tab,
-            .backspace => .backspace,
-            .insert => .insert,
-            .delete => .delete,
-            .caps_lock => .caps_lock,
-            .scroll_lock => .scroll_lock,
-            .num_lock => .num_lock,
-            .print_screen => .print_screen,
-            .pause => .pause,
-            .left_shift => .left_shift,
-            .left_control => .left_control,
-            .left_alt => .left_alt,
-            .left_super => .left_super,
-            .right_shift => .right_shift,
-            .right_control => .right_control,
-            .right_alt => .right_alt,
-            .right_super => .right_super,
-
-            .menu,
-            .world_1,
-            .world_2,
-            .unknown,
-            => .invalid,
-        };
-
-        // This is a hack for GLFW. We require our apprts to send both
-        // the UTF8 encoding AND the keypress at the same time. Its critical
-        // for things like ctrl sequences to work. However, GLFW doesn't
-        // provide this information all at once. So we just infer based on
-        // the key press. This isn't portable but GLFW is only for testing.
-        const utf8 = switch (key) {
-            inline else => |k| utf8: {
-                if (mods.shift) break :utf8 "";
-                const cp = k.codepoint() orelse break :utf8 "";
-                const byte = std.math.cast(u8, cp) orelse break :utf8 "";
-                break :utf8 &.{byte};
-            },
-        };
-
-        const key_event: input.KeyEvent = .{
-            .action = action,
-            .key = key,
-            .physical_key = key,
-            .mods = mods,
-            .consumed_mods = .{},
-            .composing = false,
-            .utf8 = utf8,
-            .unshifted_codepoint = if (utf8.len > 0) @intCast(utf8[0]) else 0,
-        };
-
-        const effect = core_win.keyCallback(key_event) catch |err| {
-            log.err("error in key callback err={}", .{err});
-            return;
-        };
-
-        // Surface closed.
-        if (effect == .closed) return;
-
-        // If it wasn't consumed, we set it on our self so that charcallback
-        // can make another attempt. Otherwise, we set null so the charcallback
-        // is ignored.
-        core_win.rt_surface.key_event = null;
-        if (effect == .ignored and
-            (action == .press or action == .repeat))
-        {
-            core_win.rt_surface.key_event = key_event;
-        }
-    }
-
-    fn focusCallback(window: glfw.Window, focused: bool) void {
-        const core_win = window.getUserPointer(CoreSurface) orelse return;
-        core_win.focusCallback(focused) catch |err| {
-            log.err("error in focus callback err={}", .{err});
-            return;
-        };
-    }
-
-    fn refreshCallback(window: glfw.Window) void {
-        const core_win = window.getUserPointer(CoreSurface) orelse return;
-        core_win.refreshCallback() catch |err| {
-            log.err("error in refresh callback err={}", .{err});
-            return;
-        };
-    }
-
-    fn scrollCallback(window: glfw.Window, xoff: f64, yoff: f64) void {
-        // Glfw doesn't support any of the scroll mods.
-        const scroll_mods: input.ScrollMods = .{};
-
-        const core_win = window.getUserPointer(CoreSurface) orelse return;
-        core_win.scrollCallback(xoff, yoff, scroll_mods) catch |err| {
-            log.err("error in scroll callback err={}", .{err});
-            return;
-        };
-    }
-
-    fn cursorPosCallback(
-        window: glfw.Window,
-        unscaled_xpos: f64,
-        unscaled_ypos: f64,
-    ) void {
-        const core_win = window.getUserPointer(CoreSurface) orelse return;
-
-        // Convert our unscaled x/y to scaled.
-        const pos = core_win.rt_surface.cursorPosToPixels(.{
-            .xpos = unscaled_xpos,
-            .ypos = unscaled_ypos,
-        }) catch |err| {
-            log.err(
-                "error converting cursor pos to scaled pixels in cursor pos callback err={}",
-                .{err},
-            );
-            return;
-        };
-
-        core_win.cursorPosCallback(.{
-            .x = @floatCast(pos.xpos),
-            .y = @floatCast(pos.ypos),
-        }, null) catch |err| {
-            log.err("error in cursor pos callback err={}", .{err});
-            return;
-        };
-    }
-
-    fn mouseButtonCallback(
-        window: glfw.Window,
-        glfw_button: glfw.MouseButton,
-        glfw_action: glfw.Action,
-        glfw_mods: glfw.Mods,
-    ) void {
-        const core_win = window.getUserPointer(CoreSurface) orelse return;
-
-        // Convert glfw button to input button
-        const mods: input.Mods = .{
-            .shift = glfw_mods.shift,
-            .ctrl = glfw_mods.control,
-            .alt = glfw_mods.alt,
-            .super = glfw_mods.super,
-        };
-        const button: input.MouseButton = switch (glfw_button) {
-            .left => .left,
-            .right => .right,
-            .middle => .middle,
-            .four => .four,
-            .five => .five,
-            .six => .six,
-            .seven => .seven,
-            .eight => .eight,
-        };
-        const action: input.MouseButtonState = switch (glfw_action) {
-            .press => .press,
-            .release => .release,
-            else => unreachable,
-        };
-
-        _ = core_win.mouseButtonCallback(action, button, mods) catch |err| {
-            log.err("error in scroll callback err={}", .{err});
-            return;
-        };
-    }
-
-    fn dropCallback(window: glfw.Window, paths: [][*:0]const u8) void {
-        const surface = window.getUserPointer(CoreSurface) orelse return;
-
-        var list = std.ArrayList(u8).init(surface.alloc);
-        defer list.deinit();
-
-        for (paths) |path| {
-            const path_slice = std.mem.span(path);
-
-            // preallocate worst case of escaping every char + space
-            list.ensureTotalCapacity(path_slice.len * 2 + 1) catch |err| {
-                log.err("error in drop callback err={}", .{err});
-                return;
-            };
-
-            const writer = list.writer();
-            for (path_slice) |c| {
-                if (std.mem.indexOfScalar(u8, "\\ ()[]{}<>\"'`!#$&;|*?\t", c)) |_| {
-                    writer.print("\\{c}", .{c}) catch unreachable; //  memory preallocated
-                } else writer.writeByte(c) catch unreachable; // same here
-            }
-            writer.writeByte(' ') catch unreachable; // separate paths
-
-            surface.textCallback(list.items) catch |err| {
-                log.err("error in drop callback err={}", .{err});
-                return;
-            };
-
-            list.clearRetainingCapacity(); // avoid unnecessary reallocations
-        }
-    }
-};
\ No newline at end of file
+            .ctrl = glfw_mods.control,
\ No newline at end of file
