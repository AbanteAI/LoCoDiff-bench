
index afd17d617..3cfb785da 100644
--- a/ghostty_src_apprt_glfw.zig_expectedoutput.txt (expected):tmp/tmp24omzj48_expected.txt	
+++ b/ghostty_src_apprt_glfw.zig_extracted.txt (actual):tmp/tmprdnv0vmv_actual.txt	
@@ -102,9 +102,6 @@ pub const App = struct {
             .new_window = .{},
         }, .{ .forever = {} });
 
-        // We want the event loop to wake up instantly so we can process our tick.
-        glfw.postEmptyEvent();
-
         return .{
             .app = core_app,
             .config = config,
@@ -257,11 +254,6 @@ pub const App = struct {
         return true;
     }
 
-    /// Reload the configuration. This should return the new configuration.
-    /// The old value can be freed immediately at this point assuming a
-    /// successful return.
-    ///
-    /// The returned pointer value is only valid for a stable self pointer.
     fn reloadConfig(
         self: *App,
         target: apprt.action.Target,
@@ -381,6 +373,7 @@ pub const App = struct {
         };
     }
 
+    /// Create a new window for the app.
     fn newSurface(self: *App, parent_: ?*CoreSurface) !*Surface {
         // Grab a surface allocation because we're going to need it.
         var surface = try self.app.alloc.create(Surface);
@@ -865,6 +858,10 @@ pub const Surface = struct {
         }
     }
 
+    pub fn defaultTermioEnv(self: *Surface) !std.process.EnvMap {
+        return try internal_os.getEnvMap(self.app.app.alloc);
+    }
+
     /// The cursor position from glfw directly is in screen coordinates but
     /// all our interface works in pixels.
     fn cursorPosToPixels(self: *const Surface, pos: glfw.Window.CursorPos) !glfw.Window.CursorPos {
@@ -887,10 +884,6 @@ pub const Surface = struct {
         };
     }
 
-    pub fn defaultTermioEnv(self: *Surface) !std.process.EnvMap {
-        return try internal_os.getEnvMap(self.app.app.alloc);
-    }
-
     fn sizeCallback(window: glfw.Window, width: i32, height: i32) void {
         _ = width;
         _ = height;
@@ -927,14 +920,6 @@ pub const Surface = struct {
         };
         key_event.utf8 = buf[0..len];
 
-        // On macOS we need to also disable some modifiers because
-        // alt+key consumes the alt.
-        if (comptime builtin.target.os.tag.isDarwin()) {
-            // For GLFW, we say we always consume alt because
-            // GLFW doesn't have a way to disable the alt key.
-            key_event.consumed_mods.alt = true;
-        }
-
         _ = core_win.keyCallback(key_event) catch |err| {
             log.err("error in key callback err={}", .{err});
             return;
