--- ghostty_src_apprt_glfw.zig_expectedoutput.txt (expected)+++ ghostty_src_apprt_glfw.zig_extracted.txt (actual)@@ -102,9 +102,6 @@             .new_window = .{},
         }, .{ .forever = {} });
 
-        // We want the event loop to wake up instantly so we can process our tick.
-        glfw.postEmptyEvent();
-
         return .{
             .app = core_app,
             .config = config,
@@ -172,6 +169,8 @@                 .surface => |v| v,
             }),
 
+            .toggle_fullscreen => self.toggleFullscreen(target),
+
             .size_limit => switch (target) {
                 .app => {},
                 .surface => |surface| try surface.rt_surface.setSizeLimits(.{
@@ -191,10 +190,6 @@                 ),
             },
 
-            .toggle_fullscreen => self.toggleFullscreen(target),
-
-            .open_config => try configpkg.edit.open(self.app.alloc),
-
             .set_title => switch (target) {
                 .app => {},
                 .surface => |surface| try surface.rt_surface.setTitle(value.title),
@@ -212,6 +207,16 @@                     .hidden => false,
                 }),
             },
+
+            .initial_position => switch (target) {
+                .app => {},
+                .surface => |surface| try surface.setInitialWindowPosition(
+                    value.x,
+                    value.y,
+                ),
+            },
+
+            .open_config => try configpkg.edit.open(self.app.alloc),
 
             .reload_config => try self.reloadConfig(target, value),
 
@@ -257,11 +262,6 @@         return true;
     }
 
-    /// Reload the configuration. This should return the new configuration.
-    /// The old value can be freed immediately at this point assuming a
-    /// successful return.
-    ///
-    /// The returned pointer value is only valid for a stable self pointer.
     fn reloadConfig(
         self: *App,
         target: apprt.action.Target,
@@ -342,6 +342,26 @@         win.setMonitor(monitor, 0, 0, video_mode.getWidth(), video_mode.getHeight(), 0);
     }
 
+    /// Create a new surface for the app.
+    fn newSurface(self: *App, parent_: ?*CoreSurface) !*Surface {
+        // Grab a surface allocation because we're going to need it.
+        var surface = try self.app.alloc.create(Surface);
+        errdefer self.app.alloc.destroy(surface);
+
+        // Create the surface -- because windows are surfaces for glfw.
+        try surface.init(self);
+        errdefer surface.deinit();
+
+        // If we have a parent, inherit some properties
+        if (self.config.@"window-inherit-font-size") {
+            if (parent_) |parent| {
+                try surface.core_surface.setFontSize(parent.font_size);
+            }
+        }
+
+        return surface;
+    }
+
     /// Create a new tab in the parent surface.
     fn newTab(self: *App, parent_: ?*CoreSurface) !void {
         if (comptime !darwin_enabled) {
@@ -381,25 +401,6 @@         };
     }
 
-    fn newSurface(self: *App, parent_: ?*CoreSurface) !*Surface {
-        // Grab a surface allocation because we're going to need it.
-        var surface = try self.app.alloc.create(Surface);
-        errdefer self.app.alloc.destroy(surface);
-
-        // Create the surface -- because windows are surfaces for glfw.
-        try surface.init(self);
-        errdefer surface.deinit();
-
-        // If we have a parent, inherit some properties
-        if (self.config.@"window-inherit-font-size") {
-            if (parent_) |parent| {
-                try surface.core_surface.setFontSize(parent.font_size);
-            }
-        }
-
-        return surface;
-    }
-
     /// Close the given surface.
     pub fn closeSurface(self: *App, surface: *Surface) void {
         surface.deinit();
@@ -418,20 +419,6 @@         _ = surface;
 
         // GLFW doesn't support the inspector
-    }
-
-    fn glfwErrorCallback(code: glfw.ErrorCode, desc: [:0]const u8) void {
-        std.log.warn("glfw error={} message={s}", .{ code, desc });
-
-        // Workaround for: https://github.com/ocornut/imgui/issues/5908
-        // If we get an invalid value with "scancode" in the message we assume
-        // it is from the glfw key callback that imgui sets and we clear the
-        // error so that our future code doesn't crash.
-        if (code == glfw.ErrorCode.InvalidValue and
-            std.mem.indexOf(u8, desc, "scancode") != null)
-        {
-            _ = glfw.getError();
-        }
     }
 
     pub fn keyboardLayout(self: *const App) input.KeyboardLayout {
@@ -619,10 +606,17 @@             app.app.alloc,
             &config,
             app.app,
-            app,
             self,
         );
         errdefer self.core_surface.deinit();
+
+        // If we have a desired window size, we can now calculate the size
+        // because we have the cell size.
+
+        // Set initial window size is now part of performAction
+
+        // Set maximized, if requested by the config
+        // Not implemented
     }
 
     pub fn deinit(self: *Surface) void {
@@ -643,7 +637,6 @@                 // destroyed so unset it so that the later logic doesn't try to
                 // use it.
                 1 => {},
-
                 // If our tab bar is visible and we are going down to 1 window,
                 // hide the tab bar. The check is "2" because our current window
                 // is still present.
@@ -675,6 +668,47 @@         self.setShouldClose();
         self.deinit();
         self.app.app.alloc.destroy(self);
+    }
+
+    /// Returns the content scale for the created window.
+    pub fn getContentScale(self: *const Surface) !apprt.ContentScale {
+        const scale = self.window.getContentScale();
+        return apprt.ContentScale{ .x = scale.x_scale, .y = scale.y_scale };
+    }
+
+    /// Returns the size of the window in pixels. The pixel size may
+    /// not match screen coordinate size but we should be able to convert
+    /// back and forth using getContentScale.
+    pub fn getSize(self: *const Surface) !apprt.SurfaceSize {
+        const size = self.window.getFramebufferSize();
+        return apprt.SurfaceSize{ .width = size.width, .height = size.height };
+    }
+
+    /// Returns the cursor position in scaled pixels relative to the
+    /// upper-left of the window.
+    pub fn getCursorPos(self: *const Surface) !apprt.CursorPos {
+        const unscaled_pos = self.window.getCursorPos();
+        const pos = try self.cursorPosToPixels(unscaled_pos);
+        return apprt.CursorPos{
+            .x = @floatCast(pos.xpos),
+            .y = @floatCast(pos.ypos),
+        };
+    }
+
+    /// Set the flag that notes this window should be closed for the next
+    /// iteration of the event loop.
+    pub fn setShouldClose(self: *Surface) void {
+        self.window.setShouldClose(true);
+    }
+
+    /// Returns true if the window is flagged to close.
+    pub fn shouldClose(self: *const Surface) bool {
+        return self.window.shouldClose();
+    }
+
+    /// Return the title of the window.
+    pub fn getTitle(self: *Surface) ?[:0]const u8 {
+        return self.title_text;
     }
 
     /// Set the initial window size. This is called exactly once at
@@ -721,96 +755,7 @@         });
     }
 
-    /// Returns the content scale for the created window.
-    pub fn getContentScale(self: *const Surface) !apprt.ContentScale {
-        const scale = self.window.getContentScale();
-        return apprt.ContentScale{ .x = scale.x_scale, .y = scale.y_scale };
-    }
-
-    /// Returns the size of the window in pixels. The pixel size may
-    /// not match screen coordinate size but we should be able to convert
-    /// back and forth using getContentScale.
-    pub fn getSize(self: *const Surface) !apprt.SurfaceSize {
-        const size = self.window.getFramebufferSize();
-        return apprt.SurfaceSize{ .width = size.width, .height = size.height };
-    }
-
-    /// Returns the cursor position in scaled pixels relative to the
-    /// upper-left of the window.
-    pub fn getCursorPos(self: *const Surface) !apprt.CursorPos {
-        const unscaled_pos = self.window.getCursorPos();
-        const pos = try self.cursorPosToPixels(unscaled_pos);
-        return apprt.CursorPos{
-            .x = @floatCast(pos.xpos),
-            .y = @floatCast(pos.ypos),
-        };
-    }
-
-    /// Set the flag that notes this window should be closed for the next
-    /// iteration of the event loop.
-    pub fn setShouldClose(self: *Surface) void {
-        self.window.setShouldClose(true);
-    }
-
-    /// Returns true if the window is flagged to close.
-    pub fn shouldClose(self: *const Surface) bool {
-        return self.window.shouldClose();
-    }
-
-    /// Set the title of the window.
-    fn setTitle(self: *Surface, slice: [:0]const u8) !void {
-        if (self.title_text) |t| self.core_surface.alloc.free(t);
-        self.title_text = try self.core_surface.alloc.dupeZ(u8, slice);
-        self.window.setTitle(self.title_text.?.ptr);
-    }
-
-    /// Return the title of the window.
-    pub fn getTitle(self: *Surface) ?[:0]const u8 {
-        return self.title_text;
-    }
-
-    /// Set the shape of the cursor.
-    fn setMouseShape(self: *Surface, shape: terminal.MouseShape) !void {
-        if ((comptime builtin.target.os.tag.isDarwin()) and
-            !internal_os.macos.isAtLeastVersion(13, 0, 0))
-        {
-            // We only set our cursor if we're NOT on Mac, or if we are then the
-            // macOS version is >= 13 (Ventura). On prior versions, glfw crashes
-            // since we use a tab group.
-            return;
-        }
-
-        const new = glfw.Cursor.createStandard(switch (shape) {
-            .default => .arrow,
-            .text => .ibeam,
-            .crosshair => .crosshair,
-            .pointer => .pointing_hand,
-            .ew_resize => .resize_ew,
-            .ns_resize => .resize_ns,
-            .nwse_resize => .resize_nwse,
-            .nesw_resize => .resize_nesw,
-            .all_scroll => .resize_all,
-            .not_allowed => .not_allowed,
-            else => return, // unsupported, ignore
-        }) orelse {
-            const err = glfw.mustGetErrorCode();
-            log.warn("error creating cursor: {}", .{err});
-            return;
-        };
-        errdefer new.destroy();
-
-        // Set our cursor before we destroy the old one
-        self.window.setCursor(new);
-
-        if (self.cursor) |c| c.destroy();
-        self.cursor = new;
-    }
-
-    /// Set the visibility of the mouse cursor.
-    fn setMouseVisibility(self: *Surface, visible: bool) void {
-        self.window.setInputModeCursor(if (visible) .normal else .hidden);
-    }
-
+    /// Returns the clipboard support.
     pub fn supportsClipboard(
         self: *const Surface,
         clipboard_type: apprt.Clipboard,
@@ -887,6 +832,74 @@         };
     }
 
+    /// Get the renderer health status, not supported, stub.
+    pub fn updateRendererHealth(self: *const Surface, health: renderer.Health) void {
+        // We don't support this in GLFW.
+        _ = self;
+        _ = health;
+    }
+
+    /// Set the shape of the cursor.
+    fn setMouseShape(self: *Surface, shape: terminal.MouseShape) !void {
+        if ((comptime builtin.target.os.tag.isDarwin()) and
+            !internal_os.macos.isAtLeastVersion(13, 0, 0))
+        {
+            // We only set our cursor if we're NOT on Mac, or if we are then the
+            // macOS version is >= 13 (Ventura). On prior versions, glfw crashes
+            // since we use a tab group.
+            return;
+        }
+
+        const new = glfw.Cursor.createStandard(switch (shape) {
+            .default => .arrow,
+            .text => .ibeam,
+            .crosshair => .crosshair,
+            .pointer => .pointing_hand,
+            .ew_resize => .resize_ew,
+            .ns_resize => .resize_ns,
+            .nwse_resize => .resize_nwse,
+            .nesw_resize => .resize_nesw,
+            .all_scroll => .resize_all,
+            .not_allowed => .not_allowed,
+            else => return, // unsupported, ignore
+        }) orelse {
+            const err = glfw.mustGetErrorCode();
+            log.warn("error creating cursor: {}", .{err});
+            return;
+        };
+        errdefer new.destroy();
+
+        // Set our cursor before we destroy the old one
+        self.window.setCursor(new);
+
+        if (self.cursor) |c| c.destroy();
+        self.cursor = new;
+    }
+
+    pub fn mouseOverLink(self: *Surface, uri: ?[]const u8) void {
+        // We don't do anything in GLFW.
+        _ = self;
+        _ = uri;
+    }
+
+    /// Set the visibility of the mouse cursor.
+    fn setMouseVisibility(self: *Surface, visible: bool) void {
+        self.window.setInputModeCursor(if (visible) .normal else .hidden);
+    }
+
+    fn setTitle(self: *Surface, slice: [:0]const u8) !void {
+        if (self.title_text) |t| self.core_surface.alloc.free(t);
+        self.title_text = try self.core_surface.alloc.dupeZ(u8, slice);
+        self.window.setTitle(self.title_text.?.ptr);
+    }
+
+    /// Set the cell size. Unused by GLFW.
+    fn setCellSize(self: *const Surface, width: u32, height: u32) !void {
+        _ = self;
+        _ = width;
+        _ = height;
+    }
+
     pub fn defaultTermioEnv(self: *Surface) !std.process.EnvMap {
         return try internal_os.getEnvMap(self.app.app.alloc);
     }
@@ -926,14 +939,6 @@             return;
         };
         key_event.utf8 = buf[0..len];
-
-        // On macOS we need to also disable some modifiers because
-        // alt+key consumes the alt.
-        if (comptime builtin.target.os.tag.isDarwin()) {
-            // For GLFW, we say we always consume alt because
-            // GLFW doesn't have a way to disable the alt key.
-            key_event.consumed_mods.alt = true;
-        }
 
         _ = core_win.keyCallback(key_event) catch |err| {
             log.err("error in key callback err={}", .{err});
@@ -951,6 +956,9 @@         _ = scancode;
 
         const core_win = window.getUserPointer(CoreSurface) orelse return;
+
+        // Reset our consumption state
+        core_win.rt_surface.key_event = null;
 
         // Convert our glfw types into our input types
         const mods: input.Mods = .{
@@ -1115,6 +1123,14 @@             .unshifted_codepoint = if (utf8.len > 0) @intCast(utf8[0]) else 0,
         };
 
+        // On macOS we need to also disable some modifiers because
+        // alt+key consumes the alt.
+        if (comptime builtin.target.os.tag.isDarwin()) {
+            // For GLFW, we say we always consume alt because
+            // GLFW doesn't have a way to disable the alt key.
+            key_event.consumed_mods.alt = true;
+        }
+
         const effect = core_win.keyCallback(key_event) catch |err| {
             log.err("error in key callback err={}", .{err});
             return;
