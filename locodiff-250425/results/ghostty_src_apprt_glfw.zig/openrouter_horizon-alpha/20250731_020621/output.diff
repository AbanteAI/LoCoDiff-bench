
index afd17d617..50ff6e82b 100644
--- a/ghostty_src_apprt_glfw.zig_expectedoutput.txt (expected):tmp/tmpe5hdrfaf_expected.txt	
+++ b/ghostty_src_apprt_glfw.zig_extracted.txt (actual):tmp/tmpz55phb3r_actual.txt	
@@ -257,6 +257,11 @@ pub const App = struct {
         return true;
     }
 
+    /// Open the configuration in the system editor.
+    pub fn openConfig(self: *App) !void {
+        try configpkg.edit.open(self.app.alloc);
+    }
+
     /// Reload the configuration. This should return the new configuration.
     /// The old value can be freed immediately at this point assuming a
     /// successful return.
@@ -342,45 +347,7 @@ pub const App = struct {
         win.setMonitor(monitor, 0, 0, video_mode.getWidth(), video_mode.getHeight(), 0);
     }
 
-    /// Create a new tab in the parent surface.
-    fn newTab(self: *App, parent_: ?*CoreSurface) !void {
-        if (comptime !darwin_enabled) {
-            log.warn("tabbing is not supported on this platform", .{});
-            return;
-        }
-
-        const parent = parent_ orelse {
-            _ = try self.newSurface(null);
-            return;
-        };
-
-        // Create the new window
-        const window = try self.newSurface(parent);
-
-        // Add the new window the parent window
-        const parent_win = glfwNative.getCocoaWindow(parent.rt_surface.window).?;
-        const other_win = glfwNative.getCocoaWindow(window.window).?;
-        const NSWindowOrderingMode = enum(isize) { below = -1, out = 0, above = 1 };
-        const nswindow = objc.Object.fromId(parent_win);
-        nswindow.msgSend(void, objc.sel("addTabbedWindow:ordered:"), .{
-            objc.Object.fromId(other_win),
-            NSWindowOrderingMode.above,
-        });
-
-        // Adding a new tab can cause the tab bar to appear which changes
-        // our viewport size. We need to call the size callback in order to
-        // update values. For example, we need this to set the proper mouse selection
-        // point in the grid.
-        const size = parent.rt_surface.getSize() catch |err| {
-            log.err("error querying window size for size callback on new tab err={}", .{err});
-            return;
-        };
-        parent.sizeCallback(size) catch |err| {
-            log.err("error in size callback from new tab err={}", .{err});
-            return;
-        };
-    }
-
+    /// Create a new window for the app.
     fn newSurface(self: *App, parent_: ?*CoreSurface) !*Surface {
         // Grab a surface allocation because we're going to need it.
         var surface = try self.app.alloc.create(Surface);
@@ -400,7 +367,6 @@ pub const App = struct {
         return surface;
     }
 
-    /// Close the given surface.
     pub fn closeSurface(self: *App, surface: *Surface) void {
         surface.deinit();
         self.app.alloc.destroy(surface);
@@ -420,20 +386,6 @@ pub const App = struct {
         // GLFW doesn't support the inspector
     }
 
-    fn glfwErrorCallback(code: glfw.ErrorCode, desc: [:0]const u8) void {
-        std.log.warn("glfw error={} message={s}", .{ code, desc });
-
-        // Workaround for: https://github.com/ocornut/imgui/issues/5908
-        // If we get an invalid value with "scancode" in the message we assume
-        // it is from the glfw key callback that imgui sets and we clear the
-        // error so that our future code doesn't crash.
-        if (code == glfw.ErrorCode.InvalidValue and
-            std.mem.indexOf(u8, desc, "scancode") != null)
-        {
-            _ = glfw.getError();
-        }
-    }
-
     pub fn keyboardLayout(self: *const App) input.KeyboardLayout {
         _ = self;
 
@@ -468,6 +420,59 @@ pub const App = struct {
             self.* = undefined;
         }
     };
+
+    fn glfwErrorCallback(code: glfw.ErrorCode, desc: [:0]const u8) void {
+        std.log.warn("glfw error={} message={s}", .{ code, desc });
+
+        // Workaround for: https://github.com/ocornut/imgui/issues/5908
+        // If we get an invalid value with "scancode" in the message we assume
+        // it is from the glfw key callback that imgui sets and we clear the
+        // error so that our future code doesn't crash.
+        if (code == glfw.ErrorCode.InvalidValue and
+            std.mem.indexOf(u8, desc, "scancode") != null)
+        {
+            _ = glfw.getError();
+        }
+    }
+
+    /// Create a new tab in the parent surface.
+    fn newTab(self: *App, parent_: ?*CoreSurface) !void {
+        if (comptime !darwin_enabled) {
+            log.warn("tabbing is not supported on this platform", .{});
+            return;
+        }
+
+        const parent = parent_ orelse {
+            _ = try self.newSurface(null);
+            return;
+        };
+
+        // Create the new window
+        const window = try self.newSurface(parent);
+
+        // Add the new window the parent window
+        const parent_win = glfwNative.getCocoaWindow(parent.rt_surface.window).?;
+        const other_win = glfwNative.getCocoaWindow(window.window).?;
+        const NSWindowOrderingMode = enum(isize) { below = -1, out = 0, above = 1 };
+        const nswindow = objc.Object.fromId(parent_win);
+        nswindow.msgSend(void, objc.sel("addTabbedWindow:ordered:"), .{
+            objc.Object.fromId(other_win),
+            NSWindowOrderingMode.above,
+        });
+
+        // Adding a new tab can cause the tab bar to appear which changes
+        // our viewport size. We need to call the size callback in order to
+        // update values. For example, we need this to set the proper mouse selection
+        // point in the grid.
+        const size = parent.rt_surface.getSize() catch |err| {
+            log.err("error querying window size for size callback on new tab err={}", .{err});
+            return;
+        };
+        parent.sizeCallback(size) catch |err| {
+            log.err("error in size callback from new tab err={}", .{err});
+            return;
+        };
+    }
 };
 
 /// These are used to keep track of the original monitor values so that we can
@@ -887,10 +892,6 @@ pub const Surface = struct {
         };
     }
 
-    pub fn defaultTermioEnv(self: *Surface) !std.process.EnvMap {
-        return try internal_os.getEnvMap(self.app.app.alloc);
-    }
-
     fn sizeCallback(window: glfw.Window, width: i32, height: i32) void {
         _ = width;
         _ = height;
@@ -1257,4 +1258,8 @@ pub const Surface = struct {
             list.clearRetainingCapacity(); // avoid unnecessary reallocations
         }
     }
+
+    pub fn defaultTermioEnv(self: *Surface) !std.process.EnvMap {
+        return try internal_os.getEnvMap(self.app.app.alloc);
+    }
 };
\ No newline at end of file
