--- ghostty_src_apprt_glfw.zig_expectedoutput.txt (expected)+++ ghostty_src_apprt_glfw.zig_extracted.txt (actual)@@ -420,20 +420,6 @@         // GLFW doesn't support the inspector
     }
 
-    fn glfwErrorCallback(code: glfw.ErrorCode, desc: [:0]const u8) void {
-        std.log.warn("glfw error={} message={s}", .{ code, desc });
-
-        // Workaround for: https://github.com/ocornut/imgui/issues/5908
-        // If we get an invalid value with "scancode" in the message we assume
-        // it is from the glfw key callback that imgui sets and we clear the
-        // error so that our future code doesn't crash.
-        if (code == glfw.ErrorCode.InvalidValue and
-            std.mem.indexOf(u8, desc, "scancode") != null)
-        {
-            _ = glfw.getError();
-        }
-    }
-
     pub fn keyboardLayout(self: *const App) input.KeyboardLayout {
         _ = self;
 
@@ -582,9 +568,10 @@         win.setMouseButtonCallback(mouseButtonCallback);
         win.setDropCallback(dropCallback);
 
+        const pos = win.getPos();
+        const size = win.getFramebufferSize();
+
         const dimensions: MonitorDimensions = dimensions: {
-            const pos = win.getPos();
-            const size = win.getFramebufferSize();
             break :dimensions .{
                 .width = size.width,
                 .height = size.height,
@@ -623,6 +610,15 @@             self,
         );
         errdefer self.core_surface.deinit();
+
+        // If we have a desired window size, we can now calculate the size
+        // because we have the cell size.
+        if (config.@"window-height" > 0 or config.@"window-width" > 0) {
+            self.window.setSize(.{
+                .height = @max(config.@"window-height" * self.core_surface.cell_size.height, 480),
+                .width = @max(config.@"window-width" * self.core_surface.cell_size.width, 640),
+            });
+        }
     }
 
     pub fn deinit(self: *Surface) void {
@@ -677,6 +673,42 @@         self.app.app.alloc.destroy(self);
     }
 
+    /// Returns the content scale for the created window.
+    pub fn getContentScale(self: *const Surface) !apprt.ContentScale {
+        const scale = self.window.getContentScale();
+        return apprt.ContentScale{ .x = scale.x_scale, .y = scale.y_scale };
+    }
+
+    /// Returns the size of the window in pixels. The pixel size may
+    /// not match screen coordinate size but we should be able to convert
+    /// back and forth using getContentScale.
+    pub fn getSize(self: *const Surface) !apprt.SurfaceSize {
+        const size = self.window.getFramebufferSize();
+        return apprt.SurfaceSize{ .width = size.width, .height = size.height };
+    }
+
+    /// Returns the cursor position in scaled pixels relative to the
+    /// upper-left of the window.
+    pub fn getCursorPos(self: *const Surface) !apprt.CursorPos {
+        const unscaled_pos = self.window.getCursorPos();
+        const pos = try self.cursorPosToPixels(unscaled_pos);
+        return apprt.CursorPos{
+            .x = @floatCast(pos.xpos),
+            .y = @floatCast(pos.ypos),
+        };
+    }
+
+    /// Set the flag that notes this window should be closed for the next
+    /// iteration of the event loop.
+    pub fn setShouldClose(self: *Surface) void {
+        self.window.setShouldClose(true);
+    }
+
+    /// Returns true if the window is flagged to close.
+    pub fn shouldClose(self: *const Surface) bool {
+        return self.window.shouldClose();
+    }
+
     /// Set the initial window size. This is called exactly once at
     /// surface initialization time. This may be called before "self"
     /// is fully initialized.
@@ -691,17 +723,6 @@             .width = @min(width, workarea.width),
             .height = @min(height, workarea.height),
         });
-    }
-
-    /// Set the initial window position. This is called exactly once at
-    /// surface initialization time. This may be called before "self"
-    /// is fully initialized.
-    fn setInitialWindowPosition(win: glfw.Window, x: ?i16, y: ?i16) void {
-        const start_position_x = x orelse return;
-        const start_position_y = y orelse return;
-
-        log.debug("setting initial window position ({},{})", .{ start_position_x, start_position_y });
-        win.setPos(.{ .x = start_position_x, .y = start_position_y });
     }
 
     /// Set the size limits of the window.
@@ -719,42 +740,6 @@             .width = null,
             .height = null,
         });
-    }
-
-    /// Returns the content scale for the created window.
-    pub fn getContentScale(self: *const Surface) !apprt.ContentScale {
-        const scale = self.window.getContentScale();
-        return apprt.ContentScale{ .x = scale.x_scale, .y = scale.y_scale };
-    }
-
-    /// Returns the size of the window in pixels. The pixel size may
-    /// not match screen coordinate size but we should be able to convert
-    /// back and forth using getContentScale.
-    pub fn getSize(self: *const Surface) !apprt.SurfaceSize {
-        const size = self.window.getFramebufferSize();
-        return apprt.SurfaceSize{ .width = size.width, .height = size.height };
-    }
-
-    /// Returns the cursor position in scaled pixels relative to the
-    /// upper-left of the window.
-    pub fn getCursorPos(self: *const Surface) !apprt.CursorPos {
-        const unscaled_pos = self.window.getCursorPos();
-        const pos = try self.cursorPosToPixels(unscaled_pos);
-        return apprt.CursorPos{
-            .x = @floatCast(pos.xpos),
-            .y = @floatCast(pos.ypos),
-        };
-    }
-
-    /// Set the flag that notes this window should be closed for the next
-    /// iteration of the event loop.
-    pub fn setShouldClose(self: *Surface) void {
-        self.window.setShouldClose(true);
-    }
-
-    /// Returns true if the window is flagged to close.
-    pub fn shouldClose(self: *const Surface) bool {
-        return self.window.shouldClose();
     }
 
     /// Set the title of the window.
@@ -1257,4 +1242,18 @@             list.clearRetainingCapacity(); // avoid unnecessary reallocations
         }
     }
-};+};
+
+fn glfwErrorCallback(code: glfw.ErrorCode, desc: [:0]const u8) void {
+    std.log.warn("glfw error={} message={s}", .{ code, desc });
+
+    // Workaround for: https://github.com/ocornut/imgui/issues/5908
+    // If we get an invalid value with "scancode" in the message we assume
+    // it is from the glfw key callback that imgui sets and we clear the
+    // error so that our future code doesn't crash.
+    if (code == glfw.ErrorCode.InvalidValue and
+        std.mem.indexOf(u8, desc, "scancode") != null)
+    {
+        _ = glfw.getError();
+    }
+}