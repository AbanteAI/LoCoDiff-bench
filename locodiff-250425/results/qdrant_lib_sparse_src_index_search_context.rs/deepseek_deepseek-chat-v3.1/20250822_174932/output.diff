
index 8be5822c3..f247ff2ed 100644
--- a/qdrant_lib_sparse_src_index_search_context.rs_expectedoutput.txt (expected):tmp/tmph3bgs6iu_expected.txt	
+++ b/qdrant_lib_sparse_src_index_search_context.rs_extracted.txt (actual):tmp/tmprlq89kwn_actual.txt	
@@ -1,4 +1,4 @@
-use std::cmp::{Ordering, max, min};
+use std::cmp::{max, min, Ordering};
 use std::sync::atomic::AtomicBool;
 use std::sync::atomic::Ordering::Relaxed;
 
@@ -8,14 +8,14 @@ use common::types::{PointOffsetType, ScoredPointOffset};
 
 use super::posting_list_common::PostingListIter;
 use crate::common::scores_memory_pool::PooledScoresHandle;
-use crate::common::sparse_vector::{RemappedSparseVector, score_vectors};
+use crate::common::sparse_vector::{score_vectors, RemappedSparseVector};
 use crate::common::types::{DimId, DimWeight};
 use crate::index::inverted_index::InvertedIndex;
 use crate::index::posting_list::PostingListIterator;
 
 /// Iterator over posting lists with a reference to the corresponding query index and weight
-pub struct IndexedPostingListIterator<T: PostingListIter> {
-    posting_list_iterator: T,
+pub struct IndexedPostingListIterator<'a> {
+    posting_list_iterator: PostingListIterator<'a>,
     query_index: DimId,
     query_weight: DimWeight,
 }
@@ -116,7 +116,7 @@ impl<'a, 'b, T: PostingListIter> SearchContext<'a, 'b, T> {
             // collect indices and values for the current record id from the query's posting lists *only*
             for posting_iterator in self.postings_iterators.iter_mut() {
                 // rely on underlying binary search as the posting lists are sorted by record id
-                match posting_iterator.posting_list_iterator.skip_to(id) {
+                match posting_iterator.posting_list_iterator.skip_to(*id) {
                     None => {} // no match for posting list
                     Some(element) => {
                         // match for posting list
@@ -142,7 +142,7 @@ impl<'a, 'b, T: PostingListIter> SearchContext<'a, 'b, T> {
 
             self.top_results.push(ScoredPointOffset {
                 score: sparse_score,
-                idx: id,
+                idx: *id,
             });
         }
         let top = std::mem::take(&mut self.top_results);
@@ -338,6 +338,7 @@ impl<'a, 'b, T: PostingListIter> SearchContext<'a, 'b, T> {
                 } else {
                     best_min_score = new_min_score;
                 }
+
                 // make sure the first posting list is the longest for pruning
                 self.promote_longest_posting_lists_to_the_front();
 
