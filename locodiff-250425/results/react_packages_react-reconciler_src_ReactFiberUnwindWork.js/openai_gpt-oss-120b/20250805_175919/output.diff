
index ba169d3f5..66c0393fa 100644
--- a/react_packages_react-reconciler_src_ReactFiberUnwindWork.js_expectedoutput.txt (expected):tmp/tmpgqf5z_mr_expected.txt	
+++ b/react_packages_react-reconciler_src_ReactFiberUnwindWork.js_extracted.txt (actual):tmp/tmprqak23_1_actual.txt	
@@ -14,6 +14,7 @@ import type {ActivityState} from './ReactFiberActivityComponent';
 import type {SuspenseState} from './ReactFiberSuspenseComponent';
 import type {Cache} from './ReactFiberCacheComponent';
 import type {TracingMarkerInstance} from './ReactFiberTracingMarkerComponent';
+import type {ReactCurrentOwner} from 'shared/ReactTypes';
 
 import {
   ClassComponent,
@@ -38,7 +39,6 @@ import {
   enableTransitionTracing,
   enableRenderableContext,
 } from 'shared/ReactFeatureFlags';
-
 import {popHostContainer, popHostContext} from './ReactFiberHostContext';
 import {
   popSuspenseListContext,
@@ -90,9 +90,10 @@ function unwindWork(
       }
       return null;
     }
+
     case HostRoot: {
       const root: FiberRoot = workInProgress.stateNode;
-      const cache: Cache = workInProgress.memoizedState.cache;
+      const cache: Cache = (workInProgress.memoizedState?.cache: any);
       popCacheProvider(workInProgress, cache);
 
       if (enableTransitionTracing) {
@@ -103,18 +104,15 @@ function unwindWork(
       popHostContainer(workInProgress);
       popTopLevelLegacyContextObject(workInProgress);
       const flags = workInProgress.flags;
-      if (
-        (flags & ShouldCapture) !== NoFlags &&
-        (flags & DidCapture) === NoFlags
-      ) {
-        // There was an error during render that wasn't captured by a suspense
-        // boundary. Do a second pass on the root to unmount the children.
+      if ((flags & ShouldCapture) !== NoFlags && (flags & DidCapture) === NoFlags) {
+        // With a component in tree not caught by a suspense boundary. Do a second pass.
         workInProgress.flags = (flags & ~ShouldCapture) | DidCapture;
         return workInProgress;
       }
-      // We unwound to the root without completing it. Exit.
+      // Unwind to the root without completing it.
       return null;
     }
+
     case HostHoistable:
     case HostSingleton:
     case HostComponent: {
@@ -122,18 +120,23 @@ function unwindWork(
       popHostContext(workInProgress);
       return null;
     }
+
     case ActivityComponent: {
       const activityState: null | ActivityState = workInProgress.memoizedState;
       if (activityState !== null) {
-        popSuspenseHandler(workInProgress);
-
+        // If we already have a mounted current fiber (i.e. not mounting),
+        // this is a rehydration boundary.
+        // Hitting this path in a new mount should never happen.
         if (workInProgress.alternate === null) {
           throw new Error(
             'Threw in newly mounted dehydrated component. This is likely a bug in ' +
               'React. Please file an issue.',
           );
         }
-
+        // This branch is hit while we are hydrating.
+        // Now we are rendering a new rendering.
+        // Reset to keep all work for this
+        // boundary.
         resetHydrationState();
       }
 
@@ -147,21 +150,24 @@ function unwindWork(
         ) {
           transferActualDuration(workInProgress);
         }
+        // Exit early and let the resumed work rest.
         return workInProgress;
       }
       return null;
     }
+
     case SuspenseComponent: {
       popSuspenseHandler(workInProgress);
       const suspenseState: null | SuspenseState = workInProgress.memoizedState;
       if (suspenseState !== null && suspenseState.dehydrated !== null) {
+        // if this is a dehydrated component,
+        // we need to reset the hydration for that.
         if (workInProgress.alternate === null) {
           throw new Error(
             'Threw in newly mounted dehydrated component. This is likely a bug in ' +
               'React. Please file an issue.',
           );
         }
-
         resetHydrationState();
       }
 
@@ -179,24 +185,35 @@ function unwindWork(
       }
       return null;
     }
+
     case SuspenseListComponent: {
       popSuspenseListContext(workInProgress);
-      // SuspenseList doesn't actually catch anything. It should've been
-      // caught by a nested boundary. If not, it should bubble through.
+      // SuspenseList doesn't actually catch anything.
+      // It should be caught by a nested boundary.
+      // If nothing catches it, it bubbles up.
       return null;
     }
+
     case HostPortal:
       popHostContainer(workInProgress);
       return null;
-    case ContextProvider:
+
+    case ContextProvider: {
       let context: ReactContext<any>;
       if (enableRenderableContext) {
+        // The Provider is directly using the context object now
+        // (renderable context flag) which means ._context is not necessary.
         context = workInProgress.type;
       } else {
-        context = workInProgress.type._context;
+        const provider: any = workInProgress.type;
+        // Old behavior: grab context from provider type.
+        // This is backward compatible for pre-vanila providers.
+        context = provider._context;
       }
       popProvider(context, workInProgress);
       return null;
+    }
+
     case OffscreenComponent:
     case LegacyHiddenComponent: {
       popSuspenseHandler(workInProgress);
@@ -216,17 +233,22 @@ function unwindWork(
       }
       return null;
     }
-    case CacheComponent:
-      const cache: Cache = workInProgress.memoizedState.cache;
+
+    case CacheComponent: {
+      const cache: Cache = (workInProgress.memoizedState?.cache: any);
       popCacheProvider(workInProgress, cache);
       return null;
-    case TracingMarkerComponent:
+    }
+
+    case TracingMarkerComponent: {
       if (enableTransitionTracing) {
         if (workInProgress.stateNode !== null) {
           popMarkerInstance(workInProgress);
         }
       }
       return null;
+    }
+
     default:
       return null;
   }
@@ -236,7 +258,7 @@ function unwindInterruptedWork(
   current: Fiber | null,
   interruptedWork: Fiber,
   renderLanes: Lanes,
-) {
+): void {
   // Note: This intentionally doesn't check if we're hydrating because comparing
   // to the current tree provider fiber is just as fast and less error-prone.
   // Ideally we would have a special version of the work loop only
@@ -245,18 +267,18 @@ function unwindInterruptedWork(
   switch (interruptedWork.tag) {
     case ClassComponent: {
       const childContextTypes = interruptedWork.type.childContextTypes;
-      if (childContextTypes !== null && childContextTypes !== undefined) {
+      if (childContextTypes != null) {
         popLegacyContext(interruptedWork);
       }
       break;
     }
     case HostRoot: {
       const root: FiberRoot = interruptedWork.stateNode;
-      const cache: Cache = interruptedWork.memoizedState.cache;
+      const cache: Cache = (interruptedWork.memoizedState?.cache: any);
       popCacheProvider(interruptedWork, cache);
 
       if (enableTransitionTracing) {
-        popRootMarkerInstance(interruptedWork);
+        popRootMarkerImpl(interruptedWork); // (pseudo function; actual implementation depends on tracing)
       }
 
       popRootTransition(interruptedWork, root, renderLanes);
@@ -273,38 +295,36 @@ function unwindInterruptedWork(
     case HostPortal:
       popHostContainer(interruptedWork);
       break;
-    case ActivityComponent: {
-      if (interruptedWork.memoizedState !== null) {
-        popSuspenseHandler(interruptedWork);
-      }
-      break;
-    }
     case SuspenseComponent:
       popSuspenseHandler(interruptedWork);
       break;
     case SuspenseListComponent:
       popSuspenseListContext(interruptedWork);
       break;
-    case ContextProvider:
+    case ContextProvider: {
       let context: ReactContext<any>;
       if (enableRenderableContext) {
         context = interruptedWork.type;
       } else {
-        context = interruptedWork.type._context;
+        const provider: any = interruptedType.type;
+        context = provider._context;
       }
       popProvider(context, interruptedWork);
       break;
+    }
     case OffscreenComponent:
-    case LegacyHiddenComponent:
+    case LegacyHiddenComponent: {
       popSuspenseHandler(interruptedWork);
       popHiddenContext(interruptedWork);
       popTransition(interruptedWork, current);
       break;
-    case CacheComponent:
-      const cache: Cache = interruptedWork.memoizedState.cache;
+    }
+    case CacheComponent: {
+      const cache: Cache = (interruptedWork.memoizedState?.cache: any);
       popCacheProvider(interruptedWork, cache);
       break;
-    case TracingMarkerComponent:
+    }
+    case TracingMarkerComponent: {
       if (enableTransitionTracing) {
         const instance: TracingMarkerInstance | null =
           interruptedWork.stateNode;
@@ -313,6 +333,7 @@ function unwindInterruptedWork(
         }
       }
       break;
+    }
     default:
       break;
   }
