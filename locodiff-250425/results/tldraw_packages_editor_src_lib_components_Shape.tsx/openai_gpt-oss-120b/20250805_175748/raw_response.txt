```tsx
import { react } from '@tldraw/state'
import { useQuickReactor, useStateTracking } from '@tldraw/state-react'
import { TLShape, TLShapeId } from '@tldraw/tlschema'
import { memo, useCallback, useEffect, useLayoutEffect, useRef } from 'react'
import { ShapeUtil } from '../editor/shapes/ShapeUtil'
import { useEditor } from '../hooks/useEditor'
import { useEditorComponents } from '../hooks/useEditorComponents'
import { Mat } from '../primitives/Mat'
import { setStyleProperty } from '../utils/dom'
import { OptionalErrorBoundary } from './ErrorBoundary'

/**
 * This component renders shapes on the canvas. There are two stages: positioning
 * and styling the shape's container using CSS, and then rendering the shape's
 * JSX using its shape util's component method.
 *
 * Rendering the "inside" of a shape is more expensive than positioning it,
 * so we use memo to wrap the inner shape and only re-render it when
 * the shape's props or meta change.
 *
 * The shape also receives props for its index and opacity. The index
 * determines the z-index of the shape, and the opacity is used
 * to set the shape's opacity based on its own opacity and that
 * of its parent.
 */
export const Shape = memo(function Shape({
	id,
	shape,
	util,
	index,
	backgroundIndex,
	opacity,
}: {
	id: TLShapeId
	shape: TLShape
	util: ShapeUtil
	index: number
	backgroundIndex: number
	opacity: number
}) {
	const editor = useEditor()
	const { ShapeErrorFallback } = useEditorComponents()

	const containerRef = useRef<HTMLDivElement>(null)
	const bgContainerRef = useRef<HTMLDivElement>(null)

	// Load any fonts needed by the shape
	useEffect(() => {
		return react('load fonts', () => {
			const fonts = editor.fonts.getShapeFontFaces(id)
			editor.fonts.requestFonts(fonts)
		})
	}, [editor, id])

	/**
	 * Memoised values so we only set styles when they actually change.
	 */
	const memoizedStuffRef = useRef({
		transform: '',
		clipPath: 'none',
		width: 0,
		height: 0,
		isCulled: false,
	})

	// Set shape container styles: transform, clip-path, size
	useQuickReactor(
		'set shape stuff',
		() => {
			const shape = editor.getShape(id)
			if (!shape) return

			const prev = memoizedStuffRef.current

			// Clip path
			const clipPath = editor.getShapeClipPath(id) ?? 'none'
			if (clipPath !== prev.clipPath) {
				setStyleProperty(containerRef.current, 'clip-path', clipPath)
				setStyleProperty(bgContainerRef.current, 'clip-path', clipPath)
				prev.clipPath = clipPath
			}

			// Transform
			const pageTransform = editor.getShapePageTransform(id)
			const transform = Mat.toCssString(pageTransform)
			if (transform !== prev.transform) {
				setStyleProperty(containerRef.current, 'transform', transform)
				setStyleProperty(bgContainerRef.current, 'transform', transform)
				prev.transform = transform
			}

			// Size
			const bounds = editor.getShapeGeometry(shape).bounds
			const width = Math.max(bounds.width, 1)
			const height = Math.max(bounds.height, 1)

			if (width !== prev.width || height !== prev.height) {
				const widthPx = width + 'px'
				const heightPx = height + 'px'
				setStyleProperty(containerRef.current, 'width', widthPx)
				setStyleContainer(bgContainerRef.current, 'width', widthPx)
				setStyleProperty(containerRef.current, 'height', heightPx)
				setStyleContainer(bgContainerRef.current, 'height', heightPx)
				prev.width = width
				prev.height = height
			}
		},
		[editor]
	)

	// Opacity & Z‑index (change infrequently)
	useLayoutEffect(() => {
		const container = containerRef.current
		const bgContainer = bgContainerRef.current

		// Opacity
		setStyleProperty(container, 'opacity', opacity)
		setStyleProperty(bgContainer, 'opacity', opacity)

		// Z‑Index
		setStyleProperty(container, 'z-index', index)
		setStyleProperty(bgContainer, 'z-index', backgroundIndex)
	}, [opacity, index, backgroundIndex])

	// Culling: hide / show container depending on whether shape is culled
	useQuickReactor(
		'set display',
		() => {
			const shape = editor.getShape(id)
			if (!shape) return

			const isCulled = editor.isShapeCulled(shape)
			if (isCulled !== memoizedStuffRef.current.isCulled) {
				setStyleProperty(containerRef.current, 'display', isCulled ? 'none' : 'block')
				setStyleProperty(bgContainerRef.current, 'display', isCulled ? 'none' : 'block')
				memoizedStuffRef.current.isCulled = isCulled
			}
		},
		[editor]
	)

	const annotateError = useCallback(
		(error: any) => editor.annotateError(error, { origin: 'shape', willCrashApp: false }),
		[editor]
	)

	const isFilledShape =
		'fill' in shape.props && shape.props.fill !== 'none'

	return (
		<>
			{util.backgroundComponent && (
				<div
					ref={bgContainerRef}
					className="tl-shape tl-shape-background"
					data-shape-type={shape.type}
					data-shape-id={shape.id}
					draggable={false}
				>
					<OptionalErrorBoundary fallback={ShapeErrorFallback} onError={annotateError}>
						<InnerShapeBackground shape={shape} util={util} />
					</OptionalErrorBoundary>
				</div>
			)}
			<div
				ref={containerRef}
				className="tl-shape"
				data-shape-type={shape.type}
				data-shape-is-filled={isFilledShape}
				data-shape-id={shape.id}
				draggable={false}
			>
				<OptionalErrorBoundary fallback={ShapeErrorFallback as any} onError={annotateError}>
					<InnerShape shape={shape} util={util} />
				</OptionalErrorBoundary>
			</div>
		</>
	)
})

/* --------- Inner shape components --------- */

export const InnerShape = memo(
	function InnerShape<T extends TLShape>({ shape, util }: { shape: T; util: ShapeUtil<T> }) {
		return useStateTracking(
			'InnerShape:' + shape.type,
			() => util.component(util.editor.store.unsafeGetWithoutCapture(shape.id) as T),
			[util, shape.id]
		)
	},
	(prev, next) =>
		prev.shape.props === next.shape.props && prev.shape.meta === next.shape.meta && prev.util === next.util
)

export const InnerShapeBackground = memo(
	function InnerShapeBackground<T extends TLShape>({
		shape,
		util,
	}: {
		shape: T
		util: ShapeUtil<T>
	}) {
		return useStateTracking(
			'InnerShape:' + shape.type,
			() => util.backgroundComponent?.(util.editor.store.unsafeGetWithoutCapture(shape.id) as T),
			[util, shape.id]
		)
	},
	(prev, next) =>
		prev.shape.props === next.props.props &&
		prev.shape.meta === next.shape.meta &&
		prev.util === next.util
)
```