
index 2c7cd6150..9ca750da7 100644
--- a/tldraw_packages_editor_src_lib_components_Shape.tsx_expectedoutput.txt (expected):tmp/tmpcny052zc_expected.txt	
+++ b/tldraw_packages_editor_src_lib_components_Shape.tsx_extracted.txt (actual):tmp/tmp1rkmc7cp_actual.txt	
@@ -9,17 +9,20 @@ import { Mat } from '../primitives/Mat'
 import { setStyleProperty } from '../utils/dom'
 import { OptionalErrorBoundary } from './ErrorBoundary'
 
-/*
-This component renders shapes on the canvas. There are two stages: positioning
-and styling the shape's container using CSS, and then rendering the shape's 
-JSX using its shape util's render method. Rendering the "inside" of a shape is
-more expensive than positioning it or changing its color, so we use memo
-to wrap the inner shape and only re-render it when the shape's props change. 
-
-The shape also receives props for its index and opacity. The index is used to
-determine the z-index of the shape, and the opacity is used to set the shape's
-opacity based on its own opacity and that of its parent's.
-*/
+/**
+ * This component renders shapes on the canvas. There are two stages: positioning
+ * and styling the shape's container using CSS, and then rendering the shape's
+ * JSX using its shape util's component method.
+ *
+ * Rendering the "inside" of a shape is more expensive than positioning it,
+ * so we use memo to wrap the inner shape and only re-render it when
+ * the shape's props or meta change.
+ *
+ * The shape also receives props for its index and opacity. The index
+ * determines the z-index of the shape, and the opacity is used
+ * to set the shape's opacity based on its own opacity and that
+ * of its parent.
+ */
 export const Shape = memo(function Shape({
 	id,
 	shape,
@@ -36,12 +39,12 @@ export const Shape = memo(function Shape({
 	opacity: number
 }) {
 	const editor = useEditor()
-
 	const { ShapeErrorFallback } = useEditorComponents()
 
 	const containerRef = useRef<HTMLDivElement>(null)
 	const bgContainerRef = useRef<HTMLDivElement>(null)
 
+	// Load any fonts needed by the shape
 	useEffect(() => {
 		return react('load fonts', () => {
 			const fonts = editor.fonts.getShapeFontFaces(id)
@@ -49,21 +52,23 @@ export const Shape = memo(function Shape({
 		})
 	}, [editor, id])
 
+	/**
+	 * Memoised values so we only set styles when they actually change.
+	 */
 	const memoizedStuffRef = useRef({
 		transform: '',
 		clipPath: 'none',
 		width: 0,
 		height: 0,
-		x: 0,
-		y: 0,
 		isCulled: false,
 	})
 
+	// Set shape container styles: transform, clip-path, size
 	useQuickReactor(
 		'set shape stuff',
 		() => {
 			const shape = editor.getShape(id)
-			if (!shape) return // probably the shape was just deleted
+			if (!shape) return
 
 			const prev = memoizedStuffRef.current
 
@@ -75,27 +80,27 @@ export const Shape = memo(function Shape({
 				prev.clipPath = clipPath
 			}
 
-			// Page transform
+			// Transform
 			const pageTransform = editor.getShapePageTransform(id)
 			const transform = Mat.toCssString(pageTransform)
-			const bounds = editor.getShapeGeometry(shape).bounds
-
-			// Update if the tranform has changed
 			if (transform !== prev.transform) {
 				setStyleProperty(containerRef.current, 'transform', transform)
 				setStyleProperty(bgContainerRef.current, 'transform', transform)
 				prev.transform = transform
 			}
 
-			// Width / Height
+			// Size
+			const bounds = editor.getShapeGeometry(shape).bounds
 			const width = Math.max(bounds.width, 1)
 			const height = Math.max(bounds.height, 1)
 
 			if (width !== prev.width || height !== prev.height) {
-				setStyleProperty(containerRef.current, 'width', width + 'px')
-				setStyleProperty(containerRef.current, 'height', height + 'px')
-				setStyleProperty(bgContainerRef.current, 'width', width + 'px')
-				setStyleProperty(bgContainerRef.current, 'height', height + 'px')
+				const widthPx = width + 'px'
+				const heightPx = height + 'px'
+				setStyleProperty(containerRef.current, 'width', widthPx)
+				setStyleContainer(bgContainerRef.current, 'width', widthPx)
+				setStyleProperty(containerRef.current, 'height', heightPx)
+				setStyleContainer(bgContainerRef.current, 'height', heightPx)
 				prev.width = width
 				prev.height = height
 			}
@@ -103,7 +108,7 @@ export const Shape = memo(function Shape({
 		[editor]
 	)
 
-	// This stuff changes pretty infrequently, so we can change them together
+	// Opacity & Z‑index (change infrequently)
 	useLayoutEffect(() => {
 		const container = containerRef.current
 		const bgContainer = bgContainerRef.current
@@ -112,19 +117,19 @@ export const Shape = memo(function Shape({
 		setStyleProperty(container, 'opacity', opacity)
 		setStyleProperty(bgContainer, 'opacity', opacity)
 
-		// Z-Index
+		// Z‑Index
 		setStyleProperty(container, 'z-index', index)
 		setStyleProperty(bgContainer, 'z-index', backgroundIndex)
 	}, [opacity, index, backgroundIndex])
 
+	// Culling: hide / show container depending on whether shape is culled
 	useQuickReactor(
 		'set display',
 		() => {
 			const shape = editor.getShape(id)
-			if (!shape) return // probably the shape was just deleted
+			if (!shape) return
 
-			const culledShapes = editor.getCulledShapes()
-			const isCulled = culledShapes.has(id)
+			const isCulled = editor.isShapeCulled(shape)
 			if (isCulled !== memoizedStuffRef.current.isCulled) {
 				setStyleProperty(containerRef.current, 'display', isCulled ? 'none' : 'block')
 				setStyleProperty(bgContainerRef.current, 'display', isCulled ? 'none' : 'block')
@@ -133,14 +138,14 @@ export const Shape = memo(function Shape({
 		},
 		[editor]
 	)
+
 	const annotateError = useCallback(
 		(error: any) => editor.annotateError(error, { origin: 'shape', willCrashApp: false }),
 		[editor]
 	)
 
-	if (!shape) return null
-
-	const isFilledShape = 'fill' in shape.props && shape.props.fill !== 'none'
+	const isFilledShape =
+		'fill' in shape.props && shape.props.fill !== 'none'
 
 	return (
 		<>
@@ -173,21 +178,18 @@ export const Shape = memo(function Shape({
 	)
 })
 
+/* --------- Inner shape components --------- */
+
 export const InnerShape = memo(
 	function InnerShape<T extends TLShape>({ shape, util }: { shape: T; util: ShapeUtil<T> }) {
 		return useStateTracking(
 			'InnerShape:' + shape.type,
-			() =>
-				// always fetch the latest shape from the store even if the props/meta have not changed, to avoid
-				// calling the render method with stale data.
-				util.component(util.editor.store.unsafeGetWithoutCapture(shape.id) as T),
+			() => util.component(util.editor.store.unsafeGetWithoutCapture(shape.id) as T),
 			[util, shape.id]
 		)
 	},
 	(prev, next) =>
-		prev.shape.props === next.shape.props &&
-		prev.shape.meta === next.shape.meta &&
-		prev.util === next.util
+		prev.shape.props === next.shape.props && prev.shape.meta === next.shape.meta && prev.util === next.util
 )
 
 export const InnerShapeBackground = memo(
@@ -200,15 +202,12 @@ export const InnerShapeBackground = memo(
 	}) {
 		return useStateTracking(
 			'InnerShape:' + shape.type,
-			() =>
-				// always fetch the latest shape from the store even if the props/meta have not changed, to avoid
-				// calling the render method with stale data.
-				util.backgroundComponent?.(util.editor.store.unsafeGetWithoutCapture(shape.id) as T),
+			() => util.backgroundComponent?.(util.editor.store.unsafeGetWithoutCapture(shape.id) as T),
 			[util, shape.id]
 		)
 	},
 	(prev, next) =>
-		prev.shape.props === next.shape.props &&
+		prev.shape.props === next.props.props &&
 		prev.shape.meta === next.shape.meta &&
 		prev.util === next.util
 )
\ No newline at end of file
