
index 2c7cd6150..1f9f3649f 100644
--- a/tldraw_packages_editor_src_lib_components_Shape.tsx_expectedoutput.txt (expected):tmp/tmpn75w52ji_expected.txt	
+++ b/tldraw_packages_editor_src_lib_components_Shape.tsx_extracted.txt (actual):tmp/tmpyaximr17_actual.txt	
@@ -6,6 +6,7 @@ import { ShapeUtil } from '../editor/shapes/ShapeUtil'
 import { useEditor } from '../hooks/useEditor'
 import { useEditorComponents } from '../hooks/useEditorComponents'
 import { Mat } from '../primitives/Mat'
+import { toDomPrecision } from '../primitives/utils'
 import { setStyleProperty } from '../utils/dom'
 import { OptionalErrorBoundary } from './ErrorBoundary'
 
@@ -13,7 +14,7 @@ import { OptionalErrorBoundary } from './ErrorBoundary'
 This component renders shapes on the canvas. There are two stages: positioning
 and styling the shape's container using CSS, and then rendering the shape's 
 JSX using its shape util's render method. Rendering the "inside" of a shape is
-more expensive than positioning it or changing its color, so we use memo
+more expensive than positioning it or changing its color, so we use React.memo
 to wrap the inner shape and only re-render it when the shape's props change. 
 
 The shape also receives props for its index and opacity. The index is used to
@@ -80,10 +81,15 @@ export const Shape = memo(function Shape({
 			const transform = Mat.toCssString(pageTransform)
 			const bounds = editor.getShapeGeometry(shape).bounds
 
-			// Update if the tranform has changed
+			// Update if the transform has changed
 			if (transform !== prev.transform) {
 				setStyleProperty(containerRef.current, 'transform', transform)
 				setStyleProperty(bgContainerRef.current, 'transform', transform)
+				setStyleProperty(
+					culledContainerRef.current,
+					'transform',
+					`${Mat.toCssString(pageTransform)} translate(${bounds.x}px, ${bounds.y}px)`
+				)
 				prev.transform = transform
 			}
 
@@ -133,6 +139,7 @@ export const Shape = memo(function Shape({
 		},
 		[editor]
 	)
+
 	const annotateError = useCallback(
 		(error: any) => editor.annotateError(error, { origin: 'shape', willCrashApp: false }),
 		[editor]
