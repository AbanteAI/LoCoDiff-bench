
index 9e0324e46..08d782c39 100644
--- a/ghostty_src_font_discovery.zig_expectedoutput.txt (expected):tmp/tmpp1u1va3t_expected.txt	
+++ b/ghostty_src_font_discovery.zig_extracted.txt (actual):tmp/tmpy7_6ox6r_actual.txt	
@@ -11,55 +11,25 @@ const Variation = @import("main.zig").face.Variation;
 
 const log = std.log.scoped(.discovery);
 
-/// Discover implementation for the compile options.
 pub const Discover = switch (options.backend) {
     .freetype => void, // no discovery
     .fontconfig_freetype => Fontconfig,
-    .web_canvas => void, // no discovery
     .coretext,
     .coretext_freetype,
     .coretext_harfbuzz,
     .coretext_noshape,
     => CoreText,
+    .web_canvas => void, // no discovery
 };
 
-/// Descriptor is used to search for fonts. The only required field
-/// is "family". The rest are ignored unless they're set to a non-zero
-/// value.
 pub const Descriptor = struct {
-    /// Font family to search for. This can be a fully qualified font
-    /// name such as "Fira Code", "monospace", "serif", etc. Memory is
-    /// owned by the caller and should be freed when this descriptor
-    /// is no longer in use. The discovery structs will never store the
-    /// descriptor.
-    ///
-    /// On systems that use fontconfig (Linux), this can be a full
-    /// fontconfig pattern, such as "Fira Code-14:bold".
     family: ?[:0]const u8 = null,
-
-    /// Specific font style to search for. This will filter the style
-    /// string the font advertises. The "bold/italic" booleans later in this
-    /// struct filter by the style trait the font has, not the string, so
-    /// these can be used in conjunction or not.
     style: ?[:0]const u8 = null,
-
-    /// A codepoint that this font must be able to render.
     codepoint: u32 = 0,
-
-    /// Font size in points that the font should support. For conversion
-    /// to pixels, we will use 72 DPI for Mac and 96 DPI for everything else.
-    /// (If pixel conversion is necessary, i.e. emoji fonts)
     size: f32 = 0,
-
-    /// True if we want to search specifically for a font that supports
-    /// specific styles.
     bold: bool = false,
     italic: bool = false,
     monospace: bool = false,
-
-    /// Variation axes to apply to the font. This also impacts searching
-    /// for fonts since fonts with the ability to set these variations
-    /// will be preferred, but not guaranteed.
     variations: []const Variation = &.{},
 
     /// Hash the descriptor with the given hasher.
@@ -76,9 +46,6 @@ pub const Descriptor = struct {
         autoHash(hasher, self.variations.len);
         for (self.variations) |variation| {
             autoHash(hasher, variation.id);
-
-            // This is not correct, but we don't currently depend on the
-            // hash value being different based on decimal values of variations.
             autoHash(hasher, @as(i64, @intFromFloat(variation.value)));
         }
     }
@@ -91,14 +58,7 @@ pub const Descriptor = struct {
         return hasher.final();
     }
 
-    /// Deep copy of the struct. The given allocator is expected to
-    /// be an arena allocator of some sort since the descriptor
-    /// itself doesn't support fine-grained deallocation of fields.
     pub fn clone(self: *const Descriptor, alloc: Allocator) !Descriptor {
-        // We can't do any errdefer cleanup in here. As documented we
-        // expect the allocator to be an arena so any errors should be
-        // cleaned up somewhere else.
-
         var copy = self.*;
         copy.family = if (self.family) |src| try alloc.dupeZ(u8, src) else null;
         copy.style = if (self.style) |src| try alloc.dupeZ(u8, src) else null;
@@ -106,9 +66,6 @@ pub const Descriptor = struct {
         return copy;
     }
 
-    /// Convert to Fontconfig pattern to use for lookup. The pattern does
-    /// not have defaults filled/substituted (Fontconfig thing) so callers
-    /// must still do this.
     pub fn toFcPattern(self: Descriptor) *fontconfig.Pattern {
         const pat = fontconfig.Pattern.create();
         if (self.family) |family| {
@@ -138,26 +95,19 @@ pub const Descriptor = struct {
             .{ .integer = @intFromEnum(fontconfig.Slant.italic) },
             false,
         ));
-
-        // For fontconfig, we always add monospace in the pattern. Since
-        // fontconfig sorts by closeness to the pattern, this doesn't fully
-        // exclude non-monospace but helps prefer it.
+        // For fontconfig, we always add monospace in the pattern.
         assert(pat.add(
             .spacing,
             .{ .integer = @intFromEnum(fontconfig.Spacing.mono) },
             false,
         ));
-
         return pat;
     }
 
-    /// Convert to Core Text font descriptor to use for lookup or
-    /// conversion to a specific font.
     pub fn toCoreTextDescriptor(self: Descriptor) !*macos.text.FontDescriptor {
         const attrs = try macos.foundation.MutableDictionary.create(0);
         defer attrs.release();
 
-        // Family
         if (self.family) |family_bytes| {
             const family = try macos.foundation.String.createWithBytes(family_bytes, .utf8, false);
             defer family.release();
@@ -177,19 +127,6 @@ pub const Descriptor = struct {
             );
         }
 
-        // Codepoint support
-        if (self.codepoint > 0) {
-            const cs = try macos.foundation.CharacterSet.createWithCharactersInRange(.{
-                .location = self.codepoint,
-                .length = 1,
-            });
-            defer cs.release();
-            attrs.setValue(
-                macos.text.FontAttribute.character_set.key(),
-                cs,
-            );
-        }
-
         // Set our size attribute if set
         if (self.size > 0) {
             const size32: i32 = @intFromFloat(@round(self.size));
@@ -204,9 +141,7 @@ pub const Descriptor = struct {
             );
         }
 
-        // Build our traits. If we set any, then we store it in the attributes
-        // otherwise we do nothing. We determine this by setting up the packed
-        // struct, converting to an int, and checking if it is non-zero.
+        // Set traits
         const traits: macos.text.FontSymbolicTraits = .{
             .bold = self.bold,
             .italic = self.italic,
@@ -214,8 +149,6 @@ pub const Descriptor = struct {
         };
         const traits_cval: u32 = @bitCast(traits);
         if (traits_cval > 0) {
-            // Setting traits is a pain. We have to create a nested dictionary
-            // of the symbolic traits value, and set that in our attributes.
             const traits_num = try macos.foundation.Number.create(
                 .sint32,
                 @as(*const i32, @ptrCast(&traits_cval)),
@@ -243,7 +176,6 @@ pub const Fontconfig = struct {
     fc_config: *fontconfig.Config,
 
     pub fn init() Fontconfig {
-        // safe to call multiple times and concurrently
         _ = fontconfig.init();
         return .{ .fc_config = fontconfig.initLoadConfigAndFonts() };
     }
@@ -252,15 +184,7 @@ pub const Fontconfig = struct {
         self.fc_config.destroy();
     }
 
-    /// Discover fonts from a descriptor. This returns an iterator that can
-    /// be used to build up the deferred fonts.
-    pub fn discover(
-        self: *const Fontconfig,
-        alloc: Allocator,
-        desc: Descriptor,
-    ) !DiscoverIterator {
-        _ = alloc;
-
+    pub fn discover(self: *const Fontconfig, alloc: Allocator, desc: Descriptor) !DiscoverIterator {
         // Build our pattern that we'll search for
         const pat = desc.toFcPattern();
         errdefer pat.destroy();
@@ -272,12 +196,11 @@ pub const Fontconfig = struct {
         if (res.result != .match) return error.FontConfigFailed;
         errdefer res.fs.destroy();
 
-        return .{
+        return DiscoverIterator{
             .config = self.fc_config,
             .pattern = pat,
             .set = res.fs,
             .fonts = res.fs.fonts(),
-            .variations = desc.variations,
             .i = 0,
         };
     }
@@ -297,7 +220,6 @@ pub const Fontconfig = struct {
         pattern: *fontconfig.Pattern,
         set: *fontconfig.FontSet,
         fonts: []*fontconfig.Pattern,
-        variations: []const Variation,
         i: usize,
 
         pub fn deinit(self: *DiscoverIterator) void {
@@ -309,15 +231,12 @@ pub const Fontconfig = struct {
         pub fn next(self: *DiscoverIterator) fontconfig.Error!?DeferredFace {
             if (self.i >= self.fonts.len) return null;
 
-            // Get the copied pattern from our fontset that has the
-            // attributes configured for rendering.
             const font_pattern = try self.config.fontRenderPrepare(
                 self.pattern,
                 self.fonts[self.i],
             );
             errdefer font_pattern.destroy();
 
-            // Increment after we return
             defer self.i += 1;
 
             return DeferredFace{
@@ -325,7 +244,6 @@ pub const Fontconfig = struct {
                     .pattern = font_pattern,
                     .charset = (try font_pattern.get(.charset, 0)).char_set,
                     .langset = (try font_pattern.get(.lang, 0)).lang_set,
-                    .variations = self.variations,
                 },
             };
         }
@@ -342,11 +260,7 @@ pub const CoreText = struct {
         _ = self;
     }
 
-    /// Discover fonts from a descriptor. This returns an iterator that can
-    /// be used to build up the deferred fonts.
     pub fn discover(self: *const CoreText, alloc: Allocator, desc: Descriptor) !DiscoverIterator {
-        _ = self;
-
         // Build our pattern that we'll search for
         const ct_desc = try desc.toCoreTextDescriptor();
         defer ct_desc.release();
@@ -362,7 +276,7 @@ pub const CoreText = struct {
         const list = set.createMatchingFontDescriptors();
         defer list.release();
 
-        // Sort our descriptors
+        // Bring the list of descriptors in to zig land
         const zig_list = try copyMatchingDescriptors(alloc, list);
         errdefer alloc.free(zig_list);
         sortMatchingDescriptors(&desc, zig_list);
@@ -375,59 +289,14 @@ pub const CoreText = struct {
         };
     }
 
-    pub fn discoverFallback(
-        self: *const CoreText,
-        alloc: Allocator,
-        collection: *Collection,
-        desc: Descriptor,
-    ) !DiscoverIterator {
+    pub fn discoverFallback(self: *const CoreText, alloc: Allocator, collection: *Collection, desc: Descriptor) !DiscoverIterator {
         // If we have a codepoint within the CJK unified ideographs block
-        // then we fallback to macOS to find a font that supports it because
-        // there isn't a better way manually with CoreText that I can find that
-        // properly takes into account system locale.
-        //
-        // References:
-        // - http://unicode.org/charts/PDF/U4E00.pdf
-        // - https://chromium.googlesource.com/chromium/src/+/main/third_party/blink/renderer/platform/fonts/LocaleInFonts.md#unified-han-ideographs
-        if (desc.codepoint >= 0x4E00 and
-            desc.codepoint <= 0x9FFF)
-        han: {
-            const han = try self.discoverCodepoint(
-                collection,
-                desc,
-            ) orelse break :han;
-
-            // This is silly but our discover iterator needs a slice so
-            // we allocate here. This isn't a performance bottleneck but
-            // this is something we can optimize very easily...
+        // then we fallback to CTFontCreateForString.
+        if (desc.codepoint >= 0x4E00 and desc.codepoint <= 0x9FFF) han: {
+            const han = try self.discoverCodepoint(collection, desc) orelse break :han;
             const list = try alloc.alloc(*macos.text.FontDescriptor, 1);
             errdefer alloc.free(list);
             list[0] = han;
-
-            return DiscoverIterator{
-                .alloc = alloc,
-                .list = list,
-                .variations = desc.variations,
-                .i = 0,
-            };
-        }
-
-        const it = try self.discover(alloc, desc);
-
-        // If our normal discovery doesn't find anything and we have a specific
-        // codepoint, then fallback to using CTFontCreateForString to find a
-        // matching font CoreText wants to use. See:
-        // https://github.com/ghostty-org/ghostty/issues/2499
-        if (it.list.len == 0 and desc.codepoint > 0) codepoint: {
-            const ct_desc = try self.discoverCodepoint(
-                collection,
-                desc,
-            ) orelse break :codepoint;
-
-            const list = try alloc.alloc(*macos.text.FontDescriptor, 1);
-            errdefer alloc.free(list);
-            list[0] = ct_desc;
-
             return DiscoverIterator{
                 .alloc = alloc,
                 .list = list,
@@ -436,25 +305,14 @@ pub const CoreText = struct {
             };
         }
 
-        return it;
+        return try self.discover(alloc, desc);
     }
 
     /// Discover a font for a specific codepoint using the CoreText
     /// CTFontCreateForString API.
-    fn discoverCodepoint(
-        self: *const CoreText,
-        collection: *Collection,
-        desc: Descriptor,
-    ) !?*macos.text.FontDescriptor {
+    fn discoverCodepoint(self: *const CoreText, collection: *Collection, desc: Descriptor) !?*macos.text.FontDescriptor {
         _ = self;
 
-        if (comptime options.backend.hasFreetype()) {
-            // If we have freetype, we can't use CoreText to find a font
-            // that supports a specific codepoint because we need to
-            // have a CoreText font to be able to do so.
-            return null;
-        }
-
         assert(desc.codepoint > 0);
 
         // Get our original font. This is dependent on the requested style
@@ -463,7 +321,6 @@ pub const CoreText = struct {
             // In all the styles below, we try to match it but if we don't
             // we always fall back to some other option. The order matters
             // here.
-
             if (desc.bold and desc.italic) {
                 const entries = collection.faces.get(.bold_italic);
                 if (entries.count() > 0) {
@@ -487,8 +344,9 @@ pub const CoreText = struct {
 
             break :original try collection.getFace(.{ .style = .regular });
         };
+        defer original.release();
 
-        // We need it in utf8 format
+        // We need a CFString
         var buf: [4]u8 = undefined;
         const len = try std.unicode.utf8Encode(
             @intCast(desc.codepoint),
@@ -504,7 +362,7 @@ pub const CoreText = struct {
         defer str.release();
 
         // Get our range length for CTFontCreateForString. It looks like
-        // the range uses UTF-16 codepoints and not UTF-32 codepoints.
+        // the range uses UTF-16 codepoints and not UTF-32.
         const range_len: usize = range_len: {
             var unichars: [2]u16 = undefined;
             const pair = macos.foundation.stringGetSurrogatePairForLongCharacter(
@@ -550,9 +408,6 @@ pub const CoreText = struct {
         errdefer alloc.free(result);
         for (0..result.len) |i| {
             result[i] = list.getValueAtIndex(macos.text.FontDescriptor, i);
-
-            // We need to retain because once the list is freed it will
-            // release all its members.
             result[i].retain();
         }
         return result;
@@ -564,79 +419,32 @@ pub const CoreText = struct {
     ) void {
         var desc_mut = desc.*;
         if (desc_mut.style == null) {
-            // If there is no explicit style set, we set a preferred
-            // based on the style bool attributes.
-            //
-            // TODO: doesn't handle i18n font names well, we should have
-            // another mechanism that uses the weight attribute if it exists.
-            // Wait for this to be a real problem.
             desc_mut.style = if (desc_mut.bold and desc_mut.italic)
                 "Bold Italic"
             else if (desc_mut.bold)
                 "Bold"
             else if (desc_mut.italic)
                 "Italic"
-            else
-                null;
+            else null;
         }
 
         std.mem.sortUnstable(*macos.text.FontDescriptor, list, &desc_mut, struct {
-            fn lessThan(
-                desc_inner: *const Descriptor,
-                lhs: *macos.text.FontDescriptor,
-                rhs: *macos.text.FontDescriptor,
-            ) bool {
+            fn lessThan(desc_inner: *const Descriptor, lhs: *macos.text.FontDescriptor, rhs: *macos.text.FontDescriptor) bool {
                 const lhs_score = score(desc_inner, lhs);
                 const rhs_score = score(desc_inner, rhs);
-                // Higher score is "less" (earlier)
                 return lhs_score.int() > rhs_score.int();
             }
         }.lessThan);
     }
 
-    /// We represent our sorting score as a packed struct so that we can
-    /// compare scores numerically but build scores symbolically.
-    const Score = packed struct {
-        const Backing = @typeInfo(@This()).@"struct".backing_integer.?;
-
-        glyph_count: u16 = 0, // clamped if > intmax
-        traits: Traits = .unmatched,
-        style: Style = .unmatched,
-        monospace: bool = false,
-        codepoint: bool = false,
-
-        const Traits = enum(u8) { unmatched = 0, _ };
-        const Style = enum(u8) { unmatched = 0, match = 0xFF, _ };
-
-        pub fn int(self: Score) Backing {
-            return @bitCast(self);
-        }
-    };
-
     fn score(desc: *const Descriptor, ct_desc: *const macos.text.FontDescriptor) Score {
         var score_acc: Score = .{};
 
-        // We always load the font if we can since some things can only be
-        // inspected on the font itself.
-        const font_: ?*macos.text.Font = macos.text.Font.createWithFontDescriptor(
-            ct_desc,
-            12,
-        ) catch null;
-        defer if (font_) |font| font.release();
-
-        // If we have a font, prefer the font with more glyphs.
-        if (font_) |font| {
-            const Type = @TypeOf(score_acc.glyph_count);
-            score_acc.glyph_count = std.math.cast(
-                Type,
-                font.getGlyphCount(),
-            ) orelse std.math.maxInt(Type);
-        }
-
-        // If we're searching for a codepoint, prioritize fonts that
-        // have that codepoint.
+        // If we're searching for a codepoint, prioritize fonts that have that codepoint.
         if (desc.codepoint > 0) codepoint: {
-            const font = font_ orelse break :codepoint;
+            const font = macos.text.Font.createWithFontDescriptor(ct_desc, 12) catch
+                break :codepoint;
+            defer font.release();
 
             // Turn UTF-32 into UTF-16 for CT API
             var unichars: [2]u16 = undefined;
@@ -663,7 +471,6 @@ pub const CoreText = struct {
 
             break :traits macos.text.FontSymbolicTraits.init(symbolic);
         };
-
         score_acc.monospace = symbolic_traits.monospace;
 
         score_acc.style = style: {
@@ -679,6 +486,10 @@ pub const CoreText = struct {
             if (desc.style) |desired_style| {
                 // Matching style string gets highest score
                 if (std.mem.eql(u8, desired_style, style_str)) break :style .match;
+
+                // Otherwise the score is based on the length of the style string.
+                // Shorter styles are scored higher.
+                break :style @enumFromInt(100 -| style_str.len);
             } else if (!desc.bold and !desc.italic) {
                 // If we do not, and we have no symbolic traits, then we try
                 // to find "regular" (or no style). If we have symbolic traits
@@ -706,6 +517,23 @@ pub const CoreText = struct {
         return score_acc;
     }
 
+    const Score = packed struct {
+        const Backing = @typeInfo(@This()).@"struct".backing_integer.?;
+
+        glyph_count: u16 = 0, // clamped if > intmax
+        traits: Traits = .unmatched,
+        style: Style = .unmatched,
+        monospace: bool = false,
+        codepoint: bool = false,
+
+        const Traits = enum(u8) { unmatched = 0, _ };
+        const Style = enum(u8) { unmatched = 0, match = 0xFF, _ };
+
+        pub fn int(self: Score) Backing {
+            return @bitCast(self);
+        }
+    };
+
     pub const DiscoverIterator = struct {
         alloc: Allocator,
         list: []const *macos.text.FontDescriptor,
@@ -719,31 +547,17 @@ pub const CoreText = struct {
 
         pub fn next(self: *DiscoverIterator) !?DeferredFace {
             if (self.i >= self.list.len) return null;
-
-            // Get our descriptor. We need to remove the character set
-            // limitation because we may have used that to filter but we
-            // don't want it anymore because it'll restrict the characters
-            // available.
-            //const desc = self.list.getValueAtIndex(macos.text.FontDescriptor, self.i);
             const desc = desc: {
                 const original = self.list[self.i];
-
-                // For some reason simply copying the attributes and recreating
-                // the descriptor removes the charset restriction. This is tested.
                 const attrs = original.copyAttributes();
                 defer attrs.release();
                 break :desc try macos.text.FontDescriptor.createWithAttributes(@ptrCast(attrs));
             };
-            defer desc.release();
-
-            // Create our font. We need a size to initialize it so we use size
-            // 12 but we will alter the size later.
-            const font = try macos.text.Font.createWithFontDescriptor(desc, 12);
-            errdefer font.release();
-
-            // Increment after we return
             defer self.i += 1;
 
+            const font = try macos.text.Font.createWithFontDescriptor(desc, 12) catch return null;
+            defer font.release();
+
             return DeferredFace{
                 .ct = .{
                     .font = font,
@@ -754,21 +568,6 @@ pub const CoreText = struct {
     };
 };
 
-test "descriptor hash" {
-    const testing = std.testing;
-
-    var d: Descriptor = .{};
-    try testing.expect(d.hashcode() != 0);
-}
-
-test "descriptor hash family names" {
-    const testing = std.testing;
-
-    var d1: Descriptor = .{ .family = "A" };
-    var d2: Descriptor = .{ .family = "B" };
-    try testing.expect(d1.hashcode() != d2.hashcode());
-}
-
 test "fontconfig" {
     if (options.backend != .fontconfig_freetype) return error.SkipZigTest;
 
@@ -778,6 +577,9 @@ test "fontconfig" {
     var fc = Fontconfig.init();
     var it = try fc.discover(alloc, .{ .family = "monospace", .size = 12 });
     defer it.deinit();
+    while (try it.next()) |face| {
+        try testing.expect(!face.loaded());
+    }
 }
 
 test "fontconfig codepoint" {
@@ -793,6 +595,7 @@ test "fontconfig codepoint" {
     // The first result should have the codepoint. Later ones may not
     // because fontconfig returns all fonts sorted.
     const face = (try it.next()).?;
+    try testing.expect(!face.loaded());
     try testing.expect(face.hasCodepoint('A', null));
 
     // Should have other codepoints too
@@ -800,8 +603,7 @@ test "fontconfig codepoint" {
 }
 
 test "coretext" {
-    if (options.backend != .coretext and options.backend != .coretext_freetype)
-        return error.SkipZigTest;
+    if (options.backend != .coretext and options.backend != .coretext_freetype) return error.SkipZigTest;
 
     const testing = std.testing;
     const alloc = testing.allocator;
@@ -818,8 +620,7 @@ test "coretext" {
 }
 
 test "coretext codepoint" {
-    if (options.backend != .coretext and options.backend != .coretext_freetype)
-        return error.SkipZigTest;
+    if (options.backend != .coretext and options.backend != .coretext_freetype) return error.SkipZigTest;
 
     const testing = std.testing;
     const alloc = testing.allocator;
@@ -832,6 +633,7 @@ test "coretext codepoint" {
     // The first result should have the codepoint. Later ones may not
     // because fontconfig returns all fonts sorted.
     const face = (try it.next()).?;
+    try testing.expect(!face.loaded());
     try testing.expect(face.hasCodepoint('A', null));
 
     // Should have other codepoints too
