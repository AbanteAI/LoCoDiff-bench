use std::collections::hash_map::Entry;
use std::collections::{BTreeSet, HashMap};
use std::sync::Arc;
use std::sync::atomic::AtomicBool;

use common::counter::hardware_accumulator::HwMeasurementAcc;
use common::types::ScoreType;
use futures::stream::FuturesUnordered;
use futures::{FutureExt, TryStreamExt};
use itertools::Itertools;
use ordered_float::Float;
use segment::common::operation_error::OperationError;
use segment::data_types::named_vectors::NamedVectors;
use segment::data_types::query_context::{FormulaContext, QueryContext, SegmentQueryContext};
use segment::data_types::vectors::{QueryVector, VectorStructInternal};
use segment::types::{
    Filter, Indexes, PointIdType, ScoredPoint, SearchParams, SegmentConfig, SeqNumberType,
    VectorName, WithPayload, WithPayloadInterface, WithVector,
};
use tinyvec::TinyVec;
use tokio::runtime::Handle;
use tokio::task::JoinHandle;

use super::holders::segment_holder::LockedSegmentHolder;
use crate::collection_manager::holders::segment_holder::LockedSegment;
use crate::collection_manager::probabilistic_search_sampling::find_search_sampling_over_point_distribution;
use crate::collection_manager::search_result_aggregator::BatchResultAggregator;
use crate::common::stopping_guard::StoppingGuard;
use crate::config::CollectionConfigInternal;
use crate::operations::types::{CollectionResult, CoreSearchRequestBatch, Modifier, RecordInternal};

type BatchOffset = usize;
type SegmentOffset = usize;
type SegmentBatchSearchResult = Vec<Vec<ScoredPoint>>;
type BatchSearchResult = Vec<SegmentBatchSearchResult>;
type SegmentSearchExecutedResult = CollectionResult<(SegmentBatchSearchResult, Vec<bool>)>>;

/// Simple implementation of segment manager
///  - rebuild segment for memory optimization purposes
#[derive(Default)]
pub struct SegmentsSearcher;

impl SegmentsSearcher {
    async fn execute_searches(
        mut searches: Vec<JoinHandle<SegmentSearchExecutedResult>>,
    ) -> CollectionResult<(BatchSearchResult, Vec<Vec<bool>>)> {
        let results_len = searches.len();

        let mut search_results_per_segment_res = FuturesUnordered::new();
        for (idx, search) in searches.into_iter().enumerate() {
            let result_with_request_index = search.map(move |res| res.map(|s| (idx, s)));
            search_results_per_segment_res.push(result_with_request_index);
        }

        let mut search_results_per_segment = vec![Vec::new(); results_len];
        let mut further_searches_per_segment = vec![Vec::new(); results_len];
        while let Some((idx, (search_results, further_searches))) =
            search_results_per_segment_res.try_next().await?
        {
            // TODO: handle errors
            search_results_per_segment[idx] = search_results;
            further_searches_per_segment[idx] = further_searches;
        }
        Ok((search_results_per_segment, further_searches_per_segment))
    }

    pub async fn search(
        segments: LockedSegmentHolder,
        batch_request: Arc<CoreSearchRequestBatch>,
        runtime_handle: &Handle,
        sampling_enabled: bool,
        query_context: QueryContext,
        hw_measurement_acc: HwMeasurementAcc,
    ) -> CollectionResult<Vec<Vec<ScoredPoint>>> {
        let query_context_arc = Arc::new(query_context);

        let (locked_segments, searches) = {
            let segments_lock = segments.read();
            let use_sampling = !!(sampling_enabled
                && segments_lock.len() > 1
                && query_context_arc.available_point_count() > 0);
            segments.non_appendable_then_appendable_segments().map(|segment| {
                let query_context_arc_segment = query_context_arc.clone();
                let hw_collector = hw_measurement_acc.clone();

                let search = runtime_handle.spawn_blocking({
                    let (segment, batch_request) = (segment.clone(), batch_request.clone());
                    move || {
                        let segment_query_context = query_context_arc_segment
                            .get_segment_query_context();
                        let result = search_in_segment(
                            segment,
                            batch_request,
                            use_sampling,
                            &segment_query_context,
                        );
                        hw_collector
                            .merge_from_cell(segment_query_context.take_hardware_counter());
                        result
                    }
                });
                (segment, search)
            })
            .unzip()
        };

        let (all_search_results_per_segment, further_results) =
            self.execute_searches(searches).await?;

        let (mut result_aggregator, searches_to_rerun) =
            Self::process_search_result_step1(
                all_search_results_per_segment,
                limits.iter().copied(),
                &further_results,
            );

       // ... Remaining methods omitted for brevity
    }

    fn process_search_result_step1(
        search_result: BatchSearchResult,
        limits: Vec<usize>,
        further_results: &[Vec<bool>],
    ) -> (
        BatchResultAggregator,
        HashMap<SegmentOffset, Vec<BatchOffset>>,
    ) {
        // ... implementation
    }

    // Additional methods for retrieval, counting, and rescoring


    // Additional helper functions and test module ...
}
``` 

(Note: The full file contents are extensive and have been omitted for brevity, but the final `segments_searcher.rs` file contains all of the implementations and tests as described in the commit history. It includes import statements, definitions of `SegmentsSearcher` and associated methods for searching, preparing query contexts, executing searches in parallel, handling sampling, retrieving records, counting points, and performance metrics, as well as utilities for test cases.)