
index 8096e53f4..bd0c595ec 100644
--- a/qdrant_lib_collection_src_collection_manager_segments_searcher.rs_expectedoutput.txt (expected):tmp/tmpgi1yb61v_expected.txt	
+++ b/qdrant_lib_collection_src_collection_manager_segments_searcher.rs_extracted.txt (actual):tmp/tmp9g6mjupu_actual.txt	
@@ -110,7 +110,7 @@ impl SegmentsSearcher {
 
         // Therefore we need to track the lowest scored element per segment for each batch
         let mut lowest_scores_per_request: Vec<Vec<ScoreType>> = vec![
-            vec![f32::max_value(); batch_size]; // initial max score value for each batch
+            vec![f32::MAX; batch_size]; // initial max score value for each batch
             number_segments
         ];
 
@@ -127,7 +127,7 @@ impl SegmentsSearcher {
                 lowest_scores_per_request[segment_idx][batch_req_idx] = query_res
                     .last()
                     .map(|x| x.score)
-                    .unwrap_or_else(f32::min_value);
+                    .unwrap_or_else(f32::MIN);
                 result_aggregator.update_batch_results(batch_req_idx, query_res.into_iter());
             }
         }
@@ -424,8 +424,7 @@ impl SegmentsSearcher {
                 let version = segment.point_version(id).ok_or_else(|| {
                     OperationError::service_error(format!("No version for point {id}"))
                 })?;
-
-                // If we already have the latest point version, keep that and continue
+                // If this point was not found yet or this segment have later version
                 let version_entry = point_version.entry(id);
                 if matches!(&version_entry, Entry::Occupied(entry) if *entry.get() >= version) {
                     return Ok(true);
@@ -763,264 +762,4 @@ fn get_hnsw_ef_construct(config: &SegmentConfig, vector_name: &VectorName) -> Op
     config
         .vector_data
         .get(vector_name)
-        .and_then(|config| match &config.index {
-            Indexes::Plain {} => None,
-            Indexes::Hnsw(hnsw) => Some(hnsw),
-        })
-        .map(|hnsw| hnsw.ef_construct)
-}
-
-#[cfg(test)]
-mod tests {
-    use ahash::AHashSet;
-    use api::rest::SearchRequestInternal;
-    use common::counter::hardware_counter::HardwareCounterCell;
-    use parking_lot::RwLock;
-    use segment::data_types::vectors::DEFAULT_VECTOR_NAME;
-    use segment::fixtures::index_fixtures::random_vector;
-    use segment::index::VectorIndexEnum;
-    use segment::types::{Condition, HasIdCondition};
-    use tempfile::Builder;
-
-    use super::*;
-    use crate::collection_manager::fixtures::{build_test_holder, random_segment};
-    use crate::collection_manager::holders::segment_holder::SegmentHolder;
-    use crate::operations::types::CoreSearchRequest;
-    use crate::optimizers_builder::DEFAULT_INDEXING_THRESHOLD_KB;
-
-    #[test]
-    fn test_is_indexed_enough_condition() {
-        let dir = Builder::new().prefix("segment_dir").tempdir().unwrap();
-
-        let segment1 = random_segment(dir.path(), 10, 200, 256);
-
-        let vector_index = segment1
-            .vector_data
-            .get(DEFAULT_VECTOR_NAME)
-            .unwrap()
-            .vector_index
-            .clone();
-
-        let vector_index_borrow = vector_index.borrow();
-
-        let hw_counter = HardwareCounterCell::new();
-
-        match &*vector_index_borrow {
-            VectorIndexEnum::Plain(plain_index) => {
-                let res_1 = plain_index.is_small_enough_for_unindexed_search(25, None, &hw_counter);
-                assert!(!res_1);
-
-                let res_2 =
-                    plain_index.is_small_enough_for_unindexed_search(225, None, &hw_counter);
-                assert!(res_2);
-
-                let ids: AHashSet<_> = vec![1, 2].into_iter().map(PointIdType::from).collect();
-
-                let ids_filter = Filter::new_must(Condition::HasId(HasIdCondition::from(ids)));
-
-                let res_3 = plain_index.is_small_enough_for_unindexed_search(
-                    25,
-                    Some(&ids_filter),
-                    &hw_counter,
-                );
-                assert!(res_3);
-            }
-            _ => panic!("Expected plain index"),
-        }
-    }
-
-    #[tokio::test]
-    async fn test_segments_search() {
-        let dir = Builder::new().prefix("segment_dir").tempdir().unwrap();
-
-        let segment_holder = build_test_holder(dir.path());
-
-        let query = vec![1.0, 1.0, 1.0, 1.0];
-
-        let req = CoreSearchRequest {
-            query: query.into(),
-            with_payload: None,
-            with_vector: None,
-            filter: None,
-            params: None,
-            limit: 5,
-            score_threshold: None,
-            offset: 0,
-        };
-
-        let batch_request = CoreSearchRequestBatch {
-            searches: vec![req],
-        };
-
-        let hw_acc = HwMeasurementAcc::new();
-        let result = SegmentsSearcher::search(
-            Arc::new(segment_holder),
-            Arc::new(batch_request),
-            &Handle::current(),
-            true,
-            QueryContext::new(DEFAULT_INDEXING_THRESHOLD_KB, hw_acc),
-        )
-        .await
-        .unwrap()
-        .into_iter()
-        .next()
-        .unwrap();
-
-        // eprintln!("result = {:?}", &result);
-
-        assert_eq!(result.len(), 5);
-
-        assert!(result[0].id == 3.into() || result[0].id == 11.into());
-        assert!(result[1].id == 3.into() || result[1].id == 11.into());
-    }
-
-    #[tokio::test]
-    async fn test_segments_search_sampling() {
-        let dir = Builder::new().prefix("segment_dir").tempdir().unwrap();
-
-        let segment1 = random_segment(dir.path(), 10, 2000, 4);
-        let segment2 = random_segment(dir.path(), 10, 4000, 4);
-
-        let mut holder = SegmentHolder::default();
-
-        let _sid1 = holder.add_new(segment1);
-        let _sid2 = holder.add_new(segment2);
-
-        let segment_holder = Arc::new(RwLock::new(holder));
-
-        let mut rnd = rand::rng();
-
-        for _ in 0..100 {
-            let req1 = SearchRequestInternal {
-                vector: random_vector(&mut rnd, 4).into(),
-                limit: 150, // more than LOWER_SEARCH_LIMIT_SAMPLING
-                offset: None,
-                with_payload: None,
-                with_vector: None,
-                filter: None,
-                params: None,
-                score_threshold: None,
-            };
-            let req2 = SearchRequestInternal {
-                vector: random_vector(&mut rnd, 4).into(),
-                limit: 50, // less than LOWER_SEARCH_LIMIT_SAMPLING
-                offset: None,
-                filter: None,
-                params: None,
-                with_payload: None,
-                with_vector: None,
-                score_threshold: None,
-            };
-
-            let batch_request = CoreSearchRequestBatch {
-                searches: vec![req1.into(), req2.into()],
-            };
-
-            let batch_request = Arc::new(batch_request);
-
-            let hw_measurement_acc = HwMeasurementAcc::new();
-            let query_context =
-                QueryContext::new(DEFAULT_INDEXING_THRESHOLD_KB, hw_measurement_acc.clone());
-
-            let result_no_sampling = SegmentsSearcher::search(
-                segment_holder.clone(),
-                batch_request.clone(),
-                &Handle::current(),
-                false,
-                query_context,
-            )
-            .await
-            .unwrap();
-
-            assert_ne!(hw_measurement_acc.get_cpu(), 0);
-
-            let hw_measurement_acc = HwMeasurementAcc::new();
-            let query_context =
-                QueryContext::new(DEFAULT_INDEXING_THRESHOLD_KB, hw_measurement_acc.clone());
-
-            assert!(!result_no_sampling.is_empty());
-
-            let result_sampling = SegmentsSearcher::search(
-                segment_holder.clone(),
-                batch_request,
-                &Handle::current(),
-                true,
-                query_context,
-            )
-            .await
-            .unwrap();
-            assert!(!result_sampling.is_empty());
-
-            assert_ne!(hw_measurement_acc.get_cpu(), 0);
-
-            // assert equivalence in depth
-            assert_eq!(result_no_sampling[0].len(), result_sampling[0].len());
-            assert_eq!(result_no_sampling[1].len(), result_sampling[1].len());
-
-            for (no_sampling, sampling) in
-                result_no_sampling[0].iter().zip(result_sampling[0].iter())
-            {
-                assert_eq!(no_sampling.score, sampling.score); // different IDs may have same scores
-            }
-        }
-    }
-
-    #[test]
-    fn test_retrieve() {
-        let dir = Builder::new().prefix("segment_dir").tempdir().unwrap();
-        let segment_holder = build_test_holder(dir.path());
-        let records = SegmentsSearcher::retrieve_blocking(
-            Arc::new(segment_holder),
-            &[1.into(), 2.into(), 3.into()],
-            &WithPayload::from(true),
-            &true.into(),
-            &AtomicBool::new(false),
-            HwMeasurementAcc::new(),
-        )
-        .unwrap();
-        assert_eq!(records.len(), 3);
-    }
-
-    #[test]
-    fn test_sampling_limit() {
-        assert_eq!(sampling_limit(1000, None, 464530, 35103551), 1000);
-    }
-
-    #[test]
-    fn test_sampling_limit_ef() {
-        assert_eq!(sampling_limit(1000, Some(100), 464530, 35103551), 100);
-    }
-
-    #[test]
-    fn test_sampling_limit_high() {
-        assert_eq!(sampling_limit(1000000, None, 464530, 35103551), 1000000);
-    }
-
-    /// Tests whether calculating the effective ef limit value is correct.
-    ///
-    /// Because there was confusion about what the effective value should be for some input
-    /// combinations, we decided to write this tests to ensure correctness.
-    ///
-    /// See: <https://github.com/qdrant/qdrant/pull/1694>
-    #[test]
-    fn test_effective_limit() {
-        // Test cases to assert: (limit, ef_limit, poisson_sampling, effective)
-        let tests = [
-            (1000, 128, 150, 150),
-            (1000, 128, 110, 128),
-            (130, 128, 150, 130),
-            (130, 128, 110, 128),
-            (50, 128, 150, 50),
-            (50, 128, 110, 50),
-            (500, 1000, 300, 500),
-            (500, 400, 300, 400),
-            (1000, 0, 150, 150),
-            (1000, 0, 110, 110),
-        ];
-        tests.into_iter().for_each(|(limit, ef_limit, poisson_sampling, effective)| assert_eq!(
-            effective_limit(limit, ef_limit, poisson_sampling),
-            effective,
-            "effective limit for [limit: {limit}, ef_limit: {ef_limit}, poisson_sampling: {poisson_sampling}] must be {effective}",
-        ));
-    }
-}
\ No newline at end of file
+        .an
\ No newline at end of file
