
index 8096e53f4..d492d1c2c 100644
--- a/qdrant_lib_collection_src_collection_manager_segments_searcher.rs_expectedoutput.txt (expected):tmp/tmpicj4kcau_expected.txt	
+++ b/qdrant_lib_collection_src_collection_manager_segments_searcher.rs_extracted.txt (actual):tmp/tmplg1hyhvs_actual.txt	
@@ -289,12 +289,10 @@ impl SegmentsSearcher {
                 })
                 .unzip()
         };
-
         // perform search on all segments concurrently
         // the resulting Vec is in the same order as the segment searches were provided.
         let (all_search_results_per_segment, further_results) =
             Self::execute_searches(searches).await?;
-        debug_assert!(all_search_results_per_segment.len() == locked_segments.len());
 
         let (mut result_aggregator, searches_to_rerun) = Self::process_search_result_step1(
             all_search_results_per_segment,
@@ -328,7 +326,6 @@ impl SegmentsSearcher {
                     res.push(runtime_handle.spawn_blocking(move || {
                         let segment_query_context =
                             query_context_arc_segment.get_segment_query_context();
-
                         search_in_segment(
                             segment,
                             partial_batch_request,
@@ -390,7 +387,6 @@ impl SegmentsSearcher {
                 let with_payload = with_payload.clone();
                 let with_vector = with_vector.clone();
                 let is_stopped = stopping_guard.get_is_stopped();
-                // TODO create one Task per segment level retrieve
                 move || {
                     Self::retrieve_blocking(
                         segments,
@@ -592,31 +588,6 @@ struct BatchSearchParams<'a> {
     pub params: Option<&'a SearchParams>,
 }
 
-/// Returns suggested search sampling size for a given number of points and required limit.
-fn sampling_limit(
-    limit: usize,
-    ef_limit: Option<usize>,
-    segment_points: usize,
-    total_points: usize,
-) -> usize {
-    // shortcut empty segment
-    if segment_points == 0 {
-        return 0;
-    }
-    let segment_probability = segment_points as f64 / total_points as f64;
-    let poisson_sampling =
-        find_search_sampling_over_point_distribution(limit as f64, segment_probability);
-
-    // if no ef_limit was found, it is a plain index => sampling optimization is not needed.
-    let effective = ef_limit.map_or(limit, |ef_limit| {
-        effective_limit(limit, ef_limit, poisson_sampling)
-    });
-    log::trace!(
-        "sampling: {effective}, poisson: {poisson_sampling} segment_probability: {segment_probability}, segment_points: {segment_points}, total_points: {total_points}",
-    );
-    effective
-}
-
 /// Determines the effective ef limit value for the given parameters.
 fn effective_limit(limit: usize, ef_limit: usize, poisson_sampling: usize) -> usize {
     // Prefer the highest of poisson_sampling/ef_limit, but never be higher than limit
@@ -756,6 +727,30 @@ fn execute_batch_search(
     Ok((res, further_results))
 }
 
+fn sampling_limit(
+    limit: usize,
+    ef_limit: Option<usize>,
+    segment_points: usize,
+    total_points: usize,
+) -> usize {
+    // shortcut empty segment
+    if segment_points == 0 {
+        return 0;
+    }
+    let segment_probability = segment_points as f64 / total_points as f64;
+    let poisson_sampling =
+        find_search_sampling_over_point_distribution(limit as f64, segment_probability);
+
+    // if no ef_limit was found, it is a plain index => sampling optimization is not needed.
+    let effective = ef_limit.map_or(limit, |ef_limit| {
+        effective_limit(limit, ef_limit, poisson_sampling)
+    });
+    log::trace!(
+        "sampling: {effective}, poisson: {poisson_sampling} segment_probability: {segment_probability}, segment_points: {segment_points}, total_points: {total_points}",
+    );
+    effective
+}
+
 /// Find the HNSW ef_construct for a named vector
 ///
 /// If the given named vector has no HNSW index, `None` is returned.
