use std::borrow::Cow;
use std::fs::{create_dir_all, File, OpenOptions};
use std::io::{self, Write};
use std::mem::MaybeUninit;
use std::ops::Range;
use std::path::{Path, PathBuf};
use std::sync::atomic::AtomicBool;

use bitvec::prelude::BitSlice;
use common::counter::hardware_counter::HardwareCounterCell;
use common::types::PointOffsetType;
use memory::fadvise::clear_disk_cache;
use memory::mmap_ops;

use crate::common::operation_error::{check_process_stopped, OperationError, OperationResult};
use crate::common::Flusher;
use crate::data_types::named_vectors::CowVector;
use crate::data_types::primitive::PrimitiveVectorElement;
use crate::data_types::vectors::{VectorElementType, VectorRef};
use crate::types::{Distance, VectorStorageDatatype};
use crate::vector_storage::common::get_async_scorer;
use crate::vector_storage::dense::mmap_dense_vectors::MmapDenseVectors;
use crate::vector_storage::{DenseVectorStorage, VectorStorage, VectorStorageEnum};

const VECTORS_PATH: &str = "matrix.dat";
const DELETED_PATH: &str = "deleted.dat";

/// Stores all dense vectors in mem-mapped file
///
/// It is not possible to insert new vectors into mem-mapped storage,
/// but possible to mark some vectors as removed
///
/// Mem-mapped storage can only be constructed from another storage
#[derive(Debug)]
pub struct MemmapDenseVectorStorage<T: PrimitiveVectorElement> {
    vectors_path: PathBuf,
    deleted_path: PathBuf,
    mmap_store: Option<MmapDenseVectors<T>>,
    distance: Distance,
}

pub fn open_memmap_vector_storage(
    path: &Path,
    dim: usize,
    distance: Distance,
) -> OperationResult<VectorStorageEnum> {
    open_memmap_vector_storage_with_async_io_impl::<VectorElementType>(path, dim, distance, get_async_scorer())
        .map(VectorStorageEnum::DenseMemmap)
}

pub fn open_memmap_vector_storage_byte(
    path: &Path,
    dim: usize,
    distance: Distance,
) -> OperationResult<VectorStorageEnum> {
    open_memmap_vector_storage_with_async_io_impl::<VectorElementType>(path, dim, distance, get_async_scorer())
        .map(VectorStorageEnum::DenseMemmapByte)
}

pub fn open_memmap_vector_storage_half(
    path: &Path,
    dim: usize,
    distance: Distance,
) -> OperationResult<VectorStorageEnum> {
    open_memmap_vector_storage_with_async_io_impl::<VectorElementType>(path, dim, distance, get_async_scorer())
        .map(VectorStorageEnum::DenseMemmapHalf)
}

pub fn open_memmap_vector_storage_with_async_io(
    path: &Path,
    dim: usize,
    distance: Distance,
    with_async_io: bool,
) -> OperationResult<VectorStorageEnum> {
    open_memmap_vector_storage_with_async_io_impl::<VectorElementType>(path, dim, distance, with_async_io)
        .map(VectorStorageEnum::DenseMemmap)
}

fn open_memmap_vector_storage_with_async_io_impl<T: PrimitiveVectorElement>(
    path: &Path,
    dim: usize,
    distance: Distance,
    with_async_io: bool,
) -> OperationResult<Box<MemmapDenseVectorStorage<T>>> {
    create_dir_all(path)?;

    let vectors_path = path.join(VECTORS_PATH);
    let deleted_path = path.join(DELETED_PATH);
    let mmap_store = MmapDenseVectors::open(&vectors_path, &deleted_path, dim, with_async_io)?;

    Ok(Box::new(MemmapDenseVectorStorage {
        vectors_path,
        deleted_path,
        mmap_store: Some(mmap_store)),
        distance,
        },
    )
}

impl<T: PrimitiveVectorElement> MemmapDenseVectorStorage<T> {
    pub fn prefault_mmap_pages(&self) -> Option<mmap_ops::PrefaultMmapPages> {
        Some(
            self.mmap_store
                .as_ref()?
                .prefault_mmap_pages(&self.vectors_path),
        )
    }

    pub fn get_mmap_vectors(&self) -> &MmapDenseVectors<T> {
        self.mmap_store.as_ref().expect("Mmap store not initialized")
    }

    pub fn has_async_reader(&self) -> bool {
        self.mmap_store
            .as_ref()
            .map(|x| x.has_async_reader())
            .unwrap_or(false)
    }

    /// Populate all pages in the mmap.
    /// Blocks until all pages are populated.
    pub fn populate(&self) -> OperationResult<()> {
        if let Some(mmap_store) = &self.mmap_store {
            mmap_store.populate()?;
        }
        Ok(())
    }

    /// Drop disk cache.
    pub fn clear_cache(&self) -> OperationResult<()> {
        clear_disk_cache(&self.vectors_path)?;
        clear_disk_cache(&self.deleted_path)?;
        Ok(())
    }
}

impl<T: PrimitiveVectorElement> DenseVectorStorage<T> for MemmapDenseVectorStorage<T> {
    fn vector_dim(&self) -> usize {
        self.mmap_store.as_ref().unwrap().dim
    }

    fn get_dense(&self, key: PointOffsetType) -> &[T] {
        self.mmap_store
            .as_ref()
            .unwrap()
            .get_vector_opt(key)
            .unwrap_or_else(|| panic!("vector not found: {key}"))
    }

    fn get_dense_batch<'a>(
        &'a self,
        keys: &[PointOffsetType],
        vectors: &'a mut [MaybeUninit<&'a [T]>],
    ) -> &'a [&'a [T]] {
        let mmap_store = self.mmap_store.as_ref().unwrap();
        mmap_store.get_vectors(keys, vectors)
    }
}

impl<T: PrimitiveVectorElement> VectorStorage for MemmapDenseVectorStorage<T> {
    fn vector_dim(&self) -> usize {
        self.mmap_store.as_ref().unwrap().dim
    }

    fn distance(&self) -> Distance {
        self.distance
    }

    fn datatype(&self) -> VectorStorageDatatype {
        T::datatype()
    }

    fn is_on_disk(&self) -> bool {
        true
    }

    fn total_vector_count(&self) -> usize {
        self.mmap_store.as_ref().unwrap().num_vectors
    }

    fn get_vector(&self, key: PointOffsetType) -> CowVector {
        self.get_vector_opt(key).expect("vector not found")
    }

    fn get_vector_opt(&self, key: PointOffsetType) -> Option<CowVector> {
        self.mmap_store
            .as_ref()
            .unwrap()
            .get_vector_opt(key)
            .map(|v| T::slice_to_float_cow(v.into()).into())
    }

    fn insert_vector(
        &mut self,
        _key: PointOffsetType,
        _vector: VectorRef,
        _hw_counter: &HardwareCounterCell,
    ) -> OperationResult<()> {
        panic!("Can't directly update vector in mmap storage")
    }

    fn update_from<'a>(
        &mut self,
        other_vectors: &'a mut impl Iterator<Item = (CowVector<'a>, bool)>,
        stopped: &AtomicBool,
    ) -> OperationResult<Range<PointOffsetType>> {
        let dim = self.vector_dim();
        let start_index = self.mmap_store.as_ref().unwrap().num_vectors as PointOffsetType;
        let mut end_index = start_index;

        // Extend vectors file, write other vectors into it
        let mut vectors_file = open_append(&self.vectors_path)?;
        let mut deleted_ids = vec![];
        for (offset, (other_vector, other_deleted)) in other_vectors.enumerate() {
            check_process_stopped(stopped)?;
            let vector = T::slice_from_float_cow(Cow::try_from(other_vector)?);
            let raw_bytes = mmap_ops::transmute_to_u8_slice(vector.as_ref());
            vectors_file.write_all(raw_bytes)?;
            end_index += 1;

            if other_deleted {
                deleted_ids.push(start_index + offset as PointOffsetType);
            }
        }
        vectors_file.sync_all()?;
        drop(vectors_file);

        // Load store with updated files
        self.mmap_store = Some(MmapDenseVectors::open(
            &self.vectors_path,
            &self.deleted_path,
            dim,
            self.mmap_store.as_ref().map(|x| x.has_async_reader()).unwrap_or(false),
        )?);

        // Mark deletions in the updated store
        let store = self.mmap_store.as_mut().expect("Mmap store must be set");
        for id in deleted_ids {
            check_process_stopped(stopped)?;
            store.delete(id);
        }

        Ok(start_index..end_index)
    }

    fn flusher(&self) -> Flusher {
        if let Some(mmap_store) = &self.mmap_store {
            let mmap_flusher = mmap_store.flusher();
            Box::new(move || mmap_flusher().map_err(OperationError::from))
        } else {
            Box::new(|| Ok(()))
        }
    }

    fn files(&self) -> Vec<PathBuf> {
        vec![self.vectors_path.clone(), self.deleted_path.clone()]
    }

    fn delete_vector(&mut self, key: PointOffsetType) -> OperationResult<bool> {
        Ok(self
            .mmap_store
            .as_mut()
            .expect("Mmap store not initialized")
            .delete(key))
    }

    fn is_deleted_vector(&self, key: PointOffsetType) -> bool {
        self.mmap_store
            .as_ref()
            .expect("Mmap store not initialized")
            .is_deleted_vector(key)
    }

    fn deleted_vector_count(&self) -> usize {
        self.mmap_store.as_ref().unwrap().deleted_count
    }

    fn deleted_vector_bitslice(&self) -> &BitSlice {
        self.mmap_store
            .as_ref()
            .unwrap()
            .deleted_vector_bitslice()
    }
}

/// Open a file shortly for appending
fn open_append<P: AsRef<Path>>(path: P) -> io::Result<File> {
    OpenOptions::new().append(true).open(path)
}

#[cfg(test)]
mod tests {
    use std::sync::Arc;
    use std::sync::atomic::AtomicBool;
    use atomic_refcell::AtomicRefCell;
    use common::counter::hardware_counter::HardwareCounterCell;
    use common::types::ScoredPointOffset;
    use memory::mmap_ops::transmute_to_u8_slice;
    use tempfile::Builder;

    use super::*;
    use crate::common::rocksdb_wrapper::{DB_VECTOR_CF, open_db};
    use crate::data_types::vectors::{DenseVector, QueryVector};
    use crate::fixtures::payload_context_fixture::FixtureIdTracker;
    use crate::id_tracker::id_tracker_base::IdTracker;
    use crate::types::{PointIdType, QuantizationConfig, ScalarQuantizationConfig};
    use crate::vector_storage::dense::simple_dense_vector_storage::open_simple_dense_vector_storage;
    use crate::vector_storage::{DEFAULT_STOPPED, new_raw_scorer_for_test};
    use crate::vector_storage::quantized::quantized_vectors::QuantizedVectors;

    // ... (tests unchanged; they make use of the public API defined above) ...
}