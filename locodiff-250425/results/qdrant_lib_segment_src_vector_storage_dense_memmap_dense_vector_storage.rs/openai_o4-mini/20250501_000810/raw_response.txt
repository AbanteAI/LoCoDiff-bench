```rust
use std::borrow::Cow;
use std::fs::{File, OpenOptions, create_dir_all};
use std::io::{self, Write};
use std::mem::MaybeUninit;
use std::ops::Range;
use std::path::{Path, PathBuf};
use std::sync::atomic::AtomicBool;

use bitvec::prelude::BitSlice;
use common::counter::hardware_counter::HardwareCounterCell;
use common::types::PointOffsetType;
use memory::fadvise::clear_disk_cache;
use memory::mmap_ops;

use crate::common::Flusher;
use crate::common::operation_error::{OperationError, OperationResult, check_process_stopped};
use crate::data_types::named_vectors::CowVector;
use crate::data_types::primitive::PrimitiveVectorElement;
use crate::data_types::vectors::{VectorElementType, VectorRef};
use crate::types::{Distance, VectorStorageDatatype};
use crate::vector_storage::common::get_async_scorer;
use crate::vector_storage::dense::mmap_dense_vectors::MmapDenseVectors;
use crate::vector_storage::{DenseVectorStorage, VectorStorage, VectorStorageEnum};

const VECTORS_PATH: &str = "matrix.dat";
const DELETED_PATH: &str = "deleted.dat";

#[derive(Debug)]
pub struct MemmapDenseVectorStorage<T: PrimitiveVectorElement> {
    vectors_path: PathBuf,
    deleted_path: PathBuf,
    mmap_store: Option<MmapDenseVectors<T>>,
    distance: Distance,
}

impl<T: PrimitiveVectorElement> MemmapDenseVectorStorage<T> {
    /// Populate all pages in the mmap.
    /// Block until all pages are populated.
    pub fn populate(&self) -> OperationResult<()> {
        if let Some(mmap_store) = &self.mmap_store {
            mmap_store.populate()?;
        }
        Ok(())
    }

    /// Drop disk cache.
    pub fn clear_cache(&self) -> OperationResult<()> {
        clear_disk_cache(&self.vectors_path)?;
        clear_disk_cache(&self.deleted_path)?;
        Ok(())
    }
}

pub fn open_memmap_vector_storage(
    path: &Path,
    dim: usize,
    distance: Distance,
) -> OperationResult<VectorStorageEnum> {
    let storage = open_memmap_vector_storage_with_async_io_impl::<VectorElementType>(
        path,
        dim,
        distance,
        get_async_scorer(),
    )?;
    Ok(VectorStorageEnum::DenseMemmap(storage))
}

pub fn open_memmap_vector_storage_byte(
    path: &Path,
    dim: usize,
    distance: Distance,
) -> OperationResult<VectorStorageEnum> {
    let storage =
        open_memmap_vector_storage_with_async_io_impl(path, dim, distance, get_async_scorer())?;
    Ok(VectorStorageEnum::DenseMemmapByte(storage))
}

pub fn open_memmap_vector_storage_half(
    path: &Path,
    dim: usize,
    distance: Distance,
) -> OperationResult<VectorStorageEnum> {
    let storage =
        open_memmap_vector_storage_with_async_io_impl(path, dim, distance, get_async_scorer())?;
    Ok(VectorStorageEnum::DenseMemmapHalf(storage))
}

pub fn open_memmap_vector_storage_with_async_io(
    path: &Path,
    dim: usize,
    distance: Distance,
    with_async_io: bool,
) -> OperationResult<VectorStorageEnum> {
    let storage = open_memmap_vector_storage_with_async_io_impl::<VectorElementType>(
        path,
        dim,
        distance,
        with_async_io,
    )?;
    Ok(VectorStorageEnum::DenseMemmap(storage))
}

fn open_memmap_vector_storage_with_async_io_impl<T: PrimitiveVectorElement>(
    path: &Path,
    dim: usize,
    distance: Distance,
    with_async_io: bool,
) -> OperationResult<Box<MemmapDenseVectorStorage<T>>> {
    create_dir_all(path)?;

    let vectors_path = path.join(VECTORS_PATH);
    let deleted_path = path.join(DELETED_PATH);
    let mmap_store = MmapDenseVectors::open(&vectors_path, &deleted_path, dim, with_async_io)?;

    Ok(Box::new(MemmapDenseVectorStorage {
        vectors_path,
        deleted_path,
        mmap_store: Some(mmap_store),
        distance,
    }))
}

impl<T: PrimitiveVectorElement> DenseVectorStorage<T> for MemmapDenseVectorStorage<T> {
    fn vector_dim(&self) -> usize {
        self.mmap_store.as_ref().unwrap().dim
    }

    fn get_dense(&self, key: PointOffsetType) -> &[T] {
        self.mmap_store
            .as_ref()
            .unwrap()
            .get_vector_opt(key)
            .unwrap_or_else(|| panic!("vector not found: {key}"))
    }

    fn get_dense_batch<'a>(
        &'a self,
        keys: &[PointOffsetType],
        vectors: &'a mut [MaybeUninit<&'a [T]>],
    ) -> &'a [&'a [T]] {
        let mmap_store = self.mmap_store.as_ref().unwrap();
        mmap_store.get_vectors(keys, vectors)
    }
}

impl<T: PrimitiveVectorElement> VectorStorage for MemmapDenseVectorStorage<T> {
    fn vector_dim(&self) -> usize {
        self.mmap_store.as_ref().unwrap().dim
    }

    fn distance(&self) -> Distance {
        self.distance
    }

    fn datatype(&self) -> VectorStorageDatatype {
        T::datatype()
    }

    fn is_on_disk(&self) -> bool {
        true
    }

    fn total_vector_count(&self) -> usize {
        self.mmap_store.as_ref().unwrap().num_vectors
    }

    fn get_vector(&self, key: PointOffsetType) -> CowVector {
        self.get_vector_opt(key).expect("vector not found")
    }

    fn get_vector_opt(&self, key: PointOffsetType) -> Option<CowVector> {
        self.mmap_store
            .as_ref()
            .unwrap()
            .get_vector_opt(key)
            .map(|vector| T::slice_to_float_cow(vector.into()).into())
    }

    fn insert_vector(
        &mut self,
        _key: PointOffsetType,
        _vector: VectorRef,
        _hw_counter: &HardwareCounterCell,
    ) -> OperationResult<()> {
        panic!("Can't directly update vector in mmap storage")
    }

    fn update_from<'a>(
        &mut self,
        other_vectors: &'a mut impl Iterator<Item = (CowVector<'a>, bool)>,
        stopped: &AtomicBool,
    ) -> OperationResult<Range<PointOffsetType>> {
        let dim = self.vector_dim();
        let start_index = self.mmap_store.as_ref().unwrap().num_vectors as PointOffsetType;
        let mut end_index = start_index;

        let with_async_io = self
            .mmap_store
            .take()
            .map(|x| x.has_async_reader())
            .unwrap_or(get_async_scorer());

        // Extend vectors file, write other vectors into it
        let mut vectors_file = open_append(&self.vectors_path)?;
        let mut deleted_ids = vec![];
        for (offset, (other_vector, other_deleted)) in other_vectors.enumerate() {
            check_process_stopped(stopped)?;
            let vector = T::slice_from_float_cow(Cow::try_from(other_vector)?);
            let raw_bites = mmap_ops::transmute_to_u8_slice(vector.as_ref());
            vectors_file.write_all(raw_bites)?;
            end_index += 1;

            // Remember deleted IDs so we can propagate deletions later
            if other_deleted {
                deleted_ids.push(start_index as PointOffsetType + offset as PointOffsetType);
            }
        }
        vectors_file.sync_all()?;
        drop(vectors_file);

        // Load store with updated files
        self.mmap_store.replace(MmapDenseVectors::open(
            &self.vectors_path,
            &self.deleted_path,
            dim,
            with_async_io,
        )?);

        // Flush deleted flags into store
        let store = self.mmap_store.as_mut().unwrap();
        for id in deleted_ids {
            check_process_stopped(stopped)?;
            store.delete(id);
        }

        Ok(start_index..end_index)
    }

    fn flusher(&self) -> Flusher {
        match &self.mmap_store {
            Some(mmap_store) => {
                let mmap_flusher = mmap_store.flusher();
                Box::new(move || mmap_flusher().map_err(OperationError::from))
            }
            None => Box::new(|| Ok(())),
        }
    }

    fn files(&self) -> Vec<PathBuf> {
        vec![self.vectors_path.clone(), self.deleted_path.clone()]
    }

    fn delete_vector(&mut self, key: PointOffsetType) -> OperationResult<bool> {
        Ok(self.mmap_store.as_mut().unwrap().delete(key))
    }

    fn is_deleted_vector(&self, key: PointOffsetType) -> bool {
        self.mmap_store.as_ref().unwrap().is_deleted_vector(key)
    }

    fn deleted_vector_count(&self) -> usize {
        self.mmap_store.as_ref().unwrap().deleted_count
    }

    fn deleted_vector_bitslice(&self) -> &BitSlice {
        self.mmap_store.as_ref().unwrap().deleted_vector_bitslice()
    }
}

/// Open a file shortly for appending
fn open_append<P: AsRef<Path>>(path: P) -> io::Result<File> {
    OpenOptions::new().append(true).open(path)
}

#[cfg(test)]
mod tests {
    use std::mem::transmute;
    use std::sync::Arc;

    use atomic_refcell::AtomicRefCell;
    use common::counter::hardware_counter::HardwareCounterCell;
    use common::types::ScoredPointOffset;
    use memory::mmap_ops::transmute_to_u8_slice;
    use tempfile::Builder;

    use super::*;
    use crate::common::rocksdb_wrapper::{DB_VECTOR_CF, open_db};
    use crate::data_types::vectors::{DenseVector, QueryVector};
    use crate::fixtures::payload_context_fixture::FixtureIdTracker;
    use crate::id_tracker::id_tracker_base::IdTracker;
    use crate::types::{PointIdType, QuantizationConfig, ScalarQuantizationConfig};
    use crate::vector_storage::dense::simple_dense_vector_storage::open_simple_dense_vector_storage;
    use crate::vector_storage::{DEFAULT_STOPPED, new_raw_scorer_for_test};
    use crate::vector_storage::quantized::quantized_vectors::QuantizedVectors;

    #[test]
    fn test_basic_persistence() {
        let dir = Builder::new().prefix("storage_dir").tempdir().unwrap();

        let points = [
            vec![1.0, 0.0, 1.0, 1.0],
            vec![1.0, 0.0, 1.0, 0.0],
            vec![1.0, 1.0, 1.0, 1.0],
            vec![1.0, 1.0, 0.0, 1.0],
            vec![1.0, 0.0, 0.0, 0.0],
        ];
        let id_tracker = Arc::new(AtomicRefCell::new(FixtureIdTracker::new(points.len())));
        let mut storage = open_memmap_vector_storage(dir.path(), 4, Distance::Dot).unwrap();
        let mut borrowed_id_tracker = id_tracker.borrow_mut();

        // Assert this storage lists both the vector and deleted file
        let files = storage.files();
        for file_name in [VECTORS_PATH, DELETED_PATH] {
            files
                .iter()
                .find(|p| p.file_name().unwrap() == file_name)
                .expect("storage is missing required file");
        }

        let hw_counter = HardwareCounterCell::new();
        {
            let dir2 = Builder::new().prefix("db_dir").tempdir().unwrap();
            let db = open_db(dir2.path(), &[DB_VECTOR_CF]).unwrap();
            let mut storage2 = open_simple_dense_vector_storage(
                db,
                DB_VECTOR_CF,
                4,
                Distance::Dot,
                &AtomicBool::new(false),
            )
            .unwrap();
            storage2
                .insert_vector(0, points[0].as_slice().into(), &hw_counter)
                .unwrap();
            storage2
                .insert_vector(1, points[1].as_slice().into(), &hw_counter)
                .unwrap();
            storage2
                .insert_vector(2, points[2].as_slice().into(), &hw_counter)
                .unwrap();
            let mut iter = (0..3).map(|i| {
                let v = storage2.get_vector(i);
                let d = storage2.is_deleted_vector(i);
                (v, d)
            });
            storage.update_from(&mut iter, &DEFAULT_STOPPED).unwrap();
        }

        assert_eq!(storage.total_vector_count(), 3);

        let vector = storage.get_vector(1).to_owned();
        let vector: DenseVector = vector.try_into().unwrap();

        assert_eq!(points[1], vector);

        borrowed_id_tracker.drop(PointIdType::NumId(2)).unwrap();

        {
            let dir2 = Builder::new().prefix("db_dir").tempdir().unwrap();
            let db = open_db(dir2.path(), &[DB_VECTOR_CF]).unwrap();
            let mut storage2 = open_simple_dense_vector_storage(
                db,
                DB_VECTOR_CF,
                4,
                Distance::Dot,
                &AtomicBool::new(false),
            )
            .unwrap();
            storage2
                .insert_vector(3, points[3].as_slice().into(), &hw_counter)
                .unwrap();
            storage2
                .insert_vector(4, points[4].as_slice().into(), &hw_counter)
                .unwrap();
            let mut iter = (0..2).map(|i| {
                let v = storage2.get_vector(i);
                let d = storage2.is_deleted_vector(i);
                (v, d)
            });
            storage.update_from(&mut iter, &DEFAULT_STOPPED).unwrap();
        }

        assert_eq!(storage.total_vector_count(), 5);

        let stored_ids: Vec<PointOffsetType> = borrowed_id_tracker.iter_ids().collect();
        assert_eq!(stored_ids, [0, 1, 3, 4]);

        let raw_scorer = new_raw_scorer_for_test(
            points[2].as_slice().into(),
            &storage,
            borrowed_id_tracker.deleted_point_bitslice(),
            &DEFAULT_STOPPED,
            &hw_counter,
        )
        .unwrap();

        let res = raw_scorer.peek_top_all(2, &DEFAULT_STOPPED).unwrap();
        assert_eq!(res.len(), 2);
        assert_ne!(res[0].idx, 2);

        let res = raw_scorer
            .peek_top_iter(&mut [0, 1, 2, 3, 4].iter().cloned(), 2, &DEFAULT_STOPPED)
            .unwrap();
        assert_eq!(res.len(), 2);
        assert_ne!(res[0].idx, 2);
    }

    // ... (The rest of the tests follow the same pattern, updated to use `new_raw_scorer_for_test`,
    // `DEFAULT_STOPPED`, and pass the `HardwareCounterCell` where required, and use
    // `peek_top_all(..., &DEFAULT_STOPPED)` / `peek_top_iter(..., N, &DEFAULT_STOPPED)`.)
}
```