--- qdrant_lib_segment_src_vector_storage_dense_memmap_dense_vector_storage.rs_expectedoutput.txt (expected)+++ qdrant_lib_segment_src_vector_storage_dense_memmap_dense_vector_storage.rs_extracted.txt (actual)@@ -292,24 +292,23 @@ 
 #[cfg(test)]
 mod tests {
-    use std::mem::transmute;
-    use std::sync::Arc;
-
+    use super::super::simple_dense_vector_storage::open_simple_dense_vector_storage;
+    use super::*;
+    use crate::common::rocksdb_wrapper::{open_db, DB_VECTOR_CF};
+    use crate::data_types::vectors::{DenseVector, QueryVector};
+    use crate::fixtures::payload_context_fixture::FixtureIdTracker;
+    use crate::id_tracker::id_tracker_base::IdTracker;
+    use crate::types::{PointIdType, QuantizationConfig, ScalarQuantizationConfig};
+    use crate::vector_storage::new_raw_scorer_for_test;
+    use crate::vector_storage::quantized::quantized_vectors::QuantizedVectors;
+    use crate::vector_storage::DEFAULT_STOPPED;
     use atomic_refcell::AtomicRefCell;
     use common::counter::hardware_counter::HardwareCounterCell;
     use common::types::ScoredPointOffset;
     use memory::mmap_ops::transmute_to_u8_slice;
+    use std::mem::transmute;
+    use std::sync::Arc;
     use tempfile::Builder;
-
-    use super::*;
-    use crate::common::rocksdb_wrapper::{DB_VECTOR_CF, open_db};
-    use crate::data_types::vectors::{DenseVector, QueryVector};
-    use crate::fixtures::payload_context_fixture::FixtureIdTracker;
-    use crate::id_tracker::id_tracker_base::IdTracker;
-    use crate::types::{PointIdType, QuantizationConfig, ScalarQuantizationConfig};
-    use crate::vector_storage::dense::simple_dense_vector_storage::open_simple_dense_vector_storage;
-    use crate::vector_storage::quantized::quantized_vectors::QuantizedVectors;
-    use crate::vector_storage::{DEFAULT_STOPPED, new_raw_scorer_for_test};
 
     #[test]
     fn test_basic_persistence() {
@@ -501,7 +500,6 @@             borrowed_id_tracker.deleted_point_bitslice(),
         )
         .unwrap();
-
         let closest = scorer
             .peek_top_iter(&mut [0, 1, 2, 3, 4].iter().cloned(), 5, &DEFAULT_STOPPED)
             .unwrap();
@@ -699,7 +697,9 @@         .unwrap();
 
         let mut res = vec![ScoredPointOffset { idx: 0, score: 0. }; query_points.len()];
-        let res_count = scorer.score_points(&query_points, &mut res);
+        let res_count = scorer
+            .score_points(&query_points, &mut res, &DEFAULT_STOPPED)
+            .unwrap();
         res.resize(res_count, ScoredPointOffset { idx: 0, score: 0. });
 
         assert_eq!(res.len(), 3);
@@ -718,7 +718,7 @@ 
         eprintln!("raw_data.len() = {:#?}", raw_data.len());
 
-        let arr: &[VectorElementType] = unsafe { transmute(raw_data) };
+        let arr: &[VectorElementType] = unsafe safety { transmute(raw_data) };
 
         let slice = &arr[0..data.len()];
 
