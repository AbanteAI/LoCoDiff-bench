
index e66df55cf..aa01dc65c 100644
--- a/qdrant_lib_segment_src_vector_storage_dense_memmap_dense_vector_storage.rs_expectedoutput.txt (expected):tmp/tmpw6ul45a4_expected.txt	
+++ b/qdrant_lib_segment_src_vector_storage_dense_memmap_dense_vector_storage.rs_extracted.txt (actual):tmp/tmp7dqmbsw4_actual.txt	
@@ -76,8 +76,7 @@ pub fn open_memmap_vector_storage_byte(
     dim: usize,
     distance: Distance,
 ) -> OperationResult<VectorStorageEnum> {
-    let storage =
-        open_memmap_vector_storage_with_async_io_impl(path, dim, distance, get_async_scorer())?;
+    let storage = open_memmap_vector_storage_with_async_io_impl(path, dim, distance, get_async_scorer())?;
     Ok(VectorStorageEnum::DenseMemmapByte(storage))
 }
 
@@ -86,8 +85,7 @@ pub fn open_memmap_vector_storage_half(
     dim: usize,
     distance: Distance,
 ) -> OperationResult<VectorStorageEnum> {
-    let storage =
-        open_memmap_vector_storage_with_async_io_impl(path, dim, distance, get_async_scorer())?;
+    let storage = open_memmap_vector_storage_with_async_io_impl(path, dim, distance, get_async_scorer())?;
     Ok(VectorStorageEnum::DenseMemmapHalf(storage))
 }
 
@@ -163,6 +161,10 @@ impl<T: PrimitiveVectorElement> DenseVectorStorage<T> for MemmapDenseVectorStora
 }
 
 impl<T: PrimitiveVectorElement> VectorStorage for MemmapDenseVectorStorage<T> {
+    fn vector_dim(&self) -> usize {
+        self.mmap_store.as_ref().unwrap().dim
+    }
+
     fn distance(&self) -> Distance {
         self.distance
     }
@@ -485,7 +487,9 @@ mod tests {
             .enumerate()
             .filter(|(_, d)| *d)
             .for_each(|(i, _)| {
-                storage.delete_vector(i as PointOffsetType).unwrap();
+                storage
+                    .delete_vector(i as PointOffsetType)
+                    .unwrap();
             });
         assert_eq!(
             storage.deleted_vector_count(),
@@ -624,9 +628,6 @@ mod tests {
         let closest = scorer
             .peek_top_iter(&mut [0, 1, 2, 3, 4].iter().cloned(), 5, &DEFAULT_STOPPED)
             .unwrap();
-
-        drop(scorer);
-
         assert_eq!(closest.len(), 3, "must have 3 vectors, 2 are deleted");
         assert_eq!(closest[0].idx, 0);
         assert_eq!(closest[1].idx, 1);
@@ -741,8 +742,9 @@ mod tests {
             vec![1.0, 0.0, 0.0, 0.0],
         ];
         let id_tracker = Arc::new(AtomicRefCell::new(FixtureIdTracker::new(points.len())));
-        let mut storage = open_memmap_vector_storage(dir.path(), 4, Distance::Dot).unwrap();
+        let storage = open_memmap_vector_storage(dir.path(), 4, Distance::Dot).unwrap();
         let borrowed_id_tracker = id_tracker.borrow_mut();
+        let mut borrowed_storage = storage.in_location().unwrap().borrow_mut();
 
         let hw_counter = HardwareCounterCell::new();
 
@@ -770,7 +772,7 @@ mod tests {
                 let deleted = storage2.is_deleted_vector(i);
                 (vector, deleted)
             });
-            storage.update_from(&mut iter, &Default::default()).unwrap();
+            borrowed_storage.update_from(&mut iter, &Default::default()).unwrap();
         }
 
         let config: QuantizationConfig = ScalarQuantizationConfig {
@@ -781,28 +783,28 @@ mod tests {
         .into();
 
         let stopped = Arc::new(AtomicBool::new(false));
-        let hardware_counter = HardwareCounterCell::new();
         let quantized_vectors =
-            QuantizedVectors::create(&storage, &config, dir.path(), 1, &stopped).unwrap();
+            QuantizedVectors::create(&borrowed_storage, &config, dir.path(), 1, &stopped).unwrap();
 
         let query: QueryVector = [0.5, 0.5, 0.5, 0.5].into();
 
+        let hardware_counter = HardwareCounterCell::new();
         let scorer_quant = quantized_vectors
             .raw_scorer(
                 query.clone(),
                 borrowed_id_tracker.deleted_point_bitslice(),
-                storage.deleted_vector_bitslice(),
+                borrowed_storage.deleted_vector_bitslice(),
+                &stopped,
                 hardware_counter,
             )
             .unwrap();
 
         let scorer_orig = new_raw_scorer_for_test(
             query.clone(),
-            &storage,
+            &borrowed_storage,
             borrowed_id_tracker.deleted_point_bitslice(),
         )
         .unwrap();
-
         for i in 0..5 {
             let quant = scorer_quant.score_point(i);
             let orig = scorer_orig.score_point(i);
@@ -812,26 +814,27 @@ mod tests {
             let orig = scorer_orig.score_internal(0, i);
             assert!((orig - quant).abs() < 0.15);
         }
-
-        let files = storage.files();
+        let files = borrowed_storage.files();
         let quantization_files = quantized_vectors.files();
 
         // test save-load
-        let quantized_vectors = QuantizedVectors::load(&storage, dir.path()).unwrap();
-        assert_eq!(files, storage.files());
+        let quantized_vectors = QuantizedVectors::load(&borrowed_storage, dir.path()).unwrap();
+        assert_eq!(files, borrowed_storage.files());
         assert_eq!(quantization_files, quantized_vectors.files());
+
         let hardware_counter = HardwareCounterCell::new();
         let scorer_quant = quantized_vectors
             .raw_scorer(
                 query.clone(),
                 borrowed_id_tracker.deleted_point_bitslice(),
-                storage.deleted_vector_bitslice(),
+                borrowed_storage.deleted_vector_bitslice(),
+                &stopped,
                 hardware_counter,
             )
             .unwrap();
         let scorer_orig = new_raw_scorer_for_test(
             query,
-            &storage,
+            &borrowed_storage,
             borrowed_id_tracker.deleted_point_bitslice(),
         )
         .unwrap();
