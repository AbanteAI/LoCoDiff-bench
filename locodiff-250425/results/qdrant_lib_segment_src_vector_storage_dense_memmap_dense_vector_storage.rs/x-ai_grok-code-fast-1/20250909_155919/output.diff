
index e66df55cf..7b118b503 100644
--- a/qdrant_lib_segment_src_vector_storage_dense_memmap_dense_vector_storage.rs_expectedoutput.txt (expected):tmp/tmpb02ogx___expected.txt	
+++ b/qdrant_lib_segment_src_vector_storage_dense_memmap_dense_vector_storage.rs_extracted.txt (actual):tmp/tmpabgb84q0_actual.txt	
@@ -163,6 +163,10 @@ impl<T: PrimitiveVectorElement> DenseVectorStorage<T> for MemmapDenseVectorStora
 }
 
 impl<T: PrimitiveVectorElement> VectorStorage for MemmapDenseVectorStorage<T> {
+    fn vector_dim(&self) -> usize {
+        self.mmap_store.as_ref().unwrap().dim
+    }
+
     fn distance(&self) -> Distance {
         self.distance
     }
@@ -292,7 +296,6 @@ fn open_append<P: AsRef<Path>>(path: P) -> io::Result<File> {
 
 #[cfg(test)]
 mod tests {
-    use std::mem::transmute;
     use std::sync::Arc;
 
     use atomic_refcell::AtomicRefCell;
@@ -509,7 +512,6 @@ mod tests {
         assert_eq!(closest[0].idx, 0);
         assert_eq!(closest[1].idx, 1);
         assert_eq!(closest[2].idx, 4);
-        drop(scorer);
 
         // Delete 1, redelete 2
         storage.delete_vector(1 as PointOffsetType).unwrap();
@@ -535,7 +537,6 @@ mod tests {
         assert_eq!(closest.len(), 2, "must have 2 vectors, 3 are deleted");
         assert_eq!(closest[0].idx, 4);
         assert_eq!(closest[1].idx, 0);
-        drop(scorer);
 
         // Delete all
         storage.delete_vector(0 as PointOffsetType).unwrap();
@@ -558,7 +559,6 @@ mod tests {
         assert!(closest.is_empty(), "must have no results, all deleted");
     }
 
-    /// Test that deleted points are properly transferred when updating from other storage.
     #[test]
     fn test_update_from_delete_points() {
         let dir = Builder::new().prefix("storage_dir").tempdir().unwrap();
@@ -624,9 +624,6 @@ mod tests {
         let closest = scorer
             .peek_top_iter(&mut [0, 1, 2, 3, 4].iter().cloned(), 5, &DEFAULT_STOPPED)
             .unwrap();
-
-        drop(scorer);
-
         assert_eq!(closest.len(), 3, "must have 3 vectors, 2 are deleted");
         assert_eq!(closest[0].idx, 0);
         assert_eq!(closest[1].idx, 1);
@@ -820,6 +817,7 @@ mod tests {
         let quantized_vectors = QuantizedVectors::load(&storage, dir.path()).unwrap();
         assert_eq!(files, storage.files());
         assert_eq!(quantization_files, quantized_vectors.files());
+
         let hardware_counter = HardwareCounterCell::new();
         let scorer_quant = quantized_vectors
             .raw_scorer(
