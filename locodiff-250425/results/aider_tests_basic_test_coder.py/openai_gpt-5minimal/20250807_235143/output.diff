
index c051e53fd..86399d8aa 100644
--- a/aider_tests_basic_test_coder.py_expectedoutput.txt (expected):tmp/tmpyycbfn97_expected.txt	
+++ b/aider_tests_basic_test_coder.py_extracted.txt (actual):tmp/tmpa_0zo77s_actual.txt	
@@ -230,43 +230,6 @@ class TestCoder(unittest.TestCase):
             # Assert that abs_fnames is still empty (file not added)
             self.assertEqual(coder.abs_fnames, set())
 
-    def test_check_for_file_mentions_with_mocked_confirm(self):
-        with GitTemporaryDirectory():
-            io = InputOutput(pretty=False)
-            coder = Coder.create(self.GPT35, None, io)
-
-            # Mock get_file_mentions to return two file names
-            coder.get_file_mentions = MagicMock(return_value=set(["file1.txt", "file2.txt"]))
-
-            # Mock confirm_ask to return False for the first call and True for the second
-            io.confirm_ask = MagicMock(side_effect=[False, True, True])
-
-            # First call to check_for_file_mentions
-            coder.check_for_file_mentions("Please check file1.txt for the info")
-
-            # Assert that confirm_ask was called twice
-            self.assertEqual(io.confirm_ask.call_count, 2)
-
-            # Assert that only file2.txt was added to abs_fnames
-            self.assertEqual(len(coder.abs_fnames), 1)
-            self.assertIn("file2.txt", str(coder.abs_fnames))
-
-            # Reset the mock
-            io.confirm_ask.reset_mock()
-
-            # Second call to check_for_file_mentions
-            coder.check_for_file_mentions("Please check file1.txt and file2.txt again")
-
-            # Assert that confirm_ask was called only once (for file1.txt)
-            self.assertEqual(io.confirm_ask.call_count, 1)
-
-            # Assert that abs_fnames still contains only file2.txt
-            self.assertEqual(len(coder.abs_fnames), 1)
-            self.assertIn("file2.txt", str(coder.abs_fnames))
-
-            # Assert that file1.txt is in ignore_mentions
-            self.assertIn("file1.txt", coder.ignore_mentions)
-
     def test_check_for_subdir_mention(self):
         with GitTemporaryDirectory():
             io = InputOutput(pretty=False, yes=True)
@@ -386,7 +349,7 @@ class TestCoder(unittest.TestCase):
 
             # Input text with multiline backticked filenames
             content = """
-Could you please **add the following files to the chat**?
+Could you please add the following files to the chat?
 
 1.  `swebench/harness/test_spec/python.py`
 2.  `swebench/harness/test_spec/javascript.py`
@@ -979,6 +942,48 @@ This command will print 'Hello, World!' to the console."""
             coder = Coder.create(self.GPT35, "diff", io=io, suggest_shell_commands=False)
             self.assertFalse(coder.suggest_shell_commands)
 
+            def mock_send(*args, **kwargs):
+                coder.partial_response_content = """Here's a shell command to run:
+
+```bash
+echo "Hello, World!"
+```
+
+This command will print 'Hello, World!' to the console."""
+                coder.partial_response_function_call = dict()
+                return []
+
+            coder.send = mock_send
+
+            # Mock the handle_shell_commands method to check if it's called
+            coder.handle_shell_commands = MagicMock()
+
+            # Run the coder with a message
+            coder.run(with_message="Suggest a shell command")
+
+            # Check if the shell command was added to the list
+            self.assertEqual(len(coder.shell_commands), 1)
+            self.assertEqual(coder.shell_commands[0].strip(), 'echo "Hello, World!"')
+
+            # Check if handle_shell_commands was called with the correct argument
+            coder.handle_shell_commands.assert_not_called()
+
+    def test_coder_create_with_new_file_oserror(self):
+        with GitTemporaryDirectory():
+            io = InputOutput(yes=True)
+            new_file = "new_file.txt"
+
+            # Mock Path.touch() to raise OSError
+            with patch("pathlib.Path.touch", side_effect=OSError("Permission denied")):
+                # Create the coder with a new file
+                coder = Coder.create(self.GPT35, "diff", io=io, fnames=[new_file])
+
+            # Check if the coder was created successfully
+            self.assertIsInstance(coder, Coder)
+
+            # Check if the new file is not in abs_fnames
+            self.assertNotIn(new_file, [os.path.basename(f) for f in coder.abs_fnames])
+
     def test_detect_urls_enabled(self):
         with GitTemporaryDirectory():
             io = InputOutput(yes=True)
@@ -1027,41 +1032,6 @@ This command will print 'Hello, World!' to the console."""
         self.assertIsInstance(exc.valid_formats, list)
         self.assertTrue(len(exc.valid_formats) > 0)
 
-    def test_system_prompt_prefix(self):
-        # Test that system_prompt_prefix is properly set and used
-        io = InputOutput(yes=True)
-        test_prefix = "Test prefix. "
-
-        # Create a model with system_prompt_prefix
-        model = Model("gpt-3.5-turbo")
-        model.system_prompt_prefix = test_prefix
-
-        coder = Coder.create(model, None, io=io)
-
-        # Get the formatted messages
-        chunks = coder.format_messages()
-        messages = chunks.all_messages()
-
-        # Check if the system message contains our prefix
-        system_message = next(msg for msg in messages if msg["role"] == "system")
-        self.assertTrue(system_message["content"].startswith(test_prefix))
-
-    def test_coder_create_with_new_file_oserror(self):
-        with GitTemporaryDirectory():
-            io = InputOutput(yes=True)
-            new_file = "new_file.txt"
-
-            # Mock Path.touch() to raise OSError
-            with patch("pathlib.Path.touch", side_effect=OSError("Permission denied")):
-                # Create the coder with a new file
-                coder = Coder.create(self.GPT35, "diff", io=io, fnames=[new_file])
-
-            # Check if the coder was created successfully
-            self.assertIsInstance(coder, Coder)
-
-            # Check if the new file is not in abs_fnames
-            self.assertNotIn(new_file, [os.path.basename(f) for f in coder.abs_fnames])
-
     def test_show_exhausted_error(self):
         with GitTemporaryDirectory():
             io = InputOutput(yes=True)
@@ -1181,6 +1151,25 @@ This command will print 'Hello, World!' to the console."""
             sanity_check_messages(coder.cur_messages)
             self.assertEqual(coder.cur_messages[-1]["role"], "assistant")
 
+    def test_system_prompt_prefix(self):
+        # Test that system_prompt_prefix is properly set and used
+        io = InputOutput(yes=True)
+        test_prefix = "Test prefix. "
+
+        # Create a model with system_prompt_prefix
+        model = Model("gpt-3.5-turbo")
+        model.system_prompt_prefix = test_prefix
+
+        coder = Coder.create(model, None, io=io)
+
+        # Get the formatted messages
+        chunks = coder.format_messages()
+        messages = chunks.all_messages()
+
+        # Check if the system message contains our prefix
+        system_message = next(msg for msg in messages if msg["role"] == "system")
+        self.assertTrue(system_message["content"].startswith(test_prefix))
+
     def test_architect_coder_auto_accept_true(self):
         with GitTemporaryDirectory():
             io = InputOutput(yes=True)
@@ -1270,6 +1259,10 @@ This command will print 'Hello, World!' to the console."""
                 coder.auto_accept_architect = False
                 coder.verbose = False
                 coder.total_cost = 0
+                coder.cur_messages = []
+                coder.done_messages = []
+                coder.summarizer = MagicMock()
+                coder.summarizer.too_big.return_value = False
 
                 # Mock editor_coder creation and execution
                 mock_editor = MagicMock()
