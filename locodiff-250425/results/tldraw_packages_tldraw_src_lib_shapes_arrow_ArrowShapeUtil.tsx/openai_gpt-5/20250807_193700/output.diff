
index e34dd9818..3d1c65cb7 100644
--- a/tldraw_packages_tldraw_src_lib_shapes_arrow_ArrowShapeUtil.tsx_expectedoutput.txt (expected):tmp/tmp8o9fb2i3_expected.txt	
+++ b/tldraw_packages_tldraw_src_lib_shapes_arrow_ArrowShapeUtil.tsx_extracted.txt (actual):tmp/tmplrulviop_actual.txt	
@@ -1,7 +1,6 @@
 import {
 	Arc2d,
 	Box,
-	EMPTY_ARRAY,
 	Edge2d,
 	Editor,
 	Geometry2d,
@@ -12,43 +11,39 @@ import {
 	SvgExportContext,
 	TLArrowBinding,
 	TLArrowShape,
-	TLArrowShapeProps,
-	TLFontFace,
 	TLHandle,
-	TLHandleDragInfo,
-	TLResizeInfo,
+	TLOnEditEndHandler,
+	TLOnHandleDragHandler,
+	TLOnResizeHandler,
+	TLOnTranslateHandler,
+	TLOnTranslateStartHandler,
 	TLShapePartial,
-	TLShapeUtilCanBeLaidOutOpts,
 	TLShapeUtilCanBindOpts,
 	TLShapeUtilCanvasSvgDef,
+	TLShapeUtilFlag,
 	Vec,
 	WeakCache,
 	arrowShapeMigrations,
 	arrowShapeProps,
-	debugFlags,
 	getDefaultColorTheme,
-	getPerfectDashProps,
-	lerp,
 	mapObjectMapValues,
-	maybeSnapToGrid,
 	structuredClone,
 	toDomPrecision,
 	track,
 	useEditor,
 	useIsEditing,
-	useSharedSafeId,
-	useValue,
 } from '@tldraw/editor'
 import React from 'react'
-import { updateArrowTerminal } from '../../bindings/arrow/ArrowBindingUtil'
-import { PlainTextLabel } from '../shared/PlainTextLabel'
-import { ShapeFill } from '../shared/ShapeFill'
+import { ShapeFill, useDefaultColorTheme } from '../shared/ShapeFill'
 import { SvgTextLabel } from '../shared/SvgTextLabel'
-import { ARROW_LABEL_PADDING, STROKE_SIZES, TEXT_PROPS } from '../shared/default-shape-constants'
-import { DefaultFontFaces } from '../shared/defaultFonts'
-import { getFillDefForCanvas, getFillDefForExport } from '../shared/defaultStyleDefs'
-import { useDefaultColorTheme } from '../shared/useDefaultColorTheme'
-import { getArrowLabelFontSize, getArrowLabelPosition } from './arrowLabel'
+import { ARROW_LABEL_FONT_SIZES, STROKE_SIZES } from '../shared/default-shape-constants'
+import {
+	getFillDefForCanvas,
+	getFillDefForExport,
+	getFontDefForExport,
+} from '../shared/defaultStyleDefs'
+import { getPerfectDashProps } from '../shared/getPerfectDashProps'
+import { getArrowLabelPosition } from './arrowLabel'
 import { getArrowheadPathForType } from './arrowheads'
 import {
 	getCurvedArrowHandlePath,
@@ -56,6 +51,7 @@ import {
 	getSolidStraightArrowPath,
 	getStraightArrowHandlePath,
 } from './arrowpaths'
+import { ArrowTextLabel } from './components/ArrowTextLabel'
 import {
 	TLArrowBindings,
 	createOrUpdateArrowBinding,
@@ -65,6 +61,8 @@ import {
 	removeArrowBinding,
 } from './shared'
 
+let globalRenderIndex = 0
+
 enum ARROW_HANDLES {
 	START = 'start',
 	MIDDLE = 'middle',
@@ -77,48 +75,20 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 	static override props = arrowShapeProps
 	static override migrations = arrowShapeMigrations
 
-	override canEdit() {
-		return true
-	}
+	override canEdit = () => true
 	override canBind({ toShapeType }: TLShapeUtilCanBindOpts<TLArrowShape>): boolean {
 		// bindings can go from arrows to shapes, but not from shapes to arrows
 		return toShapeType !== 'arrow'
 	}
-	override canSnap() {
-		return false
-	}
-	override canTabTo(shape: TLArrowShape) {
-		const bindings = getArrowBindings(this.editor, shape)
-		return !!(bindings.start || bindings.end || shape.props.text)
-	}
-	override hideResizeHandles() {
-		return true
-	}
-	override hideRotateHandle() {
-		return true
-	}
-	override hideSelectionBoundsBg() {
-		return true
-	}
-	override hideSelectionBoundsFg() {
-		return true
-	}
-
-	override canBeLaidOut(shape: TLArrowShape, info: TLShapeUtilCanBeLaidOutOpts) {
-		if (info.type === 'flip') {
-			// If we don't have this then the flip will be non-idempotent; that is, the flip will be multipotent, varipotent, or perhaps even omni-potent... and we can't have that
-			const bindings = getArrowBindings(this.editor, shape)
-			const { start, end } = bindings
-			const { shapes = [] } = info
-			if (start && !shapes.find((s) => s.id === start.toId)) return false
-			if (end && !shapes.find((s) => s.id === end.toId)) return false
-		}
-		return true
-	}
+	override canSnap = () => false
+	override hideResizeHandles: TLShapeUtilFlag<TLArrowShape> = () => true
+	override hideRotateHandle: TLShapeUtilFlag<TLArrowShape> = () => true
+	override hideSelectionBoundsBg: TLShapeUtilFlag<TLArrowShape> = () => true
+	override hideSelectionBoundsFg: TLShapeUtilFlag<TLArrowShape> = () => true
 
-	override getFontFaces(shape: TLArrowShape): TLFontFace[] {
-		if (!shape.props.text) return EMPTY_ARRAY
-		return [DefaultFontFaces[`tldraw_${shape.props.font}`].normal.normal]
+	override canBeLaidOut: TLShapeUtilFlag<TLArrowShape> = (shape) => {
+		const bindings = getArrowBindings(this.editor, shape)
+		return !bindings.start && !bindings.end
 	}
 
 	override getDefaultProps(): TLArrowShape['props'] {
@@ -136,7 +106,6 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			text: '',
 			labelPosition: 0.5,
 			font: 'draw',
-			scale: 1,
 		}
 	}
 
@@ -149,19 +118,19 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			? new Edge2d({
 					start: Vec.From(info.start.point),
 					end: Vec.From(info.end.point),
-				})
+			  })
 			: new Arc2d({
 					center: Vec.Cast(info.handleArc.center),
 					start: Vec.Cast(info.start.point),
 					end: Vec.Cast(info.end.point),
 					sweepFlag: info.bodyArc.sweepFlag,
 					largeArcFlag: info.bodyArc.largeArcFlag,
-				})
+			  })
 
 		let labelGeom
 		if (shape.props.text.trim()) {
 			const labelPosition = getArrowLabelPosition(this.editor, shape)
-			if (debugFlags.debugGeometry.get()) debugGeom.push(...labelPosition.debugGeom)
+			debugGeom.push(...labelPosition.debugGeom)
 			labelGeom = new Rectangle2d({
 				x: labelPosition.box.x,
 				y: labelPosition.box.y,
@@ -205,14 +174,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		].filter(Boolean) as TLHandle[]
 	}
 
-	override getText(shape: TLArrowShape) {
-		return shape.props.text
-	}
-
-	override onHandleDrag(
-		shape: TLArrowShape,
-		{ handle, isPrecise }: TLHandleDragInfo<TLArrowShape>
-	) {
+	override onHandleDrag: TLOnHandleDragHandler<TLArrowShape> = (shape, { handle, isPrecise }) => {
 		const handleId = handle.id as ARROW_HANDLES
 		const bindings = getArrowBindings(this.editor, shape)
 
@@ -271,10 +233,10 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		if (!target) {
 			// todo: maybe double check that this isn't equal to the other handle too?
 			removeArrowBinding(this.editor, shape, handleId)
-			const newPoint = maybeSnapToGrid(new Vec(handle.x, handle.y), this.editor)
+
 			update.props![handleId] = {
-				x: newPoint.x,
-				y: newPoint.y,
+				x: handle.x,
+				y: handle.y,
 			}
 			return update
 		}
@@ -356,7 +318,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		return update
 	}
 
-	override onTranslateStart(shape: TLArrowShape) {
+	override onTranslateStart: TLOnTranslateStartHandler<TLArrowShape> = (shape) => {
 		const bindings = getArrowBindings(this.editor, shape)
 
 		const terminalsInArrowSpace = getArrowTerminalsInArrowSpace(this.editor, shape, bindings)
@@ -393,25 +355,6 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			}),
 		})
 
-		// update arrow terminal bindings eagerly to make sure the arrows unbind nicely when translating
-		if (bindings.start) {
-			updateArrowTerminal({
-				editor: this.editor,
-				arrow: shape,
-				terminal: 'start',
-				useHandle: true,
-			})
-			shape = this.editor.getShape(shape.id) as TLArrowShape
-		}
-		if (bindings.end) {
-			updateArrowTerminal({
-				editor: this.editor,
-				arrow: shape,
-				terminal: 'end',
-				useHandle: true,
-			})
-		}
-
 		for (const handleName of [ARROW_HANDLES.START, ARROW_HANDLES.END] as const) {
 			const binding = bindings[handleName]
 			if (!binding) continue
@@ -425,7 +368,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		return
 	}
 
-	override onTranslate(initialShape: TLArrowShape, shape: TLArrowShape) {
+	override onTranslate?: TLOnTranslateHandler<TLArrowShape> = (initialShape, shape) => {
 		const atTranslationStart = shapeAtTranslationStart.get(initialShape)
 		if (!atTranslationStart) return
 
@@ -471,7 +414,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 
 	private readonly _resizeInitialBindings = new WeakCache<TLArrowShape, TLArrowBindings>()
 
-	override onResize(shape: TLArrowShape, info: TLResizeInfo<TLArrowShape>) {
+	override onResize: TLOnResizeHandler<TLArrowShape> = (shape, info) => {
 		const { scaleX, scaleY } = info
 
 		const bindings = this._resizeInitialBindings.get(shape, () =>
@@ -575,10 +518,10 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		return next
 	}
 
-	override onDoubleClickHandle(
+	override onDoubleClickHandle = (
 		shape: TLArrowShape,
 		handle: TLHandle
-	): TLShapePartial<TLArrowShape> | void {
+	): TLShapePartial<TLArrowShape> | void => {
 		switch (handle.id) {
 			case ARROW_HANDLES.START: {
 				return {
@@ -603,9 +546,27 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		}
 	}
 
+	override onEditEnd: TLOnEditEndHandler<TLArrowShape> = (shape) => {
+		const {
+			id,
+			type,
+			props: { text },
+		} = shape
+
+		if (text.trimEnd() !== shape.props.text) {
+			this.editor.updateShapes<TLArrowShape>([
+				{
+					id,
+					type,
+					props: {
+						text: text.trimEnd(),
+					},
+				},
+			])
+		}
+	}
+
 	component(shape: TLArrowShape) {
-		// eslint-disable-next-line react-hooks/rules-of-hooks
-		const theme = useDefaultColorTheme()
 		const onlySelectedShape = this.editor.getOnlySelectedShape()
 		const shouldDisplayHandles =
 			this.editor.isInAny(
@@ -614,7 +575,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 				'select.dragging_handle',
 				'select.translating',
 				'arrow.dragging'
-			) && !this.editor.getIsReadonly()
+			) && !this.editor.getInstanceState().isReadonly
 
 		const info = getArrowInfo(this.editor, shape)
 		if (!info?.isValid) return null
@@ -626,30 +587,22 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 
 		return (
 			<>
-				<SVGContainer style={{ minWidth: 50, minHeight: 50 }}>
+				<SVGContainer id={shape.id} style={{ minWidth: 50, minHeight: 50 }}>
 					<ArrowSvg
 						shape={shape}
-						shouldDisplayHandles={shouldDisplayHandles && onlySelectedShape?.id === shape.id}
+						shouldDisplayHandles={shouldDisplayHandles && onlySelectedShape === shape}
 					/>
 				</SVGContainer>
 				{showArrowLabel && (
-					<PlainTextLabel
-						shapeId={shape.id}
-						classNamePrefix="tl-arrow"
-						type="arrow"
-						font={shape.props.font}
-						fontSize={getArrowLabelFontSize(shape)}
-						lineHeight={TEXT_PROPS.lineHeight}
-						align="middle"
-						verticalAlign="middle"
+					<ArrowTextLabel
+						id={shape.id}
 						text={shape.props.text}
-						labelColor={theme[shape.props.labelColor].solid}
-						textWidth={labelPosition.box.w - ARROW_LABEL_PADDING * 2 * shape.props.scale}
+						font={shape.props.font}
+						size={shape.props.size}
+						position={labelPosition.box.center}
+						width={labelPosition.box.w}
 						isSelected={isSelected}
-						padding={0}
-						style={{
-							transform: `translate(${labelPosition.box.center.x}px, ${labelPosition.box.center.y}px)`,
-						}}
+						labelColor={shape.props.labelColor}
 					/>
 				)}
 			</>
@@ -659,8 +612,6 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 	indicator(shape: TLArrowShape) {
 		// eslint-disable-next-line react-hooks/rules-of-hooks
 		const isEditing = useIsEditing(shape.id)
-		// eslint-disable-next-line react-hooks/rules-of-hooks
-		const clipPathId = useSharedSafeId(shape.id + '_clip')
 
 		const info = getArrowInfo(this.editor, shape)
 		if (!info) return null
@@ -673,18 +624,20 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 
 		if (Vec.Equals(start, end)) return null
 
-		const strokeWidth = STROKE_SIZES[shape.props.size] * shape.props.scale
+		const strokeWidth = STROKE_SIZES[shape.props.size]
 
 		const as = info.start.arrowhead && getArrowheadPathForType(info, 'start', strokeWidth)
 		const ae = info.end.arrowhead && getArrowheadPathForType(info, 'end', strokeWidth)
 
 		const path = info.isStraight ? getSolidStraightArrowPath(info) : getSolidCurvedArrowPath(info)
 
-		const includeClipPath =
+		const includeMask =
 			(as && info.start.arrowhead !== 'arrow') ||
 			(ae && info.end.arrowhead !== 'arrow') ||
 			!!labelGeometry
 
+		const maskId = (shape.id + '_clip').replace(':', '_')
+
 		if (isEditing && labelGeometry) {
 			return (
 				<rect
@@ -692,37 +645,56 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 					y={toDomPrecision(labelGeometry.y)}
 					width={labelGeometry.w}
 					height={labelGeometry.h}
-					rx={3.5 * shape.props.scale}
-					ry={3.5 * shape.props.scale}
+					rx={3.5}
+					ry={3.5}
 				/>
 			)
 		}
-		const clipStartArrowhead = !(
-			info.start.arrowhead === 'none' || info.start.arrowhead === 'arrow'
-		)
-		const clipEndArrowhead = !(info.end.arrowhead === 'none' || info.end.arrowhead === 'arrow')
 
 		return (
 			<g>
-				{includeClipPath && (
+				{includeMask && (
 					<defs>
-						<ArrowClipPath
-							hasText={shape.props.text.trim().length > 0}
-							bounds={bounds}
-							labelBounds={labelGeometry ? labelGeometry.getBounds() : new Box(0, 0, 0, 0)}
-							as={clipStartArrowhead && as ? as : ''}
-							ae={clipEndArrowhead && ae ? ae : ''}
-						/>
+						<mask id={maskId}>
+							<rect
+								x={bounds.minX - 100}
+								y={bounds.minY - 100}
+								width={bounds.w + 200}
+								height={bounds.h + 200}
+								fill="white"
+							/>
+							{labelGeometry && (
+								<rect
+									x={toDomPrecision(labelGeometry.x)}
+									y={toDomPrecision(labelGeometry.y)}
+									width={labelGeometry.w}
+									height={labelGeometry.h}
+									fill="black"
+									rx={3.5}
+									ry={3.5}
+								/>
+							)}
+							{as && (
+								<path
+									d={as}
+									fill={info.start.arrowhead === 'arrow' ? 'none' : 'black'}
+									stroke="none"
+								/>
+							)}
+							{ae && (
+								<path
+									d={ae}
+									fill={info.end.arrowhead === 'arrow' ? 'none' : 'black'}
+									stroke="none"
+								/>
+							)}
+						</mask>
 					</defs>
 				)}
-				<g
-					style={{
-						clipPath: includeClipPath ? `url(#${clipPathId})` : undefined,
-						WebkitClipPath: includeClipPath ? `url(#${clipPathId})` : undefined,
-					}}
-				>
+				{/* firefox will clip if you provide a maskURL even if there is no mask matching that URL in the DOM */}
+				<g {...(includeMask ? { mask: `url(#${maskId})` } : undefined)}>
 					{/* This rect needs to be here if we're creating a mask due to an svg quirk on Chrome */}
-					{includeClipPath && (
+					{includeMask && (
 						<rect
 							x={bounds.minX - 100}
 							y={bounds.minY - 100}
@@ -750,47 +722,25 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		)
 	}
 
-	override onEditEnd(shape: TLArrowShape) {
-		const {
-			id,
-			type,
-			props: { text },
-		} = shape
-
-		if (text.trimEnd() !== shape.props.text) {
-			this.editor.updateShapes<TLArrowShape>([
-				{
-					id,
-					type,
-					props: {
-						text: text.trimEnd(),
-					},
-				},
-			])
-		}
-	}
-
 	override toSvg(shape: TLArrowShape, ctx: SvgExportContext) {
 		ctx.addExportDef(getFillDefForExport(shape.props.fill))
+		if (shape.props.text) ctx.addExportDef(getFontDefForExport(shape.props.font))
 		const theme = getDefaultColorTheme(ctx)
-		const scaleFactor = 1 / shape.props.scale
 
 		return (
-			<g transform={`scale(${scaleFactor})`}>
+			<>
 				<ArrowSvg shape={shape} shouldDisplayHandles={false} />
 				<SvgTextLabel
-					fontSize={getArrowLabelFontSize(shape)}
+					fontSize={ARROW_LABEL_FONT_SIZES[shape.props.size]}
 					font={shape.props.font}
 					align="middle"
 					verticalAlign="middle"
 					text={shape.props.text}
 					labelColor={theme[shape.props.labelColor].solid}
-					bounds={getArrowLabelPosition(this.editor, shape)
-						.box.clone()
-						.expandBy(-ARROW_LABEL_PADDING * shape.props.scale)}
-					padding={0}
+					bounds={getArrowLabelPosition(this.editor, shape).box}
+					padding={4}
 				/>
-			</g>
+			</>
 		)
 	}
 
@@ -807,29 +757,9 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			},
 		]
 	}
-	override getInterpolatedProps(
-		startShape: TLArrowShape,
-		endShape: TLArrowShape,
-		progress: number
-	): TLArrowShapeProps {
-		return {
-			...(progress > 0.5 ? endShape.props : startShape.props),
-			scale: lerp(startShape.props.scale, endShape.props.scale, progress),
-			start: {
-				x: lerp(startShape.props.start.x, endShape.props.start.x, progress),
-				y: lerp(startShape.props.start.y, endShape.props.start.y, progress),
-			},
-			end: {
-				x: lerp(startShape.props.end.x, endShape.props.end.x, progress),
-				y: lerp(startShape.props.end.y, endShape.props.end.y, progress),
-			},
-			bend: lerp(startShape.props.bend, endShape.props.bend, progress),
-			labelPosition: lerp(startShape.props.labelPosition, endShape.props.labelPosition, progress),
-		}
-	}
 }
 
-export function getArrowLength(editor: Editor, shape: TLArrowShape): number {
+function getLength(editor: Editor, shape: TLArrowShape): number {
 	const info = getArrowInfo(editor, shape)!
 
 	return info.isStraight
@@ -849,21 +779,15 @@ const ArrowSvg = track(function ArrowSvg({
 	const info = getArrowInfo(editor, shape)
 	const bounds = Box.ZeroFix(editor.getShapeGeometry(shape).bounds)
 	const bindings = getArrowBindings(editor, shape)
-	const isForceSolid = useValue(
-		'force solid',
-		() => {
-			return editor.getZoomLevel() < 0.2
-		},
-		[editor]
-	)
 
-	const clipPathId = useSharedSafeId(shape.id + '_clip')
-	const arrowheadDotId = useSharedSafeId('arrowhead-dot')
-	const arrowheadCrossId = useSharedSafeId('arrowhead-cross')
+	const changeIndex = React.useMemo<number>(() => {
+		return editor.environment.isSafari ? (globalRenderIndex += 1) : 0
+		// eslint-disable-next-line react-hooks/exhaustive-deps
+	}, [shape])
 
 	if (!info?.isValid) return null
 
-	const strokeWidth = STROKE_SIZES[shape.props.size] * shape.props.scale
+	const strokeWidth = STROKE_SIZES[shape.props.size]
 
 	const as = info.start.arrowhead && getArrowheadPathForType(info, 'start', strokeWidth)
 	const ae = info.end.arrowhead && getArrowheadPathForType(info, 'end', strokeWidth)
@@ -873,16 +797,12 @@ const ArrowSvg = track(function ArrowSvg({
 	let handlePath: null | React.JSX.Element = null
 
 	if (shouldDisplayHandles) {
-		const sw = 2 / editor.getZoomLevel()
-		const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
-			getArrowLength(editor, shape),
-			sw,
-			{
-				end: 'skip',
-				start: 'skip',
-				lengthRatio: 2.5,
-			}
-		)
+		const sw = 2
+		const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(getLength(editor, shape), sw, {
+			end: 'skip',
+			start: 'skip',
+			lengthRatio: 2.5,
+		})
 
 		handlePath =
 			bindings.start || bindings.end ? (
@@ -897,8 +817,8 @@ const ArrowSvg = track(function ArrowSvg({
 							? bindings.start.props.isExact
 								? ''
 								: bindings.start.props.isPrecise
-									? `url(#${arrowheadCrossId})`
-									: `url(#${arrowheadDotId})`
+									? 'url(#arrowhead-cross)'
+									: 'url(#arrowhead-dot)'
 							: ''
 					}
 					markerEnd={
@@ -906,8 +826,8 @@ const ArrowSvg = track(function ArrowSvg({
 							? bindings.end.props.isExact
 								? ''
 								: bindings.end.props.isPrecise
-									? `url(#${arrowheadCrossId})`
-									: `url(#${arrowheadDotId})`
+									? 'url(#arrowhead-cross)'
+									: 'url(#arrowhead-dot)'
 							: ''
 					}
 					opacity={0.16}
@@ -920,28 +840,48 @@ const ArrowSvg = track(function ArrowSvg({
 		strokeWidth,
 		{
 			style: shape.props.dash,
-			forceSolid: isForceSolid,
 		}
 	)
 
 	const labelPosition = getArrowLabelPosition(editor, shape)
 
-	const clipStartArrowhead = !(info.start.arrowhead === 'none' || info.start.arrowhead === 'arrow')
-	const clipEndArrowhead = !(info.end.arrowhead === 'none' || info.end.arrowhead === 'arrow')
+	const maskStartArrowhead = !(info.start.arrowhead === 'none' || info.start.arrowhead === 'arrow')
+	const maskEndArrowhead = !(info.end.arrowhead === 'none' || info.end.arrowhead === 'arrow')
+
+	// NOTE: I know right setting `changeIndex` hacky-as right! But we need this because otherwise safari loses
+	// the mask, see <https://linear.app/tldraw/issue/TLD-1500/changing-arrow-color-makes-line-pass-through-text>
+	const maskId = (shape.id + '_clip_' + changeIndex).replace(':', '_')
 
 	return (
 		<>
 			{/* Yep */}
 			<defs>
-				<clipPath id={clipPathId}>
-					<ArrowClipPath
-						hasText={shape.props.text.trim().length > 0}
-						bounds={bounds}
-						labelBounds={labelPosition.box}
-						as={clipStartArrowhead && as ? as : ''}
-						ae={clipEndArrowhead && ae ? ae : ''}
+				<mask id={maskId}>
+					<rect
+						x={toDomPrecision(-100 + bounds.minX)}
+						y={toDomPrecision(-100 + bounds.minY)}
+						width={toDomPrecision(bounds.width + 200)}
+						height={toDomPrecision(bounds.height + 200)}
+						fill="white"
 					/>
-				</clipPath>
+					{shape.props.text.trim() && (
+						<rect
+							x={labelPosition.box.x}
+							y={labelPosition.box.y}
+							width={labelPosition.box.w}
+							height={labelPosition.box.h}
+							fill="black"
+							rx={4}
+							ry={4}
+						/>
+					)}
+					{as && maskStartArrowhead && (
+						<path d={as} fill={info.start.arrowhead === 'arrow' ? 'none' : 'black'} stroke="none" />
+					)}
+					{ae && maskEndArrowhead && (
+						<path d={ae} fill={info.end.arrowhead === 'arrow' ? 'none' : 'black'} stroke="none" />
+					)}
+				</mask>
 			</defs>
 			<g
 				fill="none"
@@ -952,12 +892,8 @@ const ArrowSvg = track(function ArrowSvg({
 				pointerEvents="none"
 			>
 				{handlePath}
-				<g
-					style={{
-						clipPath: `url(#${clipPathId})`,
-						WebkitClipPath: `url(#${clipPathId})`,
-					}}
-				>
+				{/* firefox will clip if you provide a maskURL even if there is no mask matching that URL in the DOM */}
+				<g mask={`url(#${maskId})`}>
 					<rect
 						x={toDomPrecision(bounds.minX - 100)}
 						y={toDomPrecision(bounds.minY - 100)}
@@ -967,23 +903,11 @@ const ArrowSvg = track(function ArrowSvg({
 					/>
 					<path d={path} strokeDasharray={strokeDasharray} strokeDashoffset={strokeDashoffset} />
 				</g>
-				{as && clipStartArrowhead && shape.props.fill !== 'none' && (
-					<ShapeFill
-						theme={theme}
-						d={as}
-						color={shape.props.color}
-						fill={shape.props.fill}
-						scale={shape.props.scale}
-					/>
+				{as && maskStartArrowhead && shape.props.fill !== 'none' && (
+					<ShapeFill theme={theme} d={as} color={shape.props.color} fill={shape.props.fill} />
 				)}
-				{ae && clipEndArrowhead && shape.props.fill !== 'none' && (
-					<ShapeFill
-						theme={theme}
-						d={ae}
-						color={shape.props.color}
-						fill={shape.props.fill}
-						scale={shape.props.scale}
-					/>
+				{ae && maskEndArrowhead && shape.props.fill !== 'none' && (
+					<ShapeFill theme={theme} d={ae} color={shape.props.color} fill={shape.props.fill} />
 				)}
 				{as && <path d={as} />}
 				{ae && <path d={ae} />}
@@ -992,30 +916,6 @@ const ArrowSvg = track(function ArrowSvg({
 	)
 })
 
-function ArrowClipPath({
-	hasText,
-	bounds,
-	labelBounds,
-	as,
-	ae,
-}: {
-	hasText: boolean
-	bounds: Box
-	labelBounds: Box
-	as: string
-	ae: string
-}) {
-	// The direction in which we create the different path parts is important, as it determines what gets clipped.
-	// See the description on the directions in the non-zero fill rule example:
-	// https://developer.mozilla.org/en-US/docs/Web/tldraw_packages_tldraw_src_lib_shapes_arrow_ArrowShapeUtil.tsx_extracted.txt (actual): ''}${as}${ae}`} />
-}
-
 const shapeAtTranslationStart = new WeakMap<
 	TLArrowShape,
 	{
@@ -1032,18 +932,16 @@ const shapeAtTranslationStart = new WeakMap<
 >()
 
 function ArrowheadDotDef() {
-	const id = useSharedSafeId('arrowhead-dot')
 	return (
-		<marker id={id} className="tl-arrow-hint" refX="3.0" refY="3.0" orient="0">
+		<marker id="arrowhead-dot" className="tl-arrow-hint" refX="3.0" refY="3.0" orient="0">
 			<circle cx="3" cy="3" r="2" strokeDasharray="100%" />
 		</marker>
 	)
 }
 
 function ArrowheadCrossDef() {
-	const id = useSharedSafeId('arrowhead-cross')
 	return (
-		<marker id={id} className="tl-arrow-hint" refX="3.0" refY="3.0" orient="auto">
+		<marker id="arrowhead-cross" className="tl-arrow-hint" refX="3.0" refY="3.0" orient="auto">
 			<line x1="1.5" y1="1.5" x2="4.5" y2="4.5" strokeDasharray="100%" />
 			<line x1="1.5" y1="4.5" x2="4.5" y2="1.5" strokeDasharray="100%" />
 		</marker>
