
index e34dd9818..37eef6e9c 100644
--- a/tldraw_packages_tldraw_src_lib_shapes_arrow_ArrowShapeUtil.tsx_expectedoutput.txt (expected):tmp/tmp_8jbxshw_expected.txt	
+++ b/tldraw_packages_tldraw_src_lib_shapes_arrow_ArrowShapeUtil.tsx_extracted.txt (actual):tmp/tmpmn_dkig5_actual.txt	
@@ -21,6 +21,19 @@ import {
 	TLShapeUtilCanBeLaidOutOpts,
 	TLShapeUtilCanBindOpts,
 	TLShapeUtilCanvasSvgDef,
+	TLShapeUtilFlag,
+	TLShapeUtilGetGeoLabelHeightOpts,
+	TLShapeUtilGetGeoLabelWidthOpts,
+	TLShapeUtilGetLabelWidthOpts,
+	TLShapeUtilGetLabelWrapSizeOpts,
+	TLShapeUtilGetOutlineOpts,
+	TLShapeUtilGetShapeBoundsOpts,
+	TLShapeUtilOnAddToGroupHandler,
+	TLShapeUtilOnPasteHandler,
+	TLShapeUtilOnSnapToHandler,
+	TLShapeUtilOnTranslateStartHandler,
+	TLShapeUtilPoint,
+	TLShapeUtilToExportFns,
 	Vec,
 	WeakCache,
 	arrowShapeMigrations,
@@ -31,16 +44,19 @@ import {
 	lerp,
 	mapObjectMapValues,
 	maybeSnapToGrid,
+	objectMapEntries,
 	structuredClone,
 	toDomPrecision,
 	track,
 	useEditor,
 	useIsEditing,
 	useSharedSafeId,
+	useUniqueSafeId,
 	useValue,
 } from '@tldraw/editor'
 import React from 'react'
 import { updateArrowTerminal } from '../../bindings/arrow/ArrowBindingUtil'
+
 import { PlainTextLabel } from '../shared/PlainTextLabel'
 import { ShapeFill } from '../shared/ShapeFill'
 import { SvgTextLabel } from '../shared/SvgTextLabel'
@@ -57,7 +73,6 @@ import {
 	getStraightArrowHandlePath,
 } from './arrowpaths'
 import {
-	TLArrowBindings,
 	createOrUpdateArrowBinding,
 	getArrowBindings,
 	getArrowInfo,
@@ -71,7 +86,8 @@ enum ARROW_HANDLES {
 	END = 'end',
 }
 
-/** @public */
+let globalRenderIndex = 0
+
 export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 	static override type = 'arrow' as const
 	static override props = arrowShapeProps
@@ -80,17 +96,13 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 	override canEdit() {
 		return true
 	}
-	override canBind({ toShapeType }: TLShapeUtilCanBindOpts<TLArrowShape>): boolean {
+	override canBind({ toShapeType }: TLShapeUtilCanBindOpts<TLArrowShape>) {
 		// bindings can go from arrows to shapes, but not from shapes to arrows
 		return toShapeType !== 'arrow'
 	}
 	override canSnap() {
 		return false
 	}
-	override canTabTo(shape: TLArrowShape) {
-		const bindings = getArrowBindings(this.editor, shape)
-		return !!(bindings.start || bindings.end || shape.props.text)
-	}
 	override hideResizeHandles() {
 		return true
 	}
@@ -103,7 +115,6 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 	override hideSelectionBoundsFg() {
 		return true
 	}
-
 	override canBeLaidOut(shape: TLArrowShape, info: TLShapeUtilCanBeLaidOutOpts) {
 		if (info.type === 'flip') {
 			// If we don't have this then the flip will be non-idempotent; that is, the flip will be multipotent, varipotent, or perhaps even omni-potent... and we can't have that
@@ -115,12 +126,14 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		}
 		return true
 	}
-
-	override getFontFaces(shape: TLArrowShape): TLFontFace[] {
+	override canTabTo(shape: TLArrowShape) {
+		const bindings = getArrowBindings(this.editor, shape)
+		return !!(bindings.start || bindings.end || shape.props.text)
+	}
+	override getFontFaces(shape: TLArrowShape) {
 		if (!shape.props.text) return EMPTY_ARRAY
 		return [DefaultFontFaces[`tldraw_${shape.props.font}`].normal.normal]
 	}
-
 	override getDefaultProps(): TLArrowShape['props'] {
 		return {
 			dash: 'draw',
@@ -139,7 +152,6 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			scale: 1,
 		}
 	}
-
 	getGeometry(shape: TLArrowShape) {
 		const info = getArrowInfo(this.editor, shape)!
 
@@ -149,14 +161,14 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			? new Edge2d({
 					start: Vec.From(info.start.point),
 					end: Vec.From(info.end.point),
-				})
+			  })
 			: new Arc2d({
 					center: Vec.Cast(info.handleArc.center),
 					start: Vec.Cast(info.start.point),
 					end: Vec.Cast(info.end.point),
 					sweepFlag: info.bodyArc.sweepFlag,
 					largeArcFlag: info.bodyArc.largeArcFlag,
-				})
+			  })
 
 		let labelGeom
 		if (shape.props.text.trim()) {
@@ -174,9 +186,9 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 
 		return new Group2d({
 			children: [...(labelGeom ? [bodyGeom, labelGeom] : [bodyGeom]), ...debugGeom],
+			isSnappable: false,
 		})
 	}
-
 	override getHandles(shape: TLArrowShape): TLHandle[] {
 		const info = getArrowInfo(this.editor, shape)!
 
@@ -204,11 +216,6 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			},
 		].filter(Boolean) as TLHandle[]
 	}
-
-	override getText(shape: TLArrowShape) {
-		return shape.props.text
-	}
-
 	override onHandleDrag(
 		shape: TLArrowShape,
 		{ handle, isPrecise }: TLHandleDragInfo<TLArrowShape>
@@ -246,10 +253,10 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			// todo: maybe double check that this isn't equal to the other handle too?
 			// Skip binding
 			removeArrowBinding(this.editor, shape, handleId)
-
+			const newPoint = maybeSnapToGrid(new Vec(handle.x, handle.y), this.editor)
 			update.props![handleId] = {
-				x: handle.x,
-				y: handle.y,
+				x: newPoint.x,
+				y: newPoint.y,
 			}
 			return update
 		}
@@ -283,40 +290,82 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 
 		const targetGeometry = this.editor.getShapeGeometry(target)
 		const targetBounds = Box.ZeroFix(targetGeometry.bounds)
-		const pageTransform = this.editor.getShapePageTransform(update.id)!
-		const pointInPageSpace = pageTransform.applyToPoint(handle)
+		const pointInPageSpace = this.editor.getShapePageTransform(shape.id)!.applyToPoint(handle)
 		const pointInTargetSpace = this.editor.getPointInShapeSpace(target, pointInPageSpace)
 
-		let precise = isPrecise
+		if (!isPrecise) {
+			// If we're switching to a new bound shape, then precise only if moving slowly
+			if (!currentBinding || (currentBinding && target.id !== currentBinding.toId)) {
+				isPrecise = this.editor.inputs.pointerVelocity.len() < 0.5
+			}
+		}
 
-		if (!precise) {
+		if (!isPrecise) {
 			// If we're switching to a new bound shape, then precise only if moving slowly
 			if (!currentBinding || (currentBinding && target.id !== currentBinding.toId)) {
-				precise = this.editor.inputs.pointerVelocity.len() < 0.5
+				isPrecise = this.editor.inputs.pointerVelocity.len() < 0.5
 			}
 		}
 
 		if (!isPrecise) {
-			if (!targetGeometry.isClosed) {
-				precise = true
+			// If we're switching to a new bound shape, then precise only if moving slowly
+			if (!currentBinding || (currentBinding && target.id !== currentBinding.toId)) {
+				isPrecise = this.editor.inputs.pointerVelocity.len() < 0.5
 			}
+		}
 
-			// Double check that we're not going to be doing an imprecise snap on
-			// the same shape twice, as this would result in a zero length line
-			if (otherBinding && target.id === otherBinding.toId && otherBinding.props.isPrecise) {
-				precise = true
+		if (!isPrecise) {
+			// If we're switching to a new bound shape, then precise only if moving slowly
+			if (!currentBinding || (currentBinding && target.id !== currentBinding.toId)) {
+				isPrecise = this.editor.inputs.pointerVelocity.len() < 0.5
 			}
 		}
 
+		if (!isPrecise) {
+			// If we're switching to a new bound shape, then precise only if moving slowly
+			if (!currentBinding || (currentBinding && target.id !== currentBinding.toId)) {
+				isPrecise = this.editor.inputs.pointerVelocity.len() < 0.5
+			}
+		}
+
+		if (!isPrecise) {
+			// If we're switching to a new bound shape, then precise only if moving slowly
+			if (!currentBinding || (currentBinding && target.id !== currentBinding.toId)) {
+				isPrecise = this.editor.inputs.pointerVelocity.len() < 0.5
+			}
+		}
+
+		if (!isPrecise) {
+			// If we're switching to a new bound shape, then precise only if moving slowly
+			if (!currentBinding || (currentBinding && target.id !== currentBinding.toId)) {
+				isPrecise = this.editor.inputs.pointerVelocity.len() < 0.5
+			}
+		}
+
+		if (!isPrecise) {
+			// If we're switching to a new bound shape, then precise only if moving slowly
+			if (!currentBinding || (currentBinding && target.id !== currentBinding.toId)) {
+				isPrecise = this.editor.inputs.pointerVelocity.len() < 0.5
+			}
+		}
+
+		if (!isPrecise) {
+			// If we're switching to a new bound shape, then precise only if moving slowly
+			if (!currentBinding || (currentBinding && target.id !== currentBinding.toId)) {
+				isPrecise = this.editor.inputs.pointerVelocity.len() < 0.5
+			}
+		}
+
+		if (otherBinding && target.id === otherBinding.toId && otherBinding.props.isPrecise) {
+			isPrecise = true
+		}
+
 		const normalizedAnchor = {
 			x: (pointInTargetSpace.x - targetBounds.minX) / targetBounds.width,
 			y: (pointInTargetSpace.y - targetBounds.minY) / targetBounds.height,
 		}
 
-		if (precise) {
-			// Turn off precision if we're within a certain distance to the center of the shape.
-			// Funky math but we want the snap distance to be 4 at the minimum and either
-			// 16 or 15% of the smaller dimension of the target shape, whichever is smaller
+		if (isPrecise) {
 			if (
 				Vec.Dist(pointInTargetSpace, targetBounds.center) <
 				Math.max(4, Math.min(Math.min(targetBounds.width, targetBounds.height) * 0.15, 16)) /
@@ -327,14 +376,12 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			}
 		}
 
-		const b = {
+		createOrUpdateArrowBinding(this.editor, shape, target.id, {
 			terminal: handleId,
 			normalizedAnchor,
-			isPrecise: precise,
+			isPrecise,
 			isExact: this.editor.inputs.altKey,
-		}
-
-		createOrUpdateArrowBinding(this.editor, shape, target.id, b)
+		})
 
 		this.editor.setHintingShapes([target.id])
 
@@ -355,7 +402,6 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 
 		return update
 	}
-
 	override onTranslateStart(shape: TLArrowShape) {
 		const bindings = getArrowBindings(this.editor, shape)
 
@@ -366,7 +412,6 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		// If no bound shapes are in the selection, unbind any bound shapes
 
 		const selectedShapeIds = this.editor.getSelectedShapeIds()
-
 		if (
 			(bindings.start &&
 				(selectedShapeIds.includes(bindings.start.toId) ||
@@ -378,12 +423,10 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			return
 		}
 
-		// When we start translating shapes, record where their bindings were in page space so we
-		// can maintain them as we translate the arrow
 		shapeAtTranslationStart.set(shape, {
 			pagePosition: shapePageTransform.applyToPoint(shape),
 			terminalBindings: mapObjectMapValues(terminalsInArrowSpace, (terminalName, point) => {
-				const binding = bindings[terminalName]
+				const binding = bindings[terminalName as keyof TLArrowBindings]
 				if (!binding) return null
 				return {
 					binding,
@@ -393,25 +436,6 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			}),
 		})
 
-		// update arrow terminal bindings eagerly to make sure the arrows unbind nicely when translating
-		if (bindings.start) {
-			updateArrowTerminal({
-				editor: this.editor,
-				arrow: shape,
-				terminal: 'start',
-				useHandle: true,
-			})
-			shape = this.editor.getShape(shape.id) as TLArrowShape
-		}
-		if (bindings.end) {
-			updateArrowTerminal({
-				editor: this.editor,
-				arrow: shape,
-				terminal: 'end',
-				useHandle: true,
-			})
-		}
-
 		for (const handleName of [ARROW_HANDLES.START, ARROW_HANDLES.END] as const) {
 			const binding = bindings[handleName]
 			if (!binding) continue
@@ -421,17 +445,13 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 				props: { ...binding.props, isPrecise: true },
 			})
 		}
-
-		return
 	}
-
 	override onTranslate(initialShape: TLArrowShape, shape: TLArrowShape) {
 		const atTranslationStart = shapeAtTranslationStart.get(initialShape)
 		if (!atTranslationStart) return
 
-		const shapePageTransform = this.editor.getShapePageTransform(shape.id)!
 		const pageDelta = Vec.Sub(
-			shapePageTransform.applyToPoint(shape),
+			this.editor.getShapePageTransform(shape.id)!.applyToPoint(shape),
 			atTranslationStart.pagePosition
 		)
 
@@ -439,15 +459,13 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			if (!terminalBinding) continue
 
 			const newPagePoint = Vec.Add(terminalBinding.pagePosition, Vec.Mul(pageDelta, 0.5))
+
 			const newTarget = this.editor.getShapeAtPoint(newPagePoint, {
 				hitInside: true,
 				hitFrameInside: true,
 				margin: 0,
 				filter: (targetShape) => {
-					return (
-						!targetShape.isLocked &&
-						this.editor.canBindShapes({ fromShape: shape, toShape: targetShape, binding: 'arrow' })
-					)
+					return !targetShape.isLocked && this.editor.canBindShapes({ fromShape: shape, toShape: targetShape, binding: 'arrow' })
 				},
 			})
 
@@ -468,9 +486,10 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			}
 		}
 	}
-
 	private readonly _resizeInitialBindings = new WeakCache<TLArrowShape, TLArrowBindings>()
-
+	override onResizeStart(shape: TLArrowShape) {
+		this._resizeInitialBindings.set(shape, getArrowBindings(this.editor, shape))
+	}
 	override onResize(shape: TLArrowShape, info: TLResizeInfo<TLArrowShape>) {
 		const { scaleX, scaleY } = info
 
@@ -494,73 +513,55 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			end.y = terminals.end.y * scaleY
 		}
 
-		// todo: we should only change the normalized anchor positions
-		// of the shape's handles if the bound shape is also being resized
-
 		const mx = Math.abs(scaleX)
 		const my = Math.abs(scaleY)
 
-		const startNormalizedAnchor = bindings?.start
-			? Vec.From(bindings.start.props.normalizedAnchor)
-			: null
-		const endNormalizedAnchor = bindings?.end ? Vec.From(bindings.end.props.normalizedAnchor) : null
-
 		if (scaleX < 0 && scaleY >= 0) {
 			if (bend !== 0) {
 				bend *= -1
 				bend *= Math.max(mx, my)
 			}
-
-			if (startNormalizedAnchor) {
-				startNormalizedAnchor.x = 1 - startNormalizedAnchor.x
+			if (bindings.start) {
+				bindings.start.props.normalizedAnchor.x = 1 - bindings.start.props.normalizedAnchor.x
 			}
-
-			if (endNormalizedAnchor) {
-				endNormalizedAnchor.x = 1 - endNormalizedAnchor.x
+			if (bindings.end) {
+				bindings.end.props.normalizedAnchor.x = 1 - bindings.end.props.normalizedAnchor.x
 			}
 		} else if (scaleX >= 0 && scaleY < 0) {
 			if (bend !== 0) {
 				bend *= -1
 				bend *= Math.max(mx, my)
 			}
-
-			if (startNormalizedAnchor) {
-				startNormalizedAnchor.y = 1 - startNormalizedAnchor.y
+			if (bindings.start) {
+				bindings.start.props.normalizedAnchor.y = 1 - bindings.start.props.normalizedAnchor.y
 			}
-
-			if (endNormalizedAnchor) {
-				endNormalizedAnchor.y = 1 - endNormalizedAnchor.y
+			if (bindings.end) {
+				bindings.end.props.normalizedAnchor.y = 1 - bindings.end.props.normalizedAnchor.y
 			}
 		} else if (scaleX >= 0 && scaleY >= 0) {
 			if (bend !== 0) {
 				bend *= Math.max(mx, my)
 			}
-		} else if (scaleX < 0 && scaleY < 0) {
-			if (bend !== 0) {
-				bend *= Math.max(mx, my)
+			if (bindings.start) {
+				bindings.start.props.normalizedAnchor.x = 1 - bindings.start.props.normalizedAnchor.x
+				bindings.start.props.normalizedAnchor.y = 1 - bindings.start.props.normalizedAnchor.y
 			}
-
-			if (startNormalizedAnchor) {
-				startNormalizedAnchor.x = 1 - startNormalizedAnchor.x
-				startNormalizedAnchor.y = 1 - startNormalizedAnchor.y
-			}
-
-			if (endNormalizedAnchor) {
-				endNormalizedAnchor.x = 1 - endNormalizedAnchor.x
-				endNormalizedAnchor.y = 1 - endNormalizedAnchor.y
+			if (bindings.end) {
+				bindings.end.props.normalizedAnchor.x = 1 - bindings.end.props.normalizedAnchor.x
+				bindings.end.props.normalizedAnchor.y = 1 - bindings.end.props.normalizedAnchor.y
 			}
 		}
 
-		if (bindings.start && startNormalizedAnchor) {
+		if (bindings.start) {
 			createOrUpdateArrowBinding(this.editor, shape, bindings.start.toId, {
 				...bindings.start.props,
-				normalizedAnchor: startNormalizedAnchor.toJson(),
+				normalizedAnchor: bindings.start.props.normalizedAnchor,
 			})
 		}
-		if (bindings.end && endNormalizedAnchor) {
+		if (bindings.end) {
 			createOrUpdateArrowBinding(this.editor, shape, bindings.end.toId, {
 				...bindings.end.props,
-				normalizedAnchor: endNormalizedAnchor.toJson(),
+				normalizedAnchor: bindings.end.props.normalizedAnchor,
 			})
 		}
 
@@ -574,7 +575,6 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 
 		return next
 	}
-
 	override onDoubleClickHandle(
 		shape: TLArrowShape,
 		handle: TLHandle
@@ -602,10 +602,109 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			}
 		}
 	}
-
-	component(shape: TLArrowShape) {
+	override indicator(shape: TLArrowShape) {
 		// eslint-disable-next-line react-hooks/rules-of-hooks
-		const theme = useDefaultColorTheme()
+		const isEditing = useIsEditing(shape.id)
+
+		const info = getArrowInfo(this.editor, shape)
+		if (!info) return null
+		if (Vec.Equals(info.start.point, info.end.point)) return null
+
+		const strokeWidth = STROKE_SIZES[shape.props.size] * shape.props.scale
+
+		const as = info.start.arrowhead && getArrowheadPathForType(info, 'start', strokeWidth)
+		const ae = info.end.arrowhead && getArrowheadPathForType(info, 'end', strokeWidth)
+
+		const path = info.isStraight ? getSolidStraightArrowPath(info) : getSolidCurvedArrowPath(info)
+
+		const labelPosition = getArrowLabelPosition(this.editor, shape)
+
+		const clipPathId = useSharedSafeId(shape.id + '_clip')
+
+		return (
+			<>
+				{/* Yep */}
+				<defs>
+					<clipPath id={clipPathId}>
+						<ArrowClipPath
+							hasText={shape.props.text.trim().length > 0}
+							bounds={Box.ZeroFix(this.editor.getShapeGeometry(shape).bounds)}
+							labelBounds={shape.props.text.trim() ? labelPosition.box : new Box(0, 0, 0, 0)}
+							as={as && !(info.start.arrowhead === 'arrow') ? as : ''}
+							ae={ae && !(info.end.arrowhead === 'arrow') ? ae : ''}
+						/>
+					</clipPath>
+				</defs>
+				<g
+					fill="none"
+					stroke={useDefaultColorTheme()[shape.props.color].solid}
+					strokeWidth={strokeWidth}
+					strokeLinejoin="round"
+					strokeLinecap="round"
+					pointerEvents="none"
+				>
+					{as && shape.props.fill !== 'none' && (
+						<ShapeFill
+							theme={useDefaultColorTheme()}
+							d={as}
+							color={shape.props.color}
+							fill={shape.props.fill}
+							scale={shape.props.scale}
+						/>
+					)}
+					{ae && shape.props.fill !== 'none' && (
+						<ShapeFill
+							theme={useDefaultColorTheme()}
+							d={ae}
+							color={shape.props.color}
+							fill={shape.props.fill}
+							scale={shape.props.scale}
+						/>
+					)}
+					<g style={{ clipPath: `url(#${clipPathId})` }}>
+						<path d={path} />
+					</g>
+				</g>
+			</>
+		)
+	}
+	override getCanvasSvgDefs(): TLShapeUtilCanvasSvgDef[] {
+		return [
+			getFillDefForCanvas(),
+			{
+				key: `arrow:dot`,
+				component: ArrowheadDotDef,
+			},
+			{
+				key: `arrow:cross`,
+				component: ArrowheadCrossDef,
+			},
+		]
+	}
+	override getText(shape: TLArrowShape) {
+		return shape.props.text
+	}
+	override getInterpolatedProps(
+		startShape: TLArrowShape,
+		endShape: TLArrowShape,
+		progress: number
+	): TLArrowShapeProps {
+		return {
+			...(progress > 0.5 ? endShape.props : startShape.props),
+			scale: lerp(startShape.props.scale, endShape.props.scale, progress),
+			start: {
+				x: lerp(startShape.props.start.x, endShape.props.start.x, progress),
+				y: lerp(startShape.props.start.y, endShape.props.start.y, progress),
+			},
+			end: {
+				x: lerp(startShape.props.end.x, endShape.props.end.x, progress),
+				y: lerp(startShape.props.end.y, endShape.props.end.y, progress),
+			},
+			bend: lerp(startShape.props.bend, endShape.props.bend, progress),
+			labelPosition: lerp(startShape.props.labelPosition, endShape.props.labelPosition, progress),
+		}
+	}
+	override component(shape: TLArrowShape) {
 		const onlySelectedShape = this.editor.getOnlySelectedShape()
 		const shouldDisplayHandles =
 			this.editor.isInAny(
@@ -614,13 +713,12 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 				'select.dragging_handle',
 				'select.translating',
 				'arrow.dragging'
-			) && !this.editor.getIsReadonly()
+			) && !this.editor.getInstanceState().isReadonly
 
 		const info = getArrowInfo(this.editor, shape)
 		if (!info?.isValid) return null
 
 		const labelPosition = getArrowLabelPosition(this.editor, shape)
-		const isSelected = shape.id === this.editor.getOnlySelectedShapeId()
 		const isEditing = this.editor.getEditingShapeId() === shape.id
 		const showArrowLabel = isEditing || shape.props.text
 
@@ -643,9 +741,9 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 						align="middle"
 						verticalAlign="middle"
 						text={shape.props.text}
-						labelColor={theme[shape.props.labelColor].solid}
-						textWidth={labelPosition.box.w - ARROW_LABEL_PADDING * 2 * shape.props.scale}
-						isSelected={isSelected}
+						labelColor={useDefaultColorTheme()[shape.props.labelColor].solid}
+						textWidth={labelPosition.box.w}
+						isSelected={onlySelectedShape?.id === shape.id}
 						padding={0}
 						style={{
 							transform: `translate(${labelPosition.box.center.x}px, ${labelPosition.box.center.y}px)`,
@@ -655,121 +753,6 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			</>
 		)
 	}
-
-	indicator(shape: TLArrowShape) {
-		// eslint-disable-next-line react-hooks/rules-of-hooks
-		const isEditing = useIsEditing(shape.id)
-		// eslint-disable-next-line react-hooks/rules-of-hooks
-		const clipPathId = useSharedSafeId(shape.id + '_clip')
-
-		const info = getArrowInfo(this.editor, shape)
-		if (!info) return null
-
-		const { start, end } = getArrowTerminalsInArrowSpace(this.editor, shape, info?.bindings)
-		const geometry = this.editor.getShapeGeometry<Group2d>(shape)
-		const bounds = geometry.bounds
-
-		const labelGeometry = shape.props.text.trim() ? (geometry.children[1] as Rectangle2d) : null
-
-		if (Vec.Equals(start, end)) return null
-
-		const strokeWidth = STROKE_SIZES[shape.props.size] * shape.props.scale
-
-		const as = info.start.arrowhead && getArrowheadPathForType(info, 'start', strokeWidth)
-		const ae = info.end.arrowhead && getArrowheadPathForType(info, 'end', strokeWidth)
-
-		const path = info.isStraight ? getSolidStraightArrowPath(info) : getSolidCurvedArrowPath(info)
-
-		const includeClipPath =
-			(as && info.start.arrowhead !== 'arrow') ||
-			(ae && info.end.arrowhead !== 'arrow') ||
-			!!labelGeometry
-
-		if (isEditing && labelGeometry) {
-			return (
-				<rect
-					x={toDomPrecision(labelGeometry.x)}
-					y={toDomPrecision(labelGeometry.y)}
-					width={labelGeometry.w}
-					height={labelGeometry.h}
-					rx={3.5 * shape.props.scale}
-					ry={3.5 * shape.props.scale}
-				/>
-			)
-		}
-		const clipStartArrowhead = !(
-			info.start.arrowhead === 'none' || info.start.arrowhead === 'arrow'
-		)
-		const clipEndArrowhead = !(info.end.arrowhead === 'none' || info.end.arrowhead === 'arrow')
-
-		return (
-			<g>
-				{includeClipPath && (
-					<defs>
-						<ArrowClipPath
-							hasText={shape.props.text.trim().length > 0}
-							bounds={bounds}
-							labelBounds={labelGeometry ? labelGeometry.getBounds() : new Box(0, 0, 0, 0)}
-							as={clipStartArrowhead && as ? as : ''}
-							ae={clipEndArrowhead && ae ? ae : ''}
-						/>
-					</defs>
-				)}
-				<g
-					style={{
-						clipPath: includeClipPath ? `url(#${clipPathId})` : undefined,
-						WebkitClipPath: includeClipPath ? `url(#${clipPathId})` : undefined,
-					}}
-				>
-					{/* This rect needs to be here if we're creating a mask due to an svg quirk on Chrome */}
-					{includeClipPath && (
-						<rect
-							x={bounds.minX - 100}
-							y={bounds.minY - 100}
-							width={bounds.width + 200}
-							height={bounds.height + 200}
-							opacity={0}
-						/>
-					)}
-
-					<path d={path} />
-				</g>
-				{as && <path d={as} />}
-				{ae && <path d={ae} />}
-				{labelGeometry && (
-					<rect
-						x={toDomPrecision(labelGeometry.x)}
-						y={toDomPrecision(labelGeometry.y)}
-						width={labelGeometry.w}
-						height={labelGeometry.h}
-						rx={3.5}
-						ry={3.5}
-					/>
-				)}
-			</g>
-		)
-	}
-
-	override onEditEnd(shape: TLArrowShape) {
-		const {
-			id,
-			type,
-			props: { text },
-		} = shape
-
-		if (text.trimEnd() !== shape.props.text) {
-			this.editor.updateShapes<TLArrowShape>([
-				{
-					id,
-					type,
-					props: {
-						text: text.trimEnd(),
-					},
-				},
-			])
-		}
-	}
-
 	override toSvg(shape: TLArrowShape, ctx: SvgExportContext) {
 		ctx.addExportDef(getFillDefForExport(shape.props.fill))
 		const theme = getDefaultColorTheme(ctx)
@@ -785,51 +768,15 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 					verticalAlign="middle"
 					text={shape.props.text}
 					labelColor={theme[shape.props.labelColor].solid}
-					bounds={getArrowLabelPosition(this.editor, shape)
-						.box.clone()
-						.expandBy(-ARROW_LABEL_PADDING * shape.props.scale)}
-					padding={0}
+					bounds={getArrowLabelPosition(this.editor, shape).box}
+					padding={4 * shape.props.scale}
 				/>
 			</g>
 		)
 	}
-
-	override getCanvasSvgDefs(): TLShapeUtilCanvasSvgDef[] {
-		return [
-			getFillDefForCanvas(),
-			{
-				key: `arrow:dot`,
-				component: ArrowheadDotDef,
-			},
-			{
-				key: `arrow:cross`,
-				component: ArrowheadCrossDef,
-			},
-		]
-	}
-	override getInterpolatedProps(
-		startShape: TLArrowShape,
-		endShape: TLArrowShape,
-		progress: number
-	): TLArrowShapeProps {
-		return {
-			...(progress > 0.5 ? endShape.props : startShape.props),
-			scale: lerp(startShape.props.scale, endShape.props.scale, progress),
-			start: {
-				x: lerp(startShape.props.start.x, endShape.props.start.x, progress),
-				y: lerp(startShape.props.start.y, endShape.props.start.y, progress),
-			},
-			end: {
-				x: lerp(startShape.props.end.x, endShape.props.end.x, progress),
-				y: lerp(startShape.props.end.y, endShape.props.end.y, progress),
-			},
-			bend: lerp(startShape.props.bend, endShape.props.bend, progress),
-			labelPosition: lerp(startShape.props.labelPosition, endShape.props.labelPosition, progress),
-		}
-	}
 }
 
-export function getArrowLength(editor: Editor, shape: TLArrowShape): number {
+function getArrowLength(editor: Editor, shape: TLArrowShape): number {
 	const info = getArrowInfo(editor, shape)!
 
 	return info.isStraight
@@ -849,13 +796,6 @@ const ArrowSvg = track(function ArrowSvg({
 	const info = getArrowInfo(editor, shape)
 	const bounds = Box.ZeroFix(editor.getShapeGeometry(shape).bounds)
 	const bindings = getArrowBindings(editor, shape)
-	const isForceSolid = useValue(
-		'force solid',
-		() => {
-			return editor.getZoomLevel() < 0.2
-		},
-		[editor]
-	)
 
 	const clipPathId = useSharedSafeId(shape.id + '_clip')
 	const arrowheadDotId = useSharedSafeId('arrowhead-dot')
@@ -870,6 +810,23 @@ const ArrowSvg = track(function ArrowSvg({
 
 	const path = info.isStraight ? getSolidStraightArrowPath(info) : getSolidCurvedArrowPath(info)
 
+	const includeClipPath =
+		(as && info.start.arrowhead !== 'arrow') ||
+		(ae && info.end.arrowhead !== 'arrow') ||
+		!!shape.props.text.trim()
+
+	const clipStartArrowhead = !(info.start.arrowhead === 'none' || info.start.arrowhead === 'arrow')
+	const clipEndArrowhead = !(info.end.arrowhead === 'none' || info.end.arrowhead === 'arrow')
+
+	const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
+		getArrowLength(editor, shape),
+		2 / editor.getZoomLevel(),
+		{
+			style: shape.props.dash,
+			forceSolid: editor.getZoomLevel() < 0.2,
+		}
+	)
+
 	let handlePath: null | React.JSX.Element = null
 
 	if (shouldDisplayHandles) {
@@ -884,51 +841,20 @@ const ArrowSvg = track(function ArrowSvg({
 			}
 		)
 
-		handlePath =
-			bindings.start || bindings.end ? (
-				<path
-					className="tl-arrow-hint"
-					d={info.isStraight ? getStraightArrowHandlePath(info) : getCurvedArrowHandlePath(info)}
-					strokeDasharray={strokeDasharray}
-					strokeDashoffset={strokeDashoffset}
-					strokeWidth={sw}
-					markerStart={
-						bindings.start
-							? bindings.start.props.isExact
-								? ''
-								: bindings.start.props.isPrecise
-									? `url(#${arrowheadCrossId})`
-									: `url(#${arrowheadDotId})`
-							: ''
-					}
-					markerEnd={
-						bindings.end
-							? bindings.end.props.isExact
-								? ''
-								: bindings.end.props.isPrecise
-									? `url(#${arrowheadCrossId})`
-									: `url(#${arrowheadDotId})`
-							: ''
-					}
-					opacity={0.16}
-				/>
-			) : null
+		handlePath = (
+			<path
+				className="tl-arrow-hint"
+				d={info.isStraight ? getStraightArrowHandlePath(info) : getCurvedArrowHandlePath(info)}
+				strokeDasharray={strokeDasharray}
+				strokeDashoffset={strokeDashoffset}
+				strokeWidth={sw}
+				markerStart={bindings.start ? (bindings.start.props.isExact ? '' : bindings.start.props.isPrecise ? `url(#${arrowheadCrossId})` : `url(#${arrowheadDotId})`) : ''}
+				markerEnd={bindings.end ? (bindings.end.props.isExact ? '' : bindings.end.props.isPrecise ? `url(#${arrowheadCrossId})` : `url(#${arrowheadDotId})`) : ''}
+				opacity={0.16}
+			/>
+		)
 	}
 
-	const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
-		info.isStraight ? info.length : Math.abs(info.bodyArc.length),
-		strokeWidth,
-		{
-			style: shape.props.dash,
-			forceSolid: isForceSolid,
-		}
-	)
-
-	const labelPosition = getArrowLabelPosition(editor, shape)
-
-	const clipStartArrowhead = !(info.start.arrowhead === 'none' || info.start.arrowhead === 'arrow')
-	const clipEndArrowhead = !(info.end.arrowhead === 'none' || info.end.arrowhead === 'arrow')
-
 	return (
 		<>
 			{/* Yep */}
@@ -937,7 +863,7 @@ const ArrowSvg = track(function ArrowSvg({
 					<ArrowClipPath
 						hasText={shape.props.text.trim().length > 0}
 						bounds={bounds}
-						labelBounds={labelPosition.box}
+						labelBounds={shape.props.text.trim() ? editor.getShapeGeometry<Group2d>(shape).children[1]?.getBounds() ?? new Box(0, 0, 0, 0) : new Box(0, 0, 0, 0)}
 						as={clipStartArrowhead && as ? as : ''}
 						ae={clipEndArrowhead && ae ? ae : ''}
 					/>
@@ -952,38 +878,14 @@ const ArrowSvg = track(function ArrowSvg({
 				pointerEvents="none"
 			>
 				{handlePath}
-				<g
-					style={{
-						clipPath: `url(#${clipPathId})`,
-						WebkitClipPath: `url(#${clipPathId})`,
-					}}
-				>
-					<rect
-						x={toDomPrecision(bounds.minX - 100)}
-						y={toDomPrecision(bounds.minY - 100)}
-						width={toDomPrecision(bounds.width + 200)}
-						height={toDomPrecision(bounds.height + 200)}
-						opacity={0}
-					/>
+				<g style={{ clipPath: `url(#${clipPathId})` }}>
 					<path d={path} strokeDasharray={strokeDasharray} strokeDashoffset={strokeDashoffset} />
 				</g>
 				{as && clipStartArrowhead && shape.props.fill !== 'none' && (
-					<ShapeFill
-						theme={theme}
-						d={as}
-						color={shape.props.color}
-						fill={shape.props.fill}
-						scale={shape.props.scale}
-					/>
+					<ShapeFill theme={theme} d={as} color={shape.props.color} fill={shape.props.fill} scale={shape.props.scale} />
 				)}
 				{ae && clipEndArrowhead && shape.props.fill !== 'none' && (
-					<ShapeFill
-						theme={theme}
-						d={ae}
-						color={shape.props.color}
-						fill={shape.props.fill}
-						scale={shape.props.scale}
-					/>
+					<ShapeFill theme={theme} d={ae} color={shape.props.color} fill={shape.props.fill} scale={shape.props.scale} />
 				)}
 				{as && <path d={as} />}
 				{ae && <path d={ae} />}
@@ -1005,31 +907,52 @@ function ArrowClipPath({
 	as: string
 	ae: string
 }) {
-	// The direction in which we create the different path parts is important, as it determines what gets clipped.
-	// See the description on the directions in the non-zero fill rule example:
-	// https://developer.mozilla.org/en-US/docs/Web/tldraw_packages_tldraw_src_lib_shapes_arrow_ArrowShapeUtil.tsx_extracted.txt (actual): ''}${as}${ae}`} />
-}
+	if (hasText) {
+		// There doesn't seem to be an easy way to invert a clipPath, so we instead create this complex polygon.
+		// We create the three sides of the outer rectangle in the clockwise direction, then move to the inside rectangle
+		// and create that one in the counterclockwise direction (so we don't intersect and complete the path).
+		// We then finish with the outer rectangle. Diagram shows the order of the points.
+		//
+		//    (1, 11)--------------------------(2)
+		//       |                              |
+		//       |         Outer Rect           |
+		//       |                            	|
+		//       |  (8)-------------------(7)   |
+		//       |    |                    |    |
+		//       |    |                    |    |
+		//       |    |    Inner Rect      |    |
+		//       |    |                    |    |
+		//       |    |                    |    |
+		//       |  (5,9)-----------------(6)   |
+		//    (4, 10)--------------------------(3)
 
-const shapeAtTranslationStart = new WeakMap<
-	TLArrowShape,
-	{
-		pagePosition: Vec
-		terminalBindings: Record<
-			'start' | 'end',
-			{
-				pagePosition: Vec
-				shapePosition: Vec
-				binding: TLArrowBinding
-			} | null
-		>
+		return (
+			<polygon
+				points={`
+        ${toDomPrecision(bounds.minX - 100)},${toDomPrecision(bounds.minY - 100)} 
+        ${toDomPrecision(bounds.minX + bounds.width + 100)},${toDomPrecision(bounds.minY - 100)} 
+        ${toDomPrecision(bounds.minX + bounds.width + 100)},${toDomPrecision(bounds.minY + bounds.height + 100)}
+        ${toDomPrecision(bounds.minX - 100)},${toDomPrecision(bounds.minY + bounds.height + 100)}
+        ${labelBounds.minX},${labelBounds.minY + labelBounds.height}
+        ${labelBounds.minX + labelBounds.width},${labelBounds.minY + labelBounds.height}
+        ${labelBounds.minX + labelBounds.width},${labelBounds.minY}
+        ${labelBounds.minX},${labelBounds.minY}
+        ${labelBounds.minX},${labelBounds.minY + labelBounds.height}
+        ${toDomPrecision(bounds.minX - 100)},${toDomPrecision(bounds.minY + bounds.height + 100)}
+        ${toDomPrecision(bounds.minX - 100)},${toDomPrecision(bounds.minY - 100)} 
+      `}
+			/>
+		)
 	}
->()
+	return (
+		<rect
+			x={toDomPrecision(bounds.minX - 100)}
+			y={toDomPrecision(bounds.minY - 100)}
+			width={toDomPrecision(bounds.width + 200)}
+			height={toDomPrecision(bounds.height + 200)}
+		/>
+	)
+}
 
 function ArrowheadDotDef() {
 	const id = useSharedSafeId('arrowhead-dot')
@@ -1048,4 +971,19 @@ function ArrowheadCrossDef() {
 			<line x1="1.5" y1="4.5" x2="4.5" y2="1.5" strokeDasharray="100%" />
 		</marker>
 	)
-}
\ No newline at end of file
+}
+
+const shapeAtTranslationStart = new WeakMap<
+	TLArrowShape,
+	{
+		pagePosition: Vec
+		terminalBindings: Record<
+			'start' | 'end',
+			{
+				pagePosition: Vec
+				shapePosition: Vec
+				binding: TLArrowBinding
+			} | null
+		>
+	}
+>()
\ No newline at end of file
