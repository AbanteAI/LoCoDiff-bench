
index e34dd9818..1758ae32d 100644
--- a/tldraw_packages_tldraw_src_lib_shapes_arrow_ArrowShapeUtil.tsx_expectedoutput.txt (expected):tmp/tmp7b1sv36g_expected.txt	
+++ b/tldraw_packages_tldraw_src_lib_shapes_arrow_ArrowShapeUtil.tsx_extracted.txt (actual):tmp/tmpzyfz5ccj_actual.txt	
@@ -41,6 +41,7 @@ import {
 } from '@tldraw/editor'
 import React from 'react'
 import { updateArrowTerminal } from '../../bindings/arrow/ArrowBindingUtil'
+
 import { PlainTextLabel } from '../shared/PlainTextLabel'
 import { ShapeFill } from '../shared/ShapeFill'
 import { SvgTextLabel } from '../shared/SvgTextLabel'
@@ -56,6 +57,7 @@ import {
 	getSolidStraightArrowPath,
 	getStraightArrowHandlePath,
 } from './arrowpaths'
+import { ArrowTextLabel } from './components/ArrowTextLabel'
 import {
 	TLArrowBindings,
 	createOrUpdateArrowBinding,
@@ -65,6 +67,8 @@ import {
 	removeArrowBinding,
 } from './shared'
 
+export const ARROW_END_OFFSET = 0.1
+
 enum ARROW_HANDLES {
 	START = 'start',
 	MIDDLE = 'middle',
@@ -149,14 +153,15 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			? new Edge2d({
 					start: Vec.From(info.start.point),
 					end: Vec.From(info.end.point),
-				})
+			  })
 			: new Arc2d({
 					center: Vec.Cast(info.handleArc.center),
+					radius: info.handleArc.radius,
 					start: Vec.Cast(info.start.point),
 					end: Vec.Cast(info.end.point),
 					sweepFlag: info.bodyArc.sweepFlag,
 					largeArcFlag: info.bodyArc.largeArcFlag,
-				})
+			  })
 
 		let labelGeom
 		if (shape.props.text.trim()) {
@@ -174,6 +179,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 
 		return new Group2d({
 			children: [...(labelGeom ? [bodyGeom, labelGeom] : [bodyGeom]), ...debugGeom],
+			isSnappable: false,
 		})
 	}
 
@@ -187,6 +193,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 				index: 'a0',
 				x: info.start.handle.x,
 				y: info.start.handle.y,
+				canBind: true,
 			},
 			{
 				id: ARROW_HANDLES.MIDDLE,
@@ -194,6 +201,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 				index: 'a2',
 				x: info.middle.x,
 				y: info.middle.y,
+				canBind: false,
 			},
 			{
 				id: ARROW_HANDLES.END,
@@ -201,6 +209,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 				index: 'a3',
 				x: info.end.handle.x,
 				y: info.end.handle.y,
+				canBind: true,
 			},
 		].filter(Boolean) as TLHandle[]
 	}
@@ -247,9 +256,10 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			// Skip binding
 			removeArrowBinding(this.editor, shape, handleId)
 
+			const newPoint = maybeSnapToGrid(new Vec(handle.x, handle.y), this.editor)
 			update.props![handleId] = {
-				x: handle.x,
-				y: handle.y,
+				x: newPoint.x,
+				y: newPoint.y,
 			}
 			return update
 		}
@@ -271,6 +281,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		if (!target) {
 			// todo: maybe double check that this isn't equal to the other handle too?
 			removeArrowBinding(this.editor, shape, handleId)
+
 			const newPoint = maybeSnapToGrid(new Vec(handle.x, handle.y), this.editor)
 			update.props![handleId] = {
 				x: newPoint.x,
@@ -296,14 +307,20 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			}
 		}
 
-		if (!isPrecise) {
+		if (!precise) {
 			if (!targetGeometry.isClosed) {
 				precise = true
 			}
 
 			// Double check that we're not going to be doing an imprecise snap on
 			// the same shape twice, as this would result in a zero length line
-			if (otherBinding && target.id === otherBinding.toId && otherBinding.props.isPrecise) {
+			const otherHandle =
+				update.props![handleId === ARROW_HANDLES.START ? ARROW_HANDLES.END : ARROW_HANDLES.START]
+			if (
+				otherBinding.type === 'binding' &&
+				target.id === otherBinding.toId &&
+				otherBinding.props.isPrecise
+			) {
 				precise = true
 			}
 		}
@@ -362,17 +379,13 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		const terminalsInArrowSpace = getArrowTerminalsInArrowSpace(this.editor, shape, bindings)
 		const shapePageTransform = this.editor.getShapePageTransform(shape.id)!
 
-		// If at least one bound shape is in the selection, do nothing;
-		// If no bound shapes are in the selection, unbind any bound shapes
-
-		const selectedShapeIds = this.editor.getSelectedShapeIds()
-
+		// If at least one bound shape is in the selection, no changes
 		if (
 			(bindings.start &&
-				(selectedShapeIds.includes(bindings.start.toId) ||
+				(this.editor.getSelectedShapeIds().includes(bindings.start.toId) ||
 					this.editor.isAncestorSelected(bindings.start.toId))) ||
 			(bindings.end &&
-				(selectedShapeIds.includes(bindings.end.toId) ||
+				(this.editor.getSelectedShapeIds().includes(bindings.end.toId) ||
 					this.editor.isAncestorSelected(bindings.end.toId)))
 		) {
 			return
@@ -421,8 +434,6 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 				props: { ...binding.props, isPrecise: true },
 			})
 		}
-
-		return
 	}
 
 	override onTranslate(initialShape: TLArrowShape, shape: TLArrowShape) {
@@ -564,7 +575,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			})
 		}
 
-		const next = {
+		const update: TLShapePartial<TLArrowShape> = {
 			props: {
 				start,
 				end,
@@ -572,7 +583,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			},
 		}
 
-		return next
+		return update
 	}
 
 	override onDoubleClickHandle(
@@ -603,9 +614,34 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		}
 	}
 
+	hitTestPoint(shape: TLArrowShape, point: Vec): boolean {
+		const outline = this.editor.getOutline(shape)
+		const zoomLevel = this.editor.getZoomLevel()
+		const offsetDist = STROKE_SIZES[shape.props.size] / zoomLevel
+
+		for (let i = 0; i < outline.length - 1; i++) {
+			const C = outline[i]
+			const D = outline[i + 1]
+
+			if (Vec.DistanceToLineSegment(C, D, point) < offsetDist) return true
+		}
+
+		return false
+	}
+
+	hitTestLineSegment(shape: TLArrowShape, A: Vec, B: Vec): boolean {
+		const outline = this.editor.getOutline(shape)
+
+		for (let i = 0; i < outline.length - 1; i++) {
+			const C = outline[i]
+			const D = outline[i + 1]
+			if (linesIntersect(A, B, C, D)) return true
+		}
+
+		return false
+	}
+
 	component(shape: TLArrowShape) {
-		// eslint-disable-next-line react-hooks/rules-of-hooks
-		const theme = useDefaultColorTheme()
 		const onlySelectedShape = this.editor.getOnlySelectedShape()
 		const shouldDisplayHandles =
 			this.editor.isInAny(
@@ -643,7 +679,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 						align="middle"
 						verticalAlign="middle"
 						text={shape.props.text}
-						labelColor={theme[shape.props.labelColor].solid}
+						labelColor={shape.props.labelColor}
 						textWidth={labelPosition.box.w - ARROW_LABEL_PADDING * 2 * shape.props.scale}
 						isSelected={isSelected}
 						padding={0}
@@ -671,6 +707,9 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 
 		const labelGeometry = shape.props.text.trim() ? (geometry.children[1] as Rectangle2d) : null
 
+		const clipPathId = useSharedSafeId(shape.id + '_clip')
+
+		if (!info) return null
 		if (Vec.Equals(start, end)) return null
 
 		const strokeWidth = STROKE_SIZES[shape.props.size] * shape.props.scale
@@ -678,13 +717,6 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		const as = info.start.arrowhead && getArrowheadPathForType(info, 'start', strokeWidth)
 		const ae = info.end.arrowhead && getArrowheadPathForType(info, 'end', strokeWidth)
 
-		const path = info.isStraight ? getSolidStraightArrowPath(info) : getSolidCurvedArrowPath(info)
-
-		const includeClipPath =
-			(as && info.start.arrowhead !== 'arrow') ||
-			(ae && info.end.arrowhead !== 'arrow') ||
-			!!labelGeometry
-
 		if (isEditing && labelGeometry) {
 			return (
 				<rect
@@ -715,25 +747,22 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 						/>
 					</defs>
 				)}
-				<g
-					style={{
-						clipPath: includeClipPath ? `url(#${clipPathId})` : undefined,
-						WebkitClipPath: includeClipPath ? `url(#${clipPathId})` : undefined,
-					}}
-				>
+				{g(style={{
+					clipPath: includeClipPath ? `url(#${clipPathId})` : undefined,
+					WebkitClipPath: includeClipPath ? `url(#${clipPathId})` : undefined,
+				})}>
 					{/* This rect needs to be here if we're creating a mask due to an svg quirk on Chrome */}
 					{includeClipPath && (
 						<rect
 							x={bounds.minX - 100}
 							y={bounds.minY - 100}
-							width={bounds.width + 200}
-							height={bounds.height + 200}
+							width={bounds.w + 200}
+							height={bounds.h + 200}
 							opacity={0}
 						/>
 					)}
-
 					<path d={path} />
-				</g>
+				</g}
 				{as && <path d={as} />}
 				{ae && <path d={ae} />}
 				{labelGeometry && (
@@ -742,72 +771,15 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 						y={toDomPrecision(labelGeometry.y)}
 						width={labelGeometry.w}
 						height={labelGeometry.h}
-						rx={3.5}
-						ry={3.5}
+						rx={3.5 * shape.props.scale}
+						ry={3.5 * shape.props.scale}
 					/>
 				)}
 			</g>
 		)
 	}
 
-	override onEditEnd(shape: TLArrowShape) {
-		const {
-			id,
-			type,
-			props: { text },
-		} = shape
-
-		if (text.trimEnd() !== shape.props.text) {
-			this.editor.updateShapes<TLArrowShape>([
-				{
-					id,
-					type,
-					props: {
-						text: text.trimEnd(),
-					},
-				},
-			])
-		}
-	}
-
-	override toSvg(shape: TLArrowShape, ctx: SvgExportContext) {
-		ctx.addExportDef(getFillDefForExport(shape.props.fill))
-		const theme = getDefaultColorTheme(ctx)
-		const scaleFactor = 1 / shape.props.scale
-
-		return (
-			<g transform={`scale(${scaleFactor})`}>
-				<ArrowSvg shape={shape} shouldDisplayHandles={false} />
-				<SvgTextLabel
-					fontSize={getArrowLabelFontSize(shape)}
-					font={shape.props.font}
-					align="middle"
-					verticalAlign="middle"
-					text={shape.props.text}
-					labelColor={theme[shape.props.labelColor].solid}
-					bounds={getArrowLabelPosition(this.editor, shape)
-						.box.clone()
-						.expandBy(-ARROW_LABEL_PADDING * shape.props.scale)}
-					padding={0}
-				/>
-			</g>
-		)
-	}
-
-	override getCanvasSvgDefs(): TLShapeUtilCanvasSvgDef[] {
-		return [
-			getFillDefForCanvas(),
-			{
-				key: `arrow:dot`,
-				component: ArrowheadDotDef,
-			},
-			{
-				key: `arrow:cross`,
-				component: ArrowheadCrossDef,
-			},
-		]
-	}
-	override getInterpolatedProps(
+	private getInterpolatedProps(
 		startShape: TLArrowShape,
 		endShape: TLArrowShape,
 		progress: number
@@ -827,225 +799,94 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			labelPosition: lerp(startShape.props.labelPosition, endShape.props.labelPosition, progress),
 		}
 	}
-}
 
-export function getArrowLength(editor: Editor, shape: TLArrowShape): number {
-	const info = getArrowInfo(editor, shape)!
+	private getText(shape: TLArrowShape) {
+		return shape.props.text
+	}
 
-	return info.isStraight
-		? Vec.Dist(info.start.handle, info.end.handle)
-		: Math.abs(info.handleArc.length)
-}
+	private static getLength(editor: Editor, shape: TLArrowShape): number {
+		const info = getArrowInfo(editor, shape)!
+		return info.isStraight
+			? Vec.Dist(info.start.handle, info.end.handle)
+			: Math.abs(info.handleArc.length)
+	}
 
-const ArrowSvg = track(function ArrowSvg({
-	shape,
-	shouldDisplayHandles,
-}: {
-	shape: TLArrowShape
-	shouldDisplayHandles: boolean
-}) {
-	const editor = useEditor()
-	const theme = useDefaultColorTheme()
-	const info = getArrowInfo(editor, shape)
-	const bounds = Box.ZeroFix(editor.getShapeGeometry(shape).bounds)
-	const bindings = getArrowBindings(editor, shape)
-	const isForceSolid = useValue(
-		'force solid',
-		() => {
-			return editor.getZoomLevel() < 0.2
-		},
-		[editor]
-	)
-
-	const clipPathId = useSharedSafeId(shape.id + '_clip')
-	const arrowheadDotId = useSharedSafeId('arrowhead-dot')
-	const arrowheadCrossId = useSharedSafeId('arrowhead-cross')
-
-	if (!info?.isValid) return null
-
-	const strokeWidth = STROKE_SIZES[shape.props.size] * shape.props.scale
-
-	const as = info.start.arrowhead && getArrowheadPathForType(info, 'start', strokeWidth)
-	const ae = info.end.arrowhead && getArrowheadPathForType(info, 'end', strokeWidth)
-
-	const path = info.isStraight ? getSolidStraightArrowPath(info) : getSolidCurvedArrowPath(info)
-
-	let handlePath: null | React.JSX.Element = null
-
-	if (shouldDisplayHandles) {
-		const sw = 2 / editor.getZoomLevel()
-		const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
-			getArrowLength(editor, shape),
-			sw,
-			{
-				end: 'skip',
-				start: 'skip',
-				lengthRatio: 2.5,
-			}
+	private static ArrowSvg = track(function ArrowSvg({
+		shape,
+		shouldDisplayHandles,
+	}: {
+		shape: TLArrowShape
+		shouldDisplayHandles: boolean
+	}) {
+		const editor = useEditor()
+		const theme = useDefaultColorTheme()
+		const info = getArrowInfo(editor, shape)
+		const bounds = Box.ZeroFix(editor.getShapeGeometry(shape).bounds)
+		const bindings = getArrowBindings(editor, shape)
+		const isForceSolid = useValue(
+			'force solid',
+			() => {
+				return editor.getZoomLevel() < 0.2
+			},
+			[editor]
 		)
 
-		handlePath =
-			bindings.start || bindings.end ? (
-				<path
-					className="tl-arrow-hint"
-					d={info.isStraight ? getStraightArrowHandlePath(info) : getCurvedArrowHandlePath(info)}
-					strokeDasharray={strokeDasharray}
-					strokeDashoffset={strokeDashoffset}
-					strokeWidth={sw}
-					markerStart={
-						bindings.start
-							? bindings.start.props.isExact
-								? ''
-								: bindings.start.props.isPrecise
-									? `url(#${arrowheadCrossId})`
-									: `url(#${arrowheadDotId})`
-							: ''
-					}
-					markerEnd={
-						bindings.end
-							? bindings.end.props.isExact
-								? ''
-								: bindings.end.props.isPrecise
-									? `url(#${arrowheadCrossId})`
-									: `url(#${arrowheadDotId})`
-							: ''
-					}
-					opacity={0.16}
-				/>
-			) : null
-	}
+		const clipPathId = useSharedSafeId(shape.id + '_clip')
+		const arrowheadDotId = useSharedSafeId('arrowhead-dot')
+		const arrowheadCrossId = useSharedSafeId('arrowhead-cross')
 
-	const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
-		info.isStraight ? info.length : Math.abs(info.bodyArc.length),
-		strokeWidth,
-		{
-			style: shape.props.dash,
-			forceSolid: isForceSolid,
-		}
-	)
-
-	const labelPosition = getArrowLabelPosition(editor, shape)
-
-	const clipStartArrowhead = !(info.start.arrowhead === 'none' || info.start.arrowhead === 'arrow')
-	const clipEndArrowhead = !(info.end.arrowhead === 'none' || info.end.arrowhead === 'arrow')
-
-	return (
-		<>
-			{/* Yep */}
-			<defs>
-				<clipPath id={clipPathId}>
-					<ArrowClipPath
-						hasText={shape.props.text.trim().length > 0}
-						bounds={bounds}
-						labelBounds={labelPosition.box}
-						as={clipStartArrowhead && as ? as : ''}
-						ae={clipEndArrowhead && ae ? ae : ''}
-					/>
-				</clipPath>
-			</defs>
-			<g
-				fill="none"
-				stroke={theme[shape.props.color].solid}
-				strokeWidth={strokeWidth}
-				strokeLinejoin="round"
-				strokeLinecap="round"
-				pointerEvents="none"
-			>
-				{handlePath}
-				<g
-					style={{
-						clipPath: `url(#${clipPathId})`,
-						WebkitClipPath: `url(#${clipPathId})`,
-					}}
-				>
-					<rect
-						x={toDomPrecision(bounds.minX - 100)}
-						y={toDomPrecision(bounds.minY - 100)}
-						width={toDomPrecision(bounds.width + 200)}
-						height={toDomPrecision(bounds.height + 200)}
-						opacity={0}
-					/>
-					<path d={path} strokeDasharray={strokeDasharray} strokeDashoffset={strokeDashoffset} />
-				</g>
-				{as && clipStartArrowhead && shape.props.fill !== 'none' && (
-					<ShapeFill
-						theme={theme}
-						d={as}
-						color={shape.props.color}
-						fill={shape.props.fill}
-						scale={shape.props.scale}
-					/>
-				)}
-				{ae && clipEndArrowhead && shape.props.fill !== 'none' && (
-					<ShapeFill
-						theme={theme}
-						d={ae}
-						color={shape.props.color}
-						fill={shape.props.fill}
-						scale={shape.props.scale}
-					/>
-				)}
-				{as && <path d={as} />}
-				{ae && <path d={ae} />}
-			</g>
-		</>
-	)
-})
-
-function ArrowClipPath({
-	hasText,
-	bounds,
-	labelBounds,
-	as,
-	ae,
-}: {
-	hasText: boolean
-	bounds: Box
-	labelBounds: Box
-	as: string
-	ae: string
-}) {
-	// The direction in which we create the different path parts is important, as it determines what gets clipped.
-	// See the description on the directions in the non-zero fill rule example:
-	// https://developer.mozilla.org/en-US/docs/Web/tldraw_packages_tldraw_src_lib_shapes_arrow_ArrowShapeUtil.tsx_extracted.txt (actual): ''}${as}${ae}`} />
-}
+		if (!info?.isValid) return null
 
-const shapeAtTranslationStart = new WeakMap<
-	TLArrowShape,
-	{
-		pagePosition: Vec
-		terminalBindings: Record<
-			'start' | 'end',
-			{
-				pagePosition: Vec
-				shapePosition: Vec
-				binding: TLArrowBinding
-			} | null
-		>
-	}
->()
-
-function ArrowheadDotDef() {
-	const id = useSharedSafeId('arrowhead-dot')
-	return (
-		<marker id={id} className="tl-arrow-hint" refX="3.0" refY="3.0" orient="0">
-			<circle cx="3" cy="3" r="2" strokeDasharray="100%" />
-		</marker>
-	)
-}
+		const strokeWidth = STROKE_SIZES[shape.props.size] * shape.props.scale
+
+		const as = info.start.arrowhead && getArrowheadPathForType(info, 'start', strokeWidth)
+		const ae = info.end.arrowhead && getArrowheadPathForType(info, 'end', strokeWidth)
+
+		const path = info.isStraight ? getSolidStraightArrowPath(info) : getSolidCurvedArrowPath(info)
+
+		let handlePath: null | React.JSX.Element = null
+
+		if (shouldDisplayHandles) {
+			const sw = 2 / editor.getZoomLevel()
+			const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
+				ArrowShapeUtil.getLength(editor, shape),
+				sw,
+				{
+					end: 'skip',
+					start: 'skip',
+					lengthRatio: 2.5,
+				}
+			)
+
+			handlePath =
+				bindings.start || bindings.end ? (
+					<path
+						className="tl-arrow-hint"
+						d={info.isStraight ? getStraightArrowHandlePath(info) : getCurvedArrowHandlePath(info)}
+						strokeDasharray={strokeDasharray}
+						strokeDashoffset={strokeDashoffset}
+						strokeWidth={sw}
+						markerStart={
+							bindings.start
+								? bindings.start.props.isExact
+									? ''
+									: bindings.start.props.isPrecise
+										? `url(#${arrowheadCrossId})`
+										: `url(#${arrowheadDotId})`
+								: ''
+						}
+						markerEnd={
+							bindings.end
+								? bindings.end.props.isExact
+									? ''
+									: bindings.end.props.isPrecise
+										? `url(#${arrowheadCrossId})`
+										: `url(#${arrowheadDotId})`
+								: ''
+						}
+						opacity={0.16}
+					/>
+				) : null
+		}
 
-function ArrowheadCrossDef() {
-	const id = useSharedSafeId('arrowhead-cross')
-	return (
-		<marker id={id} className="tl-arrow-hint" refX="3.0" refY="3.0" orient="auto">
-			<line x1="1.5" y1="1.5" x2="4.5" y2="4.5" strokeDasharray="100%" />
-			<line x1="1.5" y1="4.5" x2="4.5" y2="1.5" strokeDasharray="100%" />
-		</marker>
-	)
-}
\ No newline at end of file
+		const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
\ No newline at end of file
