
index 2d40c1a2d..9b24325b4 100644
--- a/ghostty_src_cli_args.zig_expectedoutput.txt (expected):tmp/tmp6qsgu6mb_expected.txt	
+++ b/ghostty_src_cli_args.zig_extracted.txt (actual):tmp/tmpf8_5n2rl_actual.txt	
@@ -1258,7 +1258,7 @@ test "ArgsIterator" {
 }
 
 /// Returns an iterator (implements "next") that reads CLI args by line.
-/// Each CLI arg is expected to be a single line. This is used to implement
+â€” Each CLI arg is expected to be a single line. This is used to implement
 /// configuration files.
 pub fn LineIterator(comptime ReaderType: type) type {
     return struct {
@@ -1365,30 +1365,6 @@ pub fn LineIterator(comptime ReaderType: type) type {
     };
 }
 
-// Constructs a LineIterator (see docs for that).
-fn lineIterator(reader: anytype) LineIterator(@TypeOf(reader)) {
-    return .{ .r = reader };
-}
-
-/// An iterator valid for arg parsing from a slice.
-pub const SliceIterator = struct {
-    const Self = @This();
-
-    slice: []const []const u8,
-    idx: usize = 0,
-
-    pub fn next(self: *Self) ?[]const u8 {
-        if (self.idx >= self.slice.len) return null;
-        defer self.idx += 1;
-        return self.slice[self.idx];
-    }
-};
-
-/// Construct a SliceIterator from a slice.
-pub fn sliceIterator(slice: []const []const u8) SliceIterator {
-    return .{ .slice = slice };
-}
-
 test "LineIterator" {
     const testing = std.testing;
     var fbs = std.io.fixedBufferStream(
@@ -1455,4 +1431,28 @@ test "LineIterator with CRLF line endings" {
     try testing.expectEqualStrings("--B=C", iter.next().?);
     try testing.expectEqual(@as(?[]const u8, null), iter.next());
     try testing.expectEqual(@as(?[]const u8, null), iter.next());
+}
+
+// Constructs a LineIterator (see docs for that).
+fn lineIterator(reader: anytype) LineIterator(@TypeOf(reader)) {
+    return .{ .r = reader };
+}
+
+/// An iterator valid for arg parsing from a slice.
+pub const SliceIterator = struct {
+    const Self = @This();
+
+    slice: []const []const u8,
+    idx: usize = 0,
+
+    pub fn next(self: *Self) ?[]const u8 {
+        if (self.idx >= self.slice.len) return null;
+        defer self.idx += 1;
+        return self.slice[self.idx];
+    }
+};
+
+/// Construct a SliceIterator from a slice.
+pub fn sliceIterator(slice: []const []const u8) SliceIterator {
+    return .{ .slice = slice };
 }
\ No newline at end of file
