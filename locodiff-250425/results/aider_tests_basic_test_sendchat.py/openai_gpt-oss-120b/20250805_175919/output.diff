
index 868c7e9c0..0d555631e 100644
--- a/aider_tests_basic_test_sendchat.py_expectedoutput.txt (expected):tmp/tmpopd2w1s9_expected.txt	
+++ b/aider_tests_basic_test_sendchat.py_extracted.txt (actual):tmp/tmpwwgu2gpk_actual.txt	
@@ -4,12 +4,11 @@ from unittest.mock import MagicMock, patch
 from aider.exceptions import LiteLLMExceptions
 from aider.llm import litellm
 from aider.models import Model
-
+from aider.sendchat import simple_send_with_retries
 
 class PrintCalled(Exception):
     pass
 
-
 class TestSendChat(unittest.TestCase):
     def setUp(self):
         self.mock_messages = [{"role": "user", "content": "Hello"}]
@@ -19,80 +18,6 @@ class TestSendChat(unittest.TestCase):
         litellm_ex = LiteLLMExceptions()
         litellm_ex._load(strict=True)
 
-    @patch("litellm.completion")
-    @patch("builtins.print")
-    def test_simple_send_with_retries_rate_limit_error(self, mock_print, mock_completion):
-        mock = MagicMock()
-        mock.status_code = 500
-
-        # Set up the mock to raise
-        mock_completion.side_effect = [
-            litellm.RateLimitError(
-                "rate limit exceeded",
-                response=mock,
-                llm_provider="llm_provider",
-                model="model",
-            ),
-            None,
-        ]
-
-        # Call the simple_send_with_retries method
-        Model(self.mock_model).simple_send_with_retries(self.mock_messages)
-        assert mock_print.call_count == 3
-
-    @patch("litellm.completion")
-    def test_send_completion_basic(self, mock_completion):
-        # Setup mock response
-        mock_response = MagicMock()
-        mock_completion.return_value = mock_response
-
-        # Test basic send_completion
-        hash_obj, response = Model(self.mock_model).send_completion(
-            self.mock_messages, functions=None, stream=False
-        )
-
-        assert response == mock_response
-        mock_completion.assert_called_once()
-
-    @patch("litellm.completion")
-    def test_send_completion_with_functions(self, mock_completion):
-        mock_function = {"name": "test_function", "parameters": {"type": "object"}}
-
-        hash_obj, response = Model(self.mock_model).send_completion(
-            self.mock_messages, functions=[mock_function], stream=False
-        )
-
-        # Verify function was properly included in tools
-        called_kwargs = mock_completion.call_args.kwargs
-        assert "tools" in called_kwargs
-        assert called_kwargs["tools"][0]["function"] == mock_function
-
-    @patch("litellm.completion")
-    def test_simple_send_attribute_error(self, mock_completion):
-        # Setup mock to raise AttributeError
-        mock_completion.return_value = MagicMock()
-        mock_completion.return_value.choices = None
-
-        # Should return None on AttributeError
-        result = Model(self.mock_model).simple_send_with_retries(self.mock_messages)
-        assert result is None
-
-    @patch("litellm.completion")
-    @patch("builtins.print")
-    def test_simple_send_non_retryable_error(self, mock_print, mock_completion):
-        # Test with an error that shouldn't trigger retries
-        mock = MagicMock()
-        mock.status_code = 400
-
-        mock_completion.side_effect = litellm.NotFoundError(
-            message="Invalid request", llm_provider="test_provider", model="test_model"
-        )
-
-        result = Model(self.mock_model).simple_send_with_retries(self.mock_messages)
-        assert result is None
-        # Should only print the error message
-        assert mock_print.call_count == 1
-
     def test_ensure_alternating_roles_empty(self):
         from aider.sendchat import ensure_alternating_roles
 
@@ -100,14 +25,14 @@ class TestSendChat(unittest.TestCase):
         result = ensure_alternating_roles(messages)
         assert result == []
 
-    def test_ensure_alternating_roles_single_message(self):
+    def test_ensure_alternating_single_message(self):
         from aider.sendchat import ensure_alternating_roles
 
         messages = [{"role": "user", "content": "Hello"}]
         result = ensure_alternating_roles(messages)
         assert result == messages
 
-    def test_ensure_alternating_roles_already_alternating(self):
+    def test_ensure_alternating_already_alternating(self):
         from aider.sendchat import ensure_alternating_roles
 
         messages = [
@@ -118,7 +43,7 @@ class TestSendChat(unittest.TestCase):
         result = ensure_alternating_roles(messages)
         assert result == messages
 
-    def test_ensure_alternating_roles_consecutive_user(self):
+    def test_ensure_alternating_consecutive_user(self):
         from aider.sendchat import ensure_alternating_roles
 
         messages = [
@@ -133,7 +58,7 @@ class TestSendChat(unittest.TestCase):
         result = ensure_alternating_roles(messages)
         assert result == expected
 
-    def test_ensure_alternating_roles_consecutive_assistant(self):
+    def test_ensure_alternating_consecutive_assistant(self):
         from aider.sendchat import ensure_alternating_roles
 
         messages = [
@@ -145,10 +70,10 @@ class TestSendChat(unittest.TestCase):
             {"role": "user", "content": ""},
             {"role": "assistant", "content": "How can I help?"},
         ]
-        result = ensure_alternating_roles(messages)
+        result = ensure_alternating_messages(messages)
         assert result == expected
 
-    def test_ensure_alternating_roles_mixed_sequence(self):
+    def test_ensure_alternating_mixed_sequence(self):
         from aider.sendchat import ensure_alternating_roles
 
         messages = [
@@ -168,4 +93,82 @@ class TestSendChat(unittest.TestCase):
             {"role": "user", "content": "Write code"},
         ]
         result = ensure_alternating_roles(messages)
-        assert result == expected
\ No newline at end of file
+        assert result == expected
+
+    @patch("litellm.completion")
+    @patch("builtins.print")
+    def test_simple_send_with_retries_error_prints(self, mock_print, mock_completion):
+        # Simulate rate‑limit error on first call, then success
+        mock = MagicMock()
+        mock.status_code = 500
+        mock_completion.side_effect = [
+            litellm.RateLimitError(
+                "rate limit exceeded",
+                response=mock,
+                llm_provider="llm_provider",
+                model="model",
+            ),
+            None,
+        ]
+
+        # Simulate NotFoundError on next call, then success
+        mock_notfound = MagicMock()
+        mock_notfound.status_code = 404
+        mock_completion.side_effect = [
+            litellm.NotFoundError(
+                message="Invalid request",
+                llm_provider="test_provider",
+                model="test_model",
+            ),
+            None,
+        ]
+
+        # Call the retry‑wrapped send method
+        Model(self.mock_model).simple_send_with_retries(self.mock_messages)
+
+        # Two errors should be printed (error + retry)
+        assert mock_print.call_count == 2
+
+    @patch("litellm.completion")
+    def test_send_completion_basic(self, mock_completion):
+        mock_response = MagicMock()
+        mock_completion.return_value = mock_response
+
+        hash_obj, response = Model(self.mock_model).send_completion(
+            self.mock_messages, functions=None, stream=False
+        )
+        assert response == mock_response
+        mock_completion.assert_called_once()
+
+    @patch("litellm.completion")
+    def test_send_completion_with_functions(self, mock_completion):
+        mock_function = {"name": "test_function", "parameters": {"type": "object"}}
+
+        hash_obj, response = Model(self.mock_model).send_completion(
+            self.mock_messages, functions=[mock_function], stream=False
+        )
+        called_kwargs = mock_completion.call_args.kwargs
+        assert "tools" in called_kwargs
+        assert called_kwargs["tools"][0]["function"] == mock_function
+
+    @patch("litellm.completion")
+    def test_simple_send_attribute_error(self, mock_completion):
+        mock_completion.return_value = MagicMock()
+        mock_completion.return_value.choices = None
+
+        result = Model(self.mock_model).simple_send_with_retries(self.mock_messages)
+        assert result is None
+
+    @patch("litellm.completion")
+    @patch("builtins.print")
+    def test_simple_send_non_retryable_error(self, mock_print, mock_completion):
+        mock = MagicMock()
+        mock.status_code = 400
+        mock_completion.side_effect = litellm.NotFoundError(
+            message="Invalid request",
+            llm_provider="test_provider",
+            model="test_model"
+        )
+        result = Model(self.mock_model).simple_send_with_retries(self.mock_messages)
+        assert result is None
+        assert mock_print.call_count == 1
\ No newline at end of file
