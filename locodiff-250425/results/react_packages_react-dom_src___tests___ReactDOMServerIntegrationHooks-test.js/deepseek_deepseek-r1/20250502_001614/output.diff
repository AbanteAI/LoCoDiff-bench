--- react_packages_react-dom_src___tests___ReactDOMServerIntegrationHooks-test.js_expectedoutput.txt (expected)+++ react_packages_react-dom_src___tests___ReactDOMServerIntegrationHooks-test.js_extracted.txt (actual)@@ -424,6 +424,7 @@         });
         return 'hi';
       }
+
       const domNode = await render(
         <App />,
         render === clientRenderOnBadMarkup
@@ -621,6 +622,7 @@       expect(domNode.textContent).toEqual('Count: 0');
     });
   });
+
   describe('useInsertionEffect', () => {
     it('should warn when invoked during render', async () => {
       function Counter() {
@@ -674,6 +676,110 @@         '3. You might have more than one copy of React in the same app\n' +
         'See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.',
     );
+  });
+
+  describe('readContext', () => {
+    function readContext(Context) {
+      const dispatcher =
+        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE.H;
+      return dispatcher.readContext(Context);
+    }
+
+    itRenders(
+      'can read the same context multiple times in the same function',
+      async render => {
+        const Context = React.createContext({foo: 0, bar: 0, baz: 0});
+
+        function Provider(props) {
+          return (
+            <Context.Provider
+              value={{foo: props.foo, bar: props.bar, baz: props.baz}}>
+              {props.children}
+            </Context.Provider>
+          );
+        }
+
+        function FooAndBar() {
+          const {foo} = readContext(Context);
+          const {bar} = readContext(Context);
+          return <Text text={`Foo: ${foo}, Bar: ${bar}`} />;
+        }
+
+        function Baz() {
+          const {baz} = readContext(Context);
+          return <Text text={'Baz: ' + baz} />;
+        }
+
+        class Indirection extends React.Component {
+          shouldComponentUpdate() {
+            return false;
+          }
+          render() {
+            return this.props.children;
+          }
+        }
+
+        function App(props) {
+          return (
+            <div>
+              <Provider foo={props.foo} bar={props.bar} baz={props.baz}>
+                <Indirection>
+                  <Indirection>
+                    <FooAndBar />
+                  </Indirection>
+                  <Indirection>
+                    <Baz />
+                  </Indirection>
+                </Indirection>
+              </Provider>
+            </div>
+          );
+        }
+
+        const domNode = await render(<App foo={1} bar={3} baz={5} />);
+        expect(clearLog()).toEqual(['Foo: 1, Bar: 3', 'Baz: 5']);
+        expect(domNode.childNodes.length).toBe(2);
+        expect(domNode.firstChild.tagName).toEqual('SPAN');
+        expect(domNode.firstChild.textContent).toEqual('Foo: 1, Bar: 3');
+        expect(domNode.lastChild.tagName).toEqual('SPAN');
+        expect(domNode.lastChild.textContent).toEqual('Baz: 5');
+      },
+    );
+
+    itRenders('with a warning inside useMemo and useReducer', async render => {
+      const Context = React.createContext(42);
+
+      function ReadInMemo(props) {
+        const count = React.useMemo(() => readContext(Context), []);
+        return <Text text={count} />;
+      }
+
+      function ReadInReducer(props) {
+        const [count, dispatch] = React.useReducer(() => readContext(Context));
+        if (count !== 42) {
+          dispatch();
+        }
+        return <Text text={count} />;
+      }
+
+      const domNode1 = await render(<ReadInMemo />, 1);
+      expect(domNode1.textContent).toEqual('42');
+
+      const domNode2 = await render(<ReadInReducer />, 1);
+      expect(domNode2.textContent).toEqual('42');
+    });
+  });
+
+  describe('useDebugValue', () => {
+    itRenders('is a noop', async render => {
+      function Counter(props) {
+        const debugValue = useDebugValue(123);
+        return <Text text={typeof debugValue} />;
+      }
+
+      const domNode = await render(<Counter />);
+      expect(domNode.textContent).toEqual('undefined');
+    });
   });
 
   describe('invalid hooks', () => {
@@ -760,131 +866,6 @@     },
   );
 
-  describe('useDebugValue', () => {
-    itRenders('is a noop', async render => {
-      function Counter(props) {
-        const debugValue = useDebugValue(123);
-        return <Text text={typeof debugValue} />;
-      }
-
-      const domNode = await render(<Counter />);
-      expect(domNode.textContent).toEqual('undefined');
-    });
-  });
-
-  describe('readContext', () => {
-    function readContext(Context) {
-      const dispatcher =
-        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE.H;
-      return dispatcher.readContext(Context);
-    }
-
-    itRenders(
-      'can read the same context multiple times in the same function',
-      async render => {
-        const Context = React.createContext(
-          {foo: 0, bar: 0, baz: 0},
-          (a, b) => {
-            let result = 0;
-            if (a.foo !== b.foo) {
-              result |= 0b001;
-            }
-            if (a.bar !== b.bar) {
-              result |= 0b010;
-            }
-            if (a.baz !== b.baz) {
-              result |= 0b100;
-            }
-            return result;
-          },
-        );
-
-        function Provider(props) {
-          return (
-            <Context.Provider
-              value={{foo: props.foo, bar: props.bar, baz: props.baz}}>
-              {props.children}
-            </Context.Provider>
-          );
-        }
-
-        function FooAndBar() {
-          const {foo} = readContext(Context, 0b001);
-          const {bar} = readContext(Context, 0b010);
-          return <Text text={`Foo: ${foo}, Bar: ${bar}`} />;
-        }
-
-        function Baz() {
-          const {baz} = readContext(Context, 0b100);
-          return <Text text={'Baz: ' + baz} />;
-        }
-
-        class Indirection extends React.Component {
-          shouldComponentUpdate() {
-            return false;
-          }
-          render() {
-            return this.props.children;
-          }
-        }
-
-        function App(props) {
-          return (
-            <div>
-              <Provider foo={props.foo} bar={props.bar} baz={props.baz}>
-                <Indirection>
-                  <Indirection>
-                    <FooAndBar />
-                  </Indirection>
-                  <Indirection>
-                    <Baz />
-                  </Indirection>
-                </Indirection>
-              </Provider>
-            </div>
-          );
-        }
-
-        const domNode = await render(<App foo={1} bar={3} baz={5} />);
-        expect(clearLog()).toEqual(['Foo: 1, Bar: 3', 'Baz: 5']);
-        expect(domNode.childNodes.length).toBe(2);
-        expect(domNode.firstChild.tagName).toEqual('SPAN');
-        expect(domNode.firstChild.textContent).toEqual('Foo: 1, Bar: 3');
-        expect(domNode.lastChild.tagName).toEqual('SPAN');
-        expect(domNode.lastChild.textContent).toEqual('Baz: 5');
-      },
-    );
-
-    itRenders('with a warning inside useMemo and useReducer', async render => {
-      const Context = React.createContext(42);
-
-      function ReadInMemo(props) {
-        const count = React.useMemo(() => readContext(Context), []);
-        return <Text text={count} />;
-      }
-
-      function ReadInReducer(props) {
-        const [count, dispatch] = React.useReducer(() => readContext(Context));
-        if (count !== 42) {
-          dispatch();
-        }
-        return <Text text={count} />;
-      }
-
-      const domNode1 = await render(
-        <ReadInMemo />,
-        render === clientRenderOnBadMarkup
-          ? // On hydration mismatch we retry and therefore log the warning again.
-            2
-          : 1,
-      );
-      expect(domNode1.textContent).toEqual('42');
-
-      const domNode2 = await render(<ReadInReducer />, 1);
-      expect(domNode2.textContent).toEqual('42');
-    });
-  });
-
   it('renders successfully after a component using hooks throws an error', () => {
     function ThrowingComponent() {
       const [value, dispatch] = useReducer((state, action) => {
