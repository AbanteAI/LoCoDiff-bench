
index 4481b2693..e3b8878a1 100644
--- a/react_packages_react-dom_src___tests___ReactDOMServerIntegrationHooks-test.js_expectedoutput.txt (expected):tmp/tmp0gzpi7t4_expected.txt	
+++ b/react_packages_react-dom_src___tests___ReactDOMServerIntegrationHooks-test.js_extracted.txt (actual):tmp/tmpg21ed_tn_actual.txt	
@@ -8,8 +8,6 @@
  * @jest-environment ./scripts/jest/ReactDOMServerIntegrationEnvironment
  */
 
-/* eslint-disable no-func-assign */
-
 'use strict';
 
 const ReactDOMServerIntegrationUtils = require('./utils/ReactDOMServerIntegrationTestUtils');
@@ -424,6 +422,7 @@ describe('ReactDOMServerHooks', () => {
         });
         return 'hi';
       }
+
       const domNode = await render(
         <App />,
         render === clientRenderOnBadMarkup
@@ -434,6 +433,26 @@ describe('ReactDOMServerHooks', () => {
       expect(domNode.textContent).toEqual('hi');
     });
 
+    itThrowsWhenRendering(
+      'with a warning for useRef inside useReducer',
+      async render => {
+        function App() {
+          const [value, dispatch] = useReducer((state, action) => {
+            useRef(0);
+            return state + 1;
+          }, 0);
+          if (value === 0) {
+            dispatch();
+          }
+          return value;
+        }
+
+        const domNode = await render(<App />, 1);
+        expect(domNode.textContent).toEqual('1');
+      },
+      'Rendered more hooks than during the previous render',
+    );
+
     itRenders('with a warning for useRef inside useState', async render => {
       function App() {
         const [value] = useState(() => {
@@ -474,6 +493,8 @@ describe('ReactDOMServerHooks', () => {
 
           if (count < 3) {
             const newCount = count + 1;
+
+            ref.current = newCount;
             setCount(newCount);
           }
 
@@ -621,6 +642,7 @@ describe('ReactDOMServerHooks', () => {
       expect(domNode.textContent).toEqual('Count: 0');
     });
   });
+
   describe('useInsertionEffect', () => {
     it('should warn when invoked during render', async () => {
       function Counter() {
@@ -653,29 +675,6 @@ describe('ReactDOMServerHooks', () => {
     });
   });
 
-  describe('useContext', () => {
-    itThrowsWhenRendering(
-      'if used inside a class component',
-      async render => {
-        const Context = React.createContext({}, () => {});
-        class Counter extends React.Component {
-          render() {
-            const [count] = useContext(Context);
-            return <Text text={count} />;
-          }
-        }
-
-        return render(<Counter />);
-      },
-      'Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' +
-        ' one of the following reasons:\n' +
-        '1. You might have mismatching versions of React and the renderer (such as React DOM)\n' +
-        '2. You might be breaking the Rules of Hooks\n' +
-        '3. You might have more than one copy of React in the same app\n' +
-        'See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.',
-    );
-  });
-
   describe('invalid hooks', () => {
     it('warns when calling useRef inside useReducer', async () => {
       function App() {
@@ -760,15 +759,64 @@ describe('ReactDOMServerHooks', () => {
     },
   );
 
-  describe('useDebugValue', () => {
-    itRenders('is a noop', async render => {
-      function Counter(props) {
-        const debugValue = useDebugValue(123);
-        return <Text text={typeof debugValue} />;
+  describe('useContext', () => {
+    itThrowsWhenRendering(
+      'if used inside a class component',
+      async render => {
+        const Context = React.createContext({}, () => {});
+        class Counter extends React.Component {
+          render() {
+            const [count] = useContext(Context);
+            return <Text text={count} />;
+          }
+        }
+
+        return render(<Counter />);
+      },
+      'Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' +
+        ' one of the following reasons:\n' +
+        '1. You might have mismatching versions of React and the renderer (such as React DOM)\n' +
+        '2. You might be breaking the Rules of Hooks\n' +
+        '3. You might have more than one copy of React in the same app\n' +
+        'See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.',
+    );
+
+    it('renders successfully after a component using hooks throws an error', () => {
+      function ThrowingComponent() {
+        const [value, dispatch] = useReducer((state, action) => {
+          return state + 1;
+        }, 0);
+
+        // throw an error if the count gets too high during the re-render phase
+        if (value >= 3) {
+          throw new Error('Error from ThrowingComponent');
+        } else {
+          // dispatch to trigger a re-render of the component
+          dispatch();
+        }
+
+        return <div>{value}</div>;
       }
 
-      const domNode = await render(<Counter />);
-      expect(domNode.textContent).toEqual('undefined');
+      function NonThrowingComponent() {
+        const [count] = useState(0);
+        return <div>{count}</div>;
+      }
+
+      // First, render a component that will throw an error during a re-render triggered
+      // by a dispatch call.
+      expect(() => ReactDOMServer.renderToString(<ThrowingComponent />)).toThrow(
+        'Error from ThrowingComponent',
+      );
+
+      // Next, assert that we can render a function component using hooks immediately
+      // after an error occurred, which indictates the internal hooks state has been
+      // reset.
+      const container = document.createElement('div');
+      container.innerHTML = ReactDOMServer.renderToString(
+        <NonThrowingComponent />,
+      );
+      expect(container.children[0].textContent).toEqual('0');
     });
   });
 
@@ -855,71 +903,49 @@ describe('ReactDOMServerHooks', () => {
       },
     );
 
-    itRenders('with a warning inside useMemo and useReducer', async render => {
-      const Context = React.createContext(42);
+    itRenders(
+      'with warnings when reading context inside useMemo and useReducer',
+      async render => {
+        const Context = React.createContext(42);
 
-      function ReadInMemo(props) {
-        const count = React.useMemo(() => readContext(Context), []);
-        return <Text text={count} />;
-      }
+        function ReadInMemo(props) {
+          const count = React.useMemo(() => readContext(Context), []);
+          return <Text text={count} />;
+        }
 
-      function ReadInReducer(props) {
-        const [count, dispatch] = React.useReducer(() => readContext(Context));
-        if (count !== 42) {
-          dispatch();
+        function ReadInReducer(props) {
+          const [count, dispatch] = React.useReducer(() => readContext(Context));
+          if (count !== 42) {
+            dispatch();
+          }
+          return <Text text={count} />;
         }
-        return <Text text={count} />;
-      }
 
-      const domNode1 = await render(
-        <ReadInMemo />,
-        render === clientRenderOnBadMarkup
-          ? // On hydration mismatch we retry and therefore log the warning again.
-            2
-          : 1,
-      );
-      expect(domNode1.textContent).toEqual('42');
+        const domNode1 = await render(
+          <ReadInMemo />,
+          render === clientRenderOnBadMarkup
+            ? // On hydration mismatch we retry and therefore log the warning again.
+              2
+            : 1,
+        );
+        expect(domNode1.textContent).toEqual('42');
 
-      const domNode2 = await render(<ReadInReducer />, 1);
-      expect(domNode2.textContent).toEqual('42');
-    });
+        const domNode2 = await render(<ReadInReducer />, 1);
+        expect(domNode2.textContent).toEqual('42');
+      },
+    );
   });
 
-  it('renders successfully after a component using hooks throws an error', () => {
-    function ThrowingComponent() {
-      const [value, dispatch] = useReducer((state, action) => {
-        return state + 1;
-      }, 0);
-
-      // throw an error if the count gets too high during the re-render phase
-      if (value >= 3) {
-        throw new Error('Error from ThrowingComponent');
-      } else {
-        // dispatch to trigger a re-render of the component
-        dispatch();
+  describe('useDebugValue', () => {
+    itRenders('is a noop', async render => {
+      function Counter(props) {
+        const debugValue = useDebugValue(123);
+        return <Text text={typeof debugValue} />;
       }
 
-      return <div>{value}</div>;
-    }
-
-    function NonThrowingComponent() {
-      const [count] = useState(0);
-      return <div>{count}</div>;
-    }
-
-    // First, render a component that will throw an error during a re-render triggered
-    // by a dispatch call.
-    expect(() => ReactDOMServer.renderToString(<ThrowingComponent />)).toThrow(
-      'Error from ThrowingComponent',
-    );
-
-    // Next, assert that we can render a function component using hooks immediately
-    // after an error occurred, which indictates the internal hooks state has been
-    // reset.
-    const container = document.createElement('div');
-    container.innerHTML = ReactDOMServer.renderToString(
-      <NonThrowingComponent />,
-    );
-    expect(container.children[0].textContent).toEqual('0');
+      const domNode = await render(<Counter />);
+      expect(domNode.tagName).toEqual('SPAN');
+      expect(domNode.textContent).toEqual('undefined');
+    });
   });
 });
\ No newline at end of file
