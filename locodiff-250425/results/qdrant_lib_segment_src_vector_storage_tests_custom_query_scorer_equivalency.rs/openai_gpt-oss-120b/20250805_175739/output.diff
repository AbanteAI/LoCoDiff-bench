
index 06f94630e..52a43d90f 100644
--- a/qdrant_lib_segment_src_vector_storage_tests_custom_query_scorer_equivalency.rs_expectedoutput.txt (expected):tmp/tmpbf0_0gx6_expected.txt	
+++ b/qdrant_lib_segment_src_vector_storage_tests_custom_query_scorer_equivalency.rs_extracted.txt (actual):tmp/tmpygq3j3hq_actual.txt	
@@ -8,26 +8,27 @@ use common::types::PointOffsetType;
 use itertools::Itertools;
 use rand::rngs::StdRng;
 use rand::seq::IteratorRandom;
-use rand::{Rng, SeedableRng};
+use rand::{Rng, SeedableRng, rng};
 use rstest::rstest;
 
 use super::utils::sampler;
 use crate::common::rocksdb_wrapper;
-use crate::data_types::vectors::{QueryVector, VectorElementType};
+use crate::data_types::vectors::QueryVector;
+use crate::data_types::vectors::VectorElementType;
 use crate::fixtures::payload_context_fixture::FixtureIdTracker;
-use crate::fixtures::query_fixtures::QueryVariant;
 use crate::id_tracker::id_tracker_base::IdTracker;
-use crate::types::{
-    BinaryQuantizationConfig, Distance, ProductQuantizationConfig, QuantizationConfig,
-    ScalarQuantizationConfig,
-};
-#[cfg(target_os = "linux")]
+use crate::types::BinaryQuantizationConfig;
+use crate::types::Distance;
+use crate::types::ProductQuantizationConfig;
+use crate::types::QuantizationConfig;
+use crate::types::ScalarQuantizationConfig;
 use crate::vector_storage::dense::memmap_dense_vector_storage::open_memmap_vector_storage_with_async_io;
 use crate::vector_storage::dense::simple_dense_vector_storage::open_simple_dense_vector_storage;
 use crate::vector_storage::quantized::quantized_vectors::QuantizedVectors;
+use crate::vector_storage::query::{ContextPair, ContextQuery, DiscoveryQuery, RecoQuery, QueryVariant};
 use crate::vector_storage::tests::utils::score;
 use crate::vector_storage::vector_storage_base::VectorStorage;
-use crate::vector_storage::{VectorStorageEnum, new_raw_scorer_for_test};
+use crate::vector_storage::{new_raw_scorer_for_test, VectorStorageEnum};
 
 const DIMS: usize = 128;
 const NUM_POINTS: usize = 600;
@@ -39,7 +40,6 @@ type Result<T, E = Error> = result::Result<T, E>;
 type Error = Box<dyn error::Error>;
 
 type Sampler<'a> = Box<dyn Iterator<Item = VectorElementType> + 'a>;
-
 type SamplerGenerator = Box<dyn for<'a> Fn(&'a mut StdRng) -> Sampler<'a>>;
 
 type WithQuantization = (QuantizationConfig, SamplerGenerator);
@@ -54,22 +54,6 @@ fn random_query<R: Rng + ?Sized>(
     })
 }
 
-fn ram_storage(dir: &Path) -> VectorStorageEnum {
-    open_simple_dense_vector_storage(
-        rocksdb_wrapper::open_db(dir, &[rocksdb_wrapper::DB_VECTOR_CF]).unwrap(),
-        rocksdb_wrapper::DB_VECTOR_CF,
-        DIMS,
-        DISTANCE,
-        &AtomicBool::new(false),
-    )
-    .unwrap()
-}
-
-#[cfg(target_os = "linux")]
-fn async_memmap_storage(dir: &std::path::Path) -> VectorStorageEnum {
-    open_memmap_vector_storage_with_async_io(dir, DIMS, DISTANCE, true).unwrap()
-}
-
 fn scalar_u8() -> WithQuantization {
     let config = ScalarQuantizationConfig {
         r#type: crate::types::ScalarType::Int8,
@@ -92,8 +76,9 @@ fn product_x4() -> WithQuantization {
     }
     .into();
 
-    let sampler: SamplerGenerator =
-        Box::new(|rng: &mut StdRng| Box::new(rng.sample_iter(rand::distr::StandardUniform)));
+    let sampler: SamplerGenerator = Box::new(|rng: &mut StdRng| {
+        Box::new(rng.sample_iter(rand::distr::StandardUniform))
+    });
 
     (config, sampler)
 }
@@ -106,43 +91,73 @@ fn binary() -> WithQuantization {
 
     let sampler: SamplerGenerator = Box::new(|rng: &mut StdRng| {
         Box::new(
-            rng.sample_iter(rand::distr::Uniform::new_inclusive(-1.0, 1.0).unwrap())
-                .map(|x| f32::from(x as u8)),
+            rng.sample_iter(
+                rand::distr::Uniform::new_inclusive(-1.0, 1.0).unwrap(),
+            )
+            .map(|x| f32::from(x as u8)),
         )
     });
 
     (config, sampler)
 }
 
+fn ram_storage(dir: &Path) -> VectorStorageEnum {
+    open_simple_dense_vector_storage(
+        rocksdb_wrapper::open_db(dir, &[rocksdb_wrapper::DB_VECTOR_CF]).unwrap(),
+        rocksdb_wrapper::DB_VECTOR_CF,
+        DIMS,
+        DISTANCE,
+        &AtomicBool::new(false),
+    )
+    .unwrap()
+}
+
+#[cfg(target_os = "linux")]
+fn async_memmap_storage(dir: &std::path::Path) -> VectorStorageEnum {
+    open_memmap_vector_storage_with_async_io(dir, DIMS, DISTANCE, true).unwrap()
+}
+
 fn scoring_equivalency(
     query_variant: QueryVariant,
     other_storage: impl FnOnce(&std::path::Path) -> VectorStorageEnum,
     with_quantization: Option<WithQuantization>,
 ) -> Result<()> {
     let (quant_config, quant_sampler) = with_quantization
-        .map(|v| (Some(v.0), Some(v.1)))
+        .map(|(c, s)| (Some(c), Some(s)))
         .unwrap_or_default();
 
-    let raw_dir = tempfile::Builder::new().prefix("raw-storage").tempdir()?;
-
-    let db = rocksdb_wrapper::open_db(raw_dir.path(), &[rocksdb_wrapper::DB_VECTOR_CF])?;
+    let raw_dir = tempfile::Builder::new()
+        .prefix("raw-storage")
+        .tempdir()?;
 
-    let mut raw_storage = open_simple_dense_vector_storage(
-        db,
+    let raw_storage = open_simple_dense_vector_storage(
+        rocksdb_wrapper::open_db(
+            raw_dir.path(),
+            &[rocksdb_wrapper::DB_VECTOR_CF],
+        )?,
         rocksdb_wrapper::DB_VECTOR_CF,
         DIMS,
         DISTANCE,
         &AtomicBool::default(),
     )?;
+    let mut raw_storage = raw_storage;
 
     let mut rng = StdRng::seed_from_u64(SEED);
-    let gen_sampler = quant_sampler.unwrap_or_else(|| Box::new(|rng| Box::new(sampler(rng))));
+    let sampler_generator = quant_sampler.unwrap_or_else(|| {
+        Box::new(move |rng: &mut StdRng| {
+            Box::new(
+                rng.sample_iter(
+                    rand_distr::Uniform::new_inclusive(-1.0, 1.0).unwrap(),
+                ),
+            )
+        })
+    });
 
     super::utils::insert_distributed_vectors(
         DIMS,
         &mut raw_storage,
         NUM_POINTS,
-        &mut gen_sampler(&mut rng.clone()),
+        &mut sampler_generator(&mut rng.clone()),
     )?;
 
     let mut id_tracker = FixtureIdTracker::new(NUM_POINTS);
@@ -153,7 +168,9 @@ fn scoring_equivalency(
         NUM_POINTS / 10,
     )?;
 
-    let other_dir = tempfile::Builder::new().prefix("other-storage").tempdir()?;
+    let other_dir = tempfile::Builder::new()
+        .prefix("other-storage")
+        .tempdir()?;
 
     let mut other_storage = other_storage(other_dir.path());
 
@@ -165,29 +182,34 @@ fn scoring_equivalency(
     });
     other_storage.update_from(&mut iter, &Default::default())?;
 
-    let quant_dir = tempfile::Builder::new().prefix("quant-storage").tempdir()?;
+    let quant_dir = tempfile::Builder::new()
+        .prefix("quant-storage")
+        .tempdir()?;
     let quantized_vectors = if let Some(config) = &quant_config {
-        Some(QuantizedVectors::create(
-            &other_storage,
-            config,
-            quant_dir.path(),
-            4,
-            &AtomicBool::new(false),
-        )?)
+        Some(
+            QuantizedVectors::create(
+                &other_storage,
+                config,
+                quant_dir.path(),
+                4,
+                &AtomicBool::new(false),
+                1,
+            )?,
+        )
     } else {
         None
     };
+    let quantized_vectors = quantized_vectors.as_ref().map(|q| q.borrow());
 
     let attempts = 50;
     for i in 0..attempts {
-        let query = random_query(&query_variant, &mut rng, &gen_sampler);
+        let query = random_query(&query_variant, &mut rng, &sampler_generator);
 
         let raw_scorer = new_raw_scorer_for_test(
             query.clone(),
             &raw_storage,
             id_tracker.deleted_point_bitslice(),
-        )
-        .unwrap();
+        );
 
         let other_scorer = match &quantized_vectors {
             Some(quantized_storage) => quantized_storage
@@ -206,24 +228,21 @@ fn scoring_equivalency(
             .unwrap(),
         };
 
-        let points =
-            (0..other_storage.total_vector_count() as _).choose_multiple(&mut rng, SAMPLE_SIZE);
+        let points = (0..other_storage.total_vector_count() as _)
+            .choose_multiple(&mut rng, SAMPLE_SIZE);
 
         let raw_scores = score(&*raw_scorer, &points);
         let other_scores = score(&*other_scorer, &points);
 
-        // Compare scores
         if quantized_vectors.is_none() {
-            // both calculations are done on raw vectors, so score should be exactly the same
+            // both calculations are done on raw vectors, scores must match exactly
             assert_eq!(
-                raw_scores, other_scores,
+                raw_scores,
+                other_scores,
                 "Scorer results are not equal, attempt: {i}, query: {query:?}"
             );
         } else {
-            // Quantization is used for the other storage, so score should be similar
-            // but not necessarily the exact same. Recommend query has a step function,
-            // so small differences in similarities can lead to very different scores
-
+            // Quantization can cause differences; validate that top results overlap
             let top = SAMPLE_SIZE / 10;
 
             let raw_top: HashSet<_> = raw_scores
@@ -233,6 +252,7 @@ fn scoring_equivalency(
                 .take(top)
                 .map(|p| p.idx)
                 .collect();
+
             let other_top: HashSet<_> = other_scores
                 .iter()
                 .sorted()
@@ -244,13 +264,16 @@ fn scoring_equivalency(
             let intersection = raw_top.intersection(&other_top).count();
 
             assert!(
-                (intersection as f32 / top as f32) >= 0.7, // at least 70% of top 10% results should be shared
+                (intersection as f32) / (top as f32) >= 0.7,
                 "Top results from scorers are not similar, attempt {i}:
                 top raw: {raw_top:?},
-                top other: {other_top:?}
-                only {intersection} of {top} top results are shared",
+                top other: {other_top:?},
+                only {intersection} of {top} top results are shared"
             );
         }
+
+        raw_scorer.take_hardware_counter().discard_results();
+        other_scorer.take_hardware_counter().discard_results();
     }
 
     Ok(())
@@ -266,7 +289,12 @@ fn compare_scoring_equivalency(
     )]
     query_variant: QueryVariant,
     #[values(ram_storage)] other_storage: impl FnOnce(&std::path::Path) -> VectorStorageEnum,
-    #[values(None, Some(product_x4()), Some(scalar_u8()), Some(binary()))]
+    #[values(
+        None,
+        Some(product_x4()),
+        Some(scalar_u8()),
+        Some(binary())
+    )]
     quantization_config: Option<WithQuantization>,
 ) -> Result<()> {
     scoring_equivalency(query_variant, other_storage, quantization_config)
