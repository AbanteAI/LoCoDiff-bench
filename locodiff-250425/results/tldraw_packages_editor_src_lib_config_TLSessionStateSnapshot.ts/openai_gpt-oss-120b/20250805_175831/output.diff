
index 1dbf9d1f4..f31d39848 100644
--- a/tldraw_packages_editor_src_lib_config_TLSessionStateSnapshot.ts_expectedoutput.txt (expected):tmp/tmprpn7ua9e_expected.txt	
+++ b/tldraw_packages_editor_src_lib_config_TLSessionStateSnapshot.ts_extracted.txt (actual):tmp/tmpejs2tgdc_actual.txt	
@@ -1,5 +1,6 @@
 import { Signal, computed } from '@tldraw/state'
 import { UnknownRecord } from '@tldraw/store'
+
 import {
 	CameraRecordType,
 	InstancePageStateRecordType,
@@ -11,13 +12,16 @@ import {
 	pluckPreservingValues,
 	shapeIdValidator,
 } from '@tldraw/tlschema'
+
 import {
 	deleteFromSessionStorage,
 	getFromSessionStorage,
+	objectMapFromEntries,
 	setInSessionStorage,
 	structuredClone,
 	uniqueId,
 } from '@tldraw/utils'
+
 import { T } from '@tldraw/validate'
 import isEqual from 'lodash.isequal'
 import { tlenv } from '../globals/environment'
@@ -27,16 +31,24 @@ const tabIdKey = 'TLDRAW_TAB_ID_v2' as const
 const window = globalThis.window as
 	| {
 			navigator: Window['navigator']
+			localStorage: Window['localStorage']
+			sessionStorage: Window['sessionStorage']
 			addEventListener: Window['addEventListener']
 			TLDRAW_TAB_ID_v2?: string
 	  }
 	| undefined
 
-// https://stackoverflow.com/a/tldraw_packages_editor_src_lib_config_TLSessionStateSnapshot.ts_expectedoutput.txt (expected): string = window
-	? (window[tabIdKey] ??
-		getFromSessionStorage(tabIdKey) ??
-		`TLDRAW_INSTANCE_STATE_V1_` + uniqueId())
+	? window[tabIdKey] ??
+	  getFromSessionStorage(tabIdKey) ??
+	  `TLDRAW_INSTANCE_STATE_V1_` + uniqueId()
 	: '<error>'
+
 if (window) {
 	window[tabIdKey] = TAB_ID
 	if (iOS()) {
-		// iOS does not trigger beforeunload
-		// so we need to keep the sessionStorage value around
-		// and hope the user doesn't figure out a way to duplicate their tab
-		// in which case they'll have two tabs with the same UI state.
-		// It's not a big deal, but it's not ideal.
-		// And anyway I can't see a way to duplicate a tab in iOS Safari.
+		// iOS does not trigger beforeunload so keep sessionStorage
+		// (duplicate tab detection not perfect)
 		setInSessionStorage(tabIdKey, TAB_ID)
 	} else {
 		deleteFromSessionStorage(tabIdKey)
@@ -81,10 +90,9 @@ const CURRENT_SESSION_STATE_SNAPSHOT_VERSION = Math.max(...Object.values(Version
 
 function migrate(snapshot: any) {
 	if (snapshot.version < Versions.Initial) {
-		// initial version
-		// noop
+		// initial version (noop)
 	}
-	// add further migrations down here. see TLUserPreferences.ts for an example.
+	// add further migrations down here… 
 
 	// finally
 	snapshot.version = CURRENT_SESSION_STATE_SNAPSHOT_VERSION
@@ -133,22 +141,27 @@ const sessionStateSnapshotValidator: T.Validator<TLSessionStateSnapshot> = T.obj
 	).optional(),
 })
 
-function migrateAndValidateSessionStateSnapshot(state: unknown): TLSessionStateSnapshot | null {
+function migrateAndValidateSessionStateSnapshot(
+	state: unknown
+): TLSessionStateSnapshot | null {
 	if (!state || typeof state !== 'object') {
 		console.warn('Invalid instance state')
 		return null
 	}
-	if (!('version' in state) || typeof state.version !== 'number') {
+	if (!('version' in state) || typeof (state as any).version !== 'number') {
 		console.warn('No version in instance state')
 		return null
 	}
-	if (state.version !== CURRENT_SESSION_STATE_SNAPSHOT_VERSION) {
-		state = structuredClone(state)
-		migrate(state)
+	if ((state as any).version !== CURRENT_SESSION_STATE_SNAPSHOT_VERSION) {
+		// Clone before mutating
+		const cloned = structuredClone(state)
+		migrate(cloned)
+		; (state as any) = cloned
 	}
-
 	try {
-		return sessionStateSnapshotValidator.validate(state)
+		return sessionStateSnapshotValidator.validate(
+			state as TLSessionStateSnapshot
+		) as TLSessionStateSnapshot
 	} catch (e) {
 		console.warn(e)
 		return null
@@ -158,8 +171,6 @@ function migrateAndValidateSessionStateSnapshot(state: unknown): TLSessionStateS
 /**
  * Creates a signal of the instance state for a given store.
  * @public
- * @param store - The store to create the instance state snapshot signal for
- * @returns
  */
 export function createSessionStateSnapshotSignal(
 	store: TLStore
@@ -168,6 +179,9 @@ export function createSessionStateSnapshotSignal(
 
 	return computed<TLSessionStateSnapshot | null>(
 		'sessionStateSnapshot',
+		/**
+		 * No side‑effects, no impure getters!
+		 */
 		() => {
 			const instanceState = store.get(TLINSTANCE_ID)
 			if (!instanceState) return null
@@ -175,28 +189,28 @@ export function createSessionStateSnapshotSignal(
 			const allPageIds = [...$allPageIds.get()]
 			return {
 				version: CURRENT_SESSION_STATE_SNAPSHOT_VERSION,
-				currentPageId: instanceState.currentPageId,
-				exportBackground: instanceState.exportBackground,
-				isFocusMode: instanceState.isFocusMode,
-				isDebugMode: instanceState.isDebugMode,
-				isToolLocked: instanceState.isToolLocked,
-				isGridMode: instanceState.isGridMode,
-				pageStates: allPageIds.map((id) => {
-					const ps = store.get(InstancePageStateRecordType.createId(id))
-					const camera = store.get(CameraRecordType.createId(id))
-					return {
-						pageId: id,
-						camera: {
-							x: camera?.x ?? 0,
-							y: camera?.y ?? 0,
-							z: camera?.z ?? 1,
-						},
-						selectedShapeIds: ps?.selectedShapeIds ?? [],
-						focusedGroupId: ps?.focusedGroupId ?? null,
-					} satisfies NonNullable<TLSessionStateSnapshot['pageStates']>[0]
-				}),
-			} satisfies TLSessionStateSnapshot
-		},
+					currentPageId: instanceState.currentPageId,
+					exportBackground: instanceState.exportBackground,
+					isFocusMode: instanceState.isFocusMode,
+					isDebugMode: instanceState.isDebugMode,
+					isToolLocked: instanceState.isToolLocked,
+					isGridMode: instanceState.isGridMode,
+					pageStates: allPageIds.map((id) => {
+						const ps = store.get(InstancePageStateRecordType.createId(id))
+						const camera = store.get(CameraRecordType.createId(id))
+						return {
+							pageId: id,
+							camera: {
+								x: camera?.x ?? 0,
+								y: camera?.y ?? 0,
+								z: camera?.z ?? 1,
+							},
+							selectedShapeIds: ps?.selectedShapeIds ?? [],
+							focusedGroupId: ps?.focusedGroupId ?? null,
+						} satisfies NonNullable<TLSessionStateSnapshot['pageStates']>[0]
+					}),
+				} satisfies TLSessionStateSnapshot
+			},
 		{ isEqual }
 	)
 }
@@ -208,19 +222,15 @@ export function createSessionStateSnapshotSignal(
 export interface TLLoadSessionStateSnapshotOptions {
 	/**
 	 * By default, some session state flags like `isDebugMode` are not overwritten when loading a snapshot.
-	 * These are usually considered "sticky" by users while the document data is not.
 	 * If you want to overwrite these flags, set this to `true`.
 	 */
 	forceOverwrite?: boolean
 }
 
 /**
- * Loads a snapshot of the editor's instance state into the store of a new editor instance.
+ * Loads a snapshot of the editor's instance state into a new store.
  *
  * @public
- * @param store - The store to load the instance state into
- * @param snapshot - The instance state snapshot to load
- * @returns
  */
 export function loadSessionStateSnapshotIntoStore(
 	store: TLStore,
@@ -237,7 +247,6 @@ export function loadSessionStateSnapshotIntoStore(
 	const instanceState = store.schema.types.instance.create({
 		id: TLINSTANCE_ID,
 		...preserved,
-		// the integrity checker will ensure that the currentPageId is valid
 		currentPageId: res.currentPageId,
 		isDebugMode: primary?.isDebugMode ?? secondary?.isDebugMode,
 		isFocusMode: primary?.isFocusMode ?? secondary?.isFocusMode,
@@ -246,35 +255,49 @@ export function loadSessionStateSnapshotIntoStore(
 		exportBackground: primary?.exportBackground ?? secondary?.exportBackground,
 	})
 
+	// Gather all existing page states and cameras
+	const allPageStatesAndCameras = store
+		.allRecords()
+		.filter((r) => r.typeName === 'instance_page_state' || r.typeName === 'camera')
+
 	store.atomic(() => {
+		// Remove existing page states and cameras
+		store.remove(allPageStatesAndCameras.map((r) => r.id))
+
+		// Insert new page states and cameras from the snapshot
 		for (const ps of res.pageStates ?? []) {
 			if (!store.has(ps.pageId)) continue
 			const cameraId = CameraRecordType.createId(ps.pageId)
-			const instancePageState = InstancePageStateRecordType.createId(ps.pageId)
+			const instancePageStateId = InstancePageStateRecordType.createId(ps.pageId)
 			const previousCamera = store.get(cameraId)
-			const previousInstanceState = store.get(instancePageState)
+			const previousInstance = store.get(instancePageStateId)
+
 			store.put([
 				CameraRecordType.create({
 					id: cameraId,
 					x: ps.camera?.x ?? previousCamera?.x,
-					y: ps.camera?.y ?? previousCamera?.y,
-					z: ps.camera?.z ?? previousCamera?.z,
+					y: camera?.y ?? previousCamera?.y,
+					z: camera?.z ?? previousCamera?.z,
 				}),
 				InstancePageStateRecordType.create({
-					id: instancePageState,
+					id: instancePageStateId,
 					pageId: ps.pageId,
-					selectedShapeIds: ps.selectedShapeIds ?? previousInstanceState?.selectedShapeIds,
-					focusedGroupId: ps.focusedGroupId ?? previousInstanceState?.focusedGroupId,
+					selectedShapeIds:
+						ps.selectedShapeIds ?? previousInstance?.selectedShapeIds,
+					focusedGroupId:
+						ps.focusedGroupId ?? previousInstance?.focusedGroupId,
 				}),
 			])
 		}
-
+		// Save the instance state
 		store.put([instanceState])
 		store.ensureStoreIsUsable()
 	})
 }
 
 /**
+ * Extract instance state from legacy snapshot.
+ *
  * @internal
  */
 export function extractSessionStateFromLegacySnapshot(
@@ -287,10 +310,8 @@ export function extractSessionStateFromLegacySnapshot(
 		}
 	}
 
-	// for scratch documents, we need to extract the most recently-used instance and it's associated page states
-	// but oops we don't have the concept of "most recently-used" so we'll just take the first one
 	const oldInstance = instanceRecords.filter(
-		(r) => r.typeName === 'instance' && r.id !== TLINSTANCE_ID
+		(r) => (r as any).typeName === 'instance' && (r as any).id !== TLINSTANCE_ID
 	)[0] as any
 	if (!oldInstance) return null
 
@@ -306,17 +327,17 @@ export function extractSessionStateFromLegacySnapshot(
 			.filter((r: any) => r.typeName === 'instance_page_state' && r.instanceId === oldInstance.id)
 			.map((ps: any) => {
 				const camera = (store[ps.cameraId] as any) ?? { x: 0, y: 0, z: 1 }
-				return {
-					pageId: ps.pageId,
-					camera: {
-						x: camera.x,
-						y: camera.y,
-						z: camera.z,
-					},
-					selectedShapeIds: ps.selectedShapeIds,
-					focusedGroupId: ps.focusedGroupId,
-				} satisfies NonNullable<TLSessionStateSnapshot['pageStates']>[0]
-			}),
+					return {
+						pageId: ps.pageId,
+						camera: {
+							x: camera.x,
+							y: camera.y,
+							z: camera.z,
+						},
+						selectedShapeIds: ps.selectedShapeIds,
+						focusedGroupId: ps.focusedGroupId,
+					} satisfies NonNullable<TLSessionStateSnapshot['pageStates']>[0]
+				}),
 	}
 
 	try {
