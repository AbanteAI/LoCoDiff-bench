
index 97424dcee..adc946db1 100644
--- a/aider_aider_website__includes_leaderboard_table.js_expectedoutput.txt (expected):tmp/tmp_1otkji9_expected.txt	
+++ b/aider_aider_website__includes_leaderboard_table.js_extracted.txt (actual):tmp/tmpye8cd3dp_actual.txt	
@@ -217,140 +217,64 @@ document.addEventListener('DOMContentLoaded', function() {
     }
   });
 
-  // Function to calculate the appropriate max display cost based on visible/selected entries
-  function calculateDisplayMaxCost() {
-    // Get the appropriate set of rows based on the current mode and selection state
-    let rowsToConsider;    
-    
-    if (currentMode === 'view' && selectedRows.size > 0) {
-      // In view mode with selections, only consider selected rows
-      rowsToConsider = Array.from(allMainRows).filter(row => {
-        const rowIndex = row.querySelector('.row-selector')?.dataset.rowIndex;
-        return rowIndex && selectedRows.has(rowIndex) && !row.classList.contains('hidden-by-search');
-      });
+  // Process cost bars
+  const costBars = document.querySelectorAll('.cost-bar');
+  costBars.forEach(bar => {
+    const cost = parseFloat(bar.dataset.cost);
+    const maxCost = parseFloat(bar.dataset.maxCost);
+ 
+    if (cost > 0 && maxCost > 0) {
+      // Calculate percentage directly (linear scale)
+      const percent = (cost / maxCost) * 100;
+      // Clamp percentage between 0 and 100
+      bar.style.width = Math.max(0, Math.min(100, percent)) + '%';
     } else {
-      // In other modes or without selections, consider all visible rows
-      rowsToConsider = getVisibleMainRows();
+      // Set width to 0 if cost is 0 or negative
+      bar.style.width = '0%';
     }
-    
-    // Find the maximum cost among the rows to consider
-    let maxCost = 0;
-    rowsToConsider.forEach(row => {
-      const costBar = row.querySelector('.cost-bar');
-      if (costBar) {
-        const cost = parseFloat(costBar.dataset.cost || '0');
-        if (cost > maxCost) maxCost = cost;
-      }
-    });
-    
-    // Cap at MAX_DISPLAY_COST_CAP if any entries exceed that amount, otherwise use actual max
-    return maxCost > MAX_DISPLAY_COST_CAP ? MAX_DISPLAY_COST_CAP : Math.max(1, maxCost); // Ensure at least 1 to avoid division by zero
-  }
-  
-  // Process cost bars with dynamic scale
-  function updateCostBars() {
-    const costBars = document.querySelectorAll('.cost-bar');
-    const currentMaxDisplayCost = calculateDisplayMaxCost();
-    
-    // Remove existing special indicators first
-    document.querySelectorAll('.dark-section, .tear-line').forEach(el => el.remove());
-    
-    costBars.forEach(bar => {
-      const cost = parseFloat(bar.dataset.cost);
-      
-      if (cost > 0) {
-        // Calculate percentage based on the dynamic display max
-        const percent = Math.min(cost, currentMaxDisplayCost) / currentMaxDisplayCost * 100;
-        // Clamp percentage between 0 and 100
-        bar.style.width = Math.max(0, Math.min(100, percent)) + '%';
-        
-        // Mark bars that exceed the limit (only if our display max is capped at 50)
-        if (currentMaxDisplayCost === MAX_DISPLAY_COST_CAP && cost > MAX_DISPLAY_COST_CAP) {
-          // Create a darker section at the end with diagonal stripes
-          const darkSection = document.createElement('div');
-          darkSection.className = 'bar-viz dark-section';
-          darkSection.style.width = '15%'; // From 85% to 100%
-          darkSection.style.left = '85%';
-          darkSection.style.backgroundColor = 'rgba(13, 110, 253, 0.6)'; // Darker blue
-          darkSection.style.borderRight = '1px solid rgba(13, 110, 253, 0.8)';
-          darkSection.style.zIndex = '1';
-          // Add diagonal stripes with CSS background
-          darkSection.style.backgroundImage = 'repeating-linear-gradient(45deg, rgba(255,255,255,0.3), rgba(255,255,255,0.3) 5px, transparent 5px, transparent 10px)';
-          bar.parentNode.appendChild(darkSection);
-          
-          // Add a dashed "tear line" at the transition point
-          const tearLine = document.createElement('div');
-          tearLine.className = 'tear-line';
-          tearLine.style.position = 'absolute';
-          tearLine.style.left = '85%';
-          // Center the tear line vertically and make it 1.5x as tall as the bar
-          tearLine.style.top = '50%';
-          tearLine.style.transform = 'translateY(-50%)';
-          tearLine.style.height = '54px'; // 1.5x the bar height (36px)
-          tearLine.style.width = '2px';
-          tearLine.style.backgroundColor = 'white';
-          tearLine.style.borderLeft = '2px dashed rgba(0, 0, 0, 0.3)';
-          tearLine.style.zIndex = '2'; // Above the bar
-          bar.parentNode.appendChild(tearLine);
-        }
-      } else {
-        // Set width to 0 if cost is 0 or negative
-        bar.style.width = '0%';
+  });
+
+  // Calculate and add cost ticks dynamically
+  const costCells = document.querySelectorAll('.cost-bar-cell');
+  if (costCells.length > 0) {
+    // Find the max cost from the first available cost bar's data attribute
+    const firstCostBar = document.querySelector('.cost-bar');
+    const maxCost = parseFloat(firstCostBar?.dataset.maxCost || '1'); // Use 1 as fallback
+
+    if (maxCost > 0) {
+      const tickValues = [];
+      // Generate ticks at regular intervals (every 20% of max cost)
+      tickValues.push(0); // Add tick at base (0 position)
+      for (let i = 1; i <= 5; i++) {
+        tickValues.push((maxCost * i) / 5);
       }
-    });
-  }
-  
-  // Call this initially to set up the bars
-  updateCostBars();
 
-  // Update cost ticks dynamically based on current max display cost
-  function updateCostTicks() {
-    const costCells = document.querySelectorAll('.cost-bar-cell');
-    if (costCells.length === 0) return;
-    
-    const currentMaxDisplayCost = calculateDisplayMaxCost();
-    
-    // Remove existing ticks first
-    document.querySelectorAll('.cost-tick').forEach(tick => tick.remove());
-    
-    // Generate appropriate tick values based on current max
-    let tickValues = [];
-    
-    // Always use $10 increments, regardless of the max
-    const maxTickValue = Math.ceil(currentMaxDisplayCost / 10) * 10; // Round up to nearest $10
-    
-    for (let i = 0; i <= maxTickValue; i += 10) {
-      tickValues.push(i);
+      // Calculate percentage positions for each tick on the linear scale
+      const tickPercentages = tickValues.map(tickCost => {
+        return (tickCost / maxCost) * 100;
+      });
+
+      // Add tick divs to each cost cell
+      costCells.forEach(cell => {
+        const costBar = cell.querySelector('.cost-bar');
+        // Use optional chaining and provide '0' as fallback if costBar or dataset.cost is missing
+        const cost = parseFloat(costBar?.dataset?.cost || '0');
+
+        // Only add ticks if the cost is actually greater than 0
+        if (cost > 0) {
+          tickPercentages.forEach(percent => {
+            // Ensure percentage is within valid range
+            if (percent >= 0 && percent <= 100) {
+              const tick = document.createElement('div');
+              tick.className = 'cost-tick';
+              tick.style.left = `${percent}%`;
+              cell.appendChild(tick);
+            }
+          });
+        }
+      });
     }
-    
-    // Calculate percentage positions for each tick
-    const tickPercentages = tickValues.map(tickCost => {
-      return (tickCost / currentMaxDisplayCost) * 100;
-    });
-    
-    // Add tick divs to each cost cell
-    costCells.forEach(cell => {
-      const costBar = cell.querySelector('.cost-bar');
-      // Use optional chaining and provide '0' as fallback if costBar or dataset.cost is missing
-      const cost = parseFloat(costBar?.dataset?.cost || '0');
-      
-      // Only add ticks if the cost is actually greater than 0
-      if (cost > 0) {
-        tickPercentages.forEach((percent, index) => {
-          // Ensure percentage is within valid range
-          if (percent >= 0 && percent <= 100) {
-            const tick = document.createElement('div');
-            tick.className = 'cost-tick';
-            tick.style.left = `${percent}%`;
-            cell.appendChild(tick);
-          }
-        });
-      }
-    });
   }
-  
-  // Call this initially to set up the ticks
-  updateCostTicks();
 
 
   // --- New Event Listeners ---
@@ -497,6 +421,142 @@ document.addEventListener('DOMContentLoaded', function() {
   });
 
 
+  // Function to calculate the appropriate max display cost based on visible/selected entries
+  function calculateDisplayMaxCost() {
+    // Get the appropriate set of rows based on the current mode and selection state
+    let rowsToConsider;    
+    
+    if (currentMode === 'view' && selectedRows.size > 0) {
+      // In view mode with selections, only consider selected rows
+      rowsToConsider = Array.from(allMainRows).filter(row => {
+        const rowIndex = row.querySelector('.row-selector')?.dataset.rowIndex;
+        return rowIndex && selectedRows.has(rowIndex) && !row.classList.contains('hidden-by-search');
+      });
+    } else {
+      // In other modes or without selections, consider all visible rows
+      rowsToConsider = getVisibleMainRows();
+    }
+    
+    // Find the maximum cost among the rows to consider
+    let maxCost = 0;
+    rowsToConsider.forEach(row => {
+      const costBar = row.querySelector('.cost-bar');
+      if (costBar) {
+        const cost = parseFloat(costBar.dataset.cost || '0');
+        if (cost > maxCost) maxCost = cost;
+      }
+    });
+    
+    // Cap at MAX_DISPLAY_COST_CAP if any entries exceed that amount, otherwise use actual max
+    return maxCost > MAX_DISPLAY_COST_CAP ? MAX_DISPLAY_COST_CAP : Math.max(1, maxCost); // Ensure at least 1 to avoid division by zero
+  }
+  
+  // Process cost bars with dynamic scale
+  function updateCostBars() {
+    const costBars = document.querySelectorAll('.cost-bar');
+    const currentMaxDisplayCost = calculateDisplayMaxCost();
+    
+    // Remove existing special indicators first
+    document.querySelectorAll('.dark-section, .tear-line').forEach(el => el.remove());
+    
+    costBars.forEach(bar => {
+      const cost = parseFloat(bar.dataset.cost);
+      
+      if (cost > 0) {
+        // Calculate percentage based on the dynamic display max
+        const percent = Math.min(cost, currentMaxDisplayCost) / currentMaxDisplayCost * 100;
+        // Clamp percentage between 0 and 100
+        bar.style.width = Math.max(0, Math.min(100, percent)) + '%';
+        
+        // Mark bars that exceed the limit (only if our display max is capped at 50)
+        if (currentMaxDisplayCost === MAX_DISPLAY_COST_CAP && cost > MAX_DISPLAY_COST_CAP) {
+          // Create a darker section at the end with diagonal stripes
+          const darkSection = document.createElement('div');
+          darkSection.className = 'bar-viz dark-section';
+          darkSection.style.width = '15%'; // From 85% to 100%
+          darkSection.style.left = '85%';
+          darkSection.style.backgroundColor = 'rgba(13, 110, 253, 0.6)'; // Darker blue
+          darkSection.style.borderRight = '1px solid rgba(13, 110, 253, 0.8)';
+          darkSection.style.zIndex = '1';
+          // Add diagonal stripes with CSS background
+          darkSection.style.backgroundImage = 'repeating-linear-gradient(45deg, rgba(255,255,255,0.3), rgba(255,255,255,0.3) 5px, transparent 5px, transparent 10px)';
+          bar.parentNode.appendChild(darkSection);
+          
+          // Add a dashed "tear line" at the transition point
+          const tearLine = document.createElement('div');
+          tearLine.className = 'tear-line';
+          tearLine.style.position = 'absolute';
+          tearLine.style.left = '85%';
+          // Center the tear line vertically and make it 1.5x as tall as the bar
+          tearLine.style.top = '50%';
+          tearLine.style.transform = 'translateY(-50%)';
+          tearLine.style.height = '54px'; // 1.5x the bar height (36px)
+          tearLine.style.width = '2px';
+          tearLine.style.backgroundColor = 'white';
+          tearLine.style.borderLeft = '2px dashed rgba(0, 0, 0, 0.3)';
+          tearLine.style.zIndex = '2'; // Above the bar
+          bar.parentNode.appendChild(tearLine);
+        }
+      } else {
+        // Set width to 0 if cost is 0 or negative
+        bar.style.width = '0%';
+      }
+    });
+  }
+  
+  // Call this initially to set up the bars
+  updateCostBars();
+
+  // Update cost ticks dynamically based on current max display cost
+  function updateCostTicks() {
+    const costCells = document.querySelectorAll('.cost-bar-cell');
+    if (costCells.length === 0) return;
+    
+    const currentMaxDisplayCost = calculateDisplayMaxCost();
+    
+    // Remove existing ticks first
+    document.querySelectorAll('.cost-tick').forEach(tick => tick.remove());
+    
+    // Generate appropriate tick values based on current max
+    let tickValues = [];
+    
+    // Always use $10 increments, regardless of the max
+    const maxTickValue = Math.ceil(currentMaxDisplayCost / 10) * 10; // Round up to nearest $10
+    
+    for (let i = 0; i <= maxTickValue; i += 10) {
+      tickValues.push(i);
+    }
+    
+    // Calculate percentage positions for each tick
+    const tickPercentages = tickValues.map(tickCost => {
+      return (tickCost / currentMaxDisplayCost) * 100;
+    });
+    
+    // Add tick divs to each cost cell
+    costCells.forEach(cell => {
+      const costBar = cell.querySelector('.cost-bar');
+      // Use optional chaining and provide '0' as fallback if costBar or dataset.cost is missing
+      const cost = parseFloat(costBar?.dataset?.cost || '0');
+      
+      // Only add ticks if the cost is actually greater than 0
+      if (cost > 0) {
+        tickPercentages.forEach((percent, index) => {
+          // Ensure percentage is within valid range
+          if (percent >= 0 && percent <= 100) {
+            const tick = document.createElement('div');
+            tick.className = 'cost-tick';
+            tick.style.left = `${percent}%`;
+            cell.appendChild(tick);
+          }
+        });
+      }
+    });
+  }
+  
+  // Call this initially to set up the ticks
+  updateCostTicks();
+
+
   // --- Initial Setup ---
   updateTableView('view'); // Initialize view to 'view' mode
   applySearchFilter(); // Apply initial search filter (if any text is pre-filled or just to set initial state)
