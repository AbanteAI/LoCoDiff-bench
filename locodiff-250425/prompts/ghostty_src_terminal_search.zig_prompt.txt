# Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- src/terminal/search.zig

commit 61c5fb81150a7924e1cba399dbe526a8ef254285
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Nov 9 09:37:03 2024 -0800

    terminal: single pagelist node search

diff --git a/src/terminal/search.zig b/src/terminal/search.zig
new file mode 100644
index 00000000..96a7b56a
--- /dev/null
+++ b/src/terminal/search.zig
@@ -0,0 +1,148 @@
+const std = @import("std");
+const Allocator = std.mem.Allocator;
+const assert = std.debug.assert;
+const terminal = @import("main.zig");
+const point = terminal.point;
+const Page = terminal.Page;
+const PageList = terminal.PageList;
+const Selection = terminal.Selection;
+const Screen = terminal.Screen;
+
+pub const PageSearch = struct {
+    alloc: Allocator,
+    node: *PageList.List.Node,
+    needle: []const u8,
+    cell_map: Page.CellMap,
+    encoded: std.ArrayListUnmanaged(u8) = .{},
+    i: usize = 0,
+
+    pub fn init(
+        alloc: Allocator,
+        node: *PageList.List.Node,
+        needle: []const u8,
+    ) !PageSearch {
+        var result: PageSearch = .{
+            .alloc = alloc,
+            .node = node,
+            .needle = needle,
+            .cell_map = Page.CellMap.init(alloc),
+        };
+
+        const page: *const Page = &node.data;
+        _ = try page.encodeUtf8(result.encoded.writer(alloc), .{
+            .cell_map = &result.cell_map,
+        });
+
+        return result;
+    }
+
+    pub fn deinit(self: *PageSearch) void {
+        self.encoded.deinit(self.alloc);
+        self.cell_map.deinit();
+    }
+
+    pub fn next(self: *PageSearch) ?Selection {
+        // Search our haystack for the needle. The resulting index is
+        // the offset from self.i not the absolute index.
+        const haystack: []const u8 = self.encoded.items[self.i..];
+        const i_offset = std.mem.indexOf(u8, haystack, self.needle) orelse {
+            self.i = self.encoded.items.len;
+            return null;
+        };
+
+        // Get our full index into the encoded buffer.
+        const idx = self.i + i_offset;
+
+        // We found our search term. Move the cursor forward one beyond
+        // the match. This lets us find every repeated match.
+        self.i = idx + 1;
+
+        const tl: PageList.Pin = tl: {
+            const map = self.cell_map.items[idx];
+            break :tl .{
+                .node = self.node,
+                .y = map.y,
+                .x = map.x,
+            };
+        };
+        const br: PageList.Pin = br: {
+            const map = self.cell_map.items[idx + self.needle.len - 1];
+            break :br .{
+                .node = self.node,
+                .y = map.y,
+                .x = map.x,
+            };
+        };
+
+        return Selection.init(tl, br, false);
+    }
+};
+
+test "search single page one match" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var s = try Screen.init(alloc, 80, 24, 0);
+    defer s.deinit();
+    try s.testWriteString("hello, world");
+
+    // We want to test single-page cases.
+    try testing.expect(s.pages.pages.first == s.pages.pages.last);
+    const node: *PageList.List.Node = s.pages.pages.first.?;
+
+    var it = try PageSearch.init(alloc, node, "world");
+    defer it.deinit();
+
+    const sel = it.next().?;
+    try testing.expectEqual(point.Point{ .active = .{
+        .x = 7,
+        .y = 0,
+    } }, s.pages.pointFromPin(.active, sel.start()).?);
+    try testing.expectEqual(point.Point{ .active = .{
+        .x = 11,
+        .y = 0,
+    } }, s.pages.pointFromPin(.active, sel.end()).?);
+
+    try testing.expect(it.next() == null);
+}
+
+test "search single page multiple match" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var s = try Screen.init(alloc, 80, 24, 0);
+    defer s.deinit();
+    try s.testWriteString("hello. boo! hello. boo!");
+
+    // We want to test single-page cases.
+    try testing.expect(s.pages.pages.first == s.pages.pages.last);
+    const node: *PageList.List.Node = s.pages.pages.first.?;
+
+    var it = try PageSearch.init(alloc, node, "boo!");
+    defer it.deinit();
+
+    {
+        const sel = it.next().?;
+        try testing.expectEqual(point.Point{ .active = .{
+            .x = 7,
+            .y = 0,
+        } }, s.pages.pointFromPin(.active, sel.start()).?);
+        try testing.expectEqual(point.Point{ .active = .{
+            .x = 10,
+            .y = 0,
+        } }, s.pages.pointFromPin(.active, sel.end()).?);
+    }
+    {
+        const sel = it.next().?;
+        try testing.expectEqual(point.Point{ .active = .{
+            .x = 19,
+            .y = 0,
+        } }, s.pages.pointFromPin(.active, sel.start()).?);
+        try testing.expectEqual(point.Point{ .active = .{
+            .x = 22,
+            .y = 0,
+        } }, s.pages.pointFromPin(.active, sel.end()).?);
+    }
+
+    try testing.expect(it.next() == null);
+}

commit 2a13c6b6a35a1689d3642aeaf123485dc0a0e66c
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Nov 27 09:48:26 2024 -0800

    terminal: working on a pagelist sliding window for search

diff --git a/src/terminal/search.zig b/src/terminal/search.zig
index 96a7b56a..f35249ab 100644
--- a/src/terminal/search.zig
+++ b/src/terminal/search.zig
@@ -1,6 +1,7 @@
 const std = @import("std");
 const Allocator = std.mem.Allocator;
 const assert = std.debug.assert;
+const CircBuf = @import("../datastruct/main.zig").CircBuf;
 const terminal = @import("main.zig");
 const point = terminal.point;
 const Page = terminal.Page;
@@ -8,6 +9,211 @@ const PageList = terminal.PageList;
 const Selection = terminal.Selection;
 const Screen = terminal.Screen;
 
+pub const PageListSearch = struct {
+    alloc: Allocator,
+
+    /// The list we're searching.
+    list: *PageList,
+
+    /// The search term we're searching for.
+    needle: []const u8,
+
+    /// The window is our sliding window of pages that we're searching so
+    /// we can handle boundary cases where a needle is partially on the end
+    /// of one page and the beginning of the next.
+    ///
+    /// Note that we're not guaranteed to straddle exactly two pages. If
+    /// the needle is large enough and/or the pages are small enough then
+    /// the needle can straddle N pages. Additionally, pages aren't guaranteed
+    /// to be equal size so we can't precompute the window size.
+    window: SlidingWindow,
+
+    pub fn init(
+        alloc: Allocator,
+        list: *PageList,
+        needle: []const u8,
+    ) !PageListSearch {
+        var window = try CircBuf.init(alloc, 0);
+        errdefer window.deinit();
+
+        return .{
+            .alloc = alloc,
+            .list = list,
+            .current = list.pages.first,
+            .needle = needle,
+            .window = window,
+        };
+    }
+
+    pub fn deinit(self: *PageListSearch) void {
+        _ = self;
+
+        // TODO: deinit window
+    }
+};
+
+/// The sliding window of the pages we're searching. The window is always
+/// big enough so that the needle can fit in it.
+const SlidingWindow = struct {
+    /// The data buffer is a circular buffer of u8 that contains the
+    /// encoded page text that we can use to search for the needle.
+    data: DataBuf,
+
+    /// The meta buffer is a circular buffer that contains the metadata
+    /// about the pages we're searching. This usually isn't that large
+    /// so callers must iterate through it to find the offset to map
+    /// data to meta.
+    meta: MetaBuf,
+
+    const DataBuf = CircBuf(u8, 0);
+    const MetaBuf = CircBuf(Meta, undefined);
+    const Meta = struct {
+        node: *PageList.List.Node,
+        cell_map: Page.CellMap,
+
+        pub fn deinit(self: *Meta) void {
+            self.cell_map.deinit();
+        }
+    };
+
+    pub fn initEmpty(alloc: Allocator) Allocator.Error!SlidingWindow {
+        var data = try DataBuf.init(alloc, 0);
+        errdefer data.deinit(alloc);
+
+        var meta = try MetaBuf.init(alloc, 0);
+        errdefer meta.deinit(alloc);
+
+        return .{
+            .data = data,
+            .meta = meta,
+        };
+    }
+
+    pub fn deinit(self: *SlidingWindow, alloc: Allocator) void {
+        self.data.deinit(alloc);
+
+        var meta_it = self.meta.iterator(.forward);
+        while (meta_it.next()) |meta| meta.deinit();
+        self.meta.deinit(alloc);
+    }
+
+    /// Add a new node to the sliding window.
+    ///
+    /// The window will prune itself if it can while always maintaining
+    /// the invariant that the `fixed_size` always fits within the window.
+    ///
+    /// Note it is possible for the window to be smaller than `fixed_size`
+    /// if not enough nodes have been added yet or the screen is just
+    /// smaller than the needle.
+    pub fn append(
+        self: *SlidingWindow,
+        alloc: Allocator,
+        node: *PageList.List.Node,
+        required_size: usize,
+    ) Allocator.Error!void {
+        // Initialize our metadata for the node.
+        var meta: Meta = .{
+            .node = node,
+            .cell_map = Page.CellMap.init(alloc),
+        };
+        errdefer meta.deinit();
+
+        // This is suboptimal but we need to encode the page once to
+        // temporary memory, and then copy it into our circular buffer.
+        // In the future, we should benchmark and see if we can encode
+        // directly into the circular buffer.
+        var encoded: std.ArrayListUnmanaged(u8) = .{};
+        defer encoded.deinit(alloc);
+
+        // Encode the page into the buffer.
+        const page: *const Page = &meta.node.data;
+        _ = page.encodeUtf8(
+            encoded.writer(alloc),
+            .{ .cell_map = &meta.cell_map },
+        ) catch {
+            // writer uses anyerror but the only realistic error on
+            // an ArrayList is out of memory.
+            return error.OutOfMemory;
+        };
+        assert(meta.cell_map.items.len == encoded.items.len);
+
+        // Now that we know our buffer length, we can consider if we can
+        // prune our circular buffer or if we need to grow it.
+        prune: {
+            // Our buffer size after adding the new node.
+            const before_size: usize = self.data.len() + encoded.items.len;
+
+            // Prune as long as removing the first (oldest) node retains
+            // our required size invariant.
+            var after_size: usize = before_size;
+            while (self.meta.first()) |oldest_meta| {
+                const new_size = after_size - oldest_meta.cell_map.items.len;
+                if (new_size < required_size) break :prune;
+
+                // We can prune this node and retain our invariant.
+                // Update our new size, deinitialize the memory, and
+                // remove from the circular buffer.
+                after_size = new_size;
+                oldest_meta.deinit();
+                self.meta.deleteOldest(1);
+            }
+            assert(after_size <= before_size);
+
+            // If we didn't prune anything then we're done.
+            if (after_size == before_size) break :prune;
+
+            // We need to prune our data buffer as well.
+            self.data.deleteOldest(before_size - after_size);
+        }
+
+        // Ensure our buffers are big enough to store what we need.
+        try self.data.ensureUnusedCapacity(alloc, encoded.items.len);
+        try self.meta.ensureUnusedCapacity(alloc, 1);
+
+        // Append our new node to the circular buffer.
+        try self.data.appendSlice(encoded.items);
+        try self.meta.append(meta);
+
+        // Integrity check: verify our data matches our metadata exactly.
+        if (comptime std.debug.runtime_safety) {
+            var meta_it = self.meta.iterator(.forward);
+            var data_len: usize = 0;
+            while (meta_it.next()) |m| data_len += m.cell_map.items.len;
+            assert(data_len == self.data.len());
+        }
+    }
+};
+
+test "SlidingWindow empty on init" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var w = try SlidingWindow.initEmpty(alloc);
+    defer w.deinit(alloc);
+    try testing.expectEqual(0, w.data.len());
+    try testing.expectEqual(0, w.meta.len());
+}
+
+test "SlidingWindow single append" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var w = try SlidingWindow.initEmpty(alloc);
+    defer w.deinit(alloc);
+
+    var s = try Screen.init(alloc, 80, 24, 0);
+    defer s.deinit();
+    try s.testWriteString("hello. boo! hello. boo!");
+
+    // Imaginary needle for search
+    const needle = "boo!";
+
+    // We want to test single-page cases.
+    try testing.expect(s.pages.pages.first == s.pages.pages.last);
+    const node: *PageList.List.Node = s.pages.pages.first.?;
+    try w.append(alloc, node, needle.len);
+}
+
 pub const PageSearch = struct {
     alloc: Allocator,
     node: *PageList.List.Node,

commit 6ed298c9c1a46689440d4db2d690d0d7618bd156
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Dec 3 08:04:36 2024 -0500

    terminal: sliding window search starts working

diff --git a/src/terminal/search.zig b/src/terminal/search.zig
index f35249ab..05b2919e 100644
--- a/src/terminal/search.zig
+++ b/src/terminal/search.zig
@@ -6,6 +6,7 @@ const terminal = @import("main.zig");
 const point = terminal.point;
 const Page = terminal.Page;
 const PageList = terminal.PageList;
+const Pin = PageList.Pin;
 const Selection = terminal.Selection;
 const Screen = terminal.Screen;
 
@@ -97,6 +98,85 @@ const SlidingWindow = struct {
         self.meta.deinit(alloc);
     }
 
+    /// Search the window for the next occurrence of the needle. As
+    /// the window moves, the window will prune itself while maintaining
+    /// the invariant that the window is always big enough to contain
+    /// the needle.
+    pub fn next(self: *SlidingWindow, needle: []const u8) ?Selection {
+        const slices = self.data.getPtrSlice(0, self.data.len());
+
+        // Search the first slice for the needle.
+        if (std.mem.indexOf(u8, slices[0], needle)) |idx| {
+            return self.selection(idx, needle.len);
+        }
+
+        @panic("TODO");
+    }
+
+    /// Return a selection for the given start and length into the data
+    /// buffer and also prune the data/meta buffers if possible up to
+    /// this start index.
+    fn selection(
+        self: *SlidingWindow,
+        start: usize,
+        len: usize,
+    ) Selection {
+        assert(start < self.data.len());
+        assert(start + len < self.data.len());
+
+        var meta_it = self.meta.iterator(.forward);
+        const tl: Pin = pin(&meta_it, start);
+
+        // We have to seek back so that we reinspect our current
+        // iterator value again in case the start and end are in the
+        // same segment.
+        meta_it.seekBy(-1);
+        const br: Pin = pin(&meta_it, start + len - 1);
+
+        // TODO: prune based on meta_it.idx
+
+        return Selection.init(tl, br, false);
+    }
+
+    /// Convert a data index into a pin.
+    ///
+    /// Tip: you can get the offset into the meta buffer we searched
+    /// by inspecting the iterator index after this function returns.
+    /// I note this because this is useful if you want to prune the
+    /// meta buffer after you find a match.
+    ///
+    /// Precondition: the index must be within the data buffer.
+    fn pin(
+        it: *MetaBuf.Iterator,
+        idx: usize,
+    ) Pin {
+        var offset: usize = 0;
+        while (it.next()) |meta| {
+            // meta_i is the index we expect to find the match in the
+            // cell map within this meta if it contains it.
+            const meta_i = idx - offset;
+            if (meta_i >= meta.cell_map.items.len) {
+                // This meta doesn't contain the match. This means we
+                // can also prune this set of data because we only look
+                // forward.
+                offset += meta.cell_map.items.len;
+                continue;
+            }
+
+            // We found the meta that contains the start of the match.
+            const map = meta.cell_map.items[meta_i];
+            return .{
+                .node = meta.node,
+                .y = map.y,
+                .x = map.x,
+            };
+        }
+
+        // Unreachable because it is a precondition that the index is
+        // within the data buffer.
+        unreachable;
+    }
+
     /// Add a new node to the sliding window.
     ///
     /// The window will prune itself if it can while always maintaining
@@ -212,6 +292,62 @@ test "SlidingWindow single append" {
     try testing.expect(s.pages.pages.first == s.pages.pages.last);
     const node: *PageList.List.Node = s.pages.pages.first.?;
     try w.append(alloc, node, needle.len);
+
+    // We should be able to find two matches.
+    {
+        const sel = w.next(needle).?;
+        try testing.expectEqual(point.Point{ .active = .{
+            .x = 7,
+            .y = 0,
+        } }, s.pages.pointFromPin(.active, sel.start()).?);
+        try testing.expectEqual(point.Point{ .active = .{
+            .x = 10,
+            .y = 0,
+        } }, s.pages.pointFromPin(.active, sel.end()).?);
+    }
+    {
+        const sel = w.next(needle).?;
+        try testing.expectEqual(point.Point{ .active = .{
+            .x = 19,
+            .y = 0,
+        } }, s.pages.pointFromPin(.active, sel.start()).?);
+        try testing.expectEqual(point.Point{ .active = .{
+            .x = 22,
+            .y = 0,
+        } }, s.pages.pointFromPin(.active, sel.end()).?);
+    }
+}
+
+test "SlidingWindow two pages" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var w = try SlidingWindow.initEmpty(alloc);
+    defer w.deinit(alloc);
+
+    var s = try Screen.init(alloc, 80, 24, 1000);
+    defer s.deinit();
+
+    // Fill up the first page. The final bytes in the first page
+    // are "boo!"
+    const first_page_rows = s.pages.pages.first.?.data.capacity.rows;
+    for (0..first_page_rows - 1) |_| try s.testWriteString("\n");
+    for (0..s.pages.cols - 4) |_| try s.testWriteString("x");
+    try s.testWriteString("boo!");
+    try testing.expect(s.pages.pages.first == s.pages.pages.last);
+    try s.testWriteString("\n");
+    try testing.expect(s.pages.pages.first != s.pages.pages.last);
+    try s.testWriteString("hello. boo!");
+
+    // Imaginary needle for search
+    const needle = "boo!";
+
+    // Add both pages
+    const node: *PageList.List.Node = s.pages.pages.first.?;
+    try w.append(alloc, node, needle.len);
+    try w.append(alloc, node.next.?, needle.len);
+
+    // Ensure our data is correct
 }
 
 pub const PageSearch = struct {

commit d307b02e40de5816e0ee8e49d70e0ce555e13c18
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Dec 3 13:06:52 2024 -0500

    terminal: sliding window search can move the cursor

diff --git a/src/terminal/search.zig b/src/terminal/search.zig
index 05b2919e..e217f649 100644
--- a/src/terminal/search.zig
+++ b/src/terminal/search.zig
@@ -66,6 +66,11 @@ const SlidingWindow = struct {
     /// data to meta.
     meta: MetaBuf,
 
+    /// Offset into data for our current state. This handles the
+    /// situation where our search moved through meta[0] but didn't
+    /// do enough to prune it.
+    data_offset: usize = 0,
+
     const DataBuf = CircBuf(u8, 0);
     const MetaBuf = CircBuf(Meta, undefined);
     const Meta = struct {
@@ -98,31 +103,60 @@ const SlidingWindow = struct {
         self.meta.deinit(alloc);
     }
 
+    /// Clear all data but retain allocated capacity.
+    pub fn clearAndRetainCapacity(self: *SlidingWindow) void {
+        var meta_it = self.meta.iterator(.forward);
+        while (meta_it.next()) |meta| meta.deinit();
+        self.meta.clear();
+        self.data.clear();
+        self.data_offset = 0;
+    }
+
     /// Search the window for the next occurrence of the needle. As
     /// the window moves, the window will prune itself while maintaining
     /// the invariant that the window is always big enough to contain
     /// the needle.
     pub fn next(self: *SlidingWindow, needle: []const u8) ?Selection {
-        const slices = self.data.getPtrSlice(0, self.data.len());
+        const data_len = self.data.len();
+        if (data_len == 0) return null;
+        const slices = self.data.getPtrSlice(
+            self.data_offset,
+            data_len - self.data_offset,
+        );
 
         // Search the first slice for the needle.
         if (std.mem.indexOf(u8, slices[0], needle)) |idx| {
             return self.selection(idx, needle.len);
         }
 
-        @panic("TODO");
+        // TODO: search overlap
+
+        // Search the last slice for the needle.
+        if (std.mem.indexOf(u8, slices[1], needle)) |idx| {
+            if (true) @panic("TODO: test");
+            return self.selection(slices[0].len + idx, needle.len);
+        }
+
+        // No match. Clear everything.
+        self.clearAndRetainCapacity();
+        return null;
     }
 
     /// Return a selection for the given start and length into the data
     /// buffer and also prune the data/meta buffers if possible up to
     /// this start index.
+    ///
+    /// The start index is assumed to be relative to the offset. i.e.
+    /// index zero is actually at `self.data[self.data_offset]`. The
+    /// selection will account for the offset.
     fn selection(
         self: *SlidingWindow,
-        start: usize,
+        start_offset: usize,
         len: usize,
     ) Selection {
+        const start = start_offset + self.data_offset;
         assert(start < self.data.len());
-        assert(start + len < self.data.len());
+        assert(start + len <= self.data.len());
 
         var meta_it = self.meta.iterator(.forward);
         const tl: Pin = pin(&meta_it, start);
@@ -132,8 +166,37 @@ const SlidingWindow = struct {
         // same segment.
         meta_it.seekBy(-1);
         const br: Pin = pin(&meta_it, start + len - 1);
+        assert(meta_it.idx >= 1);
+
+        // meta_it.idx is now the index after the br pin. We can
+        // safely prune our data up to this index. (It is after
+        // because next() is called at least once).
+        const br_meta_idx: usize = meta_it.idx - 1;
+        meta_it.reset();
+        var offset: usize = 0;
+        while (meta_it.next()) |meta| {
+            const meta_idx = start - offset;
+            if (meta_idx >= meta.cell_map.items.len) {
+                // Prior to our matches, we can prune it.
+                offset += meta.cell_map.items.len;
+                meta.deinit();
+            }
+
+            assert(meta_it.idx == br_meta_idx + 1);
+            break;
+        }
+
+        // If we have metas to prune, then prune them. They should be
+        // deinitialized already from the while loop above.
+        if (br_meta_idx > 0) {
+            assert(offset > 0);
+            self.meta.deleteOldest(br_meta_idx);
+            self.data.deleteOldest(offset);
+            @panic("TODO: TEST");
+        }
 
-        // TODO: prune based on meta_it.idx
+        // Move our data one beyond so we don't rematch.
+        self.data_offset = start - offset + 1;
 
         return Selection.init(tl, br, false);
     }
@@ -316,6 +379,8 @@ test "SlidingWindow single append" {
             .y = 0,
         } }, s.pages.pointFromPin(.active, sel.end()).?);
     }
+    try testing.expect(w.next(needle) == null);
+    try testing.expect(w.next(needle) == null);
 }
 
 test "SlidingWindow two pages" {

commit b487aa8e1fbd1981103a00464333467068661006
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Dec 3 13:40:48 2024 -0500

    terminal: search across two pages and pruning appears to be working

diff --git a/src/terminal/search.zig b/src/terminal/search.zig
index e217f649..35f79ed2 100644
--- a/src/terminal/search.zig
+++ b/src/terminal/search.zig
@@ -53,8 +53,9 @@ pub const PageListSearch = struct {
     }
 };
 
-/// The sliding window of the pages we're searching. The window is always
-/// big enough so that the needle can fit in it.
+/// Search pages via a sliding window. The sliding window always maintains
+/// the invariant that data isn't pruned until we've searched it and
+/// accounted for overlaps across pages.
 const SlidingWindow = struct {
     /// The data buffer is a circular buffer of u8 that contains the
     /// encoded page text that we can use to search for the needle.
@@ -137,8 +138,42 @@ const SlidingWindow = struct {
             return self.selection(slices[0].len + idx, needle.len);
         }
 
-        // No match. Clear everything.
-        self.clearAndRetainCapacity();
+        // No match. We keep `needle.len - 1` bytes available to
+        // handle the future overlap case.
+        var meta_it = self.meta.iterator(.reverse);
+        prune: {
+            var saved: usize = 0;
+            while (meta_it.next()) |meta| {
+                const needed = needle.len - 1 - saved;
+                if (meta.cell_map.items.len >= needed) {
+                    // We save up to this meta. We set our data offset
+                    // to exactly where it needs to be to continue
+                    // searching.
+                    self.data_offset = meta.cell_map.items.len - needed;
+                    break;
+                }
+
+                saved += meta.cell_map.items.len;
+            } else {
+                // If we exited the while loop naturally then we
+                // never got the amount we needed and so there is
+                // nothing to prune.
+                assert(saved < needle.len - 1);
+                break :prune;
+            }
+
+            const prune_count = self.meta.len() - meta_it.idx;
+            if (prune_count == 0) {
+                // This can happen if we need to save up to the first
+                // meta value to retain our window.
+                break :prune;
+            }
+
+            // We can now delete all the metas up to but NOT including
+            // the meta we found through meta_it.
+            @panic("TODO: test");
+        }
+
         return null;
     }
 
@@ -158,71 +193,74 @@ const SlidingWindow = struct {
         assert(start < self.data.len());
         assert(start + len <= self.data.len());
 
+        // meta_consumed is the number of bytes we've consumed in the
+        // data buffer up to and NOT including the meta where we've
+        // found our pin. This is important because it tells us the
+        // amount of data we can safely deleted from self.data since
+        // we can't partially delete a meta block's data. (The partial
+        // amount is represented by self.data_offset).
         var meta_it = self.meta.iterator(.forward);
-        const tl: Pin = pin(&meta_it, start);
+        var meta_consumed: usize = 0;
+        const tl: Pin = pin(&meta_it, &meta_consumed, start);
 
         // We have to seek back so that we reinspect our current
         // iterator value again in case the start and end are in the
         // same segment.
         meta_it.seekBy(-1);
-        const br: Pin = pin(&meta_it, start + len - 1);
+        const br: Pin = pin(&meta_it, &meta_consumed, start + len - 1);
         assert(meta_it.idx >= 1);
 
-        // meta_it.idx is now the index after the br pin. We can
-        // safely prune our data up to this index. (It is after
-        // because next() is called at least once).
-        const br_meta_idx: usize = meta_it.idx - 1;
-        meta_it.reset();
-        var offset: usize = 0;
-        while (meta_it.next()) |meta| {
-            const meta_idx = start - offset;
-            if (meta_idx >= meta.cell_map.items.len) {
-                // Prior to our matches, we can prune it.
-                offset += meta.cell_map.items.len;
-                meta.deinit();
+        // Our offset into the current meta block is the start index
+        // minus the amount of data fully consumed. We then add one
+        // to move one past the match so we don't repeat it.
+        self.data_offset = start - meta_consumed + 1;
+
+        // meta_it.idx is br's meta index plus one (because the iterator
+        // moves one past the end; we call next() one last time). So
+        // we compare against one to check that the meta that we matched
+        // in has prior meta blocks we can prune.
+        if (meta_it.idx > 1) {
+            // Deinit all our memory in the meta blocks prior to our
+            // match.
+            const meta_count = meta_it.idx - 1;
+            meta_it.reset();
+            for (0..meta_count) |_| meta_it.next().?.deinit();
+            if (comptime std.debug.runtime_safety) {
+                assert(meta_it.idx == meta_count);
+                assert(meta_it.next().?.node == br.node);
             }
+            self.meta.deleteOldest(meta_count);
 
-            assert(meta_it.idx == br_meta_idx + 1);
-            break;
-        }
-
-        // If we have metas to prune, then prune them. They should be
-        // deinitialized already from the while loop above.
-        if (br_meta_idx > 0) {
-            assert(offset > 0);
-            self.meta.deleteOldest(br_meta_idx);
-            self.data.deleteOldest(offset);
-            @panic("TODO: TEST");
+            // Delete all the data up to our current index.
+            assert(meta_consumed > 0);
+            self.data.deleteOldest(meta_consumed);
         }
 
-        // Move our data one beyond so we don't rematch.
-        self.data_offset = start - offset + 1;
-
+        self.assertIntegrity();
         return Selection.init(tl, br, false);
     }
 
     /// Convert a data index into a pin.
     ///
-    /// Tip: you can get the offset into the meta buffer we searched
-    /// by inspecting the iterator index after this function returns.
-    /// I note this because this is useful if you want to prune the
-    /// meta buffer after you find a match.
+    /// The iterator and offset are both expected to be passed by
+    /// pointer so that the pin can be efficiently called for multiple
+    /// indexes (in order). See selection() for an example.
     ///
     /// Precondition: the index must be within the data buffer.
     fn pin(
         it: *MetaBuf.Iterator,
+        offset: *usize,
         idx: usize,
     ) Pin {
-        var offset: usize = 0;
         while (it.next()) |meta| {
             // meta_i is the index we expect to find the match in the
             // cell map within this meta if it contains it.
-            const meta_i = idx - offset;
+            const meta_i = idx - offset.*;
             if (meta_i >= meta.cell_map.items.len) {
                 // This meta doesn't contain the match. This means we
                 // can also prune this set of data because we only look
                 // forward.
-                offset += meta.cell_map.items.len;
+                offset.* += meta.cell_map.items.len;
                 continue;
             }
 
@@ -240,19 +278,13 @@ const SlidingWindow = struct {
         unreachable;
     }
 
-    /// Add a new node to the sliding window.
-    ///
-    /// The window will prune itself if it can while always maintaining
-    /// the invariant that the `fixed_size` always fits within the window.
-    ///
-    /// Note it is possible for the window to be smaller than `fixed_size`
-    /// if not enough nodes have been added yet or the screen is just
-    /// smaller than the needle.
+    /// Add a new node to the sliding window. This will always grow
+    /// the sliding window; data isn't pruned until it is consumed
+    /// via a search (via next()).
     pub fn append(
         self: *SlidingWindow,
         alloc: Allocator,
         node: *PageList.List.Node,
-        required_size: usize,
     ) Allocator.Error!void {
         // Initialize our metadata for the node.
         var meta: Meta = .{
@@ -280,35 +312,6 @@ const SlidingWindow = struct {
         };
         assert(meta.cell_map.items.len == encoded.items.len);
 
-        // Now that we know our buffer length, we can consider if we can
-        // prune our circular buffer or if we need to grow it.
-        prune: {
-            // Our buffer size after adding the new node.
-            const before_size: usize = self.data.len() + encoded.items.len;
-
-            // Prune as long as removing the first (oldest) node retains
-            // our required size invariant.
-            var after_size: usize = before_size;
-            while (self.meta.first()) |oldest_meta| {
-                const new_size = after_size - oldest_meta.cell_map.items.len;
-                if (new_size < required_size) break :prune;
-
-                // We can prune this node and retain our invariant.
-                // Update our new size, deinitialize the memory, and
-                // remove from the circular buffer.
-                after_size = new_size;
-                oldest_meta.deinit();
-                self.meta.deleteOldest(1);
-            }
-            assert(after_size <= before_size);
-
-            // If we didn't prune anything then we're done.
-            if (after_size == before_size) break :prune;
-
-            // We need to prune our data buffer as well.
-            self.data.deleteOldest(before_size - after_size);
-        }
-
         // Ensure our buffers are big enough to store what we need.
         try self.data.ensureUnusedCapacity(alloc, encoded.items.len);
         try self.meta.ensureUnusedCapacity(alloc, 1);
@@ -317,13 +320,20 @@ const SlidingWindow = struct {
         try self.data.appendSlice(encoded.items);
         try self.meta.append(meta);
 
+        self.assertIntegrity();
+    }
+
+    fn assertIntegrity(self: *const SlidingWindow) void {
+        if (comptime !std.debug.runtime_safety) return;
+
         // Integrity check: verify our data matches our metadata exactly.
-        if (comptime std.debug.runtime_safety) {
-            var meta_it = self.meta.iterator(.forward);
-            var data_len: usize = 0;
-            while (meta_it.next()) |m| data_len += m.cell_map.items.len;
-            assert(data_len == self.data.len());
-        }
+        var meta_it = self.meta.iterator(.forward);
+        var data_len: usize = 0;
+        while (meta_it.next()) |m| data_len += m.cell_map.items.len;
+        assert(data_len == self.data.len());
+
+        // Integrity check: verify our data offset is within bounds.
+        assert(self.data_offset < self.data.len());
     }
 };
 
@@ -354,7 +364,7 @@ test "SlidingWindow single append" {
     // We want to test single-page cases.
     try testing.expect(s.pages.pages.first == s.pages.pages.last);
     const node: *PageList.List.Node = s.pages.pages.first.?;
-    try w.append(alloc, node, needle.len);
+    try w.append(alloc, node);
 
     // We should be able to find two matches.
     {
@@ -409,10 +419,34 @@ test "SlidingWindow two pages" {
 
     // Add both pages
     const node: *PageList.List.Node = s.pages.pages.first.?;
-    try w.append(alloc, node, needle.len);
-    try w.append(alloc, node.next.?, needle.len);
+    try w.append(alloc, node);
+    try w.append(alloc, node.next.?);
 
-    // Ensure our data is correct
+    // Search should find two matches
+    {
+        const sel = w.next(needle).?;
+        try testing.expectEqual(point.Point{ .active = .{
+            .x = 76,
+            .y = 22,
+        } }, s.pages.pointFromPin(.active, sel.start()).?);
+        try testing.expectEqual(point.Point{ .active = .{
+            .x = 79,
+            .y = 22,
+        } }, s.pages.pointFromPin(.active, sel.end()).?);
+    }
+    {
+        const sel = w.next(needle).?;
+        try testing.expectEqual(point.Point{ .active = .{
+            .x = 7,
+            .y = 23,
+        } }, s.pages.pointFromPin(.active, sel.start()).?);
+        try testing.expectEqual(point.Point{ .active = .{
+            .x = 10,
+            .y = 23,
+        } }, s.pages.pointFromPin(.active, sel.end()).?);
+    }
+    try testing.expect(w.next(needle) == null);
+    try testing.expect(w.next(needle) == null);
 }
 
 pub const PageSearch = struct {

commit 09e4cccd2c891d3a2e242fce486f8ff8fd83db02
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Dec 3 15:39:36 2024 -0800

    terminal: remove unused pagesearch

diff --git a/src/terminal/search.zig b/src/terminal/search.zig
index 35f79ed2..40462491 100644
--- a/src/terminal/search.zig
+++ b/src/terminal/search.zig
@@ -448,142 +448,3 @@ test "SlidingWindow two pages" {
     try testing.expect(w.next(needle) == null);
     try testing.expect(w.next(needle) == null);
 }
-
-pub const PageSearch = struct {
-    alloc: Allocator,
-    node: *PageList.List.Node,
-    needle: []const u8,
-    cell_map: Page.CellMap,
-    encoded: std.ArrayListUnmanaged(u8) = .{},
-    i: usize = 0,
-
-    pub fn init(
-        alloc: Allocator,
-        node: *PageList.List.Node,
-        needle: []const u8,
-    ) !PageSearch {
-        var result: PageSearch = .{
-            .alloc = alloc,
-            .node = node,
-            .needle = needle,
-            .cell_map = Page.CellMap.init(alloc),
-        };
-
-        const page: *const Page = &node.data;
-        _ = try page.encodeUtf8(result.encoded.writer(alloc), .{
-            .cell_map = &result.cell_map,
-        });
-
-        return result;
-    }
-
-    pub fn deinit(self: *PageSearch) void {
-        self.encoded.deinit(self.alloc);
-        self.cell_map.deinit();
-    }
-
-    pub fn next(self: *PageSearch) ?Selection {
-        // Search our haystack for the needle. The resulting index is
-        // the offset from self.i not the absolute index.
-        const haystack: []const u8 = self.encoded.items[self.i..];
-        const i_offset = std.mem.indexOf(u8, haystack, self.needle) orelse {
-            self.i = self.encoded.items.len;
-            return null;
-        };
-
-        // Get our full index into the encoded buffer.
-        const idx = self.i + i_offset;
-
-        // We found our search term. Move the cursor forward one beyond
-        // the match. This lets us find every repeated match.
-        self.i = idx + 1;
-
-        const tl: PageList.Pin = tl: {
-            const map = self.cell_map.items[idx];
-            break :tl .{
-                .node = self.node,
-                .y = map.y,
-                .x = map.x,
-            };
-        };
-        const br: PageList.Pin = br: {
-            const map = self.cell_map.items[idx + self.needle.len - 1];
-            break :br .{
-                .node = self.node,
-                .y = map.y,
-                .x = map.x,
-            };
-        };
-
-        return Selection.init(tl, br, false);
-    }
-};
-
-test "search single page one match" {
-    const testing = std.testing;
-    const alloc = testing.allocator;
-
-    var s = try Screen.init(alloc, 80, 24, 0);
-    defer s.deinit();
-    try s.testWriteString("hello, world");
-
-    // We want to test single-page cases.
-    try testing.expect(s.pages.pages.first == s.pages.pages.last);
-    const node: *PageList.List.Node = s.pages.pages.first.?;
-
-    var it = try PageSearch.init(alloc, node, "world");
-    defer it.deinit();
-
-    const sel = it.next().?;
-    try testing.expectEqual(point.Point{ .active = .{
-        .x = 7,
-        .y = 0,
-    } }, s.pages.pointFromPin(.active, sel.start()).?);
-    try testing.expectEqual(point.Point{ .active = .{
-        .x = 11,
-        .y = 0,
-    } }, s.pages.pointFromPin(.active, sel.end()).?);
-
-    try testing.expect(it.next() == null);
-}
-
-test "search single page multiple match" {
-    const testing = std.testing;
-    const alloc = testing.allocator;
-
-    var s = try Screen.init(alloc, 80, 24, 0);
-    defer s.deinit();
-    try s.testWriteString("hello. boo! hello. boo!");
-
-    // We want to test single-page cases.
-    try testing.expect(s.pages.pages.first == s.pages.pages.last);
-    const node: *PageList.List.Node = s.pages.pages.first.?;
-
-    var it = try PageSearch.init(alloc, node, "boo!");
-    defer it.deinit();
-
-    {
-        const sel = it.next().?;
-        try testing.expectEqual(point.Point{ .active = .{
-            .x = 7,
-            .y = 0,
-        } }, s.pages.pointFromPin(.active, sel.start()).?);
-        try testing.expectEqual(point.Point{ .active = .{
-            .x = 10,
-            .y = 0,
-        } }, s.pages.pointFromPin(.active, sel.end()).?);
-    }
-    {
-        const sel = it.next().?;
-        try testing.expectEqual(point.Point{ .active = .{
-            .x = 19,
-            .y = 0,
-        } }, s.pages.pointFromPin(.active, sel.start()).?);
-        try testing.expectEqual(point.Point{ .active = .{
-            .x = 22,
-            .y = 0,
-        } }, s.pages.pointFromPin(.active, sel.end()).?);
-    }
-
-    try testing.expect(it.next() == null);
-}

commit 79026a114837ba0945d0f6948c7c2efc9f549516
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Dec 3 15:52:48 2024 -0800

    terminal: test no match pruning

diff --git a/src/terminal/search.zig b/src/terminal/search.zig
index 40462491..71ac6aea 100644
--- a/src/terminal/search.zig
+++ b/src/terminal/search.zig
@@ -171,9 +171,18 @@ const SlidingWindow = struct {
 
             // We can now delete all the metas up to but NOT including
             // the meta we found through meta_it.
-            @panic("TODO: test");
+            meta_it = self.meta.iterator(.forward);
+            var prune_data_len: usize = 0;
+            for (0..prune_count) |_| {
+                const meta = meta_it.next().?;
+                prune_data_len += meta.cell_map.items.len;
+                meta.deinit();
+            }
+            self.meta.deleteOldest(prune_count);
+            self.data.deleteOldest(prune_data_len);
         }
 
+        self.assertIntegrity();
         return null;
     }
 
@@ -393,6 +402,33 @@ test "SlidingWindow single append" {
     try testing.expect(w.next(needle) == null);
 }
 
+test "SlidingWindow single append no match" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var w = try SlidingWindow.initEmpty(alloc);
+    defer w.deinit(alloc);
+
+    var s = try Screen.init(alloc, 80, 24, 0);
+    defer s.deinit();
+    try s.testWriteString("hello. boo! hello. boo!");
+
+    // Imaginary needle for search
+    const needle = "nope!";
+
+    // We want to test single-page cases.
+    try testing.expect(s.pages.pages.first == s.pages.pages.last);
+    const node: *PageList.List.Node = s.pages.pages.first.?;
+    try w.append(alloc, node);
+
+    // No matches
+    try testing.expect(w.next(needle) == null);
+    try testing.expect(w.next(needle) == null);
+
+    // Should still keep the page
+    try testing.expectEqual(1, w.meta.len());
+}
+
 test "SlidingWindow two pages" {
     const testing = std.testing;
     const alloc = testing.allocator;
@@ -448,3 +484,81 @@ test "SlidingWindow two pages" {
     try testing.expect(w.next(needle) == null);
     try testing.expect(w.next(needle) == null);
 }
+
+test "SlidingWindow two pages no match prunes first page" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var w = try SlidingWindow.initEmpty(alloc);
+    defer w.deinit(alloc);
+
+    var s = try Screen.init(alloc, 80, 24, 1000);
+    defer s.deinit();
+
+    // Fill up the first page. The final bytes in the first page
+    // are "boo!"
+    const first_page_rows = s.pages.pages.first.?.data.capacity.rows;
+    for (0..first_page_rows - 1) |_| try s.testWriteString("\n");
+    for (0..s.pages.cols - 4) |_| try s.testWriteString("x");
+    try s.testWriteString("boo!");
+    try testing.expect(s.pages.pages.first == s.pages.pages.last);
+    try s.testWriteString("\n");
+    try testing.expect(s.pages.pages.first != s.pages.pages.last);
+    try s.testWriteString("hello. boo!");
+
+    // Add both pages
+    const node: *PageList.List.Node = s.pages.pages.first.?;
+    try w.append(alloc, node);
+    try w.append(alloc, node.next.?);
+
+    // Imaginary needle for search. Doesn't match!
+    const needle = "nope!";
+
+    // Search should find nothing
+    try testing.expect(w.next(needle) == null);
+    try testing.expect(w.next(needle) == null);
+
+    // We should've pruned our page because the second page
+    // has enough text to contain our needle.
+    try testing.expectEqual(1, w.meta.len());
+}
+
+test "SlidingWindow two pages no match keeps both pages" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var w = try SlidingWindow.initEmpty(alloc);
+    defer w.deinit(alloc);
+
+    var s = try Screen.init(alloc, 80, 24, 1000);
+    defer s.deinit();
+
+    // Fill up the first page. The final bytes in the first page
+    // are "boo!"
+    const first_page_rows = s.pages.pages.first.?.data.capacity.rows;
+    for (0..first_page_rows - 1) |_| try s.testWriteString("\n");
+    for (0..s.pages.cols - 4) |_| try s.testWriteString("x");
+    try s.testWriteString("boo!");
+    try testing.expect(s.pages.pages.first == s.pages.pages.last);
+    try s.testWriteString("\n");
+    try testing.expect(s.pages.pages.first != s.pages.pages.last);
+    try s.testWriteString("hello. boo!");
+
+    // Add both pages
+    const node: *PageList.List.Node = s.pages.pages.first.?;
+    try w.append(alloc, node);
+    try w.append(alloc, node.next.?);
+
+    // Imaginary needle for search. Doesn't match!
+    var needle_list = std.ArrayList(u8).init(alloc);
+    defer needle_list.deinit();
+    try needle_list.appendNTimes('x', first_page_rows * s.pages.cols);
+    const needle: []const u8 = needle_list.items;
+
+    // Search should find nothing
+    try testing.expect(w.next(needle) == null);
+    try testing.expect(w.next(needle) == null);
+
+    // No pruning because both pages are needed to fit needle.
+    try testing.expectEqual(2, w.meta.len());
+}

commit af1ee4d95f645d9a33841dcb5b77a93c8bdc9745
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Dec 4 10:36:14 2024 -0800

    terminal: search match across page boundary

diff --git a/src/terminal/search.zig b/src/terminal/search.zig
index 71ac6aea..88da8304 100644
--- a/src/terminal/search.zig
+++ b/src/terminal/search.zig
@@ -212,6 +212,12 @@ const SlidingWindow = struct {
         var meta_consumed: usize = 0;
         const tl: Pin = pin(&meta_it, &meta_consumed, start);
 
+        // Store the information required to prune later. We store this
+        // now because we only want to prune up to our START so we can
+        // find overlapping matches.
+        const tl_meta_idx = meta_it.idx - 1;
+        const tl_meta_consumed = meta_consumed;
+
         // We have to seek back so that we reinspect our current
         // iterator value again in case the start and end are in the
         // same segment.
@@ -222,27 +228,27 @@ const SlidingWindow = struct {
         // Our offset into the current meta block is the start index
         // minus the amount of data fully consumed. We then add one
         // to move one past the match so we don't repeat it.
-        self.data_offset = start - meta_consumed + 1;
+        self.data_offset = start - tl_meta_consumed + 1;
 
         // meta_it.idx is br's meta index plus one (because the iterator
         // moves one past the end; we call next() one last time). So
         // we compare against one to check that the meta that we matched
         // in has prior meta blocks we can prune.
-        if (meta_it.idx > 1) {
+        if (tl_meta_idx > 0) {
             // Deinit all our memory in the meta blocks prior to our
             // match.
-            const meta_count = meta_it.idx - 1;
+            const meta_count = tl_meta_idx;
             meta_it.reset();
             for (0..meta_count) |_| meta_it.next().?.deinit();
             if (comptime std.debug.runtime_safety) {
                 assert(meta_it.idx == meta_count);
-                assert(meta_it.next().?.node == br.node);
+                assert(meta_it.next().?.node == tl.node);
             }
             self.meta.deleteOldest(meta_count);
 
             // Delete all the data up to our current index.
-            assert(meta_consumed > 0);
-            self.data.deleteOldest(meta_consumed);
+            assert(tl_meta_consumed > 0);
+            self.data.deleteOldest(tl_meta_consumed);
         }
 
         self.assertIntegrity();
@@ -485,6 +491,53 @@ test "SlidingWindow two pages" {
     try testing.expect(w.next(needle) == null);
 }
 
+test "SlidingWindow two pages match across boundary" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var w = try SlidingWindow.initEmpty(alloc);
+    defer w.deinit(alloc);
+
+    var s = try Screen.init(alloc, 80, 24, 1000);
+    defer s.deinit();
+
+    // Fill up the first page. The final bytes in the first page
+    // are "boo!"
+    const first_page_rows = s.pages.pages.first.?.data.capacity.rows;
+    for (0..first_page_rows - 1) |_| try s.testWriteString("\n");
+    for (0..s.pages.cols - 4) |_| try s.testWriteString("x");
+    try s.testWriteString("hell");
+    try testing.expect(s.pages.pages.first == s.pages.pages.last);
+    try s.testWriteString("o, world!");
+    try testing.expect(s.pages.pages.first != s.pages.pages.last);
+
+    // Imaginary needle for search
+    const needle = "hello, world";
+
+    // Add both pages
+    const node: *PageList.List.Node = s.pages.pages.first.?;
+    try w.append(alloc, node);
+    try w.append(alloc, node.next.?);
+
+    // Search should find a match
+    {
+        const sel = w.next(needle).?;
+        try testing.expectEqual(point.Point{ .active = .{
+            .x = 76,
+            .y = 22,
+        } }, s.pages.pointFromPin(.active, sel.start()).?);
+        try testing.expectEqual(point.Point{ .active = .{
+            .x = 7,
+            .y = 23,
+        } }, s.pages.pointFromPin(.active, sel.end()).?);
+    }
+    try testing.expect(w.next(needle) == null);
+    try testing.expect(w.next(needle) == null);
+
+    // We shouldn't prune because we don't have enough space
+    try testing.expectEqual(2, w.meta.len());
+}
+
 test "SlidingWindow two pages no match prunes first page" {
     const testing = std.testing;
     const alloc = testing.allocator;

commit 852e04fa009eca31727762f2d72d2fec4fcea273
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Dec 4 10:58:22 2024 -0800

    terminal: test for match in second slice of circ buf

diff --git a/src/terminal/search.zig b/src/terminal/search.zig
index 88da8304..7b648642 100644
--- a/src/terminal/search.zig
+++ b/src/terminal/search.zig
@@ -118,12 +118,16 @@ const SlidingWindow = struct {
     /// the invariant that the window is always big enough to contain
     /// the needle.
     pub fn next(self: *SlidingWindow, needle: []const u8) ?Selection {
-        const data_len = self.data.len();
-        if (data_len == 0) return null;
-        const slices = self.data.getPtrSlice(
-            self.data_offset,
-            data_len - self.data_offset,
-        );
+        const slices = slices: {
+            // If we have less data then the needle then we can't possibly match
+            const data_len = self.data.len();
+            if (data_len < needle.len) return null;
+
+            break :slices self.data.getPtrSlice(
+                self.data_offset,
+                data_len - self.data_offset,
+            );
+        };
 
         // Search the first slice for the needle.
         if (std.mem.indexOf(u8, slices[0], needle)) |idx| {
@@ -134,7 +138,6 @@ const SlidingWindow = struct {
 
         // Search the last slice for the needle.
         if (std.mem.indexOf(u8, slices[1], needle)) |idx| {
-            if (true) @panic("TODO: test");
             return self.selection(slices[0].len + idx, needle.len);
         }
 
@@ -182,6 +185,10 @@ const SlidingWindow = struct {
             self.data.deleteOldest(prune_data_len);
         }
 
+        // Our data offset now moves to needle.len - 1 from the end so
+        // that we can handle the overlap case.
+        self.data_offset = self.data.len() - needle.len + 1;
+
         self.assertIntegrity();
         return null;
     }
@@ -615,3 +622,55 @@ test "SlidingWindow two pages no match keeps both pages" {
     // No pruning because both pages are needed to fit needle.
     try testing.expectEqual(2, w.meta.len());
 }
+
+test "SlidingWindow single append across circular buffer boundary" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var w = try SlidingWindow.initEmpty(alloc);
+    defer w.deinit(alloc);
+
+    var s = try Screen.init(alloc, 80, 24, 0);
+    defer s.deinit();
+    try s.testWriteString("XXXXXXXXXXXXXXXXXXXboo!XXXXX");
+
+    // We are trying to break a circular buffer boundary so the way we
+    // do this is to duplicate the data then do a failing search. This
+    // will cause the first page to be pruned. The next time we append we'll
+    // put it in the middle of the circ buffer. We assert this so that if
+    // our implementation changes our test will fail.
+    try testing.expect(s.pages.pages.first == s.pages.pages.last);
+    const node: *PageList.List.Node = s.pages.pages.first.?;
+    try w.append(alloc, node);
+    try w.append(alloc, node);
+    {
+        // No wrap around yet
+        const slices = w.data.getPtrSlice(0, w.data.len());
+        try testing.expect(slices[0].len > 0);
+        try testing.expect(slices[1].len == 0);
+    }
+
+    // Search non-match, prunes page
+    try testing.expect(w.next("abc") == null);
+    try testing.expectEqual(1, w.meta.len());
+
+    // Add new page, now wraps
+    try w.append(alloc, node);
+    {
+        const slices = w.data.getPtrSlice(0, w.data.len());
+        try testing.expect(slices[0].len > 0);
+        try testing.expect(slices[1].len > 0);
+    }
+    {
+        const sel = w.next("boo!").?;
+        try testing.expectEqual(point.Point{ .active = .{
+            .x = 19,
+            .y = 0,
+        } }, s.pages.pointFromPin(.active, sel.start()).?);
+        try testing.expectEqual(point.Point{ .active = .{
+            .x = 22,
+            .y = 0,
+        } }, s.pages.pointFromPin(.active, sel.end()).?);
+    }
+    try testing.expect(w.next("boo!") == null);
+}

commit 34fb840cf99fdfdd970557df8b8accbbc156b3ce
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Dec 4 11:16:36 2024 -0800

    terminal: search match on overlap case

diff --git a/src/terminal/search.zig b/src/terminal/search.zig
index 7b648642..304cc5a4 100644
--- a/src/terminal/search.zig
+++ b/src/terminal/search.zig
@@ -72,6 +72,14 @@ const SlidingWindow = struct {
     /// do enough to prune it.
     data_offset: usize = 0,
 
+    /// The needle we're searching for. Does not own the memory.
+    needle: []const u8,
+
+    /// A buffer to store the overlap search data. This is used to search
+    /// overlaps between pages where the match starts on one page and
+    /// ends on another. The length is always `needle.len * 2`.
+    overlap_buf: []u8,
+
     const DataBuf = CircBuf(u8, 0);
     const MetaBuf = CircBuf(Meta, undefined);
     const Meta = struct {
@@ -83,20 +91,29 @@ const SlidingWindow = struct {
         }
     };
 
-    pub fn initEmpty(alloc: Allocator) Allocator.Error!SlidingWindow {
+    pub fn init(
+        alloc: Allocator,
+        needle: []const u8,
+    ) Allocator.Error!SlidingWindow {
         var data = try DataBuf.init(alloc, 0);
         errdefer data.deinit(alloc);
 
         var meta = try MetaBuf.init(alloc, 0);
         errdefer meta.deinit(alloc);
 
+        const overlap_buf = try alloc.alloc(u8, needle.len * 2);
+        errdefer alloc.free(overlap_buf);
+
         return .{
             .data = data,
             .meta = meta,
+            .needle = needle,
+            .overlap_buf = overlap_buf,
         };
     }
 
     pub fn deinit(self: *SlidingWindow, alloc: Allocator) void {
+        alloc.free(self.overlap_buf);
         self.data.deinit(alloc);
 
         var meta_it = self.meta.iterator(.forward);
@@ -117,11 +134,11 @@ const SlidingWindow = struct {
     /// the window moves, the window will prune itself while maintaining
     /// the invariant that the window is always big enough to contain
     /// the needle.
-    pub fn next(self: *SlidingWindow, needle: []const u8) ?Selection {
+    pub fn next(self: *SlidingWindow) ?Selection {
         const slices = slices: {
             // If we have less data then the needle then we can't possibly match
             const data_len = self.data.len();
-            if (data_len < needle.len) return null;
+            if (data_len < self.needle.len) return null;
 
             break :slices self.data.getPtrSlice(
                 self.data_offset,
@@ -130,15 +147,46 @@ const SlidingWindow = struct {
         };
 
         // Search the first slice for the needle.
-        if (std.mem.indexOf(u8, slices[0], needle)) |idx| {
-            return self.selection(idx, needle.len);
+        if (std.mem.indexOf(u8, slices[0], self.needle)) |idx| {
+            return self.selection(idx, self.needle.len);
         }
 
-        // TODO: search overlap
+        // Search the overlap buffer for the needle.
+        if (slices[0].len > 0 and slices[1].len > 0) overlap: {
+            // Get up to needle.len - 1 bytes from each side (as much as
+            // we can) and store it in the overlap buffer.
+            const prefix: []const u8 = prefix: {
+                const len = @min(slices[0].len, self.needle.len - 1);
+                const idx = slices[0].len - len;
+                break :prefix slices[0][idx..];
+            };
+            const suffix: []const u8 = suffix: {
+                const len = @min(slices[1].len, self.needle.len - 1);
+                break :suffix slices[1][0..len];
+            };
+            const overlap_len = prefix.len + suffix.len;
+            assert(overlap_len <= self.overlap_buf.len);
+            @memcpy(self.overlap_buf[0..prefix.len], prefix);
+            @memcpy(self.overlap_buf[prefix.len..overlap_len], suffix);
+
+            // Search the overlap
+            const idx = std.mem.indexOf(
+                u8,
+                self.overlap_buf[0..overlap_len],
+                self.needle,
+            ) orelse break :overlap;
+
+            // We found a match in the overlap buffer. We need to map the
+            // index back to the data buffer in order to get our selection.
+            return self.selection(
+                slices[0].len - prefix.len + idx,
+                self.needle.len,
+            );
+        }
 
         // Search the last slice for the needle.
-        if (std.mem.indexOf(u8, slices[1], needle)) |idx| {
-            return self.selection(slices[0].len + idx, needle.len);
+        if (std.mem.indexOf(u8, slices[1], self.needle)) |idx| {
+            return self.selection(slices[0].len + idx, self.needle.len);
         }
 
         // No match. We keep `needle.len - 1` bytes available to
@@ -147,7 +195,7 @@ const SlidingWindow = struct {
         prune: {
             var saved: usize = 0;
             while (meta_it.next()) |meta| {
-                const needed = needle.len - 1 - saved;
+                const needed = self.needle.len - 1 - saved;
                 if (meta.cell_map.items.len >= needed) {
                     // We save up to this meta. We set our data offset
                     // to exactly where it needs to be to continue
@@ -161,7 +209,7 @@ const SlidingWindow = struct {
                 // If we exited the while loop naturally then we
                 // never got the amount we needed and so there is
                 // nothing to prune.
-                assert(saved < needle.len - 1);
+                assert(saved < self.needle.len - 1);
                 break :prune;
             }
 
@@ -187,7 +235,7 @@ const SlidingWindow = struct {
 
         // Our data offset now moves to needle.len - 1 from the end so
         // that we can handle the overlap case.
-        self.data_offset = self.data.len() - needle.len + 1;
+        self.data_offset = self.data.len() - self.needle.len + 1;
 
         self.assertIntegrity();
         return null;
@@ -363,7 +411,7 @@ test "SlidingWindow empty on init" {
     const testing = std.testing;
     const alloc = testing.allocator;
 
-    var w = try SlidingWindow.initEmpty(alloc);
+    var w = try SlidingWindow.init(alloc, "boo!");
     defer w.deinit(alloc);
     try testing.expectEqual(0, w.data.len());
     try testing.expectEqual(0, w.meta.len());
@@ -373,16 +421,13 @@ test "SlidingWindow single append" {
     const testing = std.testing;
     const alloc = testing.allocator;
 
-    var w = try SlidingWindow.initEmpty(alloc);
+    var w = try SlidingWindow.init(alloc, "boo!");
     defer w.deinit(alloc);
 
     var s = try Screen.init(alloc, 80, 24, 0);
     defer s.deinit();
     try s.testWriteString("hello. boo! hello. boo!");
 
-    // Imaginary needle for search
-    const needle = "boo!";
-
     // We want to test single-page cases.
     try testing.expect(s.pages.pages.first == s.pages.pages.last);
     const node: *PageList.List.Node = s.pages.pages.first.?;
@@ -390,7 +435,7 @@ test "SlidingWindow single append" {
 
     // We should be able to find two matches.
     {
-        const sel = w.next(needle).?;
+        const sel = w.next().?;
         try testing.expectEqual(point.Point{ .active = .{
             .x = 7,
             .y = 0,
@@ -401,7 +446,7 @@ test "SlidingWindow single append" {
         } }, s.pages.pointFromPin(.active, sel.end()).?);
     }
     {
-        const sel = w.next(needle).?;
+        const sel = w.next().?;
         try testing.expectEqual(point.Point{ .active = .{
             .x = 19,
             .y = 0,
@@ -411,32 +456,29 @@ test "SlidingWindow single append" {
             .y = 0,
         } }, s.pages.pointFromPin(.active, sel.end()).?);
     }
-    try testing.expect(w.next(needle) == null);
-    try testing.expect(w.next(needle) == null);
+    try testing.expect(w.next() == null);
+    try testing.expect(w.next() == null);
 }
 
 test "SlidingWindow single append no match" {
     const testing = std.testing;
     const alloc = testing.allocator;
 
-    var w = try SlidingWindow.initEmpty(alloc);
+    var w = try SlidingWindow.init(alloc, "nope!");
     defer w.deinit(alloc);
 
     var s = try Screen.init(alloc, 80, 24, 0);
     defer s.deinit();
     try s.testWriteString("hello. boo! hello. boo!");
 
-    // Imaginary needle for search
-    const needle = "nope!";
-
     // We want to test single-page cases.
     try testing.expect(s.pages.pages.first == s.pages.pages.last);
     const node: *PageList.List.Node = s.pages.pages.first.?;
     try w.append(alloc, node);
 
     // No matches
-    try testing.expect(w.next(needle) == null);
-    try testing.expect(w.next(needle) == null);
+    try testing.expect(w.next() == null);
+    try testing.expect(w.next() == null);
 
     // Should still keep the page
     try testing.expectEqual(1, w.meta.len());
@@ -446,7 +488,7 @@ test "SlidingWindow two pages" {
     const testing = std.testing;
     const alloc = testing.allocator;
 
-    var w = try SlidingWindow.initEmpty(alloc);
+    var w = try SlidingWindow.init(alloc, "boo!");
     defer w.deinit(alloc);
 
     var s = try Screen.init(alloc, 80, 24, 1000);
@@ -463,9 +505,6 @@ test "SlidingWindow two pages" {
     try testing.expect(s.pages.pages.first != s.pages.pages.last);
     try s.testWriteString("hello. boo!");
 
-    // Imaginary needle for search
-    const needle = "boo!";
-
     // Add both pages
     const node: *PageList.List.Node = s.pages.pages.first.?;
     try w.append(alloc, node);
@@ -473,7 +512,7 @@ test "SlidingWindow two pages" {
 
     // Search should find two matches
     {
-        const sel = w.next(needle).?;
+        const sel = w.next().?;
         try testing.expectEqual(point.Point{ .active = .{
             .x = 76,
             .y = 22,
@@ -484,7 +523,7 @@ test "SlidingWindow two pages" {
         } }, s.pages.pointFromPin(.active, sel.end()).?);
     }
     {
-        const sel = w.next(needle).?;
+        const sel = w.next().?;
         try testing.expectEqual(point.Point{ .active = .{
             .x = 7,
             .y = 23,
@@ -494,15 +533,15 @@ test "SlidingWindow two pages" {
             .y = 23,
         } }, s.pages.pointFromPin(.active, sel.end()).?);
     }
-    try testing.expect(w.next(needle) == null);
-    try testing.expect(w.next(needle) == null);
+    try testing.expect(w.next() == null);
+    try testing.expect(w.next() == null);
 }
 
 test "SlidingWindow two pages match across boundary" {
     const testing = std.testing;
     const alloc = testing.allocator;
 
-    var w = try SlidingWindow.initEmpty(alloc);
+    var w = try SlidingWindow.init(alloc, "hello, world");
     defer w.deinit(alloc);
 
     var s = try Screen.init(alloc, 80, 24, 1000);
@@ -518,9 +557,6 @@ test "SlidingWindow two pages match across boundary" {
     try s.testWriteString("o, world!");
     try testing.expect(s.pages.pages.first != s.pages.pages.last);
 
-    // Imaginary needle for search
-    const needle = "hello, world";
-
     // Add both pages
     const node: *PageList.List.Node = s.pages.pages.first.?;
     try w.append(alloc, node);
@@ -528,7 +564,7 @@ test "SlidingWindow two pages match across boundary" {
 
     // Search should find a match
     {
-        const sel = w.next(needle).?;
+        const sel = w.next().?;
         try testing.expectEqual(point.Point{ .active = .{
             .x = 76,
             .y = 22,
@@ -538,8 +574,8 @@ test "SlidingWindow two pages match across boundary" {
             .y = 23,
         } }, s.pages.pointFromPin(.active, sel.end()).?);
     }
-    try testing.expect(w.next(needle) == null);
-    try testing.expect(w.next(needle) == null);
+    try testing.expect(w.next() == null);
+    try testing.expect(w.next() == null);
 
     // We shouldn't prune because we don't have enough space
     try testing.expectEqual(2, w.meta.len());
@@ -549,7 +585,7 @@ test "SlidingWindow two pages no match prunes first page" {
     const testing = std.testing;
     const alloc = testing.allocator;
 
-    var w = try SlidingWindow.initEmpty(alloc);
+    var w = try SlidingWindow.init(alloc, "nope!");
     defer w.deinit(alloc);
 
     var s = try Screen.init(alloc, 80, 24, 1000);
@@ -571,12 +607,9 @@ test "SlidingWindow two pages no match prunes first page" {
     try w.append(alloc, node);
     try w.append(alloc, node.next.?);
 
-    // Imaginary needle for search. Doesn't match!
-    const needle = "nope!";
-
     // Search should find nothing
-    try testing.expect(w.next(needle) == null);
-    try testing.expect(w.next(needle) == null);
+    try testing.expect(w.next() == null);
+    try testing.expect(w.next() == null);
 
     // We should've pruned our page because the second page
     // has enough text to contain our needle.
@@ -587,9 +620,6 @@ test "SlidingWindow two pages no match keeps both pages" {
     const testing = std.testing;
     const alloc = testing.allocator;
 
-    var w = try SlidingWindow.initEmpty(alloc);
-    defer w.deinit(alloc);
-
     var s = try Screen.init(alloc, 80, 24, 1000);
     defer s.deinit();
 
@@ -604,20 +634,23 @@ test "SlidingWindow two pages no match keeps both pages" {
     try testing.expect(s.pages.pages.first != s.pages.pages.last);
     try s.testWriteString("hello. boo!");
 
-    // Add both pages
-    const node: *PageList.List.Node = s.pages.pages.first.?;
-    try w.append(alloc, node);
-    try w.append(alloc, node.next.?);
-
     // Imaginary needle for search. Doesn't match!
     var needle_list = std.ArrayList(u8).init(alloc);
     defer needle_list.deinit();
     try needle_list.appendNTimes('x', first_page_rows * s.pages.cols);
     const needle: []const u8 = needle_list.items;
 
+    var w = try SlidingWindow.init(alloc, needle);
+    defer w.deinit(alloc);
+
+    // Add both pages
+    const node: *PageList.List.Node = s.pages.pages.first.?;
+    try w.append(alloc, node);
+    try w.append(alloc, node.next.?);
+
     // Search should find nothing
-    try testing.expect(w.next(needle) == null);
-    try testing.expect(w.next(needle) == null);
+    try testing.expect(w.next() == null);
+    try testing.expect(w.next() == null);
 
     // No pruning because both pages are needed to fit needle.
     try testing.expectEqual(2, w.meta.len());
@@ -627,7 +660,7 @@ test "SlidingWindow single append across circular buffer boundary" {
     const testing = std.testing;
     const alloc = testing.allocator;
 
-    var w = try SlidingWindow.initEmpty(alloc);
+    var w = try SlidingWindow.init(alloc, "abc");
     defer w.deinit(alloc);
 
     var s = try Screen.init(alloc, 80, 24, 0);
@@ -651,9 +684,12 @@ test "SlidingWindow single append across circular buffer boundary" {
     }
 
     // Search non-match, prunes page
-    try testing.expect(w.next("abc") == null);
+    try testing.expect(w.next() == null);
     try testing.expectEqual(1, w.meta.len());
 
+    // Change the needle, just needs to be the same length (not a real API)
+    w.needle = "boo";
+
     // Add new page, now wraps
     try w.append(alloc, node);
     {
@@ -662,15 +698,70 @@ test "SlidingWindow single append across circular buffer boundary" {
         try testing.expect(slices[1].len > 0);
     }
     {
-        const sel = w.next("boo!").?;
+        const sel = w.next().?;
         try testing.expectEqual(point.Point{ .active = .{
             .x = 19,
             .y = 0,
         } }, s.pages.pointFromPin(.active, sel.start()).?);
         try testing.expectEqual(point.Point{ .active = .{
-            .x = 22,
+            .x = 21,
+            .y = 0,
+        } }, s.pages.pointFromPin(.active, sel.end()).?);
+    }
+    try testing.expect(w.next() == null);
+}
+
+test "SlidingWindow single append match on boundary" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var w = try SlidingWindow.init(alloc, "abcd");
+    defer w.deinit(alloc);
+
+    var s = try Screen.init(alloc, 80, 24, 0);
+    defer s.deinit();
+    try s.testWriteString("o!XXXXXXXXXXXXXXXXXXXbo");
+
+    // We are trying to break a circular buffer boundary so the way we
+    // do this is to duplicate the data then do a failing search. This
+    // will cause the first page to be pruned. The next time we append we'll
+    // put it in the middle of the circ buffer. We assert this so that if
+    // our implementation changes our test will fail.
+    try testing.expect(s.pages.pages.first == s.pages.pages.last);
+    const node: *PageList.List.Node = s.pages.pages.first.?;
+    try w.append(alloc, node);
+    try w.append(alloc, node);
+    {
+        // No wrap around yet
+        const slices = w.data.getPtrSlice(0, w.data.len());
+        try testing.expect(slices[0].len > 0);
+        try testing.expect(slices[1].len == 0);
+    }
+
+    // Search non-match, prunes page
+    try testing.expect(w.next() == null);
+    try testing.expectEqual(1, w.meta.len());
+
+    // Change the needle, just needs to be the same length (not a real API)
+    w.needle = "boo!";
+
+    // Add new page, now wraps
+    try w.append(alloc, node);
+    {
+        const slices = w.data.getPtrSlice(0, w.data.len());
+        try testing.expect(slices[0].len > 0);
+        try testing.expect(slices[1].len > 0);
+    }
+    {
+        const sel = w.next().?;
+        try testing.expectEqual(point.Point{ .active = .{
+            .x = 21,
+            .y = 0,
+        } }, s.pages.pointFromPin(.active, sel.start()).?);
+        try testing.expectEqual(point.Point{ .active = .{
+            .x = 1,
             .y = 0,
         } }, s.pages.pointFromPin(.active, sel.end()).?);
     }
-    try testing.expect(w.next("boo!") == null);
+    try testing.expect(w.next() == null);
 }

commit 6361bf47f7f8fda0993a15046829e8d42b085419
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Dec 4 11:23:09 2024 -0800

    terminal: update comments/docs on sliding window search

diff --git a/src/terminal/search.zig b/src/terminal/search.zig
index 304cc5a4..09078ae2 100644
--- a/src/terminal/search.zig
+++ b/src/terminal/search.zig
@@ -53,9 +53,22 @@ pub const PageListSearch = struct {
     }
 };
 
-/// Search pages via a sliding window. The sliding window always maintains
-/// the invariant that data isn't pruned until we've searched it and
-/// accounted for overlaps across pages.
+/// Searches page nodes via a sliding window. The sliding window maintains
+/// the invariant that data isn't pruned until (1) we've searched it and
+/// (2) we've accounted for overlaps across pages to fit the needle.
+///
+/// The sliding window is first initialized empty. Pages are then appended
+/// in the order to search them. If you're doing a reverse search then the
+/// pages should be appended in reverse order and the needle should be
+/// reversed.
+///
+/// All appends grow the window. The window is only pruned when a searc
+/// is done (positive or negative match) via `next()`.
+///
+/// To avoid unnecessary memory growth, the recommended usage is to
+/// call `next()` until it returns null and then `append` the next page
+/// and repeat the process. This will always maintain the minimum
+/// required memory to search for the needle.
 const SlidingWindow = struct {
     /// The data buffer is a circular buffer of u8 that contains the
     /// encoded page text that we can use to search for the needle.

commit b9dda6ad87fff1ec01699a0b12ad28cbbe51b856
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Dec 4 12:15:32 2024 -0800

    terminal: PageListSearch works!

diff --git a/src/terminal/search.zig b/src/terminal/search.zig
index 09078ae2..fe5ac0c2 100644
--- a/src/terminal/search.zig
+++ b/src/terminal/search.zig
@@ -10,46 +10,64 @@ const Pin = PageList.Pin;
 const Selection = terminal.Selection;
 const Screen = terminal.Screen;
 
+/// Searches for a term in a PageList structure.
 pub const PageListSearch = struct {
-    alloc: Allocator,
-
     /// The list we're searching.
     list: *PageList,
 
-    /// The search term we're searching for.
-    needle: []const u8,
-
-    /// The window is our sliding window of pages that we're searching so
-    /// we can handle boundary cases where a needle is partially on the end
-    /// of one page and the beginning of the next.
-    ///
-    /// Note that we're not guaranteed to straddle exactly two pages. If
-    /// the needle is large enough and/or the pages are small enough then
-    /// the needle can straddle N pages. Additionally, pages aren't guaranteed
-    /// to be equal size so we can't precompute the window size.
+    /// The sliding window of page contents and nodes to search.
     window: SlidingWindow,
 
+    /// Initialize the page list search.
+    ///
+    /// The needle is not copied and must be kept alive for the duration
+    /// of the search operation.
     pub fn init(
         alloc: Allocator,
         list: *PageList,
         needle: []const u8,
-    ) !PageListSearch {
-        var window = try CircBuf.init(alloc, 0);
-        errdefer window.deinit();
+    ) Allocator.Error!PageListSearch {
+        var window = try SlidingWindow.init(alloc, needle);
+        errdefer window.deinit(alloc);
 
         return .{
-            .alloc = alloc,
             .list = list,
-            .current = list.pages.first,
-            .needle = needle,
             .window = window,
         };
     }
 
-    pub fn deinit(self: *PageListSearch) void {
-        _ = self;
+    pub fn deinit(self: *PageListSearch, alloc: Allocator) void {
+        self.window.deinit(alloc);
+    }
 
-        // TODO: deinit window
+    /// Find the next match for the needle in the pagelist. This returns
+    /// null when there are no more matches.
+    pub fn next(
+        self: *PageListSearch,
+        alloc: Allocator,
+    ) Allocator.Error!?Selection {
+        // Try to search for the needle in the window. If we find a match
+        // then we can return that and we're done.
+        if (self.window.next()) |sel| return sel;
+
+        // Get our next node. If we have a value in our window then we
+        // can determine the next node. If we don't, we've never setup the
+        // window so we use our first node.
+        var node_: ?*PageList.List.Node = if (self.window.meta.last()) |meta|
+            meta.node.next
+        else
+            self.list.pages.first;
+
+        // Add one pagelist node at a time, look for matches, and repeat
+        // until we find a match or we reach the end of the pagelist.
+        // This append then next pattern limits memory usage of the window.
+        while (node_) |node| : (node_ = node.next) {
+            try self.window.append(alloc, node);
+            if (self.window.next()) |sel| return sel;
+        }
+
+        // We've reached the end of the pagelist, no matches.
+        return null;
     }
 };
 
@@ -420,6 +438,45 @@ const SlidingWindow = struct {
     }
 };
 
+test "PageListSearch single page" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var s = try Screen.init(alloc, 80, 24, 0);
+    defer s.deinit();
+    try s.testWriteString("hello. boo! hello. boo!");
+    try testing.expect(s.pages.pages.first == s.pages.pages.last);
+
+    var search = try PageListSearch.init(alloc, &s.pages, "boo!");
+    defer search.deinit(alloc);
+
+    // We should be able to find two matches.
+    {
+        const sel = (try search.next(alloc)).?;
+        try testing.expectEqual(point.Point{ .active = .{
+            .x = 7,
+            .y = 0,
+        } }, s.pages.pointFromPin(.active, sel.start()).?);
+        try testing.expectEqual(point.Point{ .active = .{
+            .x = 10,
+            .y = 0,
+        } }, s.pages.pointFromPin(.active, sel.end()).?);
+    }
+    {
+        const sel = (try search.next(alloc)).?;
+        try testing.expectEqual(point.Point{ .active = .{
+            .x = 19,
+            .y = 0,
+        } }, s.pages.pointFromPin(.active, sel.start()).?);
+        try testing.expectEqual(point.Point{ .active = .{
+            .x = 22,
+            .y = 0,
+        } }, s.pages.pointFromPin(.active, sel.end()).?);
+    }
+    try testing.expect((try search.next(alloc)) == null);
+    try testing.expect((try search.next(alloc)) == null);
+}
+
 test "SlidingWindow empty on init" {
     const testing = std.testing;
     const alloc = testing.allocator;

commit 50b36c5d8606a4fd0be5fafd4e641751f2625861
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Dec 4 12:38:29 2024 -0800

    comments

diff --git a/src/terminal/search.zig b/src/terminal/search.zig
index fe5ac0c2..56b181c4 100644
--- a/src/terminal/search.zig
+++ b/src/terminal/search.zig
@@ -1,3 +1,26 @@
+//! Search functionality for the terminal.
+//!
+//! At the time of writing this comment, this is a **work in progress**.
+//!
+//! Search at the time of writing is implemented using a simple
+//! boyer-moore-horspool algorithm. The suboptimal part of the implementation
+//! is that we need to encode each terminal page into a text buffer in order
+//! to apply BMH to it. This is because the terminal page is not laid out
+//! in a flat text form.
+//!
+//! To minimize memory usage, we use a sliding window to search for the
+//! needle. The sliding window only keeps the minimum amount of page data
+//! in memory to search for a needle (i.e. `needle.len - 1` bytes of overlap
+//! between terminal pages).
+//!
+//! Future work:
+//!
+//!   - PageListSearch on a PageList concurrently with another thread
+//!   - Handle pruned pages in a PageList to ensure we don't keep references
+//!   - Repeat search a changing active area of the screen
+//!   - Reverse search so that more recent matches are found first
+//!
+
 const std = @import("std");
 const Allocator = std.mem.Allocator;
 const assert = std.debug.assert;
@@ -11,6 +34,10 @@ const Selection = terminal.Selection;
 const Screen = terminal.Screen;
 
 /// Searches for a term in a PageList structure.
+///
+/// At the time of writing, this does not support searching a pagelist
+/// simultaneously as its being used by another thread. This will be resolved
+/// in the future.
 pub const PageListSearch = struct {
     /// The list we're searching.
     list: *PageList,

