{% extends "base.html" %}

{% block title %}Benchmark Overview - LoCoDiff Explorer{% endblock %}

{% block content %}
    <h1>LoCoDiff Benchmark Overview</h1>

    <div class="metadata-box">
        <h2>Benchmark Summary</h2>
        <p><strong>Total Benchmark Cases Defined:</strong> {{ total_cases if total_cases is not none else 'Metadata not found' }}</p>
        <p><strong>Models with Results Found:</strong> {{ models|length }}</p>
        {% if benchmark_metadata and benchmark_metadata.generation_parameters %}
            <h3>Generation Parameters</h3>
            <ul>
                {% for key, value in benchmark_metadata.generation_parameters.items() %}
                    <li><strong>{{ key|replace('_', ' ')|title }}:</strong> {{ value }}</li>
                {% endfor %}
            </ul>
        {% endif %}
    </div>

    <h2>Models Explored</h2>
    {% if models %}
        <ul>
            {% for model in models %}
                <li><a href="{{ url_for('model_results', model_name=model) }}">{{ model }}</a></li>
            {% endfor %}
        </ul>
    {% else %}
        <p>No benchmark results found in <code>{{ config.RESULTS_BASE_DIR }}</code>.</p>
        <p>Run the benchmark using <code>./benchmark_pipeline/3_run_benchmark.py --model &lt;model_name&gt; --num-runs -1</code>.</p>
    {% endif %}

    {% if analysis_results and analysis_results.models %}
        <!-- Removed checkbox model selector -->

        <h2>Overall Model Performance Summary</h2>
        <table>
            <thead>
                <tr>
                    <th>Model</th>
                    <th>Defined</th>
                    <th>Runs Found</th>
                    <th>Successful</th>
                    <th>Success Rate</th>
                    <th>Total Cost (USD)</th>
                </tr>
            </thead>
            <tbody>
                {% for model_name in models %} {# Use sorted list from route #}
                    {% set stats = analysis_results.models[model_name] %}
                    <tr>
                        <td><a href="{{ url_for('model_results', model_name=model_name) }}">{{ model_name }}</a></td>
                        <td>{{ stats.total_benchmarks }}</td>
                        <td>{{ stats.runs_found }}</td>
                        <td>{{ stats.successful_runs }}</td>
                        <td>{{ "%.1f%%"|format(stats.success_rate * 100) }}</td>
                        <td>${{ "%.4f"|format(stats.total_cost_usd) }}</td>
                    </tr>
                {% endfor %}
            </tbody>
        </table>

        <!-- Removed Per-Bucket Success Rate Table -->

    {% elif models %} {# Only show this if models were found but analysis failed #}
        <p class="failure">Analysis results could not be generated or loaded. Check application logs.</p>
    {% endif %}

    <!-- Removed original bucket plot section -->

    <h2>Sliding Window Success Rate Plot (+/- 10k Tokens)</h2>
    
    <!-- Add model selection controls outside the chart -->
    <div id="modelSelectionControls" style="margin-bottom: 15px;">
        <strong>Select Models:</strong>
        <div id="modelCheckboxes" style="margin-top: 8px;">
            <!-- Model checkboxes will be dynamically added here by JavaScript -->
        </div>
    </div>

    {% if available_languages %}
    <div id="languageSelectionControls" style="margin-bottom: 20px;">
        <strong>Filter by Language:</strong>
        <div id="languageCheckboxes" style="margin-top: 8px;">
            {% for lang in available_languages %}
            <div style="display: inline-block; margin-right: 15px;">
                <input type="checkbox" id="lang-checkbox-{{ loop.index0 }}" name="language" value="{{ lang }}" class="language-filter-checkbox" checked>
                <label for="lang-checkbox-{{ loop.index0 }}" style="margin-left: 5px;">{{ lang|title }}</label>
            </div>
            {% endfor %}
        </div>
    </div>
    {% endif %}

    <div class="chart-container">
        <canvas id="slidingSuccessRateChart"></canvas>
    </div>
    <p><small>Interactive plot showing success rate within a +/- 10k token window around each point. Hover over data points to see details.</small></p>

{% endblock %}

{% block scripts %}
<script>
document.addEventListener('DOMContentLoaded', function() {
    // Chart context and state variables
    const ctxSliding = document.getElementById('slidingSuccessRateChart').getContext('2d');
    let slidingChart = null; // Holds the Chart.js instance
    let currentChartData = null; // Store the raw data used for the current chart
    let modelVisibility = {}; // Track which models are visible via checkboxes
    let selectedLanguages = []; // Track selected languages

    // Constants from backend
    const maxTokenLimit = {{ max_token_limit | default('null') }};
    const maxTokenLimitK = maxTokenLimit !== null ? Math.ceil(maxTokenLimit / 1000) : null;
    const availableLanguages = {{ available_languages | tojson | safe }}; // Get languages from backend

    // UI Elements
    const modelCheckboxesDiv = document.getElementById('modelCheckboxes');
    const languageCheckboxesDiv = document.getElementById('languageCheckboxes');

    // Color palette for datasets - will be assigned to models in order
    const colorPalette = [
        'rgb(54, 162, 235)',   // blue
        'rgb(255, 99, 132)',   // red
        'rgb(75, 192, 192)',   // teal
        'rgb(255, 159, 64)',   // orange
        'rgb(153, 102, 255)',  // purple
        'rgb(255, 205, 86)',   // yellow
        'rgb(201, 203, 207)',  // grey
        'rgb(22, 160, 133)',   // green
        'rgb(142, 68, 173)',   // dark purple
        'rgb(211, 84, 0)'      // dark orange
    ];
    
    // Format tooltips for sliding chart with range, counts, rate, and CI
    const slidingTooltipCallback = {
        title: function(tooltipItems) {
            // Calculate range from window center label (e.g., "10k")
            const label = tooltipItems[0].label || '';
            const centerK = parseInt(label.replace('k', ''), 10);
            if (!isNaN(centerK)) {
                const windowRadiusK = 10; // Window radius is 10k
                const lowerRangeK = Math.max(0, centerK - windowRadiusK);
                let upperRangeK = centerK + windowRadiusK;
                
                // Cap the upper range at the max_token_limit (converted to K)
                if (maxTokenLimitK !== null) {
                    upperRangeK = Math.min(upperRangeK, maxTokenLimitK);
                }
                
                // Ensure lower doesn't exceed upper after capping
                const finalLowerRangeK = Math.min(lowerRangeK, upperRangeK);

                return `Token Range: ${finalLowerRangeK}k - ${upperRangeK}k`;
            }
            return 'Token Range: N/A'; // Fallback
        },
        label: function(context) {
            // This callback now returns an array of strings for multi-line display
            const datasetLabel = context.dataset.label || '';
            const value = context.parsed.y;
            const dataIndex = context.dataIndex;
            const dataset = context.dataset;
            
            let lines = [datasetLabel]; // Start with model name

            // Add Solved/Total
            const successes = dataset.successes ? dataset.successes[dataIndex] : null;
            const totals = dataset.totals ? dataset.totals[dataIndex] : null;
            if (successes !== null && totals !== null) {
                 lines.push(`  Solved: ${successes} / ${totals}`);
            } else {
                 lines.push('  Solved: N/A');
            }

            // Add Success Rate
            if (value !== null && !isNaN(value)) {
                lines.push(`  Rate: ${(value * 100).toFixed(1)}%`);
            } else {
                lines.push('  Rate: N/A');
            }

            // Add Confidence Interval
            const lowerBound = dataset.wilson_lower ? dataset.wilson_lower[dataIndex] : null;
            const upperBound = dataset.wilson_upper ? dataset.wilson_upper[dataIndex] : null;
            if (lowerBound !== null && upperBound !== null) {
                lines.push(`  95% CI: ${(lowerBound * 100).toFixed(1)}% - ${(upperBound * 100).toFixed(1)}%`);
            } else {
                lines.push('  95% CI: N/A');
            }
            
            return lines; // Return array of strings
        }
        // No footer needed for now
    };
    
    // Create model checkboxes based on data
    function createModelCheckboxes(data) {
        if (!data || !data.datasets) {
            console.error("No dataset data available for creating checkboxes");
            return;
        }
        
        const modelCheckboxesDiv = document.getElementById('modelCheckboxes');
        if (!modelCheckboxesDiv) {
            console.error("Could not find modelCheckboxes div");
            return;
        }
        
        // Clear any existing checkboxes
        modelCheckboxesDiv.innerHTML = '';
        
        // Track which models we've already created checkboxes for
        const processedModels = new Set();
        
        console.log("Creating checkboxes for", data.datasets.length, "datasets");
        
        // Create a checkbox for each main dataset (not the CI datasets)
        data.datasets.forEach((dataset, index) => {
            // Skip if this is a confidence interval dataset (has 'CI Lower' or 'CI Upper' in label)
            if (dataset.label && (dataset.label.includes('CI Lower') || dataset.label.includes('CI Upper'))) {
                return;
            }
            
            // Extract model name from label (remove cost part if needed)
            let modelName = dataset.label || "";
            if (modelName.includes('($')) {
                modelName = modelName.split(' ($')[0];
            }
            
            // Skip if we already processed this model
            if (processedModels.has(modelName)) return;
            processedModels.add(modelName);
            
            console.log(`Creating checkbox for model: ${modelName}`);
            
            // Create the checkbox container (for styling)
            const checkboxContainer = document.createElement('div');
            checkboxContainer.style.display = 'inline-block';
            checkboxContainer.style.marginRight = '15px';
            checkboxContainer.className = 'model-checkbox-container';
            
            // Create the checkbox
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = `model-checkbox-${index}`;
            checkbox.value = modelName;
            checkbox.className = 'model-visibility-checkbox';
            checkbox.dataset.modelIndex = index;
            checkbox.checked = true; // Default to checked
            modelVisibility[modelName] = true; // Track visibility
            
            // Assign the color
            const colorIndex = index % colorPalette.length;
            const color = colorPalette[colorIndex];
            
            // Create the label
            const label = document.createElement('label');
            label.htmlFor = `model-checkbox-${index}`;
            label.style.marginLeft = '5px';
            label.style.color = color; // Use the same color as the chart line
            label.style.fontWeight = 'bold';
            
            // Add the cost to the label if available
            if (dataset.label && dataset.label.includes('($')) {
                const costPart = dataset.label.split('($')[1].split(')')[0];
                label.textContent = `${modelName} ($${costPart}`;
            } else {
                label.textContent = modelName;
            }
            
            // Add event listener to toggle visibility
            checkbox.addEventListener('change', function(event) {
                console.log(`Checkbox change event for ${modelName}: checked=${this.checked}`);
                toggleModelVisibility(modelName, this.checked);
            });
            
            // Add checkbox and label to container
            checkboxContainer.appendChild(checkbox);
            checkboxContainer.appendChild(label);
            
            // Add to the div
            modelCheckboxesDiv.appendChild(checkboxContainer);
        });
        
        console.log(`Created ${processedModels.size} model checkboxes`);
    }

    // Get currently selected languages from checkboxes
    function getSelectedLanguages() {
        const checkboxes = document.querySelectorAll('.language-filter-checkbox:checked');
        return Array.from(checkboxes).map(cb => cb.value);
    }

    // Toggle visibility of a model and its CI bands IN THE CURRENT CHART
    function toggleModelVisibility(modelName, isVisible) {
        if (!slidingChart) {
            console.error("Chart not initialized when trying to toggle visibility");
            return;
        }

        // Update tracking state
        modelVisibility[modelName] = isVisible;

        let updatedAny = false;

        // Find corresponding datasets in the current chart instance
        slidingChart.data.datasets.forEach((dataset, index) => {
            let datasetModelName = dataset.label || "";
            if (datasetModelName.includes('($')) {
                datasetModelName = datasetModelName.split(' ($')[0];
            }

            const isMainModelLine = datasetModelName === modelName;
            // Adjust CI label matching slightly for robustness
            const isCILower = (dataset.label && dataset.label.startsWith(modelName) && dataset.label.endsWith('CI Lower'));
            const isCIUpper = (dataset.label && dataset.label.startsWith(modelName) && dataset.label.endsWith('CI Upper'));

            if (isMainModelLine || isCILower || isCIUpper) {
                // Use Chart.js API to hide/show dataset
                slidingChart.setDatasetVisibility(index, isVisible);
                updatedAny = true;
                // console.log(`Set dataset ${index} (${dataset.label}) visibility to ${isVisible}`);
            }
        });

        if (!updatedAny) {
            console.warn(`No datasets matched model name "${modelName}" for visibility toggle.`);
        }

        // Update the chart to reflect visibility changes
        slidingChart.update();
    }

    // Function to actually create/update the Chart.js instance with new data
    function renderChart(ctx, chartData, chartTitle, xAxisLabel, tooltipCallback) {
        if (!chartData || !chartData.labels || !chartData.datasets) {
             console.error("Invalid chart data provided to renderChart");
             // Optionally display an error message on the canvas
             displayChartError(ctx, "Invalid data received from server.");
             return null; // Indicate failure
        }

        // Destroy existing chart instance if it exists
        if (slidingChart) {
            slidingChart.destroy();
            slidingChart = null;
            console.log("Destroyed previous chart instance.");
        }

        // Adjust the x-axis range (same logic as before)
        if (chartData.labels && chartData.labels.length > 0) {
            const windowRadiusK = 10;
            let cutoffIndex = -1;
            try {
                const lastLabel = chartData.labels[chartData.labels.length - 1];
                const lastCenterK = parseInt(lastLabel.replace('k', ''), 10);
                if (!isNaN(lastCenterK) && lastCenterK > windowRadiusK) {
                    const cutoffK = lastCenterK - windowRadiusK;
                    cutoffIndex = chartData.labels.findIndex(label => {
                        const centerK = parseInt(label.replace('k', ''), 10);
                        return centerK > cutoffK;
                    });
                }
            } catch (e) { console.warn("Error parsing labels for cutoff:", e); }

            if (cutoffIndex > 0) {
                chartData.labels = chartData.labels.slice(0, cutoffIndex);
                chartData.datasets.forEach(dataset => {
                    if (dataset.data) dataset.data = dataset.data.slice(0, cutoffIndex);
                    if (dataset.wilson_lower) dataset.wilson_lower = dataset.wilson_lower.slice(0, cutoffIndex);
                    if (dataset.wilson_upper) dataset.wilson_upper = dataset.wilson_upper.slice(0, cutoffIndex);
                    if (dataset.totals) dataset.totals = dataset.totals.slice(0, cutoffIndex);
                    if (dataset.successes) dataset.successes = dataset.successes.slice(0, cutoffIndex);
                });
            }
        }

        let chartDatasets = [];
        // Process the datasets and assign colors/structure
        chartData.datasets.forEach((apiDataset, index) => {
            const colorIndex = index % colorPalette.length;
            const mainColor = colorPalette[colorIndex];
            const transparentColor = mainColor.replace('rgb', 'rgba').replace(')', ', 0.2)');

            // Main data line
            const mainDataset = {
                ...apiDataset,
                borderColor: mainColor,
                backgroundColor: mainColor,
                pointBackgroundColor: mainColor,
                pointHoverRadius: 6,
                fill: false,
                tension: 0.1,
                order: 1,
                spanGaps: true, // Always true for sliding chart
                // Set initial visibility based on modelVisibility state
                hidden: !modelVisibility[apiDataset.label.split(' ($')[0]]
            };
            chartDatasets.push(mainDataset);

            // Add CI bands if data exists
            if (apiDataset.wilson_lower && apiDataset.wilson_upper) {
                chartDatasets.push({
                    label: apiDataset.label + ' CI Lower',
                    data: apiDataset.wilson_lower,
                    borderColor: 'transparent',
                    backgroundColor: transparentColor,
                    pointRadius: 0,
                    fill: '+1',
                    hidden: !modelVisibility[apiDataset.label.split(' ($')[0]], // Match main line visibility
                    showInLegend: false,
                    order: 2,
                    spanGaps: true,
                });
                chartDatasets.push({
                    label: apiDataset.label + ' CI Upper',
                    data: apiDataset.wilson_upper,
                    borderColor: 'transparent',
                    backgroundColor: 'transparent',
                    pointRadius: 0,
                    fill: false,
                    hidden: !modelVisibility[apiDataset.label.split(' ($')[0]], // Match main line visibility
                    showInLegend: false,
                    order: 3,
                    spanGaps: true,
                });
            }
        });

        // Create the new chart instance
        const newChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: chartData.labels,
                datasets: chartDatasets
            },
            options: { // Keep options mostly the same
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: true, max: 1,
                        ticks: { callback: value => (value * 100) + '%' },
                        title: { display: true, text: 'Success Rate' },
                        grid: { color: 'rgba(0, 0, 0, 0.1)' }
                    },
                    x: {
                        title: { display: true, text: xAxisLabel },
                        grid: { display: false }
                    }
                },
                plugins: {
                    tooltip: { callbacks: tooltipCallback },
                    legend: {
                        display: true, position: 'right',
                        labels: {
                            boxWidth: 12, padding: 15,
                            filter: (legendItem, data) => {
                                const txt = legendItem.text || '';
                                // Filter out CI bands and hidden datasets
                                return !txt.includes(' CI ') && !data.datasets[legendItem.datasetIndex].hidden;
                            }
                        },
                        onClick: (e, legendItem, legend) => {
                            let modelName = legendItem.text.split(' ($')[0];
                            const isVisible = !modelVisibility[modelName]; // Toggle state

                            // Update the corresponding checkbox
                            const checkbox = document.querySelector(`.model-visibility-checkbox[value="${modelName}"]`);
                            if (checkbox) checkbox.checked = isVisible;

                            // Toggle visibility in the chart
                            toggleModelVisibility(modelName, isVisible);

                            // Prevent default behavior
                            return false;
                        }
                    },
                    title: {
                        display: true, text: chartTitle,
                        font: { size: 16 }, padding: 20
                    }
                }
            }
        });

        console.log("Rendered new chart instance.");
        return newChart; // Return the new instance
    }

    // Function to display errors on the chart canvas
    function displayChartError(ctx, message) {
        const errorContainer = ctx.canvas.closest('.chart-container');
        if (errorContainer) {
            const errorMsg = document.createElement('div');
            errorMsg.style.textAlign = 'center';
            errorMsg.style.paddingTop = '150px';
            errorMsg.innerHTML = `
                <p style="color: red; font-weight: bold;">Error loading chart data</p>
                <p>${message}</p>
                <p>Check browser console for details.</p>
            `;
            // Clear previous content (like the canvas) and add error message
            while (errorContainer.firstChild) {
                errorContainer.removeChild(errorContainer.firstChild);
            }
            // Re-add canvas in case we retry later? Or just show error. Let's just show error.
            // errorContainer.appendChild(ctx.canvas); // Keep canvas element?
            errorContainer.appendChild(errorMsg);
        }
         // Destroy chart instance if it exists and we hit an error
        if (slidingChart) {
            slidingChart.destroy();
            slidingChart = null;
        }
    }


    // Function to fetch data and update the chart
    function fetchAndUpdateChart() {
        const currentSelectedLangs = getSelectedLanguages();
        const languagesParam = currentSelectedLangs.length > 0 ? currentSelectedLangs.join(',') : 'null'; // Use 'null' or empty string if none selected? API handles null/empty
        const apiUrl = `/api/sliding-plot-data?languages=${languagesParam}`;

        console.log(`Fetching chart data from: ${apiUrl}`);

        fetch(apiUrl)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`API response was not ok (${response.status})`);
                }
                return response.json();
            })
            .then(data => {
                if (data.error) {
                    throw new Error(data.error);
                }

                // Store the fetched data
                currentChartData = data;

                // Create model checkboxes based on the *new* data (models might change based on language filter)
                // Preserve the checked state from modelVisibility
                createModelCheckboxes(data);

                // Render the chart with the new data
                slidingChart = renderChart(
                    ctxSliding,
                    data,
                    'Sliding Window Success Rate (+/- 10k Tokens)',
                    'Window Center (k tokens)',
                    slidingTooltipCallback
                );
                if (!slidingChart) {
                     console.error("Chart rendering failed.");
                     // Error message should already be displayed by renderChart
                } else {
                     console.log("Chart updated successfully.");
                }
            })
            .catch(error => {
                console.error(`Error fetching or rendering chart data from ${apiUrl}:`, error);
                displayChartError(ctxSliding, error.message); // Display error on canvas
            });
    }

    // --- Initial Setup ---

    // Initialize selected languages (all checked by default)
    selectedLanguages = getSelectedLanguages();

    // Add event listeners to language checkboxes
    if (languageCheckboxesDiv) {
        const langCheckboxes = document.querySelectorAll('.language-filter-checkbox');
        langCheckboxes.forEach(checkbox => {
            checkbox.addEventListener('change', function() {
                console.log("Language selection changed.");
                fetchAndUpdateChart(); // Refetch and redraw chart
            });
        });
    } else {
         console.log("No language checkboxes found to add listeners to.");
    }

    // Initial chart load
    fetchAndUpdateChart();

});
</script>
{% endblock %}
