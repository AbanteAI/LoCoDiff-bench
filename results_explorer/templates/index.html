{% extends "base.html" %}

{% block title %}Benchmark Overview - LoCoDiff Explorer{% endblock %}

{% block content %}
    <h1>LoCoDiff Benchmark Overview</h1>

    <div class="metadata-box">
        <h2>Benchmark Summary</h2>
        <p><strong>Total Benchmark Cases Defined:</strong> {{ total_cases if total_cases is not none else 'Metadata not found' }}</p>
        <p><strong>Models with Results Found:</strong> {{ models|length }}</p>
        {% if benchmark_metadata and benchmark_metadata.generation_parameters %}
            <h3>Generation Parameters</h3>
            <ul>
                {% for key, value in benchmark_metadata.generation_parameters.items() %}
                    <li><strong>{{ key|replace('_', ' ')|title }}:</strong> {{ value }}</li>
                {% endfor %}
            </ul>
        {% endif %}
    </div>

    <h2>Models Explored</h2>
    {% if models %}
        <ul>
            {% for model in models %}
                <li><a href="{{ url_for('model_results', model_name=model) }}">{{ model }}</a></li>
            {% endfor %}
        </ul>
    {% else %}
        <p>No benchmark results found in <code>{{ config.RESULTS_BASE_DIR }}</code>.</p>
        <p>Run the benchmark using <code>./benchmark_pipeline/3_run_benchmark.py --model &lt;model_name&gt; --num-runs -1</code>.</p>
    {% endif %}

    {% if analysis_results and analysis_results.models %}
        <div id="model-selector" style="margin-bottom: 20px; padding: 10px; border: 1px solid #ddd;">
            <strong>Select Models to Display:</strong><br>
            {% for model in models %}
                <label style="margin-right: 15px; display: inline-block;">
                    <input type="checkbox" class="model-toggle-checkbox" data-model-name="{{ model }}" checked> {{ model }}
                </label>
            {% endfor %}
        </div>

        <h2>Overall Model Performance Summary</h2>
        <table>
            <thead>
                <tr>
                    <th>Model</th>
                    <th>Defined</th>
                    <th>Runs Found</th>
                    <th>Successful</th>
                    <th>Success Rate</th>
                    <th>Total Cost (USD)</th>
                </tr>
            </thead>
            <tbody>
                {% for model_name in models %} {# Use sorted list from route #}
                    {% set stats = analysis_results.models[model_name] %}
                    <tr>
                        <td><a href="{{ url_for('model_results', model_name=model_name) }}">{{ model_name }}</a></td>
                        <td>{{ stats.total_benchmarks }}</td>
                        <td>{{ stats.runs_found }}</td>
                        <td>{{ stats.successful_runs }}</td>
                        <td>{{ "%.1f%%"|format(stats.success_rate * 100) }}</td>
                        <td>${{ "%.4f"|format(stats.total_cost_usd) }}</td>
                    </tr>
                {% endfor %}
            </tbody>
        </table>

        <h2>Per-Bucket Success Rate (%)</h2>
        {% if analysis_results.bucket_keys %}
            <table>
                <thead>
                    <tr>
                        <th>Bucket (k tk)</th>
                        {% for model_name in models %}
                            <th>{{ model_name }}</th>
                        {% endfor %}
                    </tr>
                </thead>
                <tbody>
                    {% for i in range(analysis_results.bucket_keys|length) %}
                        {% set bucket_key = analysis_results.bucket_keys[i] %}
                        {% set formatted_key = analysis_results.formatted_bucket_keys[i] %}
                        <tr>
                            <td>{{ formatted_key }}</td>
                            {% for model_name in models %}
                                {% set bucket_stats = analysis_results.models[model_name].buckets[bucket_key] %}
                                <td>
                                    {% if bucket_stats.runs_found > 0 %}
                                        {{ "%.1f%%"|format(bucket_stats.success_rate * 100) }}
                                        <small>({{ bucket_stats.successful_runs }}/{{ bucket_stats.runs_found }})</small>
                                    {% elif bucket_stats.total_in_bucket > 0 %}
                                        0/0
                                    {% else %}
                                        - {# Bucket empty #}
                                    {% endif %}
                                </td>
                            {% endfor %}
                        </tr>
                    {% endfor %}
                </tbody>
            </table>
        {% else %}
            <p>No bucket information found in analysis results.</p>
        {% endif %}

    {% elif models %} {# Only show this if models were found but analysis failed #}
        <p class="failure">Analysis results could not be generated or loaded. Check application logs.</p>
    {% endif %}


    <h2>Overall Success Rate Plot</h2>
    <div class="chart-container">
        <canvas id="successRateChart"></canvas>
    </div>
    <p><small>Interactive plot generated dynamically using Chart.js. Hover over data points to see details.</small></p>

    <h2>Sliding Window Success Rate Plot (+/- 5k Tokens)</h2>
    <div class="chart-container">
        <canvas id="slidingSuccessRateChart"></canvas>
    </div>
    <p><small>Interactive plot showing success rate within a +/- 5k token window around each point. Hover over data points to see details.</small></p>

{% endblock %}

{% block scripts %}
<script>
document.addEventListener('DOMContentLoaded', function() {
    const ctxBucket = document.getElementById('successRateChart').getContext('2d');
    const ctxSliding = document.getElementById('slidingSuccessRateChart').getContext('2d');
    let bucketChart = null;
    let slidingChart = null;
    
    // Color palette for datasets - will be assigned to models in order
    const colorPalette = [
        'rgb(54, 162, 235)',   // blue
        'rgb(255, 99, 132)',   // red
        'rgb(75, 192, 192)',   // teal
        'rgb(255, 159, 64)',   // orange
        'rgb(153, 102, 255)',  // purple
        'rgb(255, 205, 86)',   // yellow
        'rgb(201, 203, 207)',  // grey
        'rgb(22, 160, 133)',   // green
        'rgb(142, 68, 173)',   // dark purple
        'rgb(211, 84, 0)'      // dark orange
    ];
    
    // Format tooltips for sliding chart with range, counts, rate, and CI
    const slidingTooltipCallback = {
        title: function(tooltipItems) {
            // Calculate range from window center label (e.g., "10k")
            const label = tooltipItems[0].label || '';
            const centerK = parseInt(label.replace('k', ''), 10);
            if (!isNaN(centerK)) {
                const lowerRangeK = Math.max(0, centerK - 5); // Window radius is 5k
                const upperRangeK = centerK + 5;
                return `Token Range: ${lowerRangeK}k - ${upperRangeK}k`;
            }
            return 'Token Range: N/A'; // Fallback
        },
        label: function(context) {
            // This callback now returns an array of strings for multi-line display
            const datasetLabel = context.dataset.label || '';
            const value = context.parsed.y;
            const dataIndex = context.dataIndex;
            const dataset = context.dataset;
            
            let lines = [datasetLabel]; // Start with model name

            // Add Solved/Total
            const successes = dataset.successes ? dataset.successes[dataIndex] : null;
            const totals = dataset.totals ? dataset.totals[dataIndex] : null;
            if (successes !== null && totals !== null) {
                 lines.push(`  Solved: ${successes} / ${totals}`);
            } else {
                 lines.push('  Solved: N/A');
            }

            // Add Success Rate
            if (value !== null && !isNaN(value)) {
                lines.push(`  Rate: ${(value * 100).toFixed(1)}%`);
            } else {
                lines.push('  Rate: N/A');
            }

            // Add Confidence Interval
            const lowerBound = dataset.wilson_lower ? dataset.wilson_lower[dataIndex] : null;
            const upperBound = dataset.wilson_upper ? dataset.wilson_upper[dataIndex] : null;
            if (lowerBound !== null && upperBound !== null) {
                lines.push(`  95% CI: ${(lowerBound * 100).toFixed(1)}% - ${(upperBound * 100).toFixed(1)}%`);
            } else {
                lines.push('  95% CI: N/A');
            }
            
            return lines; // Return array of strings
        }
        // No footer needed for now
    };
    
    // Tooltip callback for the original bucket chart (simpler)
    const bucketTooltipCallback = {
        label: function(context) {
            const label = context.dataset.label || '';
            const value = context.parsed.y;
            return label + ': ' + (value !== null && !isNaN(value) ? (value * 100).toFixed(1) + '%' : 'N/A');
        },
        title: function(context) {
            return 'Bucket: ' + context[0].label;
        }
    };


    // Function to create a chart
    function createChart(ctx, apiUrl, chartTitle, xAxisLabel, tooltipCallbacks) { // Added tooltipCallbacks param
        fetch(apiUrl)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`API response was not ok (${response.status})`);
                }
                return response.json();
            })
            .then(data => {
                if (data.error) {
                    throw new Error(data.error);
                }

                let chartDatasets = [];
                const isSlidingChart = apiUrl.includes('sliding');

                // Process the datasets and assign colors/structure
                data.datasets.forEach((apiDataset, index) => {
                    const colorIndex = index % colorPalette.length;
                    const mainColor = colorPalette[colorIndex];
                    const transparentColor = mainColor.replace('rgb', 'rgba').replace(')', ', 0.2)'); // Lighter fill for bands

                    // Main data line
                    const mainDataset = {
                        ...apiDataset, // Includes label, data, wilson_lower, wilson_upper
                        borderColor: mainColor,
                        backgroundColor: mainColor, // For points
                        pointBackgroundColor: mainColor,
                        pointHoverRadius: 6,
                        fill: false,
                        tension: 0.1,
                        order: 1, // Draw main line on top
                        spanGaps: isSlidingChart, // Apply spanGaps if it's the sliding chart
                    };
                    chartDatasets.push(mainDataset);

                    // Add datasets for confidence interval bands ONLY for the sliding chart
                    if (isSlidingChart && apiDataset.wilson_lower && apiDataset.wilson_upper) {
                        // Lower bound dataset (invisible line, fills up to upper bound)
                        chartDatasets.push({
                            label: apiDataset.label + ' CI Lower', // Internal label, not shown in legend
                            data: apiDataset.wilson_lower,
                            borderColor: 'transparent',
                            backgroundColor: transparentColor, // Fill color
                            pointRadius: 0,
                            fill: '+1', // Fill to the next dataset (upper bound)
                            showInLegend: false,
                            order: 2, // Draw fill below main line
                            spanGaps: true, // Connect gaps for fill
                        });

                        // Upper bound dataset (invisible line, defines top of fill)
                        chartDatasets.push({
                            label: apiDataset.label + ' CI Upper', // Internal label, not shown in legend
                            data: apiDataset.wilson_upper,
                            borderColor: 'transparent',
                            backgroundColor: 'transparent', // No background for this line itself
                            pointRadius: 0,
                            fill: false, // Don't fill this line itself
                            showInLegend: false,
                            order: 3, // Draw below lower bound fill target
                            spanGaps: true, // Connect gaps for fill boundary
                        });
                    }
                });
                
                // Create the chart
                return new Chart(ctx, {
                    type: 'line',
                    data: { // Structure data for Chart.js
                        labels: data.labels,
                        datasets: chartDatasets // Use the structured datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true,
                                max: 1,
                                ticks: {
                                    callback: function(value) {
                                        return (value * 100) + '%';
                                    }
                                },
                                title: {
                                    display: true,
                                    text: 'Success Rate'
                                },
                                grid: {
                                    color: 'rgba(0, 0, 0, 0.1)'
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: xAxisLabel // Use dynamic label
                                },
                                grid: {
                                    display: false
                                }
                            }
                        },
                        plugins: {
                            tooltip: {
                                callbacks: tooltipCallbacks // Use the passed callbacks
                            },
                            legend: {
                                display: false, // Hide legend, using checkboxes instead
                                position: 'right',
                                labels: {
                                    boxWidth: 12,
                                    padding: 15
                                },
                                title: {
                                    display: true,
                                    text: 'Models',
                                    padding: 10
                                }
                            },
                            title: {
                                display: true,
                                text: chartTitle, // Use dynamic title
                                font: {
                                    size: 16
                                },
                                padding: 20
                            }
                        }
                    }
                });
            })
            .catch(error => {
                console.error(`Error fetching chart data from ${apiUrl}:`, error);
                // Display error message in the canvas container
                const errorContainer = ctx.canvas.closest('.chart-container'); // Find parent container
                if (errorContainer) {
                    const errorMsg = document.createElement('div');
                    errorMsg.style.textAlign = 'center';
                    errorMsg.style.paddingTop = '150px'; // Adjust as needed
                    errorMsg.innerHTML = `
                        <p style="color: red; font-weight: bold;">Error loading chart data</p>
                        <p>${error.message}</p>
                        <p>Check browser console for details.</p>
                    `;
                    // Clear previous content and add error message
                    while (errorContainer.firstChild) {
                        errorContainer.removeChild(errorContainer.firstChild);
                    }
                    errorContainer.appendChild(errorMsg);
                }
            });
    } // End of createChart function definition

    // Create the Bucket Chart
    bucketChart = createChart(
        ctxBucket,
        '/api/plot-data',
        'Benchmark Success Rate per Prompt Token Bucket',
        'Prompt Token Bucket (k tokens)',
        bucketTooltipCallback // Pass bucket-specific callbacks
    );

    // Create the Sliding Window Chart
    slidingChart = createChart(
        ctxSliding,
        '/api/sliding-plot-data',
        'Sliding Window Success Rate (+/- 5k Tokens)',
        'Window Center (k tokens)',
        slidingTooltipCallback // Pass sliding-specific callbacks
    );

    // --- Checkbox Logic for Model Toggling ---
    const checkboxes = document.querySelectorAll('.model-toggle-checkbox');

    function setModelVisibility(chartInstance, modelName, isVisible) {
        if (!chartInstance || !chartInstance.data || !chartInstance.data.datasets) return;
        
        chartInstance.data.datasets.forEach(dataset => {
            // Check if the dataset label starts with the model name
            // This handles the main line and the CI bands (e.g., "modelName ($cost)", "modelName CI Lower")
            if (dataset.label && dataset.label.startsWith(modelName)) {
                 dataset.hidden = !isVisible;
            }
        });
    }

    checkboxes.forEach(checkbox => {
        checkbox.addEventListener('change', function() {
            const modelName = this.getAttribute('data-model-name');
            const isVisible = this.checked;

            // Toggle visibility in both charts if they exist
            if (bucketChart) {
                setModelVisibility(bucketChart, modelName, isVisible);
                bucketChart.update();
            }
            if (slidingChart) {
                setModelVisibility(slidingChart, modelName, isVisible);
                slidingChart.update();
            }
        });
    });
    // --- End Checkbox Logic ---

});
</script>
{% endblock %}
