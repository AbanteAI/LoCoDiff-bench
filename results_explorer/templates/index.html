{% extends "base.html" %}

{% block title %}Benchmark Overview - LoCoDiff Explorer{% endblock %}

{% block content %}
    <h1>LoCoDiff Benchmark Overview</h1>

    <div class="metadata-box">
        <h2>Benchmark Summary</h2>
        <p><strong>Total Benchmark Cases Defined:</strong> {{ total_cases if total_cases is not none else 'Metadata not found' }}</p>
        <p><strong>Models with Results Found:</strong> {{ models|length }}</p>
        {% if benchmark_metadata and benchmark_metadata.generation_parameters %}
            <h3>Generation Parameters</h3>
            <ul>
                {% for key, value in benchmark_metadata.generation_parameters.items() %}
                    <li><strong>{{ key|replace('_', ' ')|title }}:</strong> {{ value }}</li>
                {% endfor %}
            </ul>
        {% endif %}
    </div>

    <h2>Models Explored</h2>
    {% if models %}
        <ul>
            {% for model in models %}
                <li><a href="{{ url_for('model_results', model_name=model) }}">{{ model }}</a></li>
            {% endfor %}
        </ul>
    {% else %}
        <p>No benchmark results found in <code>{{ config.RESULTS_BASE_DIR }}</code>.</p>
        <p>Run the benchmark using <code>./benchmark_pipeline/3_run_benchmark.py --model &lt;model_name&gt; --num-runs -1</code>.</p>
    {% endif %}

    {% if analysis_results and analysis_results.models %}
        <!-- Removed checkbox model selector -->

        <h2>Overall Model Performance Summary</h2>
        <table>
            <thead>
                <tr>
                    <th>Model</th>
                    <th>Defined</th>
                    <th>Runs Found</th>
                    <th>Successful</th>
                    <th>Success Rate</th>
                    <th>Total Cost (USD)</th>
                </tr>
            </thead>
            <tbody>
                {% for model_name in models %} {# Use sorted list from route #}
                    {% set stats = analysis_results.models[model_name] %}
                    <tr>
                        <td><a href="{{ url_for('model_results', model_name=model_name) }}">{{ model_name }}</a></td>
                        <td>{{ stats.total_benchmarks }}</td>
                        <td>{{ stats.runs_found }}</td>
                        <td>{{ stats.successful_runs }}</td>
                        <td>{{ "%.1f%%"|format(stats.success_rate * 100) }}</td>
                        <td>${{ "%.4f"|format(stats.total_cost_usd) }}</td>
                    </tr>
                {% endfor %}
            </tbody>
        </table>

        <!-- Removed Per-Bucket Success Rate Table -->

    {% elif models %} {# Only show this if models were found but analysis failed #}
        <p class="failure">Analysis results could not be generated or loaded. Check application logs.</p>
    {% endif %}

    <!-- Removed original bucket plot section -->

    <h2>Sliding Window Success Rate Plot (+/- 5k Tokens)</h2>
    
    <!-- Add model selection controls outside the chart -->
    <div id="modelSelectionControls" style="margin-bottom: 15px;">
        <strong>Select Models:</strong>
        <div id="modelCheckboxes" style="margin-top: 8px;">
            <!-- Checkboxes will be dynamically added here by JavaScript -->
        </div>
    </div>
    
    <div class="chart-container">
        <canvas id="slidingSuccessRateChart"></canvas>
    </div>
    <p><small>Interactive plot showing success rate within a +/- 5k token window around each point. Hover over data points to see details.</small></p>

{% endblock %}

{% block scripts %}
<script>
document.addEventListener('DOMContentLoaded', function() {
    // Only need context and chart variable for the sliding chart now
    const ctxSliding = document.getElementById('slidingSuccessRateChart').getContext('2d');
    let slidingChart = null;
    let chartData = null; // Store the chart data for manipulating later
    let modelVisibility = {}; // Track which models are visible
    
    // Color palette for datasets - will be assigned to models in order
    const colorPalette = [
        'rgb(54, 162, 235)',   // blue
        'rgb(255, 99, 132)',   // red
        'rgb(75, 192, 192)',   // teal
        'rgb(255, 159, 64)',   // orange
        'rgb(153, 102, 255)',  // purple
        'rgb(255, 205, 86)',   // yellow
        'rgb(201, 203, 207)',  // grey
        'rgb(22, 160, 133)',   // green
        'rgb(142, 68, 173)',   // dark purple
        'rgb(211, 84, 0)'      // dark orange
    ];
    
    // Format tooltips for sliding chart with range, counts, rate, and CI
    const slidingTooltipCallback = {
        title: function(tooltipItems) {
            // Calculate range from window center label (e.g., "10k")
            const label = tooltipItems[0].label || '';
            const centerK = parseInt(label.replace('k', ''), 10);
            if (!isNaN(centerK)) {
                const lowerRangeK = Math.max(0, centerK - 5); // Window radius is 5k
                const upperRangeK = centerK + 5;
                return `Token Range: ${lowerRangeK}k - ${upperRangeK}k`;
            }
            return 'Token Range: N/A'; // Fallback
        },
        label: function(context) {
            // This callback now returns an array of strings for multi-line display
            const datasetLabel = context.dataset.label || '';
            const value = context.parsed.y;
            const dataIndex = context.dataIndex;
            const dataset = context.dataset;
            
            let lines = [datasetLabel]; // Start with model name

            // Add Solved/Total
            const successes = dataset.successes ? dataset.successes[dataIndex] : null;
            const totals = dataset.totals ? dataset.totals[dataIndex] : null;
            if (successes !== null && totals !== null) {
                 lines.push(`  Solved: ${successes} / ${totals}`);
            } else {
                 lines.push('  Solved: N/A');
            }

            // Add Success Rate
            if (value !== null && !isNaN(value)) {
                lines.push(`  Rate: ${(value * 100).toFixed(1)}%`);
            } else {
                lines.push('  Rate: N/A');
            }

            // Add Confidence Interval
            const lowerBound = dataset.wilson_lower ? dataset.wilson_lower[dataIndex] : null;
            const upperBound = dataset.wilson_upper ? dataset.wilson_upper[dataIndex] : null;
            if (lowerBound !== null && upperBound !== null) {
                lines.push(`  95% CI: ${(lowerBound * 100).toFixed(1)}% - ${(upperBound * 100).toFixed(1)}%`);
            } else {
                lines.push('  95% CI: N/A');
            }
            
            return lines; // Return array of strings
        }
        // No footer needed for now
    };
    
    // Create model checkboxes based on data
    function createModelCheckboxes(data) {
        if (!data || !data.datasets) return;
        
        const modelCheckboxesDiv = document.getElementById('modelCheckboxes');
        if (!modelCheckboxesDiv) return;
        
        // Clear any existing checkboxes
        modelCheckboxesDiv.innerHTML = '';
        
        // Track which models we've already created checkboxes for
        const processedModels = new Set();
        
        // Create a checkbox for each main dataset (not the CI datasets)
        data.datasets.forEach((dataset, index) => {
            // Skip if this is a confidence interval dataset (has 'CI Lower' or 'CI Upper' in label)
            if (dataset.label && (dataset.label.includes('CI Lower') || dataset.label.includes('CI Upper'))) {
                return;
            }
            
            // Extract model name from label (remove cost part if needed)
            let modelName = dataset.label;
            if (modelName.includes('($')) {
                modelName = modelName.split(' ($')[0];
            }
            
            // Skip if we already processed this model
            if (processedModels.has(modelName)) return;
            processedModels.add(modelName);
            
            // Create the checkbox container (for styling)
            const checkboxContainer = document.createElement('div');
            checkboxContainer.style.display = 'inline-block';
            checkboxContainer.style.marginRight = '15px';
            
            // Create the checkbox
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = `model-checkbox-${index}`;
            checkbox.value = modelName;
            checkbox.checked = true; // Default to checked
            modelVisibility[modelName] = true; // Track visibility
            
            // Assign the color
            const colorIndex = index % colorPalette.length;
            const color = colorPalette[colorIndex];
            
            // Create the label
            const label = document.createElement('label');
            label.htmlFor = `model-checkbox-${index}`;
            label.style.marginLeft = '5px';
            label.style.color = color; // Use the same color as the chart line
            label.style.fontWeight = 'bold';
            
            // Add the cost to the label if available
            if (dataset.label.includes('($')) {
                const costPart = dataset.label.split('($')[1].split(')')[0];
                label.textContent = `${modelName} ($${costPart}`;
            } else {
                label.textContent = modelName;
            }
            
            // Add event listener to toggle visibility
            checkbox.addEventListener('change', function() {
                toggleModelVisibility(modelName, this.checked);
            });
            
            // Add checkbox and label to container
            checkboxContainer.appendChild(checkbox);
            checkboxContainer.appendChild(label);
            
            // Add to the div
            modelCheckboxesDiv.appendChild(checkboxContainer);
        });
    }
    
    // Toggle visibility of a model and its CI bands
    function toggleModelVisibility(modelName, isVisible) {
        if (!slidingChart) return;
        
        // Update tracking
        modelVisibility[modelName] = isVisible;
        
        // Find corresponding datasets
        slidingChart.data.datasets.forEach(dataset => {
            // Check if this dataset belongs to the model (either main line or CI)
            const isMainModelLine = dataset.label && dataset.label.startsWith(modelName);
            const isCILower = dataset.label && dataset.label.startsWith(`${modelName} CI Lower`);
            const isCIUpper = dataset.label && dataset.label.startsWith(`${modelName} CI Upper`);
            
            if (isMainModelLine || isCILower || isCIUpper) {
                dataset.hidden = !isVisible;
            }
        });
        
        // Update the chart
        slidingChart.update();
    }
    
    // Function to create a chart
    function createChart(ctx, apiUrl, chartTitle, xAxisLabel, tooltipCallback) { 
        fetch(apiUrl)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`API response was not ok (${response.status})`);
                }
                return response.json();
            })
            .then(data => {
                if (data.error) {
                    throw new Error(data.error);
                }
                
                // Store chart data for later use
                chartData = data;
                
                // Adjust the x-axis range to remove the last 5k tokens
                // First, process the labels and datasets to remove the last data point
                if (data.labels && data.labels.length > 0) {
                    // Calculate cutoff point at max - 5k
                    let cutoffIndex = -1;
                    try {
                        const lastLabel = data.labels[data.labels.length - 1];
                        const lastCenterK = parseInt(lastLabel.replace('k', ''), 10);
                        if (!isNaN(lastCenterK) && lastCenterK > 5) {
                            const cutoffK = lastCenterK - 5;
                            // Find the index of the cutoff point
                            cutoffIndex = data.labels.findIndex(label => {
                                const centerK = parseInt(label.replace('k', ''), 10);
                                return centerK > cutoffK;
                            });
                        }
                    } catch (e) {
                        console.warn("Error parsing labels for cutoff:", e);
                    }
                    
                    // If we found a valid cutoff, crop the data
                    if (cutoffIndex > 0) {
                        data.labels = data.labels.slice(0, cutoffIndex);
                        data.datasets.forEach(dataset => {
                            if (dataset.data) {
                                dataset.data = dataset.data.slice(0, cutoffIndex);
                            }
                            if (dataset.wilson_lower) {
                                dataset.wilson_lower = dataset.wilson_lower.slice(0, cutoffIndex);
                            }
                            if (dataset.wilson_upper) {
                                dataset.wilson_upper = dataset.wilson_upper.slice(0, cutoffIndex);
                            }
                            if (dataset.totals) {
                                dataset.totals = dataset.totals.slice(0, cutoffIndex);
                            }
                            if (dataset.successes) {
                                dataset.successes = dataset.successes.slice(0, cutoffIndex);
                            }
                        });
                    }
                }

                let chartDatasets = [];
                const isSlidingChart = apiUrl.includes('sliding');

                // Process the datasets and assign colors/structure
                data.datasets.forEach((apiDataset, index) => {
                    const colorIndex = index % colorPalette.length;
                    const mainColor = colorPalette[colorIndex];
                    const transparentColor = mainColor.replace('rgb', 'rgba').replace(')', ', 0.2)'); // Lighter fill for bands

                    // Main data line
                    const mainDataset = {
                        ...apiDataset, // Includes label, data, wilson_lower, wilson_upper
                        borderColor: mainColor,
                        backgroundColor: mainColor, // For points
                        pointBackgroundColor: mainColor,
                        pointHoverRadius: 6,
                        fill: false,
                        tension: 0.1,
                        order: 1, // Draw main line on top
                        spanGaps: isSlidingChart, // Apply spanGaps if it's the sliding chart
                    };
                    chartDatasets.push(mainDataset);

                    // Add datasets for confidence interval bands ONLY for the sliding chart
                    if (isSlidingChart && apiDataset.wilson_lower && apiDataset.wilson_upper) {
                        // Lower bound dataset (invisible line, fills up to upper bound)
                        chartDatasets.push({
                            label: apiDataset.label + ' CI Lower', // Internal label, not shown in legend
                            data: apiDataset.wilson_lower,
                            borderColor: 'transparent',
                            backgroundColor: transparentColor, // Fill color
                            pointRadius: 0,
                            fill: '+1', // Fill to the next dataset (upper bound)
                            hidden: false, // Ensure it's visible even if not in legend
                            showInLegend: false, // Hide from legend
                            order: 2, // Draw fill below main line
                            spanGaps: true, // Connect gaps for fill
                        });

                        // Upper bound dataset (invisible line, defines top of fill)
                        chartDatasets.push({
                            label: apiDataset.label + ' CI Upper', // Internal label, not shown in legend
                            data: apiDataset.wilson_upper,
                            borderColor: 'transparent',
                            backgroundColor: 'transparent', // No background for this line itself
                            pointRadius: 0,
                            fill: false, // Don't fill this line itself
                            hidden: false, // Ensure it's visible even if not in legend
                            showInLegend: false, // Hide from legend
                            order: 3, // Draw below lower bound fill target
                            spanGaps: true, // Connect gaps for fill boundary
                        });
                    }
                });
                
                // Create the chart
                const chart = new Chart(ctx, {
                    type: 'line',
                    data: { // Structure data for Chart.js
                        labels: data.labels,
                        datasets: chartDatasets // Use the structured datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true,
                                max: 1,
                                ticks: {
                                    callback: function(value) {
                                        return (value * 100) + '%';
                                    }
                                },
                                title: {
                                    display: true,
                                    text: 'Success Rate'
                                },
                                grid: {
                                    color: 'rgba(0, 0, 0, 0.1)'
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: xAxisLabel // Use dynamic label
                                },
                                grid: {
                                    display: false
                                }
                            }
                        },
                        plugins: {
                            tooltip: {
                                callbacks: tooltipCallback // Use the single passed callback object
                            },
                            legend: {
                                display: false, // Disable the built-in legend since we use external checkboxes
                            },
                            title: {
                                display: true,
                                text: chartTitle, // Use dynamic title
                                font: {
                                    size: 16
                                },
                                padding: 20
                            }
                        }
                    }
                });
                
                // Create the model selection checkboxes
                createModelCheckboxes(data);
                
                return chart;
            })
            .catch(error => {
                console.error(`Error fetching chart data from ${apiUrl}:`, error);
                // Display error message in the canvas container
                const errorContainer = ctx.canvas.closest('.chart-container'); // Find parent container
                if (errorContainer) {
                    const errorMsg = document.createElement('div');
                    errorMsg.style.textAlign = 'center';
                    errorMsg.style.paddingTop = '150px'; // Adjust as needed
                    errorMsg.innerHTML = `
                        <p style="color: red; font-weight: bold;">Error loading chart data</p>
                        <p>${error.message}</p>
                        <p>Check browser console for details.</p>
                    `;
                    // Clear previous content and add error message
                    while (errorContainer.firstChild) {
                        errorContainer.removeChild(errorContainer.firstChild);
                    }
                    errorContainer.appendChild(errorMsg);
                }
            });
    } // End of createChart function definition

    // Create the Sliding Window Chart
    slidingChart = createChart(
        ctxSliding,
        '/api/sliding-plot-data',
        'Sliding Window Success Rate (+/- 5k Tokens)',
        'Window Center (k tokens)',
        slidingTooltipCallback // Pass the tooltip callback for the sliding chart
    );
});
</script>
{% endblock %}
